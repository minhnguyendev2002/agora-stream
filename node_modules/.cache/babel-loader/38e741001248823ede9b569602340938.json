{"ast":null,"code":"/**\n * AgoraWebSDK_N-v4.16.1-0-gb268655f-dirty Copyright AgoraInc.\n */\n\n!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (e = \"undefined\" != typeof globalThis ? globalThis : e || self).AgoraRTC = t();\n}(this, function () {\n  \"use strict\";\n\n  function e(e, t) {\n    return t.forEach(function (t) {\n      t && \"string\" != typeof t && !Array.isArray(t) && Object.keys(t).forEach(function (i) {\n        if (\"default\" !== i && !(i in e)) {\n          var r = Object.getOwnPropertyDescriptor(t, i);\n          Object.defineProperty(e, i, r.get ? r : {\n            enumerable: !0,\n            get: function () {\n              return t[i];\n            }\n          });\n        }\n      });\n    }), Object.freeze(e);\n  }\n  var t = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n    i = function (e) {\n      try {\n        return !!e();\n      } catch (e) {\n        return !0;\n      }\n    },\n    r = !i(function () {\n      var e = function () {}.bind();\n      return \"function\" != typeof e || e.hasOwnProperty(\"prototype\");\n    }),\n    n = r,\n    o = Function.prototype,\n    s = o.bind,\n    a = o.call,\n    c = n && s.bind(a, a),\n    d = n ? function (e) {\n      return e && c(e);\n    } : function (e) {\n      return e && function () {\n        return a.apply(e, arguments);\n      };\n    },\n    u = d({}.isPrototypeOf),\n    l = function (e) {\n      return e && e.Math == Math && e;\n    },\n    h = l(\"object\" == typeof globalThis && globalThis) || l(\"object\" == typeof window && window) || l(\"object\" == typeof self && self) || l(\"object\" == typeof t && t) || function () {\n      return this;\n    }() || Function(\"return this\")(),\n    p = r,\n    _ = Function.prototype,\n    E = _.apply,\n    f = _.call,\n    m = \"object\" == typeof Reflect && Reflect.apply || (p ? f.bind(E) : function () {\n      return f.apply(E, arguments);\n    }),\n    g = function (e) {\n      return \"function\" == typeof e;\n    },\n    S = {},\n    T = !i(function () {\n      return 7 != Object.defineProperty({}, 1, {\n        get: function () {\n          return 7;\n        }\n      })[1];\n    }),\n    v = r,\n    R = Function.prototype.call,\n    I = v ? R.bind(R) : function () {\n      return R.apply(R, arguments);\n    },\n    y = {},\n    C = {}.propertyIsEnumerable,\n    A = Object.getOwnPropertyDescriptor,\n    O = A && !C.call({\n      1: 2\n    }, 1);\n  y.f = O ? function (e) {\n    var t = A(this, e);\n    return !!t && t.enumerable;\n  } : C;\n  var b,\n    w,\n    N = function (e, t) {\n      return {\n        enumerable: !(1 & e),\n        configurable: !(2 & e),\n        writable: !(4 & e),\n        value: t\n      };\n    },\n    D = d,\n    P = D({}.toString),\n    L = D(\"\".slice),\n    k = function (e) {\n      return L(P(e), 8, -1);\n    },\n    M = d,\n    U = i,\n    x = k,\n    V = h.Object,\n    j = M(\"\".split),\n    F = U(function () {\n      return !V(\"z\").propertyIsEnumerable(0);\n    }) ? function (e) {\n      return \"String\" == x(e) ? j(e, \"\") : V(e);\n    } : V,\n    B = h.TypeError,\n    G = function (e) {\n      if (null == e) throw B(\"Can't call method on \" + e);\n      return e;\n    },\n    W = F,\n    H = G,\n    K = function (e) {\n      return W(H(e));\n    },\n    Y = g,\n    q = function (e) {\n      return \"object\" == typeof e ? null !== e : Y(e);\n    },\n    J = {},\n    X = J,\n    z = h,\n    Q = g,\n    Z = function (e) {\n      return Q(e) ? e : void 0;\n    },\n    $ = function (e, t) {\n      return arguments.length < 2 ? Z(X[e]) || Z(z[e]) : X[e] && X[e][t] || z[e] && z[e][t];\n    },\n    ee = $(\"navigator\", \"userAgent\") || \"\",\n    te = h,\n    ie = ee,\n    re = te.process,\n    ne = te.Deno,\n    oe = re && re.versions || ne && ne.version,\n    se = oe && oe.v8;\n  se && (w = (b = se.split(\".\"))[0] > 0 && b[0] < 4 ? 1 : +(b[0] + b[1])), !w && ie && (!(b = ie.match(/Edge\\/(\\d+)/)) || b[1] >= 74) && (b = ie.match(/Chrome\\/(\\d+)/)) && (w = +b[1]);\n  var ae = w,\n    ce = ae,\n    de = i,\n    ue = !!Object.getOwnPropertySymbols && !de(function () {\n      var e = Symbol();\n      return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && ce && ce < 41;\n    }),\n    le = ue && !Symbol.sham && \"symbol\" == typeof Symbol.iterator,\n    he = $,\n    pe = g,\n    _e = u,\n    Ee = le,\n    fe = h.Object,\n    me = Ee ? function (e) {\n      return \"symbol\" == typeof e;\n    } : function (e) {\n      var t = he(\"Symbol\");\n      return pe(t) && _e(t.prototype, fe(e));\n    },\n    ge = h.String,\n    Se = function (e) {\n      try {\n        return ge(e);\n      } catch (e) {\n        return \"Object\";\n      }\n    },\n    Te = g,\n    ve = Se,\n    Re = h.TypeError,\n    Ie = function (e) {\n      if (Te(e)) return e;\n      throw Re(ve(e) + \" is not a function\");\n    },\n    ye = Ie,\n    Ce = function (e, t) {\n      var i = e[t];\n      return null == i ? void 0 : ye(i);\n    },\n    Ae = I,\n    Oe = g,\n    be = q,\n    we = h.TypeError,\n    Ne = {\n      exports: {}\n    },\n    De = h,\n    Pe = Object.defineProperty,\n    Le = function (e, t) {\n      try {\n        Pe(De, e, {\n          value: t,\n          configurable: !0,\n          writable: !0\n        });\n      } catch (i) {\n        De[e] = t;\n      }\n      return t;\n    },\n    ke = \"__core-js_shared__\",\n    Me = h[ke] || Le(ke, {}),\n    Ue = Me;\n  (Ne.exports = function (e, t) {\n    return Ue[e] || (Ue[e] = void 0 !== t ? t : {});\n  })(\"versions\", []).push({\n    version: \"3.20.3\",\n    mode: \"pure\",\n    copyright: \"Â© 2014-2022 Denis Pushkarev (zloirock.ru)\",\n    license: \"https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE\",\n    source: \"https://github.com/zloirock/core-js\"\n  });\n  var xe = G,\n    Ve = h.Object,\n    je = function (e) {\n      return Ve(xe(e));\n    },\n    Fe = je,\n    Be = d({}.hasOwnProperty),\n    Ge = Object.hasOwn || function (e, t) {\n      return Be(Fe(e), t);\n    },\n    We = d,\n    He = 0,\n    Ke = Math.random(),\n    Ye = We(1..toString),\n    qe = function (e) {\n      return \"Symbol(\" + (void 0 === e ? \"\" : e) + \")_\" + Ye(++He + Ke, 36);\n    },\n    Je = h,\n    Xe = Ne.exports,\n    ze = Ge,\n    Qe = qe,\n    Ze = ue,\n    $e = le,\n    et = Xe(\"wks\"),\n    tt = Je.Symbol,\n    it = tt && tt.for,\n    rt = $e ? tt : tt && tt.withoutSetter || Qe,\n    nt = function (e) {\n      if (!ze(et, e) || !Ze && \"string\" != typeof et[e]) {\n        var t = \"Symbol.\" + e;\n        Ze && ze(tt, e) ? et[e] = tt[e] : et[e] = $e && it ? it(t) : rt(t);\n      }\n      return et[e];\n    },\n    ot = I,\n    st = q,\n    at = me,\n    ct = Ce,\n    dt = function (e, t) {\n      var i, r;\n      if (\"string\" === t && Oe(i = e.toString) && !be(r = Ae(i, e))) return r;\n      if (Oe(i = e.valueOf) && !be(r = Ae(i, e))) return r;\n      if (\"string\" !== t && Oe(i = e.toString) && !be(r = Ae(i, e))) return r;\n      throw we(\"Can't convert object to primitive value\");\n    },\n    ut = nt,\n    lt = h.TypeError,\n    ht = ut(\"toPrimitive\"),\n    pt = function (e, t) {\n      if (!st(e) || at(e)) return e;\n      var i,\n        r = ct(e, ht);\n      if (r) {\n        if (void 0 === t && (t = \"default\"), i = ot(r, e, t), !st(i) || at(i)) return i;\n        throw lt(\"Can't convert object to primitive value\");\n      }\n      return void 0 === t && (t = \"number\"), dt(e, t);\n    },\n    _t = me,\n    Et = function (e) {\n      var t = pt(e, \"string\");\n      return _t(t) ? t : t + \"\";\n    },\n    ft = q,\n    mt = h.document,\n    gt = ft(mt) && ft(mt.createElement),\n    St = function (e) {\n      return gt ? mt.createElement(e) : {};\n    },\n    Tt = St,\n    vt = !T && !i(function () {\n      return 7 != Object.defineProperty(Tt(\"div\"), \"a\", {\n        get: function () {\n          return 7;\n        }\n      }).a;\n    }),\n    Rt = T,\n    It = I,\n    yt = y,\n    Ct = N,\n    At = K,\n    Ot = Et,\n    bt = Ge,\n    wt = vt,\n    Nt = Object.getOwnPropertyDescriptor;\n  S.f = Rt ? Nt : function (e, t) {\n    if (e = At(e), t = Ot(t), wt) try {\n      return Nt(e, t);\n    } catch (e) {}\n    if (bt(e, t)) return Ct(!It(yt.f, e, t), e[t]);\n  };\n  var Dt = i,\n    Pt = g,\n    Lt = /#|\\.prototype\\./,\n    kt = function (e, t) {\n      var i = Ut[Mt(e)];\n      return i == Vt || i != xt && (Pt(t) ? Dt(t) : !!t);\n    },\n    Mt = kt.normalize = function (e) {\n      return String(e).replace(Lt, \".\").toLowerCase();\n    },\n    Ut = kt.data = {},\n    xt = kt.NATIVE = \"N\",\n    Vt = kt.POLYFILL = \"P\",\n    jt = kt,\n    Ft = Ie,\n    Bt = r,\n    Gt = d(d.bind),\n    Wt = function (e, t) {\n      return Ft(e), void 0 === t ? e : Bt ? Gt(e, t) : function () {\n        return e.apply(t, arguments);\n      };\n    },\n    Ht = {},\n    Kt = T && i(function () {\n      return 42 != Object.defineProperty(function () {}, \"prototype\", {\n        value: 42,\n        writable: !1\n      }).prototype;\n    }),\n    Yt = h,\n    qt = q,\n    Jt = Yt.String,\n    Xt = Yt.TypeError,\n    zt = function (e) {\n      if (qt(e)) return e;\n      throw Xt(Jt(e) + \" is not an object\");\n    },\n    Qt = T,\n    Zt = vt,\n    $t = Kt,\n    ei = zt,\n    ti = Et,\n    ii = h.TypeError,\n    ri = Object.defineProperty,\n    ni = Object.getOwnPropertyDescriptor,\n    oi = \"enumerable\",\n    si = \"configurable\",\n    ai = \"writable\";\n  Ht.f = Qt ? $t ? function (e, t, i) {\n    if (ei(e), t = ti(t), ei(i), \"function\" == typeof e && \"prototype\" === t && \"value\" in i && ai in i && !i.writable) {\n      var r = ni(e, t);\n      r && r.writable && (e[t] = i.value, i = {\n        configurable: si in i ? i.configurable : r.configurable,\n        enumerable: oi in i ? i.enumerable : r.enumerable,\n        writable: !1\n      });\n    }\n    return ri(e, t, i);\n  } : ri : function (e, t, i) {\n    if (ei(e), t = ti(t), ei(i), Zt) try {\n      return ri(e, t, i);\n    } catch (e) {}\n    if (\"get\" in i || \"set\" in i) throw ii(\"Accessors not supported\");\n    return \"value\" in i && (e[t] = i.value), e;\n  };\n  var ci = Ht,\n    di = N,\n    ui = T ? function (e, t, i) {\n      return ci.f(e, t, di(1, i));\n    } : function (e, t, i) {\n      return e[t] = i, e;\n    },\n    li = h,\n    hi = m,\n    pi = d,\n    _i = g,\n    Ei = S.f,\n    fi = jt,\n    mi = J,\n    gi = Wt,\n    Si = ui,\n    Ti = Ge,\n    vi = function (e) {\n      var t = function (i, r, n) {\n        if (this instanceof t) {\n          switch (arguments.length) {\n            case 0:\n              return new e();\n            case 1:\n              return new e(i);\n            case 2:\n              return new e(i, r);\n          }\n          return new e(i, r, n);\n        }\n        return hi(e, this, arguments);\n      };\n      return t.prototype = e.prototype, t;\n    },\n    Ri = function (e, t) {\n      var i,\n        r,\n        n,\n        o,\n        s,\n        a,\n        c,\n        d,\n        u = e.target,\n        l = e.global,\n        h = e.stat,\n        p = e.proto,\n        _ = l ? li : h ? li[u] : (li[u] || {}).prototype,\n        E = l ? mi : mi[u] || Si(mi, u, {})[u],\n        f = E.prototype;\n      for (n in t) i = !fi(l ? n : u + (h ? \".\" : \"#\") + n, e.forced) && _ && Ti(_, n), s = E[n], i && (a = e.noTargetGet ? (d = Ei(_, n)) && d.value : _[n]), o = i && a ? a : t[n], i && typeof s == typeof o || (c = e.bind && i ? gi(o, li) : e.wrap && i ? vi(o) : p && _i(o) ? pi(o) : o, (e.sham || o && o.sham || s && s.sham) && Si(c, \"sham\", !0), Si(E, n, c), p && (Ti(mi, r = u + \"Prototype\") || Si(mi, r, {}), Si(mi[r], n, o), e.real && f && !f[n] && Si(f, n, o)));\n    },\n    Ii = Math.ceil,\n    yi = Math.floor,\n    Ci = function (e) {\n      var t = +e;\n      return t != t || 0 === t ? 0 : (t > 0 ? yi : Ii)(t);\n    },\n    Ai = Ci,\n    Oi = Math.min,\n    bi = function (e) {\n      return e > 0 ? Oi(Ai(e), 9007199254740991) : 0;\n    },\n    wi = function (e) {\n      return bi(e.length);\n    },\n    Ni = Ie,\n    Di = je,\n    Pi = F,\n    Li = wi,\n    ki = h.TypeError,\n    Mi = function (e) {\n      return function (t, i, r, n) {\n        Ni(i);\n        var o = Di(t),\n          s = Pi(o),\n          a = Li(o),\n          c = e ? a - 1 : 0,\n          d = e ? -1 : 1;\n        if (r < 2) for (;;) {\n          if (c in s) {\n            n = s[c], c += d;\n            break;\n          }\n          if (c += d, e ? c < 0 : a <= c) throw ki(\"Reduce of empty array with no initial value\");\n        }\n        for (; e ? c >= 0 : a > c; c += d) c in s && (n = i(n, s[c], c, o));\n        return n;\n      };\n    },\n    Ui = {\n      left: Mi(!1),\n      right: Mi(!0)\n    },\n    xi = i,\n    Vi = function (e, t) {\n      var i = [][e];\n      return !!i && xi(function () {\n        i.call(null, t || function () {\n          throw 1;\n        }, 1);\n      });\n    },\n    ji = \"process\" == k(h.process),\n    Fi = Ui.left,\n    Bi = ae,\n    Gi = ji;\n  Ri({\n    target: \"Array\",\n    proto: !0,\n    forced: !Vi(\"reduce\") || !Gi && Bi > 79 && Bi < 83\n  }, {\n    reduce: function (e) {\n      var t = arguments.length;\n      return Fi(this, e, t, t > 1 ? arguments[1] : void 0);\n    }\n  });\n  var Wi = J,\n    Hi = function (e) {\n      return Wi[e + \"Prototype\"];\n    },\n    Ki = Hi(\"Array\").reduce,\n    Yi = u,\n    qi = Ki,\n    Ji = Array.prototype,\n    Xi = function (e) {\n      var t = e.reduce;\n      return e === Ji || Yi(Ji, e) && t === Ji.reduce ? qi : t;\n    },\n    zi = Xi;\n  let Qi = !0,\n    Zi = !0;\n  function $i(e, t, i) {\n    const r = e.match(t);\n    return r && r.length >= i && parseInt(r[i], 10);\n  }\n  function er(e, t, i) {\n    if (!e.RTCPeerConnection) return;\n    const r = e.RTCPeerConnection.prototype,\n      n = r.addEventListener;\n    r.addEventListener = function (e, r) {\n      if (e !== t) return n.apply(this, arguments);\n      const o = e => {\n        const t = i(e);\n        t && (r.handleEvent ? r.handleEvent(t) : r(t));\n      };\n      return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map()), this._eventMap[t].set(r, o), n.apply(this, [e, o]);\n    };\n    const o = r.removeEventListener;\n    r.removeEventListener = function (e, i) {\n      if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments);\n      if (!this._eventMap[t].has(i)) return o.apply(this, arguments);\n      const r = this._eventMap[t].get(i);\n      return this._eventMap[t].delete(i), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, r]);\n    }, Object.defineProperty(r, \"on\" + t, {\n      get() {\n        return this[\"_on\" + t];\n      },\n      set(e) {\n        this[\"_on\" + t] && (this.removeEventListener(t, this[\"_on\" + t]), delete this[\"_on\" + t]), e && this.addEventListener(t, this[\"_on\" + t] = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  }\n  function tr(e) {\n    return \"boolean\" != typeof e ? new Error(\"Argument type: \" + typeof e + \". Please use a boolean.\") : (Qi = e, e ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n  }\n  function ir(e) {\n    return \"boolean\" != typeof e ? new Error(\"Argument type: \" + typeof e + \". Please use a boolean.\") : (Zi = !e, \"adapter.js deprecation warnings \" + (e ? \"disabled\" : \"enabled\"));\n  }\n  function rr() {\n    if (\"object\" == typeof window) {\n      if (Qi) return;\n      \"undefined\" != typeof console && \"function\" == typeof console.log && console.log.apply(console, arguments);\n    }\n  }\n  function nr(e, t) {\n    Zi && console.warn(e + \" is deprecated, please use \" + t + \" instead.\");\n  }\n  function or(e) {\n    const t = {\n      browser: null,\n      version: null\n    };\n    if (void 0 === e || !e.navigator) return t.browser = \"Not a browser.\", t;\n    const {\n      navigator: i\n    } = e;\n    if (i.mozGetUserMedia) t.browser = \"firefox\", t.version = $i(i.userAgent, /Firefox\\/(\\d+)\\./, 1);else if (i.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = \"chrome\", t.version = $i(i.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);else {\n      if (!e.RTCPeerConnection || !i.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) return t.browser = \"Not a supported browser.\", t;\n      t.browser = \"safari\", t.version = $i(i.userAgent, /AppleWebKit\\/(\\d+)\\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && \"currentDirection\" in e.RTCRtpTransceiver.prototype;\n    }\n    return t;\n  }\n  function sr(e) {\n    return \"[object Object]\" === Object.prototype.toString.call(e);\n  }\n  function ar(e) {\n    var t;\n    return sr(e) ? zi(t = Object.keys(e)).call(t, function (t, i) {\n      const r = sr(e[i]),\n        n = r ? ar(e[i]) : e[i],\n        o = r && !Object.keys(n).length;\n      return void 0 === n || o ? t : Object.assign(t, {\n        [i]: n\n      });\n    }, {}) : e;\n  }\n  function cr(e, t, i) {\n    const r = i ? \"outbound-rtp\" : \"inbound-rtp\",\n      n = new Map();\n    if (null === t) return n;\n    const o = [];\n    return e.forEach(e => {\n      \"track\" === e.type && e.trackIdentifier === t.id && o.push(e);\n    }), o.forEach(t => {\n      e.forEach(i => {\n        i.type === r && i.trackId === t.id && function e(t, i, r) {\n          i && !r.has(i.id) && (r.set(i.id, i), Object.keys(i).forEach(n => {\n            n.endsWith(\"Id\") ? e(t, t.get(i[n]), r) : n.endsWith(\"Ids\") && i[n].forEach(i => {\n              e(t, t.get(i), r);\n            });\n          }));\n        }(e, i, n);\n      });\n    }), n;\n  }\n  var dr = Ne.exports,\n    ur = qe,\n    lr = dr(\"keys\"),\n    hr = function (e) {\n      return lr[e] || (lr[e] = ur(e));\n    },\n    pr = !i(function () {\n      function e() {}\n      return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;\n    }),\n    _r = h,\n    Er = Ge,\n    fr = g,\n    mr = je,\n    gr = pr,\n    Sr = hr(\"IE_PROTO\"),\n    Tr = _r.Object,\n    vr = Tr.prototype,\n    Rr = gr ? Tr.getPrototypeOf : function (e) {\n      var t = mr(e);\n      if (Er(t, Sr)) return t[Sr];\n      var i = t.constructor;\n      return fr(i) && t instanceof i ? i.prototype : t instanceof Tr ? vr : null;\n    },\n    Ir = h,\n    yr = g,\n    Cr = Ir.String,\n    Ar = Ir.TypeError,\n    Or = d,\n    br = zt,\n    wr = function (e) {\n      if (\"object\" == typeof e || yr(e)) return e;\n      throw Ar(\"Can't set \" + Cr(e) + \" as a prototype\");\n    },\n    Nr = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n      var e,\n        t = !1,\n        i = {};\n      try {\n        (e = Or(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set))(i, []), t = i instanceof Array;\n      } catch (e) {}\n      return function (i, r) {\n        return br(i), wr(r), t ? e(i, r) : i.__proto__ = r, i;\n      };\n    }() : void 0),\n    Dr = {},\n    Pr = Ci,\n    Lr = Math.max,\n    kr = Math.min,\n    Mr = function (e, t) {\n      var i = Pr(e);\n      return i < 0 ? Lr(i + t, 0) : kr(i, t);\n    },\n    Ur = K,\n    xr = Mr,\n    Vr = wi,\n    jr = function (e) {\n      return function (t, i, r) {\n        var n,\n          o = Ur(t),\n          s = Vr(o),\n          a = xr(r, s);\n        if (e && i != i) {\n          for (; s > a;) if ((n = o[a++]) != n) return !0;\n        } else for (; s > a; a++) if ((e || a in o) && o[a] === i) return e || a || 0;\n        return !e && -1;\n      };\n    },\n    Fr = {\n      includes: jr(!0),\n      indexOf: jr(!1)\n    },\n    Br = {},\n    Gr = Ge,\n    Wr = K,\n    Hr = Fr.indexOf,\n    Kr = Br,\n    Yr = d([].push),\n    qr = function (e, t) {\n      var i,\n        r = Wr(e),\n        n = 0,\n        o = [];\n      for (i in r) !Gr(Kr, i) && Gr(r, i) && Yr(o, i);\n      for (; t.length > n;) Gr(r, i = t[n++]) && (~Hr(o, i) || Yr(o, i));\n      return o;\n    },\n    Jr = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"],\n    Xr = qr,\n    zr = Jr.concat(\"length\", \"prototype\");\n  Dr.f = Object.getOwnPropertyNames || function (e) {\n    return Xr(e, zr);\n  };\n  var Qr = {};\n  Qr.f = Object.getOwnPropertySymbols;\n  var Zr = $,\n    $r = Dr,\n    en = Qr,\n    tn = zt,\n    rn = d([].concat),\n    nn = Zr(\"Reflect\", \"ownKeys\") || function (e) {\n      var t = $r.f(tn(e)),\n        i = en.f;\n      return i ? rn(t, i(e)) : t;\n    },\n    on = Ge,\n    sn = nn,\n    an = S,\n    cn = Ht,\n    dn = {},\n    un = qr,\n    ln = Jr,\n    hn = Object.keys || function (e) {\n      return un(e, ln);\n    },\n    pn = T,\n    _n = Kt,\n    En = Ht,\n    fn = zt,\n    mn = K,\n    gn = hn;\n  dn.f = pn && !_n ? Object.defineProperties : function (e, t) {\n    fn(e);\n    for (var i, r = mn(t), n = gn(t), o = n.length, s = 0; o > s;) En.f(e, i = n[s++], r[i]);\n    return e;\n  };\n  var Sn,\n    Tn = $(\"document\", \"documentElement\"),\n    vn = zt,\n    Rn = dn,\n    In = Jr,\n    yn = Br,\n    Cn = Tn,\n    An = St,\n    On = hr(\"IE_PROTO\"),\n    bn = function () {},\n    wn = function (e) {\n      return \"<script>\" + e + \"</\" + \"script>\";\n    },\n    Nn = function (e) {\n      e.write(wn(\"\")), e.close();\n      var t = e.parentWindow.Object;\n      return e = null, t;\n    },\n    Dn = function () {\n      try {\n        Sn = new ActiveXObject(\"htmlfile\");\n      } catch (e) {}\n      var e, t;\n      Dn = \"undefined\" != typeof document ? document.domain && Sn ? Nn(Sn) : ((t = An(\"iframe\")).style.display = \"none\", Cn.appendChild(t), t.src = String(\"javascript:\"), (e = t.contentWindow.document).open(), e.write(wn(\"document.F=Object\")), e.close(), e.F) : Nn(Sn);\n      for (var i = In.length; i--;) delete Dn.prototype[In[i]];\n      return Dn();\n    };\n  yn[On] = !0;\n  var Pn = Object.create || function (e, t) {\n      var i;\n      return null !== e ? (bn.prototype = vn(e), i = new bn(), bn.prototype = null, i[On] = e) : i = Dn(), void 0 === t ? i : Rn.f(i, t);\n    },\n    Ln = d(\"\".replace),\n    kn = String(Error(\"zxcasd\").stack),\n    Mn = /\\n\\s*at [^:]*:[^\\n]*/,\n    Un = Mn.test(kn),\n    xn = q,\n    Vn = ui,\n    jn = {},\n    Fn = jn,\n    Bn = nt(\"iterator\"),\n    Gn = Array.prototype,\n    Wn = function (e) {\n      return void 0 !== e && (Fn.Array === e || Gn[Bn] === e);\n    },\n    Hn = {};\n  Hn[nt(\"toStringTag\")] = \"z\";\n  var Kn = \"[object z]\" === String(Hn),\n    Yn = h,\n    qn = Kn,\n    Jn = g,\n    Xn = k,\n    zn = nt(\"toStringTag\"),\n    Qn = Yn.Object,\n    Zn = \"Arguments\" == Xn(function () {\n      return arguments;\n    }()),\n    $n = qn ? Xn : function (e) {\n      var t, i, r;\n      return void 0 === e ? \"Undefined\" : null === e ? \"Null\" : \"string\" == typeof (i = function (e, t) {\n        try {\n          return e[t];\n        } catch (e) {}\n      }(t = Qn(e), zn)) ? i : Zn ? Xn(t) : \"Object\" == (r = Xn(t)) && Jn(t.callee) ? \"Arguments\" : r;\n    },\n    eo = $n,\n    to = Ce,\n    io = jn,\n    ro = nt(\"iterator\"),\n    no = function (e) {\n      if (null != e) return to(e, ro) || to(e, \"@@iterator\") || io[eo(e)];\n    },\n    oo = I,\n    so = Ie,\n    ao = zt,\n    co = Se,\n    uo = no,\n    lo = h.TypeError,\n    ho = function (e, t) {\n      var i = arguments.length < 2 ? uo(e) : t;\n      if (so(i)) return ao(oo(i, e));\n      throw lo(co(e) + \" is not iterable\");\n    },\n    po = I,\n    _o = zt,\n    Eo = Ce,\n    fo = function (e, t, i) {\n      var r, n;\n      _o(e);\n      try {\n        if (!(r = Eo(e, \"return\"))) {\n          if (\"throw\" === t) throw i;\n          return i;\n        }\n        r = po(r, e);\n      } catch (e) {\n        n = !0, r = e;\n      }\n      if (\"throw\" === t) throw i;\n      if (n) throw r;\n      return _o(r), i;\n    },\n    mo = Wt,\n    go = I,\n    So = zt,\n    To = Se,\n    vo = Wn,\n    Ro = wi,\n    Io = u,\n    yo = ho,\n    Co = no,\n    Ao = fo,\n    Oo = h.TypeError,\n    bo = function (e, t) {\n      this.stopped = e, this.result = t;\n    },\n    wo = bo.prototype,\n    No = function (e, t, i) {\n      var r,\n        n,\n        o,\n        s,\n        a,\n        c,\n        d,\n        u = i && i.that,\n        l = !(!i || !i.AS_ENTRIES),\n        h = !(!i || !i.IS_ITERATOR),\n        p = !(!i || !i.INTERRUPTED),\n        _ = mo(t, u),\n        E = function (e) {\n          return r && Ao(r, \"normal\", e), new bo(!0, e);\n        },\n        f = function (e) {\n          return l ? (So(e), p ? _(e[0], e[1], E) : _(e[0], e[1])) : p ? _(e, E) : _(e);\n        };\n      if (h) r = e;else {\n        if (!(n = Co(e))) throw Oo(To(e) + \" is not iterable\");\n        if (vo(n)) {\n          for (o = 0, s = Ro(e); s > o; o++) if ((a = f(e[o])) && Io(wo, a)) return a;\n          return new bo(!1);\n        }\n        r = yo(e, n);\n      }\n      for (c = r.next; !(d = go(c, r)).done;) {\n        try {\n          a = f(d.value);\n        } catch (e) {\n          Ao(r, \"throw\", e);\n        }\n        if (\"object\" == typeof a && a && Io(wo, a)) return a;\n      }\n      return new bo(!1);\n    },\n    Do = $n,\n    Po = h.String,\n    Lo = function (e) {\n      if (\"Symbol\" === Do(e)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n      return Po(e);\n    },\n    ko = Lo,\n    Mo = N,\n    Uo = !i(function () {\n      var e = Error(\"a\");\n      return !(\"stack\" in e) || (Object.defineProperty(e, \"stack\", Mo(1, 7)), 7 !== e.stack);\n    }),\n    xo = Ri,\n    Vo = h,\n    jo = u,\n    Fo = Rr,\n    Bo = Nr,\n    Go = function (e, t, i) {\n      for (var r = sn(t), n = cn.f, o = an.f, s = 0; s < r.length; s++) {\n        var a = r[s];\n        on(e, a) || i && on(i, a) || n(e, a, o(t, a));\n      }\n    },\n    Wo = Pn,\n    Ho = ui,\n    Ko = N,\n    Yo = function (e, t) {\n      if (Un && \"string\" == typeof e) for (; t--;) e = Ln(e, Mn, \"\");\n      return e;\n    },\n    qo = function (e, t) {\n      xn(t) && \"cause\" in t && Vn(e, \"cause\", t.cause);\n    },\n    Jo = No,\n    Xo = function (e, t) {\n      return void 0 === e ? arguments.length < 2 ? \"\" : t : ko(e);\n    },\n    zo = Uo,\n    Qo = nt(\"toStringTag\"),\n    Zo = Vo.Error,\n    $o = [].push,\n    es = function (e, t) {\n      var i,\n        r = arguments.length > 2 ? arguments[2] : void 0,\n        n = jo(ts, this);\n      Bo ? i = Bo(new Zo(), n ? Fo(this) : ts) : (i = n ? this : Wo(ts), Ho(i, Qo, \"Error\")), void 0 !== t && Ho(i, \"message\", Xo(t)), zo && Ho(i, \"stack\", Yo(i.stack, 1)), qo(i, r);\n      var o = [];\n      return Jo(e, $o, {\n        that: o\n      }), Ho(i, \"errors\", o), i;\n    };\n  Bo ? Bo(es, Zo) : Go(es, Zo, {\n    name: !0\n  });\n  var ts = es.prototype = Wo(Zo.prototype, {\n    constructor: Ko(1, es),\n    message: Ko(1, \"\"),\n    name: Ko(1, \"AggregateError\")\n  });\n  xo({\n    global: !0\n  }, {\n    AggregateError: es\n  });\n  var is = g,\n    rs = Me,\n    ns = d(Function.toString);\n  is(rs.inspectSource) || (rs.inspectSource = function (e) {\n    return ns(e);\n  });\n  var os,\n    ss,\n    as,\n    cs = rs.inspectSource,\n    ds = g,\n    us = cs,\n    ls = h.WeakMap,\n    hs = ds(ls) && /native code/.test(us(ls)),\n    ps = h,\n    _s = d,\n    Es = q,\n    fs = ui,\n    ms = Ge,\n    gs = Me,\n    Ss = hr,\n    Ts = Br,\n    vs = \"Object already initialized\",\n    Rs = ps.TypeError,\n    Is = ps.WeakMap;\n  if (hs || gs.state) {\n    var ys = gs.state || (gs.state = new Is()),\n      Cs = _s(ys.get),\n      As = _s(ys.has),\n      Os = _s(ys.set);\n    os = function (e, t) {\n      if (As(ys, e)) throw new Rs(vs);\n      return t.facade = e, Os(ys, e, t), t;\n    }, ss = function (e) {\n      return Cs(ys, e) || {};\n    }, as = function (e) {\n      return As(ys, e);\n    };\n  } else {\n    var bs = Ss(\"state\");\n    Ts[bs] = !0, os = function (e, t) {\n      if (ms(e, bs)) throw new Rs(vs);\n      return t.facade = e, fs(e, bs, t), t;\n    }, ss = function (e) {\n      return ms(e, bs) ? e[bs] : {};\n    }, as = function (e) {\n      return ms(e, bs);\n    };\n  }\n  var ws,\n    Ns,\n    Ds,\n    Ps = {\n      set: os,\n      get: ss,\n      has: as,\n      enforce: function (e) {\n        return as(e) ? ss(e) : os(e, {});\n      },\n      getterFor: function (e) {\n        return function (t) {\n          var i;\n          if (!Es(t) || (i = ss(t)).type !== e) throw Rs(\"Incompatible receiver, \" + e + \" required\");\n          return i;\n        };\n      }\n    },\n    Ls = T,\n    ks = Ge,\n    Ms = Function.prototype,\n    Us = Ls && Object.getOwnPropertyDescriptor,\n    xs = ks(Ms, \"name\"),\n    Vs = {\n      EXISTS: xs,\n      PROPER: xs && \"something\" === function () {}.name,\n      CONFIGURABLE: xs && (!Ls || Ls && Us(Ms, \"name\").configurable)\n    },\n    js = ui,\n    Fs = function (e, t, i, r) {\n      r && r.enumerable ? e[t] = i : js(e, t, i);\n    },\n    Bs = i,\n    Gs = g,\n    Ws = Pn,\n    Hs = Rr,\n    Ks = Fs,\n    Ys = nt(\"iterator\"),\n    qs = !1;\n  [].keys && (\"next\" in (Ds = [].keys()) ? (Ns = Hs(Hs(Ds))) !== Object.prototype && (ws = Ns) : qs = !0);\n  var Js = null == ws || Bs(function () {\n    var e = {};\n    return ws[Ys].call(e) !== e;\n  });\n  Gs((ws = Js ? {} : Ws(ws))[Ys]) || Ks(ws, Ys, function () {\n    return this;\n  });\n  var Xs = {\n      IteratorPrototype: ws,\n      BUGGY_SAFARI_ITERATORS: qs\n    },\n    zs = $n,\n    Qs = Kn ? {}.toString : function () {\n      return \"[object \" + zs(this) + \"]\";\n    },\n    Zs = Kn,\n    $s = Ht.f,\n    ea = ui,\n    ta = Ge,\n    ia = Qs,\n    ra = nt(\"toStringTag\"),\n    na = function (e, t, i, r) {\n      if (e) {\n        var n = i ? e : e.prototype;\n        ta(n, ra) || $s(n, ra, {\n          configurable: !0,\n          value: t\n        }), r && !Zs && ea(n, \"toString\", ia);\n      }\n    },\n    oa = Xs.IteratorPrototype,\n    sa = Pn,\n    aa = N,\n    ca = na,\n    da = jn,\n    ua = function () {\n      return this;\n    },\n    la = function (e, t, i, r) {\n      var n = t + \" Iterator\";\n      return e.prototype = sa(oa, {\n        next: aa(+!r, i)\n      }), ca(e, n, !1, !0), da[n] = ua, e;\n    },\n    ha = Ri,\n    pa = I,\n    _a = la,\n    Ea = Rr,\n    fa = na,\n    ma = Fs,\n    ga = jn,\n    Sa = Vs.PROPER,\n    Ta = Xs.BUGGY_SAFARI_ITERATORS,\n    va = nt(\"iterator\"),\n    Ra = \"keys\",\n    Ia = \"values\",\n    ya = \"entries\",\n    Ca = function () {\n      return this;\n    },\n    Aa = function (e, t, i, r, n, o, s) {\n      _a(i, t, r);\n      var a,\n        c,\n        d,\n        u = function (e) {\n          if (e === n && E) return E;\n          if (!Ta && e in p) return p[e];\n          switch (e) {\n            case Ra:\n            case Ia:\n            case ya:\n              return function () {\n                return new i(this, e);\n              };\n          }\n          return function () {\n            return new i(this);\n          };\n        },\n        l = t + \" Iterator\",\n        h = !1,\n        p = e.prototype,\n        _ = p[va] || p[\"@@iterator\"] || n && p[n],\n        E = !Ta && _ || u(n),\n        f = \"Array\" == t && p.entries || _;\n      if (f && (a = Ea(f.call(new e()))) !== Object.prototype && a.next && (fa(a, l, !0, !0), ga[l] = Ca), Sa && n == Ia && _ && _.name !== Ia && (h = !0, E = function () {\n        return pa(_, this);\n      }), n) if (c = {\n        values: u(Ia),\n        keys: o ? E : u(Ra),\n        entries: u(ya)\n      }, s) for (d in c) (Ta || h || !(d in p)) && ma(p, d, c[d]);else ha({\n        target: t,\n        proto: !0,\n        forced: Ta || h\n      }, c);\n      return s && p[va] !== E && ma(p, va, E, {\n        name: n\n      }), ga[t] = E, c;\n    },\n    Oa = K,\n    ba = jn,\n    wa = Ps;\n  Ht.f;\n  var Na = Aa,\n    Da = \"Array Iterator\",\n    Pa = wa.set,\n    La = wa.getterFor(Da);\n  Na(Array, \"Array\", function (e, t) {\n    Pa(this, {\n      type: Da,\n      target: Oa(e),\n      index: 0,\n      kind: t\n    });\n  }, function () {\n    var e = La(this),\n      t = e.target,\n      i = e.kind,\n      r = e.index++;\n    return !t || r >= t.length ? (e.target = void 0, {\n      value: void 0,\n      done: !0\n    }) : \"keys\" == i ? {\n      value: r,\n      done: !1\n    } : \"values\" == i ? {\n      value: t[r],\n      done: !1\n    } : {\n      value: [r, t[r]],\n      done: !1\n    };\n  }, \"values\"), ba.Arguments = ba.Array;\n  var ka = h.Promise,\n    Ma = Fs,\n    Ua = function (e, t, i) {\n      for (var r in t) i && i.unsafe && e[r] ? e[r] = t[r] : Ma(e, r, t[r], i);\n      return e;\n    },\n    xa = $,\n    Va = Ht,\n    ja = T,\n    Fa = nt(\"species\"),\n    Ba = u,\n    Ga = h.TypeError,\n    Wa = function (e, t) {\n      if (Ba(t, e)) return e;\n      throw Ga(\"Incorrect invocation\");\n    },\n    Ha = nt(\"iterator\"),\n    Ka = !1;\n  try {\n    var Ya = 0,\n      qa = {\n        next: function () {\n          return {\n            done: !!Ya++\n          };\n        },\n        return: function () {\n          Ka = !0;\n        }\n      };\n    qa[Ha] = function () {\n      return this;\n    }, Array.from(qa, function () {\n      throw 2;\n    });\n  } catch (e) {}\n  var Ja = d,\n    Xa = i,\n    za = g,\n    Qa = $n,\n    Za = cs,\n    $a = function () {},\n    ec = [],\n    tc = $(\"Reflect\", \"construct\"),\n    ic = /^\\s*(?:class|function)\\b/,\n    rc = Ja(ic.exec),\n    nc = !ic.exec($a),\n    oc = function (e) {\n      if (!za(e)) return !1;\n      try {\n        return tc($a, ec, e), !0;\n      } catch (e) {\n        return !1;\n      }\n    },\n    sc = function (e) {\n      if (!za(e)) return !1;\n      switch (Qa(e)) {\n        case \"AsyncFunction\":\n        case \"GeneratorFunction\":\n        case \"AsyncGeneratorFunction\":\n          return !1;\n      }\n      try {\n        return nc || !!rc(ic, Za(e));\n      } catch (e) {\n        return !0;\n      }\n    };\n  sc.sham = !0;\n  var ac,\n    cc,\n    dc,\n    uc,\n    lc = !tc || Xa(function () {\n      var e;\n      return oc(oc.call) || !oc(Object) || !oc(function () {\n        e = !0;\n      }) || e;\n    }) ? sc : oc,\n    hc = lc,\n    pc = Se,\n    _c = h.TypeError,\n    Ec = zt,\n    fc = function (e) {\n      if (hc(e)) return e;\n      throw _c(pc(e) + \" is not a constructor\");\n    },\n    mc = nt(\"species\"),\n    gc = function (e, t) {\n      var i,\n        r = Ec(e).constructor;\n      return void 0 === r || null == (i = Ec(r)[mc]) ? t : fc(i);\n    },\n    Sc = d([].slice),\n    Tc = /(?:ipad|iphone|ipod).*applewebkit/i.test(ee),\n    vc = h,\n    Rc = m,\n    Ic = Wt,\n    yc = g,\n    Cc = Ge,\n    Ac = i,\n    Oc = Tn,\n    bc = Sc,\n    wc = St,\n    Nc = Tc,\n    Dc = ji,\n    Pc = vc.setImmediate,\n    Lc = vc.clearImmediate,\n    kc = vc.process,\n    Mc = vc.Dispatch,\n    Uc = vc.Function,\n    xc = vc.MessageChannel,\n    Vc = vc.String,\n    jc = 0,\n    Fc = {},\n    Bc = \"onreadystatechange\";\n  try {\n    ac = vc.location;\n  } catch (e) {}\n  var Gc = function (e) {\n      if (Cc(Fc, e)) {\n        var t = Fc[e];\n        delete Fc[e], t();\n      }\n    },\n    Wc = function (e) {\n      return function () {\n        Gc(e);\n      };\n    },\n    Hc = function (e) {\n      Gc(e.data);\n    },\n    Kc = function (e) {\n      vc.postMessage(Vc(e), ac.protocol + \"//\" + ac.host);\n    };\n  Pc && Lc || (Pc = function (e) {\n    var t = bc(arguments, 1);\n    return Fc[++jc] = function () {\n      Rc(yc(e) ? e : Uc(e), void 0, t);\n    }, cc(jc), jc;\n  }, Lc = function (e) {\n    delete Fc[e];\n  }, Dc ? cc = function (e) {\n    kc.nextTick(Wc(e));\n  } : Mc && Mc.now ? cc = function (e) {\n    Mc.now(Wc(e));\n  } : xc && !Nc ? (uc = (dc = new xc()).port2, dc.port1.onmessage = Hc, cc = Ic(uc.postMessage, uc)) : vc.addEventListener && yc(vc.postMessage) && !vc.importScripts && ac && \"file:\" !== ac.protocol && !Ac(Kc) ? (cc = Kc, vc.addEventListener(\"message\", Hc, !1)) : cc = Bc in wc(\"script\") ? function (e) {\n    Oc.appendChild(wc(\"script\")).onreadystatechange = function () {\n      Oc.removeChild(this), Gc(e);\n    };\n  } : function (e) {\n    setTimeout(Wc(e), 0);\n  });\n  var Yc,\n    qc,\n    Jc,\n    Xc,\n    zc,\n    Qc,\n    Zc,\n    $c,\n    ed = {\n      set: Pc,\n      clear: Lc\n    },\n    td = h,\n    id = /ipad|iphone|ipod/i.test(ee) && void 0 !== td.Pebble,\n    rd = /web0s(?!.*chrome)/i.test(ee),\n    nd = h,\n    od = Wt,\n    sd = S.f,\n    ad = ed.set,\n    cd = Tc,\n    dd = id,\n    ud = rd,\n    ld = ji,\n    hd = nd.MutationObserver || nd.WebKitMutationObserver,\n    pd = nd.document,\n    _d = nd.process,\n    Ed = nd.Promise,\n    fd = sd(nd, \"queueMicrotask\"),\n    md = fd && fd.value;\n  md || (Yc = function () {\n    var e, t;\n    for (ld && (e = _d.domain) && e.exit(); qc;) {\n      t = qc.fn, qc = qc.next;\n      try {\n        t();\n      } catch (e) {\n        throw qc ? Xc() : Jc = void 0, e;\n      }\n    }\n    Jc = void 0, e && e.enter();\n  }, cd || ld || ud || !hd || !pd ? !dd && Ed && Ed.resolve ? ((Zc = Ed.resolve(void 0)).constructor = Ed, $c = od(Zc.then, Zc), Xc = function () {\n    $c(Yc);\n  }) : ld ? Xc = function () {\n    _d.nextTick(Yc);\n  } : (ad = od(ad, nd), Xc = function () {\n    ad(Yc);\n  }) : (zc = !0, Qc = pd.createTextNode(\"\"), new hd(Yc).observe(Qc, {\n    characterData: !0\n  }), Xc = function () {\n    Qc.data = zc = !zc;\n  }));\n  var gd = md || function (e) {\n      var t = {\n        fn: e,\n        next: void 0\n      };\n      Jc && (Jc.next = t), qc || (qc = t, Xc()), Jc = t;\n    },\n    Sd = {},\n    Td = Ie,\n    vd = function (e) {\n      var t, i;\n      this.promise = new e(function (e, r) {\n        if (void 0 !== t || void 0 !== i) throw TypeError(\"Bad Promise constructor\");\n        t = e, i = r;\n      }), this.resolve = Td(t), this.reject = Td(i);\n    };\n  Sd.f = function (e) {\n    return new vd(e);\n  };\n  var Rd = zt,\n    Id = q,\n    yd = Sd,\n    Cd = function (e, t) {\n      if (Rd(e), Id(t) && t.constructor === e) return t;\n      var i = yd.f(e);\n      return (0, i.resolve)(t), i.promise;\n    },\n    Ad = h,\n    Od = function (e) {\n      try {\n        return {\n          error: !1,\n          value: e()\n        };\n      } catch (e) {\n        return {\n          error: !0,\n          value: e\n        };\n      }\n    },\n    bd = function () {\n      this.head = null, this.tail = null;\n    };\n  bd.prototype = {\n    add: function (e) {\n      var t = {\n        item: e,\n        next: null\n      };\n      this.head ? this.tail.next = t : this.head = t, this.tail = t;\n    },\n    get: function () {\n      var e = this.head;\n      if (e) return this.head = e.next, this.tail === e && (this.tail = null), e.item;\n    }\n  };\n  var wd,\n    Nd,\n    Dd,\n    Pd = \"object\" == typeof window,\n    Ld = Ri,\n    kd = h,\n    Md = $,\n    Ud = I,\n    xd = ka,\n    Vd = Ua,\n    jd = na,\n    Fd = function (e) {\n      var t = xa(e),\n        i = Va.f;\n      ja && t && !t[Fa] && i(t, Fa, {\n        configurable: !0,\n        get: function () {\n          return this;\n        }\n      });\n    },\n    Bd = Ie,\n    Gd = g,\n    Wd = q,\n    Hd = Wa,\n    Kd = cs,\n    Yd = No,\n    qd = function (e, t) {\n      if (!t && !Ka) return !1;\n      var i = !1;\n      try {\n        var r = {};\n        r[Ha] = function () {\n          return {\n            next: function () {\n              return {\n                done: i = !0\n              };\n            }\n          };\n        }, e(r);\n      } catch (e) {}\n      return i;\n    },\n    Jd = gc,\n    Xd = ed.set,\n    zd = gd,\n    Qd = Cd,\n    Zd = function (e, t) {\n      var i = Ad.console;\n      i && i.error && (1 == arguments.length ? i.error(e) : i.error(e, t));\n    },\n    $d = Sd,\n    eu = Od,\n    tu = bd,\n    iu = Ps,\n    ru = jt,\n    nu = Pd,\n    ou = ji,\n    su = ae,\n    au = nt(\"species\"),\n    cu = \"Promise\",\n    du = iu.getterFor(cu),\n    uu = iu.set,\n    lu = iu.getterFor(cu),\n    hu = xd && xd.prototype,\n    pu = xd,\n    _u = hu,\n    Eu = kd.TypeError,\n    fu = kd.document,\n    mu = kd.process,\n    gu = $d.f,\n    Su = gu,\n    Tu = !!(fu && fu.createEvent && kd.dispatchEvent),\n    vu = Gd(kd.PromiseRejectionEvent),\n    Ru = \"unhandledrejection\",\n    Iu = ru(cu, function () {\n      var e = Kd(pu),\n        t = e !== String(pu);\n      if (!t && 66 === su) return !0;\n      if (!_u.finally) return !0;\n      if (su >= 51 && /native code/.test(e)) return !1;\n      var i = new pu(function (e) {\n          e(1);\n        }),\n        r = function (e) {\n          e(function () {}, function () {});\n        };\n      return (i.constructor = {})[au] = r, !(i.then(function () {}) instanceof r) || !t && nu && !vu;\n    }),\n    yu = Iu || !qd(function (e) {\n      pu.all(e).catch(function () {});\n    }),\n    Cu = function (e) {\n      var t;\n      return !(!Wd(e) || !Gd(t = e.then)) && t;\n    },\n    Au = function (e, t) {\n      var i,\n        r,\n        n,\n        o = t.value,\n        s = 1 == t.state,\n        a = s ? e.ok : e.fail,\n        c = e.resolve,\n        d = e.reject,\n        u = e.domain;\n      try {\n        a ? (s || (2 === t.rejection && Du(t), t.rejection = 1), !0 === a ? i = o : (u && u.enter(), i = a(o), u && (u.exit(), n = !0)), i === e.promise ? d(Eu(\"Promise-chain cycle\")) : (r = Cu(i)) ? Ud(r, i, c, d) : c(i)) : d(o);\n      } catch (e) {\n        u && !n && u.exit(), d(e);\n      }\n    },\n    Ou = function (e, t) {\n      e.notified || (e.notified = !0, zd(function () {\n        for (var i, r = e.reactions; i = r.get();) Au(i, e);\n        e.notified = !1, t && !e.rejection && wu(e);\n      }));\n    },\n    bu = function (e, t, i) {\n      var r, n;\n      Tu ? ((r = fu.createEvent(\"Event\")).promise = t, r.reason = i, r.initEvent(e, !1, !0), kd.dispatchEvent(r)) : r = {\n        promise: t,\n        reason: i\n      }, !vu && (n = kd[\"on\" + e]) ? n(r) : e === Ru && Zd(\"Unhandled promise rejection\", i);\n    },\n    wu = function (e) {\n      Ud(Xd, kd, function () {\n        var t,\n          i = e.facade,\n          r = e.value;\n        if (Nu(e) && (t = eu(function () {\n          ou ? mu.emit(\"unhandledRejection\", r, i) : bu(Ru, i, r);\n        }), e.rejection = ou || Nu(e) ? 2 : 1, t.error)) throw t.value;\n      });\n    },\n    Nu = function (e) {\n      return 1 !== e.rejection && !e.parent;\n    },\n    Du = function (e) {\n      Ud(Xd, kd, function () {\n        var t = e.facade;\n        ou ? mu.emit(\"rejectionHandled\", t) : bu(\"rejectionhandled\", t, e.value);\n      });\n    },\n    Pu = function (e, t, i) {\n      return function (r) {\n        e(t, r, i);\n      };\n    },\n    Lu = function (e, t, i) {\n      e.done || (e.done = !0, i && (e = i), e.value = t, e.state = 2, Ou(e, !0));\n    },\n    ku = function (e, t, i) {\n      if (!e.done) {\n        e.done = !0, i && (e = i);\n        try {\n          if (e.facade === t) throw Eu(\"Promise can't be resolved itself\");\n          var r = Cu(t);\n          r ? zd(function () {\n            var i = {\n              done: !1\n            };\n            try {\n              Ud(r, t, Pu(ku, i, e), Pu(Lu, i, e));\n            } catch (t) {\n              Lu(i, t, e);\n            }\n          }) : (e.value = t, e.state = 1, Ou(e, !1));\n        } catch (t) {\n          Lu({\n            done: !1\n          }, t, e);\n        }\n      }\n    };\n  Iu && (_u = (pu = function (e) {\n    Hd(this, _u), Bd(e), Ud(wd, this);\n    var t = du(this);\n    try {\n      e(Pu(ku, t), Pu(Lu, t));\n    } catch (e) {\n      Lu(t, e);\n    }\n  }).prototype, (wd = function (e) {\n    uu(this, {\n      type: cu,\n      done: !1,\n      notified: !1,\n      parent: !1,\n      reactions: new tu(),\n      rejection: !1,\n      state: 0,\n      value: void 0\n    });\n  }).prototype = Vd(_u, {\n    then: function (e, t) {\n      var i = lu(this),\n        r = gu(Jd(this, pu));\n      return i.parent = !0, r.ok = !Gd(e) || e, r.fail = Gd(t) && t, r.domain = ou ? mu.domain : void 0, 0 == i.state ? i.reactions.add(r) : zd(function () {\n        Au(r, i);\n      }), r.promise;\n    },\n    catch: function (e) {\n      return this.then(void 0, e);\n    }\n  }), Nd = function () {\n    var e = new wd(),\n      t = du(e);\n    this.promise = e, this.resolve = Pu(ku, t), this.reject = Pu(Lu, t);\n  }, $d.f = gu = function (e) {\n    return e === pu || e === Dd ? new Nd(e) : Su(e);\n  }), Ld({\n    global: !0,\n    wrap: !0,\n    forced: Iu\n  }, {\n    Promise: pu\n  }), jd(pu, cu, !1, !0), Fd(cu), Dd = Md(cu), Ld({\n    target: cu,\n    stat: !0,\n    forced: Iu\n  }, {\n    reject: function (e) {\n      var t = gu(this);\n      return Ud(t.reject, void 0, e), t.promise;\n    }\n  }), Ld({\n    target: cu,\n    stat: !0,\n    forced: true\n  }, {\n    resolve: function (e) {\n      return Qd(this === Dd ? pu : this, e);\n    }\n  }), Ld({\n    target: cu,\n    stat: !0,\n    forced: yu\n  }, {\n    all: function (e) {\n      var t = this,\n        i = gu(t),\n        r = i.resolve,\n        n = i.reject,\n        o = eu(function () {\n          var i = Bd(t.resolve),\n            o = [],\n            s = 0,\n            a = 1;\n          Yd(e, function (e) {\n            var c = s++,\n              d = !1;\n            a++, Ud(i, t, e).then(function (e) {\n              d || (d = !0, o[c] = e, --a || r(o));\n            }, n);\n          }), --a || r(o);\n        });\n      return o.error && n(o.value), i.promise;\n    },\n    race: function (e) {\n      var t = this,\n        i = gu(t),\n        r = i.reject,\n        n = eu(function () {\n          var n = Bd(t.resolve);\n          Yd(e, function (e) {\n            Ud(n, t, e).then(i.resolve, r);\n          });\n        });\n      return n.error && r(n.value), i.promise;\n    }\n  });\n  var Mu = I,\n    Uu = Ie,\n    xu = Sd,\n    Vu = Od,\n    ju = No;\n  Ri({\n    target: \"Promise\",\n    stat: !0\n  }, {\n    allSettled: function (e) {\n      var t = this,\n        i = xu.f(t),\n        r = i.resolve,\n        n = i.reject,\n        o = Vu(function () {\n          var i = Uu(t.resolve),\n            n = [],\n            o = 0,\n            s = 1;\n          ju(e, function (e) {\n            var a = o++,\n              c = !1;\n            s++, Mu(i, t, e).then(function (e) {\n              c || (c = !0, n[a] = {\n                status: \"fulfilled\",\n                value: e\n              }, --s || r(n));\n            }, function (e) {\n              c || (c = !0, n[a] = {\n                status: \"rejected\",\n                reason: e\n              }, --s || r(n));\n            });\n          }), --s || r(n);\n        });\n      return o.error && n(o.value), i.promise;\n    }\n  });\n  var Fu = Ie,\n    Bu = $,\n    Gu = I,\n    Wu = Sd,\n    Hu = Od,\n    Ku = No,\n    Yu = \"No one promise resolved\";\n  Ri({\n    target: \"Promise\",\n    stat: !0\n  }, {\n    any: function (e) {\n      var t = this,\n        i = Bu(\"AggregateError\"),\n        r = Wu.f(t),\n        n = r.resolve,\n        o = r.reject,\n        s = Hu(function () {\n          var r = Fu(t.resolve),\n            s = [],\n            a = 0,\n            c = 1,\n            d = !1;\n          Ku(e, function (e) {\n            var u = a++,\n              l = !1;\n            c++, Gu(r, t, e).then(function (e) {\n              l || d || (d = !0, n(e));\n            }, function (e) {\n              l || d || (l = !0, s[u] = e, --c || o(new i(s, Yu)));\n            });\n          }), --c || o(new i(s, Yu));\n        });\n      return s.error && o(s.value), r.promise;\n    }\n  });\n  var qu = ka,\n    Ju = $,\n    Xu = g,\n    zu = gc,\n    Qu = Cd;\n  Ri({\n    target: \"Promise\",\n    proto: !0,\n    real: !0,\n    forced: !!qu && i(function () {\n      qu.prototype.finally.call({\n        then: function () {}\n      }, function () {});\n    })\n  }, {\n    finally: function (e) {\n      var t = zu(this, Ju(\"Promise\")),\n        i = Xu(e);\n      return this.then(i ? function (i) {\n        return Qu(t, e()).then(function () {\n          return i;\n        });\n      } : e, i ? function (i) {\n        return Qu(t, e()).then(function () {\n          throw i;\n        });\n      } : e);\n    }\n  });\n  var Zu = d,\n    $u = Ci,\n    el = Lo,\n    tl = G,\n    il = Zu(\"\".charAt),\n    rl = Zu(\"\".charCodeAt),\n    nl = Zu(\"\".slice),\n    ol = function (e) {\n      return function (t, i) {\n        var r,\n          n,\n          o = el(tl(t)),\n          s = $u(i),\n          a = o.length;\n        return s < 0 || s >= a ? e ? \"\" : void 0 : (r = rl(o, s)) < 55296 || r > 56319 || s + 1 === a || (n = rl(o, s + 1)) < 56320 || n > 57343 ? e ? il(o, s) : r : e ? nl(o, s, s + 2) : n - 56320 + (r - 55296 << 10) + 65536;\n      };\n    },\n    sl = {\n      codeAt: ol(!1),\n      charAt: ol(!0)\n    },\n    al = sl.charAt,\n    cl = Lo,\n    dl = Ps,\n    ul = Aa,\n    ll = \"String Iterator\",\n    hl = dl.set,\n    pl = dl.getterFor(ll);\n  ul(String, \"String\", function (e) {\n    hl(this, {\n      type: ll,\n      string: cl(e),\n      index: 0\n    });\n  }, function () {\n    var e,\n      t = pl(this),\n      i = t.string,\n      r = t.index;\n    return r >= i.length ? {\n      value: void 0,\n      done: !0\n    } : (e = al(i, r), t.index += e.length, {\n      value: e,\n      done: !1\n    });\n  });\n  var _l = J.Promise,\n    El = {\n      CSSRuleList: 0,\n      CSSStyleDeclaration: 0,\n      CSSValueList: 0,\n      ClientRectList: 0,\n      DOMRectList: 0,\n      DOMStringList: 0,\n      DOMTokenList: 1,\n      DataTransferItemList: 0,\n      FileList: 0,\n      HTMLAllCollection: 0,\n      HTMLCollection: 0,\n      HTMLFormElement: 0,\n      HTMLSelectElement: 0,\n      MediaList: 0,\n      MimeTypeArray: 0,\n      NamedNodeMap: 0,\n      NodeList: 1,\n      PaintRequestList: 0,\n      Plugin: 0,\n      PluginArray: 0,\n      SVGLengthList: 0,\n      SVGNumberList: 0,\n      SVGPathSegList: 0,\n      SVGPointList: 0,\n      SVGStringList: 0,\n      SVGTransformList: 0,\n      SourceBufferList: 0,\n      StyleSheetList: 0,\n      TextTrackCueList: 0,\n      TextTrackList: 0,\n      TouchList: 0\n    },\n    fl = h,\n    ml = $n,\n    gl = ui,\n    Sl = jn,\n    Tl = nt(\"toStringTag\");\n  for (var vl in El) {\n    var Rl = fl[vl],\n      Il = Rl && Rl.prototype;\n    Il && ml(Il) !== Tl && gl(Il, Tl, vl), Sl[vl] = Sl.Array;\n  }\n  var yl = _l,\n    Cl = yl;\n  const Al = rr;\n  function Ol(e, t) {\n    const i = e && e.navigator;\n    if (!i.mediaDevices) return;\n    const r = function (e) {\n        if (\"object\" != typeof e || e.mandatory || e.optional) return e;\n        const t = {};\n        return Object.keys(e).forEach(i => {\n          if (\"require\" === i || \"advanced\" === i || \"mediaSource\" === i) return;\n          const r = \"object\" == typeof e[i] ? e[i] : {\n            ideal: e[i]\n          };\n          void 0 !== r.exact && \"number\" == typeof r.exact && (r.min = r.max = r.exact);\n          const n = function (e, t) {\n            return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : \"deviceId\" === t ? \"sourceId\" : t;\n          };\n          if (void 0 !== r.ideal) {\n            t.optional = t.optional || [];\n            let e = {};\n            \"number\" == typeof r.ideal ? (e[n(\"min\", i)] = r.ideal, t.optional.push(e), e = {}, e[n(\"max\", i)] = r.ideal, t.optional.push(e)) : (e[n(\"\", i)] = r.ideal, t.optional.push(e));\n          }\n          void 0 !== r.exact && \"number\" != typeof r.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[n(\"\", i)] = r.exact) : [\"min\", \"max\"].forEach(e => {\n            void 0 !== r[e] && (t.mandatory = t.mandatory || {}, t.mandatory[n(e, i)] = r[e]);\n          });\n        }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t;\n      },\n      n = function (e, n) {\n        if (t.version >= 61) return n(e);\n        if ((e = JSON.parse(JSON.stringify(e))) && \"object\" == typeof e.audio) {\n          const t = function (e, t, i) {\n            t in e && !(i in e) && (e[i] = e[t], delete e[t]);\n          };\n          t((e = JSON.parse(JSON.stringify(e))).audio, \"autoGainControl\", \"googAutoGainControl\"), t(e.audio, \"noiseSuppression\", \"googNoiseSuppression\"), e.audio = r(e.audio);\n        }\n        if (e && \"object\" == typeof e.video) {\n          let o = e.video.facingMode;\n          o = o && (\"object\" == typeof o ? o : {\n            ideal: o\n          });\n          const s = t.version < 66;\n          if (o && (\"user\" === o.exact || \"environment\" === o.exact || \"user\" === o.ideal || \"environment\" === o.ideal) && (!i.mediaDevices.getSupportedConstraints || !i.mediaDevices.getSupportedConstraints().facingMode || s)) {\n            let t;\n            if (delete e.video.facingMode, \"environment\" === o.exact || \"environment\" === o.ideal ? t = [\"back\", \"rear\"] : \"user\" !== o.exact && \"user\" !== o.ideal || (t = [\"front\"]), t) return i.mediaDevices.enumerateDevices().then(i => {\n              let s = (i = i.filter(e => \"videoinput\" === e.kind)).find(e => t.some(t => e.label.toLowerCase().includes(t)));\n              return !s && i.length && t.includes(\"back\") && (s = i[i.length - 1]), s && (e.video.deviceId = o.exact ? {\n                exact: s.deviceId\n              } : {\n                ideal: s.deviceId\n              }), e.video = r(e.video), Al(\"chrome: \" + JSON.stringify(e)), n(e);\n            });\n          }\n          e.video = r(e.video);\n        }\n        return Al(\"chrome: \" + JSON.stringify(e)), n(e);\n      },\n      o = function (e) {\n        return t.version >= 64 ? e : {\n          name: {\n            PermissionDeniedError: \"NotAllowedError\",\n            PermissionDismissedError: \"NotAllowedError\",\n            InvalidStateError: \"NotAllowedError\",\n            DevicesNotFoundError: \"NotFoundError\",\n            ConstraintNotSatisfiedError: \"OverconstrainedError\",\n            TrackStartError: \"NotReadableError\",\n            MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n            MediaDeviceKillSwitchOn: \"NotAllowedError\",\n            TabCaptureError: \"AbortError\",\n            ScreenCaptureError: \"AbortError\",\n            DeviceCaptureError: \"AbortError\"\n          }[e.name] || e.name,\n          message: e.message,\n          constraint: e.constraint || e.constraintName,\n          toString() {\n            return this.name + (this.message && \": \") + this.message;\n          }\n        };\n      };\n    if (i.getUserMedia = function (e, t, r) {\n      n(e, e => {\n        i.webkitGetUserMedia(e, t, e => {\n          r && r(o(e));\n        });\n      });\n    }.bind(i), i.mediaDevices.getUserMedia) {\n      const e = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n      i.mediaDevices.getUserMedia = function (t) {\n        return n(t, t => e(t).then(e => {\n          if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {\n            e.stop();\n          }), new DOMException(\"\", \"NotFoundError\");\n          return e;\n        }, e => Cl.reject(o(e))));\n      };\n    }\n  }\n  function bl(e) {\n    e.MediaStream = e.MediaStream || e.webkitMediaStream;\n  }\n  function wl(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection && !(\"ontrack\" in e.RTCPeerConnection.prototype)) {\n      Object.defineProperty(e.RTCPeerConnection.prototype, \"ontrack\", {\n        get() {\n          return this._ontrack;\n        },\n        set(e) {\n          this._ontrack && this.removeEventListener(\"track\", this._ontrack), this.addEventListener(\"track\", this._ontrack = e);\n        },\n        enumerable: !0,\n        configurable: !0\n      });\n      const t = e.RTCPeerConnection.prototype.setRemoteDescription;\n      e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        return this._ontrackpoly || (this._ontrackpoly = t => {\n          t.stream.addEventListener(\"addtrack\", i => {\n            let r;\n            r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === i.track.id) : {\n              track: i.track\n            };\n            const n = new Event(\"track\");\n            n.track = i.track, n.receiver = r, n.transceiver = {\n              receiver: r\n            }, n.streams = [t.stream], this.dispatchEvent(n);\n          }), t.stream.getTracks().forEach(i => {\n            let r;\n            r = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === i.id) : {\n              track: i\n            };\n            const n = new Event(\"track\");\n            n.track = i, n.receiver = r, n.transceiver = {\n              receiver: r\n            }, n.streams = [t.stream], this.dispatchEvent(n);\n          });\n        }, this.addEventListener(\"addstream\", this._ontrackpoly)), t.apply(this, arguments);\n      };\n    } else er(e, \"track\", e => (e.transceiver || Object.defineProperty(e, \"transceiver\", {\n      value: {\n        receiver: e.receiver\n      }\n    }), e));\n  }\n  function Nl(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection && !(\"getSenders\" in e.RTCPeerConnection.prototype) && \"createDTMFSender\" in e.RTCPeerConnection.prototype) {\n      const t = function (e, t) {\n        return {\n          track: t,\n          get dtmf() {\n            return void 0 === this._dtmf && (\"audio\" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf;\n          },\n          _pc: e\n        };\n      };\n      if (!e.RTCPeerConnection.prototype.getSenders) {\n        e.RTCPeerConnection.prototype.getSenders = function () {\n          return this._senders = this._senders || [], this._senders.slice();\n        };\n        const i = e.RTCPeerConnection.prototype.addTrack;\n        e.RTCPeerConnection.prototype.addTrack = function (e, r) {\n          let n = i.apply(this, arguments);\n          return n || (n = t(this, e), this._senders.push(n)), n;\n        };\n        const r = e.RTCPeerConnection.prototype.removeTrack;\n        e.RTCPeerConnection.prototype.removeTrack = function (e) {\n          r.apply(this, arguments);\n          const t = this._senders.indexOf(e);\n          -1 !== t && this._senders.splice(t, 1);\n        };\n      }\n      const i = e.RTCPeerConnection.prototype.addStream;\n      e.RTCPeerConnection.prototype.addStream = function (e) {\n        this._senders = this._senders || [], i.apply(this, [e]), e.getTracks().forEach(e => {\n          this._senders.push(t(this, e));\n        });\n      };\n      const r = e.RTCPeerConnection.prototype.removeStream;\n      e.RTCPeerConnection.prototype.removeStream = function (e) {\n        this._senders = this._senders || [], r.apply(this, [e]), e.getTracks().forEach(e => {\n          const t = this._senders.find(t => t.track === e);\n          t && this._senders.splice(this._senders.indexOf(t), 1);\n        });\n      };\n    } else if (\"object\" == typeof e && e.RTCPeerConnection && \"getSenders\" in e.RTCPeerConnection.prototype && \"createDTMFSender\" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !(\"dtmf\" in e.RTCRtpSender.prototype)) {\n      const t = e.RTCPeerConnection.prototype.getSenders;\n      e.RTCPeerConnection.prototype.getSenders = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      }, Object.defineProperty(e.RTCRtpSender.prototype, \"dtmf\", {\n        get() {\n          return void 0 === this._dtmf && (\"audio\" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;\n        }\n      });\n    }\n  }\n  function Dl(e) {\n    if (!e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.getStats;\n    e.RTCPeerConnection.prototype.getStats = function () {\n      const [e, i, r] = arguments;\n      if (arguments.length > 0 && \"function\" == typeof e) return t.apply(this, arguments);\n      if (0 === t.length && (0 === arguments.length || \"function\" != typeof e)) return t.apply(this, []);\n      const n = function (e) {\n          const t = {};\n          return e.result().forEach(e => {\n            const i = {\n              id: e.id,\n              timestamp: e.timestamp,\n              type: {\n                localcandidate: \"local-candidate\",\n                remotecandidate: \"remote-candidate\"\n              }[e.type] || e.type\n            };\n            e.names().forEach(t => {\n              i[t] = e.stat(t);\n            }), t[i.id] = i;\n          }), t;\n        },\n        o = function (e) {\n          return new Map(Object.keys(e).map(t => [t, e[t]]));\n        };\n      if (arguments.length >= 2) {\n        const r = function (e) {\n          i(o(n(e)));\n        };\n        return t.apply(this, [r, e]);\n      }\n      return new Cl((e, i) => {\n        t.apply(this, [function (t) {\n          e(o(n(t)));\n        }, i]);\n      }).then(i, r);\n    };\n  }\n  function Pl(e) {\n    if (!(\"object\" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;\n    if (!(\"getStats\" in e.RTCRtpSender.prototype)) {\n      const t = e.RTCPeerConnection.prototype.getSenders;\n      t && (e.RTCPeerConnection.prototype.getSenders = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      });\n      const i = e.RTCPeerConnection.prototype.addTrack;\n      i && (e.RTCPeerConnection.prototype.addTrack = function () {\n        const e = i.apply(this, arguments);\n        return e._pc = this, e;\n      }), e.RTCRtpSender.prototype.getStats = function () {\n        const e = this;\n        return this._pc.getStats().then(t => cr(t, e.track, !0));\n      };\n    }\n    if (!(\"getStats\" in e.RTCRtpReceiver.prototype)) {\n      const t = e.RTCPeerConnection.prototype.getReceivers;\n      t && (e.RTCPeerConnection.prototype.getReceivers = function () {\n        const e = t.apply(this, []);\n        return e.forEach(e => e._pc = this), e;\n      }), er(e, \"track\", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {\n        const e = this;\n        return this._pc.getStats().then(t => cr(t, e.track, !1));\n      };\n    }\n    if (!(\"getStats\" in e.RTCRtpSender.prototype) || !(\"getStats\" in e.RTCRtpReceiver.prototype)) return;\n    const t = e.RTCPeerConnection.prototype.getStats;\n    e.RTCPeerConnection.prototype.getStats = function () {\n      if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {\n        const e = arguments[0];\n        let t, i, r;\n        return this.getSenders().forEach(i => {\n          i.track === e && (t ? r = !0 : t = i);\n        }), this.getReceivers().forEach(t => (t.track === e && (i ? r = !0 : i = t), t.track === e)), r || t && i ? Cl.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\")) : t ? t.getStats() : i ? i.getStats() : Cl.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n      }\n      return t.apply(this, arguments);\n    };\n  }\n  function Ll(e) {\n    e.RTCPeerConnection.prototype.getLocalStreams = function () {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0]);\n    };\n    const t = e.RTCPeerConnection.prototype.addTrack;\n    e.RTCPeerConnection.prototype.addTrack = function (e, i) {\n      if (!i) return t.apply(this, arguments);\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      const r = t.apply(this, arguments);\n      return this._shimmedLocalStreams[i.id] ? -1 === this._shimmedLocalStreams[i.id].indexOf(r) && this._shimmedLocalStreams[i.id].push(r) : this._shimmedLocalStreams[i.id] = [i, r], r;\n    };\n    const i = e.RTCPeerConnection.prototype.addStream;\n    e.RTCPeerConnection.prototype.addStream = function (e) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {\n        if (this.getSenders().find(t => t.track === e)) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      });\n      const t = this.getSenders();\n      i.apply(this, arguments);\n      const r = this.getSenders().filter(e => -1 === t.indexOf(e));\n      this._shimmedLocalStreams[e.id] = [e].concat(r);\n    };\n    const r = e.RTCPeerConnection.prototype.removeStream;\n    e.RTCPeerConnection.prototype.removeStream = function (e) {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], r.apply(this, arguments);\n    };\n    const n = e.RTCPeerConnection.prototype.removeTrack;\n    e.RTCPeerConnection.prototype.removeTrack = function (e) {\n      return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {\n        const i = this._shimmedLocalStreams[t].indexOf(e);\n        -1 !== i && this._shimmedLocalStreams[t].splice(i, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t];\n      }), n.apply(this, arguments);\n    };\n  }\n  function kl(e, t) {\n    if (!e.RTCPeerConnection) return;\n    if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return Ll(e);\n    const i = e.RTCPeerConnection.prototype.getLocalStreams;\n    e.RTCPeerConnection.prototype.getLocalStreams = function () {\n      const e = i.apply(this);\n      return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id]);\n    };\n    const r = e.RTCPeerConnection.prototype.addStream;\n    e.RTCPeerConnection.prototype.addStream = function (t) {\n      if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {\n        if (this.getSenders().find(t => t.track === e)) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      }), !this._reverseStreams[t.id]) {\n        const i = new e.MediaStream(t.getTracks());\n        this._streams[t.id] = i, this._reverseStreams[i.id] = t, t = i;\n      }\n      r.apply(this, [t]);\n    };\n    const n = e.RTCPeerConnection.prototype.removeStream;\n    function o(e, t) {\n      let i = t.sdp;\n      return Object.keys(e._reverseStreams || []).forEach(t => {\n        const r = e._reverseStreams[t],\n          n = e._streams[r.id];\n        i = i.replace(new RegExp(n.id, \"g\"), r.id);\n      }), new RTCSessionDescription({\n        type: t.type,\n        sdp: i\n      });\n    }\n    function s(e, t) {\n      let i = t.sdp;\n      return Object.keys(e._reverseStreams || []).forEach(t => {\n        const r = e._reverseStreams[t],\n          n = e._streams[r.id];\n        i = i.replace(new RegExp(r.id, \"g\"), n.id);\n      }), new RTCSessionDescription({\n        type: t.type,\n        sdp: i\n      });\n    }\n    e.RTCPeerConnection.prototype.removeStream = function (e) {\n      this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, n.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id];\n    }, e.RTCPeerConnection.prototype.addTrack = function (t, i) {\n      if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n      const r = [].slice.call(arguments, 1);\n      if (1 !== r.length || !r[0].getTracks().find(e => e === t)) throw new DOMException(\"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\", \"NotSupportedError\");\n      const n = this.getSenders().find(e => e.track === t);\n      if (n) throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n      this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};\n      const o = this._streams[i.id];\n      if (o) o.addTrack(t), Cl.resolve().then(() => {\n        this.dispatchEvent(new Event(\"negotiationneeded\"));\n      });else {\n        const r = new e.MediaStream([t]);\n        this._streams[i.id] = r, this._reverseStreams[r.id] = i, this.addStream(r);\n      }\n      return this.getSenders().find(e => e.track === t);\n    }, [\"createOffer\", \"createAnswer\"].forEach(function (t) {\n      const i = e.RTCPeerConnection.prototype[t],\n        r = {\n          [t]() {\n            const e = arguments;\n            return arguments.length && \"function\" == typeof arguments[0] ? i.apply(this, [t => {\n              const i = o(this, t);\n              e[0].apply(null, [i]);\n            }, t => {\n              e[1] && e[1].apply(null, t);\n            }, arguments[2]]) : i.apply(this, arguments).then(e => o(this, e));\n          }\n        };\n      e.RTCPeerConnection.prototype[t] = r[t];\n    });\n    const a = e.RTCPeerConnection.prototype.setLocalDescription;\n    e.RTCPeerConnection.prototype.setLocalDescription = function () {\n      return arguments.length && arguments[0].type ? (arguments[0] = s(this, arguments[0]), a.apply(this, arguments)) : a.apply(this, arguments);\n    };\n    const c = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(e.RTCPeerConnection.prototype, \"localDescription\", {\n      get() {\n        const e = c.get.apply(this);\n        return \"\" === e.type ? e : o(this, e);\n      }\n    }), e.RTCPeerConnection.prototype.removeTrack = function (e) {\n      if (\"closed\" === this.signalingState) throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n      if (!e._pc) throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\", \"TypeError\");\n      if (!(e._pc === this)) throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n      let t;\n      this._streams = this._streams || {}, Object.keys(this._streams).forEach(i => {\n        this._streams[i].getTracks().find(t => e.track === t) && (t = this._streams[i]);\n      }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event(\"negotiationneeded\")));\n    };\n  }\n  function Ml(e, t) {\n    !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (t) {\n      const i = e.RTCPeerConnection.prototype[t],\n        r = {\n          [t]() {\n            return arguments[0] = new (\"addIceCandidate\" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);\n          }\n        };\n      e.RTCPeerConnection.prototype[t] = r[t];\n    });\n  }\n  function Ul(e, t) {\n    er(e, \"negotiationneeded\", e => {\n      const i = e.target;\n      if (!(t.version < 72 || i.getConfiguration && \"plan-b\" === i.getConfiguration().sdpSemantics) || \"stable\" === i.signalingState) return e;\n    });\n  }\n  var xl = Object.freeze({\n    __proto__: null,\n    shimMediaStream: bl,\n    shimOnTrack: wl,\n    shimGetSendersWithDtmf: Nl,\n    shimGetStats: Dl,\n    shimSenderReceiverGetStats: Pl,\n    shimAddTrackRemoveTrackWithNative: Ll,\n    shimAddTrackRemoveTrack: kl,\n    shimPeerConnection: Ml,\n    fixNegotiationNeeded: Ul,\n    shimGetUserMedia: Ol,\n    shimGetDisplayMedia: function (e, t) {\n      e.navigator.mediaDevices && \"getDisplayMedia\" in e.navigator.mediaDevices || e.navigator.mediaDevices && (\"function\" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (i) {\n        return t(i).then(t => {\n          const r = i.video && i.video.width,\n            n = i.video && i.video.height,\n            o = i.video && i.video.frameRate;\n          return i.video = {\n            mandatory: {\n              chromeMediaSource: \"desktop\",\n              chromeMediaSourceId: t,\n              maxFrameRate: o || 3\n            }\n          }, r && (i.video.mandatory.maxWidth = r), n && (i.video.mandatory.maxHeight = n), e.navigator.mediaDevices.getUserMedia(i);\n        });\n      } : console.error(\"shimGetDisplayMedia: getSourceId argument is not a function\"));\n    }\n  });\n  function Vl(e, t) {\n    const i = e && e.navigator,\n      r = e && e.MediaStreamTrack;\n    if (i.getUserMedia = function (e, t, r) {\n      nr(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\"), i.mediaDevices.getUserMedia(e).then(t, r);\n    }, !(t.version > 55 && \"autoGainControl\" in i.mediaDevices.getSupportedConstraints())) {\n      const e = function (e, t, i) {\n          t in e && !(i in e) && (e[i] = e[t], delete e[t]);\n        },\n        t = i.mediaDevices.getUserMedia.bind(i.mediaDevices);\n      if (i.mediaDevices.getUserMedia = function (i) {\n        return \"object\" == typeof i && \"object\" == typeof i.audio && (i = JSON.parse(JSON.stringify(i)), e(i.audio, \"autoGainControl\", \"mozAutoGainControl\"), e(i.audio, \"noiseSuppression\", \"mozNoiseSuppression\")), t(i);\n      }, r && r.prototype.getSettings) {\n        const t = r.prototype.getSettings;\n        r.prototype.getSettings = function () {\n          const i = t.apply(this, arguments);\n          return e(i, \"mozAutoGainControl\", \"autoGainControl\"), e(i, \"mozNoiseSuppression\", \"noiseSuppression\"), i;\n        };\n      }\n      if (r && r.prototype.applyConstraints) {\n        const t = r.prototype.applyConstraints;\n        r.prototype.applyConstraints = function (i) {\n          return \"audio\" === this.kind && \"object\" == typeof i && (i = JSON.parse(JSON.stringify(i)), e(i, \"autoGainControl\", \"mozAutoGainControl\"), e(i, \"noiseSuppression\", \"mozNoiseSuppression\")), t.apply(this, [i]);\n        };\n      }\n    }\n  }\n  function jl(e) {\n    \"object\" == typeof e && e.RTCTrackEvent && \"receiver\" in e.RTCTrackEvent.prototype && !(\"transceiver\" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n  function Fl(e, t) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;\n    !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && [\"setLocalDescription\", \"setRemoteDescription\", \"addIceCandidate\"].forEach(function (t) {\n      const i = e.RTCPeerConnection.prototype[t],\n        r = {\n          [t]() {\n            return arguments[0] = new (\"addIceCandidate\" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), i.apply(this, arguments);\n          }\n        };\n      e.RTCPeerConnection.prototype[t] = r[t];\n    });\n    const i = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n      },\n      r = e.RTCPeerConnection.prototype.getStats;\n    e.RTCPeerConnection.prototype.getStats = function () {\n      const [e, n, o] = arguments;\n      return r.apply(this, [e || null]).then(e => {\n        if (t.version < 53 && !n) try {\n          e.forEach(e => {\n            e.type = i[e.type] || e.type;\n          });\n        } catch (t) {\n          if (\"TypeError\" !== t.name) throw t;\n          e.forEach((t, r) => {\n            e.set(r, Object.assign({}, t, {\n              type: i[t.type] || t.type\n            }));\n          });\n        }\n        return e;\n      }).then(n, o);\n    };\n  }\n  function Bl(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;\n    if (e.RTCRtpSender && \"getStats\" in e.RTCRtpSender.prototype) return;\n    const t = e.RTCPeerConnection.prototype.getSenders;\n    t && (e.RTCPeerConnection.prototype.getSenders = function () {\n      const e = t.apply(this, []);\n      return e.forEach(e => e._pc = this), e;\n    });\n    const i = e.RTCPeerConnection.prototype.addTrack;\n    i && (e.RTCPeerConnection.prototype.addTrack = function () {\n      const e = i.apply(this, arguments);\n      return e._pc = this, e;\n    }), e.RTCRtpSender.prototype.getStats = function () {\n      return this.track ? this._pc.getStats(this.track) : Cl.resolve(new Map());\n    };\n  }\n  function Gl(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;\n    if (e.RTCRtpSender && \"getStats\" in e.RTCRtpReceiver.prototype) return;\n    const t = e.RTCPeerConnection.prototype.getReceivers;\n    t && (e.RTCPeerConnection.prototype.getReceivers = function () {\n      const e = t.apply(this, []);\n      return e.forEach(e => e._pc = this), e;\n    }), er(e, \"track\", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {\n      return this._pc.getStats(this.track);\n    };\n  }\n  function Wl(e) {\n    e.RTCPeerConnection && !(\"removeStream\" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) {\n      nr(\"removeStream\", \"removeTrack\"), this.getSenders().forEach(t => {\n        t.track && e.getTracks().includes(t.track) && this.removeTrack(t);\n      });\n    });\n  }\n  function Hl(e) {\n    e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel);\n  }\n  function Kl(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.addTransceiver;\n    t && (e.RTCPeerConnection.prototype.addTransceiver = function () {\n      this.setParametersPromises = [];\n      let e = arguments[1] && arguments[1].sendEncodings;\n      void 0 === e && (e = []), e = [...e];\n      const i = e.length > 0;\n      i && e.forEach(e => {\n        if (\"rid\" in e) {\n          if (!/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError(\"Invalid RID value provided.\");\n        }\n        if (\"scaleResolutionDownBy\" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n        if (\"maxFramerate\" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError(\"max_framerate must be >= 0.0\");\n      });\n      const r = t.apply(this, arguments);\n      if (i) {\n        const {\n            sender: t\n          } = r,\n          i = t.getParameters();\n        (!(\"encodings\" in i) || 1 === i.encodings.length && 0 === Object.keys(i.encodings[0]).length) && (i.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(i).then(() => {\n          delete t.sendEncodings;\n        }).catch(() => {\n          delete t.sendEncodings;\n        })));\n      }\n      return r;\n    });\n  }\n  function Yl(e) {\n    if (\"object\" != typeof e || !e.RTCRtpSender) return;\n    const t = e.RTCRtpSender.prototype.getParameters;\n    t && (e.RTCRtpSender.prototype.getParameters = function () {\n      const e = t.apply(this, arguments);\n      return \"encodings\" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e;\n    });\n  }\n  function ql(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.createOffer;\n    e.RTCPeerConnection.prototype.createOffer = function () {\n      return this.setParametersPromises && this.setParametersPromises.length ? Cl.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {\n        this.setParametersPromises = [];\n      }) : t.apply(this, arguments);\n    };\n  }\n  function Jl(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype.createAnswer;\n    e.RTCPeerConnection.prototype.createAnswer = function () {\n      return this.setParametersPromises && this.setParametersPromises.length ? Cl.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {\n        this.setParametersPromises = [];\n      }) : t.apply(this, arguments);\n    };\n  }\n  var Xl = Object.freeze({\n    __proto__: null,\n    shimOnTrack: jl,\n    shimPeerConnection: Fl,\n    shimSenderGetStats: Bl,\n    shimReceiverGetStats: Gl,\n    shimRemoveStream: Wl,\n    shimRTCDataChannel: Hl,\n    shimAddTransceiver: Kl,\n    shimGetParameters: Yl,\n    shimCreateOffer: ql,\n    shimCreateAnswer: Jl,\n    shimGetUserMedia: Vl,\n    shimGetDisplayMedia: function (e, t) {\n      e.navigator.mediaDevices && \"getDisplayMedia\" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (i) {\n        if (!i || !i.video) {\n          const e = new DOMException(\"getDisplayMedia without video constraints is undefined\");\n          return e.name = \"NotFoundError\", e.code = 8, Cl.reject(e);\n        }\n        return !0 === i.video ? i.video = {\n          mediaSource: t\n        } : i.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(i);\n      });\n    }\n  });\n  function zl(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection) {\n      if (\"getLocalStreams\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () {\n        return this._localStreams || (this._localStreams = []), this._localStreams;\n      }), !(\"addStream\" in e.RTCPeerConnection.prototype)) {\n        const t = e.RTCPeerConnection.prototype.addTrack;\n        e.RTCPeerConnection.prototype.addStream = function (e) {\n          this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(i => t.call(this, i, e)), e.getVideoTracks().forEach(i => t.call(this, i, e));\n        }, e.RTCPeerConnection.prototype.addTrack = function (e) {\n          for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) r[n - 1] = arguments[n];\n          return r && r.forEach(e => {\n            this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e];\n          }), t.apply(this, arguments);\n        };\n      }\n      \"removeStream\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) {\n        this._localStreams || (this._localStreams = []);\n        const t = this._localStreams.indexOf(e);\n        if (-1 === t) return;\n        this._localStreams.splice(t, 1);\n        const i = e.getTracks();\n        this.getSenders().forEach(e => {\n          i.includes(e.track) && this.removeTrack(e);\n        });\n      });\n    }\n  }\n  function Ql(e) {\n    if (\"object\" == typeof e && e.RTCPeerConnection && (\"getRemoteStreams\" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () {\n      return this._remoteStreams ? this._remoteStreams : [];\n    }), !(\"onaddstream\" in e.RTCPeerConnection.prototype))) {\n      Object.defineProperty(e.RTCPeerConnection.prototype, \"onaddstream\", {\n        get() {\n          return this._onaddstream;\n        },\n        set(e) {\n          this._onaddstream && (this.removeEventListener(\"addstream\", this._onaddstream), this.removeEventListener(\"track\", this._onaddstreampoly)), this.addEventListener(\"addstream\", this._onaddstream = e), this.addEventListener(\"track\", this._onaddstreampoly = e => {\n            e.streams.forEach(e => {\n              if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;\n              this._remoteStreams.push(e);\n              const t = new Event(\"addstream\");\n              t.stream = e, this.dispatchEvent(t);\n            });\n          });\n        }\n      });\n      const t = e.RTCPeerConnection.prototype.setRemoteDescription;\n      e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n        const e = this;\n        return this._onaddstreampoly || this.addEventListener(\"track\", this._onaddstreampoly = function (t) {\n          t.streams.forEach(t => {\n            if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;\n            e._remoteStreams.push(t);\n            const i = new Event(\"addstream\");\n            i.stream = t, e.dispatchEvent(i);\n          });\n        }), t.apply(e, arguments);\n      };\n    }\n  }\n  function Zl(e) {\n    if (\"object\" != typeof e || !e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection.prototype,\n      i = t.createOffer,\n      r = t.createAnswer,\n      n = t.setLocalDescription,\n      o = t.setRemoteDescription,\n      s = t.addIceCandidate;\n    t.createOffer = function (e, t) {\n      const r = arguments.length >= 2 ? arguments[2] : arguments[0],\n        n = i.apply(this, [r]);\n      return t ? (n.then(e, t), Cl.resolve()) : n;\n    }, t.createAnswer = function (e, t) {\n      const i = arguments.length >= 2 ? arguments[2] : arguments[0],\n        n = r.apply(this, [i]);\n      return t ? (n.then(e, t), Cl.resolve()) : n;\n    };\n    let a = function (e, t, i) {\n      const r = n.apply(this, [e]);\n      return i ? (r.then(t, i), Cl.resolve()) : r;\n    };\n    t.setLocalDescription = a, a = function (e, t, i) {\n      const r = o.apply(this, [e]);\n      return i ? (r.then(t, i), Cl.resolve()) : r;\n    }, t.setRemoteDescription = a, a = function (e, t, i) {\n      const r = s.apply(this, [e]);\n      return i ? (r.then(t, i), Cl.resolve()) : r;\n    }, t.addIceCandidate = a;\n  }\n  function $l(e) {\n    const t = e && e.navigator;\n    if (t.mediaDevices && t.mediaDevices.getUserMedia) {\n      const e = t.mediaDevices,\n        i = e.getUserMedia.bind(e);\n      t.mediaDevices.getUserMedia = e => i(eh(e));\n    }\n    !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, i, r) {\n      t.mediaDevices.getUserMedia(e).then(i, r);\n    }.bind(t));\n  }\n  function eh(e) {\n    return e && void 0 !== e.video ? Object.assign({}, e, {\n      video: ar(e.video)\n    }) : e;\n  }\n  function th(e) {\n    if (!e.RTCPeerConnection) return;\n    const t = e.RTCPeerConnection;\n    e.RTCPeerConnection = function (e, i) {\n      if (e && e.iceServers) {\n        const t = [];\n        for (let i = 0; i < e.iceServers.length; i++) {\n          let r = e.iceServers[i];\n          !r.hasOwnProperty(\"urls\") && r.hasOwnProperty(\"url\") ? (nr(\"RTCIceServer.url\", \"RTCIceServer.urls\"), r = JSON.parse(JSON.stringify(r)), r.urls = r.url, delete r.url, t.push(r)) : t.push(e.iceServers[i]);\n        }\n        e.iceServers = t;\n      }\n      return new t(e, i);\n    }, e.RTCPeerConnection.prototype = t.prototype, \"generateCertificate\" in t && Object.defineProperty(e.RTCPeerConnection, \"generateCertificate\", {\n      get: () => t.generateCertificate\n    });\n  }\n  function ih(e) {\n    \"object\" == typeof e && e.RTCTrackEvent && \"receiver\" in e.RTCTrackEvent.prototype && !(\"transceiver\" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n      get() {\n        return {\n          receiver: this.receiver\n        };\n      }\n    });\n  }\n  function rh(e) {\n    const t = e.RTCPeerConnection.prototype.createOffer;\n    e.RTCPeerConnection.prototype.createOffer = function (e) {\n      if (e) {\n        void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);\n        const t = this.getTransceivers().find(e => \"audio\" === e.receiver.track.kind);\n        !1 === e.offerToReceiveAudio && t ? \"sendrecv\" === t.direction ? t.setDirection ? t.setDirection(\"sendonly\") : t.direction = \"sendonly\" : \"recvonly\" === t.direction && (t.setDirection ? t.setDirection(\"inactive\") : t.direction = \"inactive\") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);\n        const i = this.getTransceivers().find(e => \"video\" === e.receiver.track.kind);\n        !1 === e.offerToReceiveVideo && i ? \"sendrecv\" === i.direction ? i.setDirection ? i.setDirection(\"sendonly\") : i.direction = \"sendonly\" : \"recvonly\" === i.direction && (i.setDirection ? i.setDirection(\"inactive\") : i.direction = \"inactive\") : !0 !== e.offerToReceiveVideo || i || this.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        });\n      }\n      return t.apply(this, arguments);\n    };\n  }\n  function nh(e) {\n    \"object\" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext);\n  }\n  var oh = Object.freeze({\n      __proto__: null,\n      shimLocalStreamsAPI: zl,\n      shimRemoteStreamsAPI: Ql,\n      shimCallbacksAPI: Zl,\n      shimGetUserMedia: $l,\n      shimConstraints: eh,\n      shimRTCIceServerUrls: th,\n      shimTrackEventTransceiver: ih,\n      shimCreateOfferLegacy: rh,\n      shimAudioContext: nh\n    }),\n    sh = \"\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff\",\n    ah = G,\n    ch = Lo,\n    dh = d(\"\".replace),\n    uh = \"[\\t\\n\\v\\f\\r Â áââââââââââââ¯âã\\u2028\\u2029\\ufeff]\",\n    lh = RegExp(\"^\" + uh + uh + \"*\"),\n    hh = RegExp(uh + uh + \"*$\"),\n    ph = function (e) {\n      return function (t) {\n        var i = ch(ah(t));\n        return 1 & e && (i = dh(i, lh, \"\")), 2 & e && (i = dh(i, hh, \"\")), i;\n      };\n    },\n    _h = {\n      start: ph(1),\n      end: ph(2),\n      trim: ph(3)\n    },\n    Eh = Vs.PROPER,\n    fh = i,\n    mh = sh,\n    gh = _h.trim;\n  Ri({\n    target: \"String\",\n    proto: !0,\n    forced: function (e) {\n      return fh(function () {\n        return !!mh[e]() || \"âÂá \" !== \"âÂá \"[e]() || Eh && mh[e].name !== e;\n      });\n    }(\"trim\")\n  }, {\n    trim: function () {\n      return gh(this);\n    }\n  });\n  var Sh = Hi(\"String\").trim,\n    Th = u,\n    vh = Sh,\n    Rh = String.prototype,\n    Ih = function (e) {\n      var t = e.trim;\n      return \"string\" == typeof e || e === Rh || Th(Rh, e) && t === Rh.trim ? vh : t;\n    },\n    yh = {\n      exports: {}\n    };\n  !function (e) {\n    const t = {\n      generateIdentifier: function () {\n        return Math.random().toString(36).substr(2, 10);\n      }\n    };\n    t.localCName = t.generateIdentifier(), t.splitLines = function (e) {\n      return Ih(e).call(e).split(\"\\n\").map(e => Ih(e).call(e));\n    }, t.splitSections = function (e) {\n      return e.split(\"\\nm=\").map((e, t) => {\n        var i;\n        return Ih(i = t > 0 ? \"m=\" + e : e).call(i) + \"\\r\\n\";\n      });\n    }, t.getDescription = function (e) {\n      const i = t.splitSections(e);\n      return i && i[0];\n    }, t.getMediaSections = function (e) {\n      const i = t.splitSections(e);\n      return i.shift(), i;\n    }, t.matchPrefix = function (e, i) {\n      return t.splitLines(e).filter(e => 0 === e.indexOf(i));\n    }, t.parseCandidate = function (e) {\n      let t;\n      t = 0 === e.indexOf(\"a=candidate:\") ? e.substring(12).split(\" \") : e.substring(10).split(\" \");\n      const i = {\n        foundation: t[0],\n        component: {\n          1: \"rtp\",\n          2: \"rtcp\"\n        }[t[1]] || t[1],\n        protocol: t[2].toLowerCase(),\n        priority: parseInt(t[3], 10),\n        ip: t[4],\n        address: t[4],\n        port: parseInt(t[5], 10),\n        type: t[7]\n      };\n      for (let e = 8; e < t.length; e += 2) switch (t[e]) {\n        case \"raddr\":\n          i.relatedAddress = t[e + 1];\n          break;\n        case \"rport\":\n          i.relatedPort = parseInt(t[e + 1], 10);\n          break;\n        case \"tcptype\":\n          i.tcpType = t[e + 1];\n          break;\n        case \"ufrag\":\n          i.ufrag = t[e + 1], i.usernameFragment = t[e + 1];\n          break;\n        default:\n          void 0 === i[t[e]] && (i[t[e]] = t[e + 1]);\n      }\n      return i;\n    }, t.writeCandidate = function (e) {\n      const t = [];\n      t.push(e.foundation);\n      const i = e.component;\n      \"rtp\" === i ? t.push(1) : \"rtcp\" === i ? t.push(2) : t.push(i), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);\n      const r = e.type;\n      return t.push(\"typ\"), t.push(r), \"host\" !== r && e.relatedAddress && e.relatedPort && (t.push(\"raddr\"), t.push(e.relatedAddress), t.push(\"rport\"), t.push(e.relatedPort)), e.tcpType && \"tcp\" === e.protocol.toLowerCase() && (t.push(\"tcptype\"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push(\"ufrag\"), t.push(e.usernameFragment || e.ufrag)), \"candidate:\" + t.join(\" \");\n    }, t.parseIceOptions = function (e) {\n      return e.substr(14).split(\" \");\n    }, t.parseRtpMap = function (e) {\n      let t = e.substr(9).split(\" \");\n      const i = {\n        payloadType: parseInt(t.shift(), 10)\n      };\n      return t = t[0].split(\"/\"), i.name = t[0], i.clockRate = parseInt(t[1], 10), i.channels = 3 === t.length ? parseInt(t[2], 10) : 1, i.numChannels = i.channels, i;\n    }, t.writeRtpMap = function (e) {\n      let t = e.payloadType;\n      void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);\n      const i = e.channels || e.numChannels || 1;\n      return \"a=rtpmap:\" + t + \" \" + e.name + \"/\" + e.clockRate + (1 !== i ? \"/\" + i : \"\") + \"\\r\\n\";\n    }, t.parseExtmap = function (e) {\n      const t = e.substr(9).split(\" \");\n      return {\n        id: parseInt(t[0], 10),\n        direction: t[0].indexOf(\"/\") > 0 ? t[0].split(\"/\")[1] : \"sendrecv\",\n        uri: t[1]\n      };\n    }, t.writeExtmap = function (e) {\n      return \"a=extmap:\" + (e.id || e.preferredId) + (e.direction && \"sendrecv\" !== e.direction ? \"/\" + e.direction : \"\") + \" \" + e.uri + \"\\r\\n\";\n    }, t.parseFmtp = function (e) {\n      const t = {};\n      let i;\n      const r = e.substr(e.indexOf(\" \") + 1).split(\";\");\n      for (let e = 0; e < r.length; e++) {\n        var n, o;\n        i = Ih(n = r[e]).call(n).split(\"=\"), t[Ih(o = i[0]).call(o)] = i[1];\n      }\n      return t;\n    }, t.writeFmtp = function (e) {\n      let t = \"\",\n        i = e.payloadType;\n      if (void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {\n        const r = [];\n        Object.keys(e.parameters).forEach(t => {\n          void 0 !== e.parameters[t] ? r.push(t + \"=\" + e.parameters[t]) : r.push(t);\n        }), t += \"a=fmtp:\" + i + \" \" + r.join(\";\") + \"\\r\\n\";\n      }\n      return t;\n    }, t.parseRtcpFb = function (e) {\n      const t = e.substr(e.indexOf(\" \") + 1).split(\" \");\n      return {\n        type: t.shift(),\n        parameter: t.join(\" \")\n      };\n    }, t.writeRtcpFb = function (e) {\n      let t = \"\",\n        i = e.payloadType;\n      return void 0 !== e.preferredPayloadType && (i = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(e => {\n        t += \"a=rtcp-fb:\" + i + \" \" + e.type + (e.parameter && e.parameter.length ? \" \" + e.parameter : \"\") + \"\\r\\n\";\n      }), t;\n    }, t.parseSsrcMedia = function (e) {\n      const t = e.indexOf(\" \"),\n        i = {\n          ssrc: parseInt(e.substr(7, t - 7), 10)\n        },\n        r = e.indexOf(\":\", t);\n      return r > -1 ? (i.attribute = e.substr(t + 1, r - t - 1), i.value = e.substr(r + 1)) : i.attribute = e.substr(t + 1), i;\n    }, t.parseSsrcGroup = function (e) {\n      const t = e.substr(13).split(\" \");\n      return {\n        semantics: t.shift(),\n        ssrcs: t.map(e => parseInt(e, 10))\n      };\n    }, t.getMid = function (e) {\n      const i = t.matchPrefix(e, \"a=mid:\")[0];\n      if (i) return i.substr(6);\n    }, t.parseFingerprint = function (e) {\n      const t = e.substr(14).split(\" \");\n      return {\n        algorithm: t[0].toLowerCase(),\n        value: t[1].toUpperCase()\n      };\n    }, t.getDtlsParameters = function (e, i) {\n      return {\n        role: \"auto\",\n        fingerprints: t.matchPrefix(e + i, \"a=fingerprint:\").map(t.parseFingerprint)\n      };\n    }, t.writeDtlsParameters = function (e, t) {\n      let i = \"a=setup:\" + t + \"\\r\\n\";\n      return e.fingerprints.forEach(e => {\n        i += \"a=fingerprint:\" + e.algorithm + \" \" + e.value + \"\\r\\n\";\n      }), i;\n    }, t.parseCryptoLine = function (e) {\n      const t = e.substr(9).split(\" \");\n      return {\n        tag: parseInt(t[0], 10),\n        cryptoSuite: t[1],\n        keyParams: t[2],\n        sessionParams: t.slice(3)\n      };\n    }, t.writeCryptoLine = function (e) {\n      return \"a=crypto:\" + e.tag + \" \" + e.cryptoSuite + \" \" + (\"object\" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? \" \" + e.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n    }, t.parseCryptoKeyParams = function (e) {\n      if (0 !== e.indexOf(\"inline:\")) return null;\n      const t = e.substr(7).split(\"|\");\n      return {\n        keyMethod: \"inline\",\n        keySalt: t[0],\n        lifeTime: t[1],\n        mkiValue: t[2] ? t[2].split(\":\")[0] : void 0,\n        mkiLength: t[2] ? t[2].split(\":\")[1] : void 0\n      };\n    }, t.writeCryptoKeyParams = function (e) {\n      return e.keyMethod + \":\" + e.keySalt + (e.lifeTime ? \"|\" + e.lifeTime : \"\") + (e.mkiValue && e.mkiLength ? \"|\" + e.mkiValue + \":\" + e.mkiLength : \"\");\n    }, t.getCryptoParameters = function (e, i) {\n      return t.matchPrefix(e + i, \"a=crypto:\").map(t.parseCryptoLine);\n    }, t.getIceParameters = function (e, i) {\n      const r = t.matchPrefix(e + i, \"a=ice-ufrag:\")[0],\n        n = t.matchPrefix(e + i, \"a=ice-pwd:\")[0];\n      return r && n ? {\n        usernameFragment: r.substr(12),\n        password: n.substr(10)\n      } : null;\n    }, t.writeIceParameters = function (e) {\n      let t = \"a=ice-ufrag:\" + e.usernameFragment + \"\\r\\na=ice-pwd:\" + e.password + \"\\r\\n\";\n      return e.iceLite && (t += \"a=ice-lite\\r\\n\"), t;\n    }, t.parseRtpParameters = function (e) {\n      const i = {\n          codecs: [],\n          headerExtensions: [],\n          fecMechanisms: [],\n          rtcp: []\n        },\n        r = t.splitLines(e)[0].split(\" \");\n      for (let n = 3; n < r.length; n++) {\n        const o = r[n],\n          s = t.matchPrefix(e, \"a=rtpmap:\" + o + \" \")[0];\n        if (s) {\n          const r = t.parseRtpMap(s),\n            n = t.matchPrefix(e, \"a=fmtp:\" + o + \" \");\n          switch (r.parameters = n.length ? t.parseFmtp(n[0]) : {}, r.rtcpFeedback = t.matchPrefix(e, \"a=rtcp-fb:\" + o + \" \").map(t.parseRtcpFb), i.codecs.push(r), r.name.toUpperCase()) {\n            case \"RED\":\n            case \"ULPFEC\":\n              i.fecMechanisms.push(r.name.toUpperCase());\n          }\n        }\n      }\n      return t.matchPrefix(e, \"a=extmap:\").forEach(e => {\n        i.headerExtensions.push(t.parseExtmap(e));\n      }), i;\n    }, t.writeRtpDescription = function (e, i) {\n      let r = \"\";\n      r += \"m=\" + e + \" \", r += i.codecs.length > 0 ? \"9\" : \"0\", r += \" UDP/TLS/RTP/SAVPF \", r += i.codecs.map(e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType).join(\" \") + \"\\r\\n\", r += \"c=IN IP4 0.0.0.0\\r\\n\", r += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\", i.codecs.forEach(e => {\n        r += t.writeRtpMap(e), r += t.writeFmtp(e), r += t.writeRtcpFb(e);\n      });\n      let n = 0;\n      return i.codecs.forEach(e => {\n        e.maxptime > n && (n = e.maxptime);\n      }), n > 0 && (r += \"a=maxptime:\" + n + \"\\r\\n\"), i.headerExtensions && i.headerExtensions.forEach(e => {\n        r += t.writeExtmap(e);\n      }), r;\n    }, t.parseRtpEncodingParameters = function (e) {\n      const i = [],\n        r = t.parseRtpParameters(e),\n        n = -1 !== r.fecMechanisms.indexOf(\"RED\"),\n        o = -1 !== r.fecMechanisms.indexOf(\"ULPFEC\"),\n        s = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"cname\" === e.attribute),\n        a = s.length > 0 && s[0].ssrc;\n      let c;\n      const d = t.matchPrefix(e, \"a=ssrc-group:FID\").map(e => e.substr(17).split(\" \").map(e => parseInt(e, 10)));\n      d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), r.codecs.forEach(e => {\n        if (\"RTX\" === e.name.toUpperCase() && e.parameters.apt) {\n          let t = {\n            ssrc: a,\n            codecPayloadType: parseInt(e.parameters.apt, 10)\n          };\n          a && c && (t.rtx = {\n            ssrc: c\n          }), i.push(t), n && (t = JSON.parse(JSON.stringify(t)), t.fec = {\n            ssrc: a,\n            mechanism: o ? \"red+ulpfec\" : \"red\"\n          }, i.push(t));\n        }\n      }), 0 === i.length && a && i.push({\n        ssrc: a\n      });\n      let u = t.matchPrefix(e, \"b=\");\n      return u.length && (u = 0 === u[0].indexOf(\"b=TIAS:\") ? parseInt(u[0].substr(7), 10) : 0 === u[0].indexOf(\"b=AS:\") ? 1e3 * parseInt(u[0].substr(5), 10) * .95 - 16e3 : void 0, i.forEach(e => {\n        e.maxBitrate = u;\n      })), i;\n    }, t.parseRtcpParameters = function (e) {\n      const i = {},\n        r = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"cname\" === e.attribute)[0];\n      r && (i.cname = r.value, i.ssrc = r.ssrc);\n      const n = t.matchPrefix(e, \"a=rtcp-rsize\");\n      i.reducedSize = n.length > 0, i.compound = 0 === n.length;\n      const o = t.matchPrefix(e, \"a=rtcp-mux\");\n      return i.mux = o.length > 0, i;\n    }, t.writeRtcpParameters = function (e) {\n      let t = \"\";\n      return e.reducedSize && (t += \"a=rtcp-rsize\\r\\n\"), e.mux && (t += \"a=rtcp-mux\\r\\n\"), void 0 !== e.ssrc && e.cname && (t += \"a=ssrc:\" + e.ssrc + \" cname:\" + e.cname + \"\\r\\n\"), t;\n    }, t.parseMsid = function (e) {\n      let i;\n      const r = t.matchPrefix(e, \"a=msid:\");\n      if (1 === r.length) return i = r[0].substr(7).split(\" \"), {\n        stream: i[0],\n        track: i[1]\n      };\n      const n = t.matchPrefix(e, \"a=ssrc:\").map(e => t.parseSsrcMedia(e)).filter(e => \"msid\" === e.attribute);\n      return n.length > 0 ? (i = n[0].value.split(\" \"), {\n        stream: i[0],\n        track: i[1]\n      }) : void 0;\n    }, t.parseSctpDescription = function (e) {\n      const i = t.parseMLine(e),\n        r = t.matchPrefix(e, \"a=max-message-size:\");\n      let n;\n      r.length > 0 && (n = parseInt(r[0].substr(19), 10)), isNaN(n) && (n = 65536);\n      const o = t.matchPrefix(e, \"a=sctp-port:\");\n      if (o.length > 0) return {\n        port: parseInt(o[0].substr(12), 10),\n        protocol: i.fmt,\n        maxMessageSize: n\n      };\n      const s = t.matchPrefix(e, \"a=sctpmap:\");\n      if (s.length > 0) {\n        const e = s[0].substr(10).split(\" \");\n        return {\n          port: parseInt(e[0], 10),\n          protocol: e[1],\n          maxMessageSize: n\n        };\n      }\n    }, t.writeSctpDescription = function (e, t) {\n      let i = [];\n      return i = \"DTLS/SCTP\" !== e.protocol ? [\"m=\" + e.kind + \" 9 \" + e.protocol + \" \" + t.protocol + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctp-port:\" + t.port + \"\\r\\n\"] : [\"m=\" + e.kind + \" 9 \" + e.protocol + \" \" + t.port + \"\\r\\n\", \"c=IN IP4 0.0.0.0\\r\\n\", \"a=sctpmap:\" + t.port + \" \" + t.protocol + \" 65535\\r\\n\"], void 0 !== t.maxMessageSize && i.push(\"a=max-message-size:\" + t.maxMessageSize + \"\\r\\n\"), i.join(\"\");\n    }, t.generateSessionId = function () {\n      return Math.random().toString().substr(2, 21);\n    }, t.writeSessionBoilerplate = function (e, i, r) {\n      let n;\n      const o = void 0 !== i ? i : 2;\n      n = e || t.generateSessionId();\n      return \"v=0\\r\\no=\" + (r || \"thisisadapterortc\") + \" \" + n + \" \" + o + \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\";\n    }, t.getDirection = function (e, i) {\n      const r = t.splitLines(e);\n      for (let e = 0; e < r.length; e++) switch (r[e]) {\n        case \"a=sendrecv\":\n        case \"a=sendonly\":\n        case \"a=recvonly\":\n        case \"a=inactive\":\n          return r[e].substr(2);\n      }\n      return i ? t.getDirection(i) : \"sendrecv\";\n    }, t.getKind = function (e) {\n      return t.splitLines(e)[0].split(\" \")[0].substr(2);\n    }, t.isRejected = function (e) {\n      return \"0\" === e.split(\" \", 2)[1];\n    }, t.parseMLine = function (e) {\n      const i = t.splitLines(e)[0].substr(2).split(\" \");\n      return {\n        kind: i[0],\n        port: parseInt(i[1], 10),\n        protocol: i[2],\n        fmt: i.slice(3).join(\" \")\n      };\n    }, t.parseOLine = function (e) {\n      const i = t.matchPrefix(e, \"o=\")[0].substr(2).split(\" \");\n      return {\n        username: i[0],\n        sessionId: i[1],\n        sessionVersion: parseInt(i[2], 10),\n        netType: i[3],\n        addressType: i[4],\n        address: i[5]\n      };\n    }, t.isValidSDP = function (e) {\n      if (\"string\" != typeof e || 0 === e.length) return !1;\n      const i = t.splitLines(e);\n      for (let e = 0; e < i.length; e++) if (i[e].length < 2 || \"=\" !== i[e].charAt(1)) return !1;\n      return !0;\n    }, e.exports = t;\n  }(yh);\n  var Ch = yh.exports,\n    Ah = Object.freeze(e({\n      __proto__: null,\n      default: Ch\n    }, [yh.exports]));\n  function Oh(e) {\n    if (!e.RTCIceCandidate || e.RTCIceCandidate && \"foundation\" in e.RTCIceCandidate.prototype) return;\n    const t = e.RTCIceCandidate;\n    e.RTCIceCandidate = function (e) {\n      if (\"object\" == typeof e && e.candidate && 0 === e.candidate.indexOf(\"a=\") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {\n        const i = new t(e),\n          r = Ch.parseCandidate(e.candidate),\n          n = Object.assign(i, r);\n        return n.toJSON = function () {\n          return {\n            candidate: n.candidate,\n            sdpMid: n.sdpMid,\n            sdpMLineIndex: n.sdpMLineIndex,\n            usernameFragment: n.usernameFragment\n          };\n        }, n;\n      }\n      return new t(e);\n    }, e.RTCIceCandidate.prototype = t.prototype, er(e, \"icecandidate\", t => (t.candidate && Object.defineProperty(t, \"candidate\", {\n      value: new e.RTCIceCandidate(t.candidate),\n      writable: \"false\"\n    }), t));\n  }\n  function bh(e) {\n    !e.RTCIceCandidate || e.RTCIceCandidate && \"relayProtocol\" in e.RTCIceCandidate.prototype || er(e, \"icecandidate\", e => {\n      if (e.candidate) {\n        const t = Ch.parseCandidate(e.candidate.candidate);\n        \"relay\" === t.type && (e.candidate.relayProtocol = {\n          0: \"tls\",\n          1: \"tcp\",\n          2: \"udp\"\n        }[t.priority >> 24]);\n      }\n      return e;\n    });\n  }\n  function wh(e, t) {\n    if (!e.RTCPeerConnection) return;\n    \"sctp\" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, \"sctp\", {\n      get() {\n        return void 0 === this._sctp ? null : this._sctp;\n      }\n    });\n    const i = function (e) {\n        if (!e || !e.sdp) return !1;\n        const t = Ch.splitSections(e.sdp);\n        return t.shift(), t.some(e => {\n          const t = Ch.parseMLine(e);\n          return t && \"application\" === t.kind && -1 !== t.protocol.indexOf(\"SCTP\");\n        });\n      },\n      r = function (e) {\n        const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (null === t || t.length < 2) return -1;\n        const i = parseInt(t[1], 10);\n        return i != i ? -1 : i;\n      },\n      n = function (e) {\n        let i = 65536;\n        return \"firefox\" === t.browser && (i = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), i;\n      },\n      o = function (e, i) {\n        let r = 65536;\n        \"firefox\" === t.browser && 57 === t.version && (r = 65535);\n        const n = Ch.matchPrefix(e.sdp, \"a=max-message-size:\");\n        return n.length > 0 ? r = parseInt(n[0].substr(19), 10) : \"firefox\" === t.browser && -1 !== i && (r = 2147483637), r;\n      },\n      s = e.RTCPeerConnection.prototype.setRemoteDescription;\n    e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n      if (this._sctp = null, \"chrome\" === t.browser && t.version >= 76) {\n        const {\n          sdpSemantics: e\n        } = this.getConfiguration();\n        \"plan-b\" === e && Object.defineProperty(this, \"sctp\", {\n          get() {\n            return void 0 === this._sctp ? null : this._sctp;\n          },\n          enumerable: !0,\n          configurable: !0\n        });\n      }\n      if (i(arguments[0])) {\n        const e = r(arguments[0]),\n          t = n(e),\n          i = o(arguments[0], e);\n        let s;\n        s = 0 === t && 0 === i ? Number.POSITIVE_INFINITY : 0 === t || 0 === i ? Math.max(t, i) : Math.min(t, i);\n        const a = {};\n        Object.defineProperty(a, \"maxMessageSize\", {\n          get: () => s\n        }), this._sctp = a;\n      }\n      return s.apply(this, arguments);\n    };\n  }\n  function Nh(e) {\n    if (!e.RTCPeerConnection || !(\"createDataChannel\" in e.RTCPeerConnection.prototype)) return;\n    function t(e, t) {\n      const i = e.send;\n      e.send = function () {\n        const r = arguments[0],\n          n = r.length || r.size || r.byteLength;\n        if (\"open\" === e.readyState && t.sctp && n > t.sctp.maxMessageSize) throw new TypeError(\"Message too large (can send a maximum of \" + t.sctp.maxMessageSize + \" bytes)\");\n        return i.apply(e, arguments);\n      };\n    }\n    const i = e.RTCPeerConnection.prototype.createDataChannel;\n    e.RTCPeerConnection.prototype.createDataChannel = function () {\n      const e = i.apply(this, arguments);\n      return t(e, this), e;\n    }, er(e, \"datachannel\", e => (t(e.channel, e.target), e));\n  }\n  function Dh(e) {\n    if (!e.RTCPeerConnection || \"connectionState\" in e.RTCPeerConnection.prototype) return;\n    const t = e.RTCPeerConnection.prototype;\n    Object.defineProperty(t, \"connectionState\", {\n      get() {\n        return {\n          completed: \"connected\",\n          checking: \"connecting\"\n        }[this.iceConnectionState] || this.iceConnectionState;\n      },\n      enumerable: !0,\n      configurable: !0\n    }), Object.defineProperty(t, \"onconnectionstatechange\", {\n      get() {\n        return this._onconnectionstatechange || null;\n      },\n      set(e) {\n        this._onconnectionstatechange && (this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = e);\n      },\n      enumerable: !0,\n      configurable: !0\n    }), [\"setLocalDescription\", \"setRemoteDescription\"].forEach(e => {\n      const i = t[e];\n      t[e] = function () {\n        return this._connectionstatechangepoly || (this._connectionstatechangepoly = e => {\n          const t = e.target;\n          if (t._lastConnectionState !== t.connectionState) {\n            t._lastConnectionState = t.connectionState;\n            const i = new Event(\"connectionstatechange\", e);\n            t.dispatchEvent(i);\n          }\n          return e;\n        }, this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly)), i.apply(this, arguments);\n      };\n    });\n  }\n  function Ph(e, t) {\n    if (!e.RTCPeerConnection) return;\n    if (\"chrome\" === t.browser && t.version >= 71) return;\n    if (\"safari\" === t.browser && t.version >= 605) return;\n    const i = e.RTCPeerConnection.prototype.setRemoteDescription;\n    e.RTCPeerConnection.prototype.setRemoteDescription = function (t) {\n      if (t && t.sdp && -1 !== t.sdp.indexOf(\"\\na=extmap-allow-mixed\")) {\n        const i = t.sdp.split(\"\\n\").filter(e => \"a=extmap-allow-mixed\" !== Ih(e).call(e)).join(\"\\n\");\n        e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({\n          type: t.type,\n          sdp: i\n        }) : t.sdp = i;\n      }\n      return i.apply(this, arguments);\n    };\n  }\n  function Lh(e, t) {\n    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;\n    const i = e.RTCPeerConnection.prototype.addIceCandidate;\n    i && 0 !== i.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () {\n      return arguments[0] ? (\"chrome\" === t.browser && t.version < 78 || \"firefox\" === t.browser && t.version < 68 || \"safari\" === t.browser) && arguments[0] && \"\" === arguments[0].candidate ? Cl.resolve() : i.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Cl.resolve());\n    });\n  }\n  function kh(e, t) {\n    if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;\n    const i = e.RTCPeerConnection.prototype.setLocalDescription;\n    i && 0 !== i.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () {\n      let e = arguments[0] || {};\n      if (\"object\" != typeof e || e.type && e.sdp) return i.apply(this, arguments);\n      if (e = {\n        type: e.type,\n        sdp: e.sdp\n      }, !e.type) switch (this.signalingState) {\n        case \"stable\":\n        case \"have-local-offer\":\n        case \"have-remote-pranswer\":\n          e.type = \"offer\";\n          break;\n        default:\n          e.type = \"answer\";\n      }\n      if (e.sdp || \"offer\" !== e.type && \"answer\" !== e.type) return i.apply(this, [e]);\n      const t = \"offer\" === e.type ? this.createOffer : this.createAnswer;\n      return t.apply(this).then(e => i.apply(this, [e]));\n    });\n  }\n  var Mh = Object.freeze({\n    __proto__: null,\n    shimRTCIceCandidate: Oh,\n    shimRTCIceCandidateRelayProtocol: bh,\n    shimMaxMessageSize: wh,\n    shimSendThrowTypeError: Nh,\n    shimConnectionState: Dh,\n    removeExtmapAllowMixed: Ph,\n    shimAddIceCandidateNullOrEmpty: Lh,\n    shimParameterlessSetLocalDescription: kh\n  });\n  let Uh, xh;\n  !function () {\n    let {\n        window: e\n      } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n      t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n        shimChrome: !0,\n        shimFirefox: !0,\n        shimSafari: !0\n      };\n    const i = rr,\n      r = or(e),\n      n = {\n        browserDetails: r,\n        commonShim: Mh,\n        extractVersion: $i,\n        disableLog: tr,\n        disableWarnings: ir,\n        sdp: Ah\n      };\n    switch (r.browser) {\n      case \"chrome\":\n        if (!xl || !Ml || !t.shimChrome) return i(\"Chrome shim is not included in this adapter release.\"), n;\n        if (null === r.version) return i(\"Chrome shim can not determine version, not shimming.\"), n;\n        i(\"adapter.js shimming chrome.\"), n.browserShim = xl, Lh(e, r), kh(e), Ol(e, r), bl(e), Ml(e, r), wl(e), kl(e, r), Nl(e), Dl(e), Pl(e), Ul(e, r), Oh(e), bh(e), Dh(e), wh(e, r), Nh(e), Ph(e, r);\n        break;\n      case \"firefox\":\n        if (!Xl || !Fl || !t.shimFirefox) return i(\"Firefox shim is not included in this adapter release.\"), n;\n        i(\"adapter.js shimming firefox.\"), n.browserShim = Xl, Lh(e, r), kh(e), Vl(e, r), Fl(e, r), jl(e), Wl(e), Bl(e), Gl(e), Hl(e), Kl(e), Yl(e), ql(e), Jl(e), Oh(e), Dh(e), wh(e, r), Nh(e);\n        break;\n      case \"safari\":\n        if (!oh || !t.shimSafari) return i(\"Safari shim is not included in this adapter release.\"), n;\n        i(\"adapter.js shimming safari.\"), n.browserShim = oh, Lh(e, r), kh(e), th(e), rh(e), Zl(e), zl(e), Ql(e), ih(e), $l(e), nh(e), Oh(e), bh(e), wh(e, r), Nh(e), Ph(e, r);\n        break;\n      default:\n        i(\"Unsupported browser!\");\n    }\n  }({\n    window: \"undefined\" == typeof window ? void 0 : window\n  }), function (e) {\n    e.WIN_10 = \"Windows 10\", e.WIN_81 = \"Windows 8.1\", e.WIN_8 = \"Windows 8\", e.WIN_7 = \"Windows 7\", e.WIN_VISTA = \"Windows Vista\", e.WIN_SERVER_2003 = \"Windows Server 2003\", e.WIN_XP = \"Windows XP\", e.WIN_2000 = \"Windows 2000\", e.ANDROID = \"Android\", e.OPEN_BSD = \"Open BSD\", e.SUN_OS = \"Sun OS\", e.LINUX = \"Linux\", e.IOS = \"iOS\", e.MAC_OS = \"Mac OS\", e.QNX = \"QNX\", e.UNIX = \"UNIX\", e.BEOS = \"BeOS\", e.OS_2 = \"OS/2\", e.SEARCH_BOT = \"Search Bot\";\n  }(Uh || (Uh = {})), function (e) {\n    e.CHROME = \"Chrome\", e.SAFARI = \"Safari\", e.EDGE = \"Edge\", e.FIREFOX = \"Firefox\", e.OPERA = \"OPR\", e.QQ = \"QQBrowser\", e.WECHAT = \"MicroMessenger\";\n  }(xh || (xh = {}));\n  var Vh = {\n    exports: {}\n  };\n  !function (e, i) {\n    !function (t, r) {\n      var n = \"function\",\n        o = \"undefined\",\n        s = \"object\",\n        a = \"string\",\n        c = \"model\",\n        d = \"name\",\n        u = \"type\",\n        l = \"vendor\",\n        h = \"version\",\n        p = \"architecture\",\n        _ = \"console\",\n        E = \"mobile\",\n        f = \"tablet\",\n        m = \"smarttv\",\n        g = \"wearable\",\n        S = \"embedded\",\n        T = \"Amazon\",\n        v = \"Apple\",\n        R = \"ASUS\",\n        I = \"BlackBerry\",\n        y = \"Firefox\",\n        C = \"Google\",\n        A = \"Huawei\",\n        O = \"LG\",\n        b = \"Microsoft\",\n        w = \"Motorola\",\n        N = \"Opera\",\n        D = \"Samsung\",\n        P = \"Sharp\",\n        L = \"Sony\",\n        k = \"Xiaomi\",\n        M = \"Zebra\",\n        U = \"Facebook\",\n        x = function (e) {\n          for (var t = {}, i = 0; i < e.length; i++) t[e[i].toUpperCase()] = e[i];\n          return t;\n        },\n        V = function (e, t) {\n          return typeof e === a && -1 !== j(t).indexOf(j(e));\n        },\n        j = function (e) {\n          return e.toLowerCase();\n        },\n        F = function (e, t) {\n          if (typeof e === a) return e = e.replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\"), typeof t === o ? e : e.substring(0, 350);\n        },\n        B = function (e, t) {\n          for (var i, o, a, c, d, u, l = 0; l < t.length && !d;) {\n            var h = t[l],\n              p = t[l + 1];\n            for (i = o = 0; i < h.length && !d;) if (d = h[i++].exec(e)) for (a = 0; a < p.length; a++) u = d[++o], typeof (c = p[a]) === s && c.length > 0 ? 2 === c.length ? typeof c[1] == n ? this[c[0]] = c[1].call(this, u) : this[c[0]] = c[1] : 3 === c.length ? typeof c[1] !== n || c[1].exec && c[1].test ? this[c[0]] = u ? u.replace(c[1], c[2]) : r : this[c[0]] = u ? c[1].call(this, u, c[2]) : r : 4 === c.length && (this[c[0]] = u ? c[3].call(this, u.replace(c[1], c[2])) : r) : this[c] = u || r;\n            l += 2;\n          }\n        },\n        G = function (e, t) {\n          for (var i in t) if (typeof t[i] === s && t[i].length > 0) {\n            for (var n = 0; n < t[i].length; n++) if (V(t[i][n], e)) return \"?\" === i ? r : i;\n          } else if (V(t[i], e)) return \"?\" === i ? r : i;\n          return e;\n        },\n        W = {\n          ME: \"4.90\",\n          \"NT 3.11\": \"NT3.51\",\n          \"NT 4.0\": \"NT4.0\",\n          2e3: \"NT 5.0\",\n          XP: [\"NT 5.1\", \"NT 5.2\"],\n          Vista: \"NT 6.0\",\n          7: \"NT 6.1\",\n          8: \"NT 6.2\",\n          8.1: \"NT 6.3\",\n          10: [\"NT 6.4\", \"NT 10.0\"],\n          RT: \"ARM\"\n        },\n        H = {\n          browser: [[/\\b(?:crmo|crios)\\/([\\w\\.]+)/i], [h, [d, \"Chrome\"]], [/edg(?:e|ios|a)?\\/([\\w\\.]+)/i], [h, [d, \"Edge\"]], [/(opera mini)\\/([-\\w\\.]+)/i, /(opera [mobiletab]{3,6})\\b.+version\\/([-\\w\\.]+)/i, /(opera)(?:.+version\\/|[\\/ ]+)([\\w\\.]+)/i], [d, h], [/opios[\\/ ]+([\\w\\.]+)/i], [h, [d, \"Opera Mini\"]], [/\\bopr\\/([\\w\\.]+)/i], [h, [d, N]], [/(kindle)\\/([\\w\\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\\/ ]?([\\w\\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\\/ ]?([\\w\\.]*)/i, /(ba?idubrowser)[\\/ ]?([\\w\\.]+)/i, /(?:ms|\\()(ie) ([\\w\\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\\/([-\\w\\.]+)/i, /(weibo)__([\\d\\.]+)/i], [d, h], [/(?:\\buc? ?browser|(?:juc.+)ucweb)[\\/ ]?([\\w\\.]+)/i], [h, [d, \"UCBrowser\"]], [/microm.+\\bqbcore\\/([\\w\\.]+)/i, /\\bqbcore\\/([\\w\\.]+).+microm/i], [h, [d, \"WeChat(Win) Desktop\"]], [/micromessenger\\/([\\w\\.]+)/i], [h, [d, \"WeChat\"]], [/konqueror\\/([\\w\\.]+)/i], [h, [d, \"Konqueror\"]], [/trident.+rv[: ]([\\w\\.]{1,9})\\b.+like gecko/i], [h, [d, \"IE\"]], [/yabrowser\\/([\\w\\.]+)/i], [h, [d, \"Yandex\"]], [/(avast|avg)\\/([\\w\\.]+)/i], [[d, /(.+)/, \"$1 Secure Browser\"], h], [/\\bfocus\\/([\\w\\.]+)/i], [h, [d, \"Firefox Focus\"]], [/\\bopt\\/([\\w\\.]+)/i], [h, [d, \"Opera Touch\"]], [/coc_coc\\w+\\/([\\w\\.]+)/i], [h, [d, \"Coc Coc\"]], [/dolfin\\/([\\w\\.]+)/i], [h, [d, \"Dolphin\"]], [/coast\\/([\\w\\.]+)/i], [h, [d, \"Opera Coast\"]], [/miuibrowser\\/([\\w\\.]+)/i], [h, [d, \"MIUI Browser\"]], [/fxios\\/([-\\w\\.]+)/i], [h, [d, y]], [/\\bqihu|(qi?ho?o?|360)browser/i], [[d, \"360 Browser\"]], [/(oculus|samsung|sailfish|huawei)browser\\/([\\w\\.]+)/i], [[d, /(.+)/, \"$1 Browser\"], h], [/(comodo_dragon)\\/([\\w\\.]+)/i], [[d, /_/g, \" \"], h], [/(electron)\\/([\\w\\.]+) safari/i, /(tesla)(?: qtcarbrowser|\\/(20\\d\\d\\.[-\\w\\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\\/ ]?([\\w\\.]+)/i], [d, h], [/(metasr)[\\/ ]?([\\w\\.]+)/i, /(lbbrowser)/i, /\\[(linkedin)app\\]/i], [d], [/((?:fban\\/fbios|fb_iab\\/fb4a)(?!.+fbav)|;fbav\\/([\\w\\.]+);)/i], [[d, U], h], [/safari (line)\\/([\\w\\.]+)/i, /\\b(line)\\/([\\w\\.]+)\\/iab/i, /(chromium|instagram)[\\/ ]([-\\w\\.]+)/i], [d, h], [/\\bgsa\\/([\\w\\.]+) .*safari\\//i], [h, [d, \"GSA\"]], [/headlesschrome(?:\\/([\\w\\.]+)| )/i], [h, [d, \"Chrome Headless\"]], [/ wv\\).+(chrome)\\/([\\w\\.]+)/i], [[d, \"Chrome WebView\"], h], [/droid.+ version\\/([\\w\\.]+)\\b.+(?:mobile safari|safari)/i], [h, [d, \"Android Browser\"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\\/v?([\\w\\.]+)/i], [d, h], [/version\\/([\\w\\.\\,]+) .*mobile\\/\\w+ (safari)/i], [h, [d, \"Mobile Safari\"]], [/version\\/([\\w(\\.|\\,)]+) .*(mobile ?safari|safari)/i], [h, d], [/webkit.+?(mobile ?safari|safari)(\\/[\\w\\.]+)/i], [d, [h, G, {\n            \"1.0\": \"/8\",\n            1.2: \"/1\",\n            1.3: \"/3\",\n            \"2.0\": \"/412\",\n            \"2.0.2\": \"/416\",\n            \"2.0.3\": \"/417\",\n            \"2.0.4\": \"/419\",\n            \"?\": \"/\"\n          }]], [/(webkit|khtml)\\/([\\w\\.]+)/i], [d, h], [/(navigator|netscape\\d?)\\/([-\\w\\.]+)/i], [[d, \"Netscape\"], h], [/mobile vr; rv:([\\w\\.]+)\\).+firefox/i], [h, [d, \"Firefox Reality\"]], [/ekiohf.+(flow)\\/([\\w\\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\\/ ]?([\\w\\.\\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\\/([-\\w\\.]+)$/i, /(firefox)\\/([\\w\\.]+)/i, /(mozilla)\\/([\\w\\.]+) .+rv\\:.+gecko\\/\\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\\. ]?browser)[-\\/ ]?v?([\\w\\.]+)/i, /(links) \\(([\\w\\.]+)/i], [d, h]],\n          cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\\)]/i], [[p, \"amd64\"]], [/(ia32(?=;))/i], [[p, j]], [/((?:i[346]|x)86)[;\\)]/i], [[p, \"ia32\"]], [/\\b(aarch64|arm(v?8e?l?|_?64))\\b/i], [[p, \"arm64\"]], [/\\b(arm(?:v[67])?ht?n?[fl]p?)\\b/i], [[p, \"armhf\"]], [/windows (ce|mobile); ppc;/i], [[p, \"arm\"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\\))/i], [[p, /ower/, \"\", j]], [/(sun4\\w)[;\\)]/i], [[p, \"sparc\"]], [/((?:avr32|ia64(?=;))|68k(?=\\))|\\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\\b|pa-risc)/i], [[p, j]]],\n          device: [[/\\b(sch-i[89]0\\d|shw-m380s|sm-[ptx]\\w{2,4}|gt-[pn]\\d{2,4}|sgh-t8[56]9|nexus 10)/i], [c, [l, D], [u, f]], [/\\b((?:s[cgp]h|gt|sm)-\\w+|galaxy nexus)/i, /samsung[- ]([-\\w]+)/i, /sec-(sgh\\w+)/i], [c, [l, D], [u, E]], [/\\((ip(?:hone|od)[\\w ]*);/i], [c, [l, v], [u, E]], [/\\((ipad);[-\\w\\),; ]+apple/i, /applecoremedia\\/[\\w\\.]+ \\((ipad)/i, /\\b(ipad)\\d\\d?,\\d\\d?[;\\]].+ios/i], [c, [l, v], [u, f]], [/\\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\\d{2})\\b(?!.+d\\/s)/i], [c, [l, A], [u, f]], [/(?:huawei|honor)([-\\w ]+)[;\\)]/i, /\\b(nexus 6p|\\w{2,4}e?-[atu]?[ln][\\dx][012359c][adn]?)\\b(?!.+d\\/s)/i], [c, [l, A], [u, E]], [/\\b(poco[\\w ]+)(?: bui|\\))/i, /\\b; (\\w+) build\\/hm\\1/i, /\\b(hm[-_ ]?note?[_ ]?(?:\\d\\w)?) bui/i, /\\b(redmi[\\-_ ]?(?:note|k)?[\\w_ ]+)(?: bui|\\))/i, /\\b(mi[-_ ]?(?:a\\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\\d?\\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\\))/i], [[c, /_/g, \" \"], [l, k], [u, E]], [/\\b(mi[-_ ]?(?:pad)(?:[\\w_ ]+))(?: bui|\\))/i], [[c, /_/g, \" \"], [l, k], [u, f]], [/; (\\w+) bui.+ oppo/i, /\\b(cph[12]\\d{3}|p(?:af|c[al]|d\\w|e[ar])[mt]\\d0|x9007|a101op)\\b/i], [c, [l, \"OPPO\"], [u, E]], [/vivo (\\w+)(?: bui|\\))/i, /\\b(v[12]\\d{3}\\w?[at])(?: bui|;)/i], [c, [l, \"Vivo\"], [u, E]], [/\\b(rmx[12]\\d{3})(?: bui|;|\\))/i], [c, [l, \"Realme\"], [u, E]], [/\\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\\b[\\w ]+build\\//i, /\\bmot(?:orola)?[- ](\\w*)/i, /((?:moto[\\w\\(\\) ]+|xt\\d{3,4}|nexus 6)(?= bui|\\)))/i], [c, [l, w], [u, E]], [/\\b(mz60\\d|xoom[2 ]{0,2}) build\\//i], [c, [l, w], [u, f]], [/((?=lg)?[vl]k\\-?\\d{3}) bui| 3\\.[-\\w; ]{10}lg?-([06cv9]{3,4})/i], [c, [l, O], [u, f]], [/(lm(?:-?f100[nv]?|-[\\w\\.]+)(?= bui|\\))|nexus [45])/i, /\\blg[-e;\\/ ]+((?!browser|netcast|android tv)\\w+)/i, /\\blg-?([\\d\\w]+) bui/i], [c, [l, O], [u, E]], [/(ideatab[-\\w ]+)/i, /lenovo ?(s[56]000[-\\w]+|tab(?:[\\w ]+)|yt[-\\d\\w]{6}|tb[-\\d\\w]{6})/i], [c, [l, \"Lenovo\"], [u, f]], [/(?:maemo|nokia).*(n900|lumia \\d+)/i, /nokia[-_ ]?([-\\w\\.]*)/i], [[c, /_/g, \" \"], [l, \"Nokia\"], [u, E]], [/(pixel c)\\b/i], [c, [l, C], [u, f]], [/droid.+; (pixel[\\daxl ]{0,6})(?: bui|\\))/i], [c, [l, C], [u, E]], [/droid.+ (a?\\d[0-2]{2}so|[c-g]\\d{4}|so[-gl]\\w+|xq-a\\w[4-7][12])(?= bui|\\).+chrome\\/(?![1-6]{0,1}\\d\\.))/i], [c, [l, L], [u, E]], [/sony tablet [ps]/i, /\\b(?:sony)?sgp\\w+(?: bui|\\))/i], [[c, \"Xperia Tablet\"], [l, L], [u, f]], [/ (kb2005|in20[12]5|be20[12][59])\\b/i, /(?:one)?(?:plus)? (a\\d0\\d\\d)(?: b|\\))/i], [c, [l, \"OnePlus\"], [u, E]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\\))/i, /(kf[a-z]+)( bui|\\)).+silk\\//i], [c, [l, T], [u, f]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\\)).+silk\\//i], [[c, /(.+)/g, \"Fire Phone $1\"], [l, T], [u, E]], [/(playbook);[-\\w\\),; ]+(rim)/i], [c, l, [u, f]], [/\\b((?:bb[a-f]|st[hv])100-\\d)/i, /\\(bb10; (\\w+)/i], [c, [l, I], [u, E]], [/(?:\\b|asus_)(transfo[prime ]{4,10} \\w+|eeepc|slider \\w+|nexus 7|padfone|p00[cj])/i], [c, [l, R], [u, f]], [/ (z[bes]6[027][012][km][ls]|zenfone \\d\\w?)\\b/i], [c, [l, R], [u, E]], [/(nexus 9)/i], [c, [l, \"HTC\"], [u, f]], [/(htc)[-;_ ]{1,2}([\\w ]+(?=\\)| bui)|\\w+)/i, /(zte)[- ]([\\w ]+?)(?: bui|\\/|\\))/i, /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\\w]*)/i], [l, [c, /_/g, \" \"], [u, E]], [/droid.+; ([ab][1-7]-?[0178a]\\d\\d?)/i], [c, [l, \"Acer\"], [u, f]], [/droid.+; (m[1-5] note) bui/i, /\\bmz-([-\\w]{2,})/i], [c, [l, \"Meizu\"], [u, E]], [/\\b(sh-?[altvz]?\\d\\d[a-ekm]?)/i], [c, [l, P], [u, E]], [/(blackberry|benq|palm(?=\\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\\w]*)/i, /(hp) ([\\w ]+\\w)/i, /(asus)-?(\\w+)/i, /(microsoft); (lumia[\\w ]+)/i, /(lenovo)[-_ ]?([-\\w]+)/i, /(jolla)/i, /(oppo) ?([\\w ]+) bui/i], [l, c, [u, E]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\\/([\\w\\.]+)/i, /(nook)[\\w ]+build\\/(\\w+)/i, /(dell) (strea[kpr\\d ]*[\\dko])/i, /(le[- ]+pan)[- ]+(\\w{1,9}) bui/i, /(trinity)[- ]*(t\\d{3}) bui/i, /(gigaset)[- ]+(q\\w{1,9}) bui/i, /(vodafone) ([\\w ]+)(?:\\)| bui)/i], [l, c, [u, f]], [/(surface duo)/i], [c, [l, b], [u, f]], [/droid [\\d\\.]+; (fp\\du?)(?: b|\\))/i], [c, [l, \"Fairphone\"], [u, E]], [/(u304aa)/i], [c, [l, \"AT&T\"], [u, E]], [/\\bsie-(\\w*)/i], [c, [l, \"Siemens\"], [u, E]], [/\\b(rct\\w+) b/i], [c, [l, \"RCA\"], [u, f]], [/\\b(venue[\\d ]{2,7}) b/i], [c, [l, \"Dell\"], [u, f]], [/\\b(q(?:mv|ta)\\w+) b/i], [c, [l, \"Verizon\"], [u, f]], [/\\b(?:barnes[& ]+noble |bn[rt])([\\w\\+ ]*) b/i], [c, [l, \"Barnes & Noble\"], [u, f]], [/\\b(tm\\d{3}\\w+) b/i], [c, [l, \"NuVision\"], [u, f]], [/\\b(k88) b/i], [c, [l, \"ZTE\"], [u, f]], [/\\b(nx\\d{3}j) b/i], [c, [l, \"ZTE\"], [u, E]], [/\\b(gen\\d{3}) b.+49h/i], [c, [l, \"Swiss\"], [u, E]], [/\\b(zur\\d{3}) b/i], [c, [l, \"Swiss\"], [u, f]], [/\\b((zeki)?tb.*\\b) b/i], [c, [l, \"Zeki\"], [u, f]], [/\\b([yr]\\d{2}) b/i, /\\b(dragon[- ]+touch |dt)(\\w{5}) b/i], [[l, \"Dragon Touch\"], c, [u, f]], [/\\b(ns-?\\w{0,9}) b/i], [c, [l, \"Insignia\"], [u, f]], [/\\b((nxa|next)-?\\w{0,9}) b/i], [c, [l, \"NextBook\"], [u, f]], [/\\b(xtreme\\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[l, \"Voice\"], c, [u, E]], [/\\b(lvtel\\-)?(v1[12]) b/i], [[l, \"LvTel\"], c, [u, E]], [/\\b(ph-1) /i], [c, [l, \"Essential\"], [u, E]], [/\\b(v(100md|700na|7011|917g).*\\b) b/i], [c, [l, \"Envizen\"], [u, f]], [/\\b(trio[-\\w\\. ]+) b/i], [c, [l, \"MachSpeed\"], [u, f]], [/\\btu_(1491) b/i], [c, [l, \"Rotor\"], [u, f]], [/(shield[\\w ]+) b/i], [c, [l, \"Nvidia\"], [u, f]], [/(sprint) (\\w+)/i], [l, c, [u, E]], [/(kin\\.[onetw]{3})/i], [[c, /\\./g, \" \"], [l, b], [u, E]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\\)/i], [c, [l, M], [u, f]], [/droid.+; (ec30|ps20|tc[2-8]\\d[kx])\\)/i], [c, [l, M], [u, E]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [l, c, [u, _]], [/droid.+; (shield) bui/i], [c, [l, \"Nvidia\"], [u, _]], [/(playstation [345portablevi]+)/i], [c, [l, L], [u, _]], [/\\b(xbox(?: one)?(?!; xbox))[\\); ]/i], [c, [l, b], [u, _]], [/smart-tv.+(samsung)/i], [l, [u, m]], [/hbbtv.+maple;(\\d+)/i], [[c, /^/, \"SmartTV\"], [l, D], [u, m]], [/(nux; netcast.+smarttv|lg (netcast\\.tv-201\\d|android tv))/i], [[l, O], [u, m]], [/(apple) ?tv/i], [l, [c, \"Apple TV\"], [u, m]], [/crkey/i], [[c, \"Chromecast\"], [l, C], [u, m]], [/droid.+aft(\\w)( bui|\\))/i], [c, [l, T], [u, m]], [/\\(dtv[\\);].+(aquos)/i, /(aquos-tv[\\w ]+)\\)/i], [c, [l, P], [u, m]], [/(bravia[\\w ]+)( bui|\\))/i], [c, [l, L], [u, m]], [/(mitv-\\w{5}) bui/i], [c, [l, k], [u, m]], [/\\b(roku)[\\dx]*[\\)\\/]((?:dvp-)?[\\d\\.]*)/i, /hbbtv\\/\\d+\\.\\d+\\.\\d+ +\\([\\w ]*; *(\\w[^;]*);([^;]*)/i], [[l, F], [c, F], [u, m]], [/\\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\\b/i], [[u, m]], [/((pebble))app/i], [l, c, [u, g]], [/droid.+; (glass) \\d/i], [c, [l, C], [u, g]], [/droid.+; (wt63?0{2,3})\\)/i], [c, [l, M], [u, g]], [/(quest( 2)?)/i], [c, [l, U], [u, g]], [/(tesla)(?: qtcarbrowser|\\/[-\\w\\.]+)/i], [l, [u, S]], [/droid .+?; ([^;]+?)(?: bui|\\) applew).+? mobile safari/i], [c, [u, E]], [/droid .+?; ([^;]+?)(?: bui|\\) applew).+?(?! mobile) safari/i], [c, [u, f]], [/\\b((tablet|tab)[;\\/]|focus\\/\\d(?!.+mobile))/i], [[u, f]], [/(phone|mobile(?:[;\\/]| [ \\w\\/\\.]*safari)|pda(?=.+windows ce))/i], [[u, E]], [/(android[-\\w\\. ]{0,9});.+buil/i], [c, [l, \"Generic\"]]],\n          engine: [[/windows.+ edge\\/([\\w\\.]+)/i], [h, [d, \"EdgeHTML\"]], [/webkit\\/537\\.36.+chrome\\/(?!27)([\\w\\.]+)/i], [h, [d, \"Blink\"]], [/(presto)\\/([\\w\\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\\/([\\w\\.]+)/i, /ekioh(flow)\\/([\\w\\.]+)/i, /(khtml|tasman|links)[\\/ ]\\(?([\\w\\.]+)/i, /(icab)[\\/ ]([23]\\.[\\d\\.]+)/i], [d, h], [/rv\\:([\\w\\.]{1,9})\\b.+(gecko)/i], [h, d]],\n          os: [[/microsoft (windows) (vista|xp)/i], [d, h], [/(windows) nt 6\\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\\/ ]?([\\d\\.\\w ]*)/i, /(windows)[\\/ ]?([ntce\\d\\. ]+\\w)(?!.+xbox)/i], [d, [h, G, W]], [/(win(?=3|9|n)|win 9x )([nt\\d\\.]+)/i], [[d, \"Windows\"], [h, G, W]], [/ip[honead]{2,4}\\b(?:.*os ([\\w]+) like mac|; opera)/i, /cfnetwork\\/.+darwin/i], [[h, /_/g, \".\"], [d, \"iOS\"]], [/(mac os x) ?([\\w\\. ]*)/i, /(macintosh|mac_powerpc\\b)(?!.+haiku)/i], [[d, \"Mac OS\"], [h, /_/g, \".\"]], [/droid ([\\w\\.]+)\\b.+(android[- ]x86|harmonyos)/i], [h, d], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\\/ ]?([\\w\\.]*)/i, /(blackberry)\\w*\\/([\\w\\.]*)/i, /(tizen|kaios)[\\/ ]([\\w\\.]+)/i, /\\((series40);/i], [d, h], [/\\(bb(10);/i], [h, [d, I]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\\/ ]?([\\w\\.]*)/i], [h, [d, \"Symbian\"]], [/mozilla\\/[\\d\\.]+ \\((?:mobile|tablet|tv|mobile; [\\w ]+); rv:.+ gecko\\/([\\w\\.]+)/i], [h, [d, \"Firefox OS\"]], [/web0s;.+rt(tv)/i, /\\b(?:hp)?wos(?:browser)?\\/([\\w\\.]+)/i], [h, [d, \"webOS\"]], [/crkey\\/([\\d\\.]+)/i], [h, [d, \"Chromecast\"]], [/(cros) [\\w]+ ([\\w\\.]+\\w)/i], [[d, \"Chromium OS\"], h], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\\);]+)/i, /\\b(joli|palm)\\b ?(?:os)?\\/?([\\w\\.]*)/i, /(mint)[\\/\\(\\) ]?(\\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\\/ ]?(?!chrom|package)([-\\w\\.]*)/i, /(hurd|linux) ?([\\w\\.]*)/i, /(gnu) ?([\\w\\.]*)/i, /\\b([-frentopcghs]{0,5}bsd|dragonfly)[\\/ ]?(?!amd|[ix346]{1,2}86)([\\w\\.]*)/i, /(haiku) (\\w+)/i], [d, h], [/(sunos) ?([\\w\\.\\d]*)/i], [[d, \"Solaris\"], h], [/((?:open)?solaris)[-\\/ ]?([\\w\\.]*)/i, /(aix) ((\\d)(?=\\.|\\)| )[\\w\\.])*/i, /\\b(beos|os\\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\\w\\.]*)/i], [d, h]]\n        },\n        K = function (e, i) {\n          if (typeof e === s && (i = e, e = r), !(this instanceof K)) return new K(e, i).getResult();\n          var n = e || (typeof t !== o && t.navigator && t.navigator.userAgent ? t.navigator.userAgent : \"\"),\n            c = i ? function (e, t) {\n              var i = {};\n              for (var r in e) t[r] && t[r].length % 2 == 0 ? i[r] = t[r].concat(e[r]) : i[r] = e[r];\n              return i;\n            }(H, i) : H;\n          return this.getBrowser = function () {\n            var e = {};\n            return e.name = r, e.version = r, B.call(e, n, c.browser), e.major = function (e) {\n              return typeof e === a ? e.replace(/[^\\d\\.]/g, \"\").split(\".\")[0] : r;\n            }(e.version), e;\n          }, this.getCPU = function () {\n            var e = {};\n            return e.architecture = r, B.call(e, n, c.cpu), e;\n          }, this.getDevice = function () {\n            var e = {};\n            return e.vendor = r, e.model = r, e.type = r, B.call(e, n, c.device), e;\n          }, this.getEngine = function () {\n            var e = {};\n            return e.name = r, e.version = r, B.call(e, n, c.engine), e;\n          }, this.getOS = function () {\n            var e = {};\n            return e.name = r, e.version = r, B.call(e, n, c.os), e;\n          }, this.getResult = function () {\n            return {\n              ua: this.getUA(),\n              browser: this.getBrowser(),\n              engine: this.getEngine(),\n              os: this.getOS(),\n              device: this.getDevice(),\n              cpu: this.getCPU()\n            };\n          }, this.getUA = function () {\n            return n;\n          }, this.setUA = function (e) {\n            return n = typeof e === a && e.length > 350 ? F(e, 350) : e, this;\n          }, this.setUA(n), this;\n        };\n      K.VERSION = \"0.7.32\", K.BROWSER = x([d, h, \"major\"]), K.CPU = x([p]), K.DEVICE = x([c, l, u, _, E, m, f, g, S]), K.ENGINE = K.OS = x([d, h]), e.exports && (i = e.exports = K), i.UAParser = K;\n      var Y = typeof t !== o && (t.jQuery || t.Zepto);\n      if (Y && !Y.ua) {\n        var q = new K();\n        Y.ua = q.getResult(), Y.ua.get = function () {\n          return q.getUA();\n        }, Y.ua.set = function (e) {\n          q.setUA(e);\n          var t = q.getResult();\n          for (var i in t) Y.ua[i] = t[i];\n        };\n      }\n    }(\"object\" == typeof window ? window : t);\n  }(Vh, Vh.exports);\n  const jh = new (0, Vh.exports)();\n  let Fh = jh.getResult();\n  function Bh(e) {\n    return e && jh.setUA(e), Fh = jh.getResult(), {\n      name: Gh(Fh),\n      version: Wh(Fh),\n      os: Hh(Fh),\n      osVersion: Fh.os.version\n    };\n  }\n  function Gh(e) {\n    if (\"Blink\" === e.engine.name && \"WeChat\" !== e.browser.name) return xh.CHROME;\n    switch (e.browser.name) {\n      case \"Chrome Headless\":\n      case \"Chrome\":\n      case \"Chromium\":\n        return xh.CHROME;\n      case \"Safari\":\n      case \"Mobile Safari\":\n        return xh.SAFARI;\n      case \"Edge\":\n        return xh.EDGE;\n      case \"Firefox\":\n        return xh.FIREFOX;\n      case \"QQBrowser\":\n        return xh.QQ;\n      case \"Opera\":\n        return xh.OPERA;\n      case \"WeChat\":\n        return xh.WECHAT;\n      default:\n        return e.browser.name || \"\";\n    }\n  }\n  function Wh(e) {\n    let t;\n    return t = \"Blink\" === e.engine.name ? e.engine.version || \"\" : e.browser.version || \"\", t.split(\".\")[0];\n  }\n  function Hh(e) {\n    switch (e.os.name) {\n      case \"Windows\":\n        return e.os.version ? e.os.name + \" \" + e.os.version : e.os.name;\n      default:\n        return e.os.name || \"\";\n    }\n  }\n  function Kh() {\n    return Bh().os;\n  }\n  function Yh() {\n    const e = Bh();\n    return !!(\"WebKit\" === Fh.engine.name && e.os === Uh.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e.name !== xh.SAFARI || Zh() && e.name !== xh.SAFARI);\n  }\n  function qh() {\n    const e = Bh();\n    if (Yh()) {\n      if (e.os === Uh.MAC_OS) return !0;\n      if (e.os === Uh.IOS) {\n        const e = Fh.os.version && Fh.os.version.split(\".\");\n        if (e && 14 === Number(e[0]) && e[1] && Number(e[1]) >= 3) return !0;\n        if (e && Number(e[0]) > 14) return !0;\n      }\n    }\n    return !1;\n  }\n  function Jh() {\n    return \"WebKit\" === Fh.engine.name;\n  }\n  function Xh() {\n    return Bh().name === xh.CHROME;\n  }\n  function zh() {\n    return Bh().name === xh.SAFARI;\n  }\n  function Qh() {\n    return Bh().name === xh.FIREFOX;\n  }\n  function Zh() {\n    return Bh().os === Uh.IOS;\n  }\n  function $h() {\n    const e = Bh();\n    return !(e.name !== xh.CHROME || !e.osVersion) && Number(e.version) <= 90;\n  }\n  function ep() {\n    const e = Bh();\n    if (e.os !== Uh.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 15 === Number(t[0]);\n  }\n  function tp() {\n    const e = Bh();\n    if (e.os !== Uh.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 15 === Number(t[0]) && 0 === Number(t[1]);\n  }\n  function ip() {\n    const e = Bh();\n    if (e.os !== Uh.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 15 === Number(t[0]) && Number(t[1]) >= 1;\n  }\n  function rp() {\n    const e = Bh();\n    if (e.os !== Uh.IOS || !e.osVersion) return !1;\n    const t = e.osVersion.split(\".\");\n    return 15 === Number(t[0]) && Number(t[1]) >= 2;\n  }\n  function np() {\n    return zh() && navigator.maxTouchPoints > 0;\n  }\n  function op() {\n    return Bh().name === xh.WECHAT;\n  }\n  function sp() {\n    return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./) && window.navigator.appVersion.match(/Chrome\\/([\\w\\W]*?)\\./)[1] <= 35;\n  }\n  function ap() {\n    const e = Bh();\n    if (e.name === xh.EDGE || e.name === xh.SAFARI) return !1;\n    return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]./i);\n  }\n  function cp() {\n    return Bh().os === Uh.ANDROID;\n  }\n  function dp() {\n    const e = Bh();\n    return \"Android\" === e.os && (\"Chrome\" === e.name || e.name === xh.WECHAT || /chrome|chromium/i.test(navigator.userAgent));\n  }\n  var up = {\n      exports: {}\n    },\n    lp = Ri,\n    hp = T,\n    pp = Ht.f;\n  lp({\n    target: \"Object\",\n    stat: !0,\n    forced: Object.defineProperty !== pp,\n    sham: !hp\n  }, {\n    defineProperty: pp\n  });\n  var _p = J.Object,\n    Ep = up.exports = function (e, t, i) {\n      return _p.defineProperty(e, t, i);\n    };\n  _p.defineProperty.sham && (Ep.sham = !0);\n  var fp = up.exports;\n  function mp(e, t, i) {\n    return t in e ? fp(e, t, {\n      value: i,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = i, e;\n  }\n  var gp,\n    Sp = {\n      exports: {}\n    },\n    Tp = function (e, t) {\n      return function () {\n        for (var i = new Array(arguments.length), r = 0; r < i.length; r++) i[r] = arguments[r];\n        return e.apply(t, i);\n      };\n    },\n    vp = Tp,\n    Rp = Object.prototype.toString,\n    Ip = (gp = Object.create(null), function (e) {\n      var t = Rp.call(e);\n      return gp[t] || (gp[t] = t.slice(8, -1).toLowerCase());\n    });\n  function yp(e) {\n    return e = e.toLowerCase(), function (t) {\n      return Ip(t) === e;\n    };\n  }\n  function Cp(e) {\n    return Array.isArray(e);\n  }\n  function Ap(e) {\n    return void 0 === e;\n  }\n  var Op = yp(\"ArrayBuffer\");\n  function bp(e) {\n    return null !== e && \"object\" == typeof e;\n  }\n  function wp(e) {\n    if (\"object\" !== Ip(e)) return !1;\n    var t = Object.getPrototypeOf(e);\n    return null === t || t === Object.prototype;\n  }\n  var Np = yp(\"Date\"),\n    Dp = yp(\"File\"),\n    Pp = yp(\"Blob\"),\n    Lp = yp(\"FileList\");\n  function kp(e) {\n    return \"[object Function]\" === Rp.call(e);\n  }\n  var Mp = yp(\"URLSearchParams\");\n  function Up(e, t) {\n    if (null != e) if (\"object\" != typeof e && (e = [e]), Cp(e)) for (var i = 0, r = e.length; i < r; i++) t.call(null, e[i], i, e);else for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.call(null, e[n], n, e);\n  }\n  var xp,\n    Vp = (xp = \"undefined\" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function (e) {\n      return xp && e instanceof xp;\n    }),\n    jp = {\n      isArray: Cp,\n      isArrayBuffer: Op,\n      isBuffer: function (e) {\n        return null !== e && !Ap(e) && null !== e.constructor && !Ap(e.constructor) && \"function\" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);\n      },\n      isFormData: function (e) {\n        var t = \"[object FormData]\";\n        return e && (\"function\" == typeof FormData && e instanceof FormData || Rp.call(e) === t || kp(e.toString) && e.toString() === t);\n      },\n      isArrayBufferView: function (e) {\n        return \"undefined\" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && Op(e.buffer);\n      },\n      isString: function (e) {\n        return \"string\" == typeof e;\n      },\n      isNumber: function (e) {\n        return \"number\" == typeof e;\n      },\n      isObject: bp,\n      isPlainObject: wp,\n      isUndefined: Ap,\n      isDate: Np,\n      isFile: Dp,\n      isBlob: Pp,\n      isFunction: kp,\n      isStream: function (e) {\n        return bp(e) && kp(e.pipe);\n      },\n      isURLSearchParams: Mp,\n      isStandardBrowserEnv: function () {\n        return (\"undefined\" == typeof navigator || \"ReactNative\" !== navigator.product && \"NativeScript\" !== navigator.product && \"NS\" !== navigator.product) && \"undefined\" != typeof window && \"undefined\" != typeof document;\n      },\n      forEach: Up,\n      merge: function e() {\n        var t = {};\n        function i(i, r) {\n          wp(t[r]) && wp(i) ? t[r] = e(t[r], i) : wp(i) ? t[r] = e({}, i) : Cp(i) ? t[r] = i.slice() : t[r] = i;\n        }\n        for (var r = 0, n = arguments.length; r < n; r++) Up(arguments[r], i);\n        return t;\n      },\n      extend: function (e, t, i) {\n        return Up(t, function (t, r) {\n          e[r] = i && \"function\" == typeof t ? vp(t, i) : t;\n        }), e;\n      },\n      trim: function (e) {\n        return e.trim ? e.trim() : e.replace(/^\\s+|\\s+$/g, \"\");\n      },\n      stripBOM: function (e) {\n        return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e;\n      },\n      inherits: function (e, t, i, r) {\n        e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, i && Object.assign(e.prototype, i);\n      },\n      toFlatObject: function (e, t, i) {\n        var r,\n          n,\n          o,\n          s = {};\n        t = t || {};\n        do {\n          for (n = (r = Object.getOwnPropertyNames(e)).length; n-- > 0;) s[o = r[n]] || (t[o] = e[o], s[o] = !0);\n          e = Object.getPrototypeOf(e);\n        } while (e && (!i || i(e, t)) && e !== Object.prototype);\n        return t;\n      },\n      kindOf: Ip,\n      kindOfTest: yp,\n      endsWith: function (e, t, i) {\n        e = String(e), (void 0 === i || i > e.length) && (i = e.length), i -= t.length;\n        var r = e.indexOf(t, i);\n        return -1 !== r && r === i;\n      },\n      toArray: function (e) {\n        if (!e) return null;\n        var t = e.length;\n        if (Ap(t)) return null;\n        for (var i = new Array(t); t-- > 0;) i[t] = e[t];\n        return i;\n      },\n      isTypedArray: Vp,\n      isFileList: Lp\n    },\n    Fp = jp;\n  function Bp(e) {\n    return encodeURIComponent(e).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n  }\n  var Gp = function (e, t, i) {\n      if (!t) return e;\n      var r;\n      if (i) r = i(t);else if (Fp.isURLSearchParams(t)) r = t.toString();else {\n        var n = [];\n        Fp.forEach(t, function (e, t) {\n          null != e && (Fp.isArray(e) ? t += \"[]\" : e = [e], Fp.forEach(e, function (e) {\n            Fp.isDate(e) ? e = e.toISOString() : Fp.isObject(e) && (e = JSON.stringify(e)), n.push(Bp(t) + \"=\" + Bp(e));\n          }));\n        }), r = n.join(\"&\");\n      }\n      if (r) {\n        var o = e.indexOf(\"#\");\n        -1 !== o && (e = e.slice(0, o)), e += (-1 === e.indexOf(\"?\") ? \"?\" : \"&\") + r;\n      }\n      return e;\n    },\n    Wp = jp;\n  function Hp() {\n    this.handlers = [];\n  }\n  Hp.prototype.use = function (e, t, i) {\n    return this.handlers.push({\n      fulfilled: e,\n      rejected: t,\n      synchronous: !!i && i.synchronous,\n      runWhen: i ? i.runWhen : null\n    }), this.handlers.length - 1;\n  }, Hp.prototype.eject = function (e) {\n    this.handlers[e] && (this.handlers[e] = null);\n  }, Hp.prototype.forEach = function (e) {\n    Wp.forEach(this.handlers, function (t) {\n      null !== t && e(t);\n    });\n  };\n  var Kp = Hp,\n    Yp = jp,\n    qp = jp;\n  function Jp(e, t, i, r, n) {\n    Error.call(this), this.message = e, this.name = \"AxiosError\", t && (this.code = t), i && (this.config = i), r && (this.request = r), n && (this.response = n);\n  }\n  qp.inherits(Jp, Error, {\n    toJSON: function () {\n      return {\n        message: this.message,\n        name: this.name,\n        description: this.description,\n        number: this.number,\n        fileName: this.fileName,\n        lineNumber: this.lineNumber,\n        columnNumber: this.columnNumber,\n        stack: this.stack,\n        config: this.config,\n        code: this.code,\n        status: this.response && this.response.status ? this.response.status : null\n      };\n    }\n  });\n  var Xp = Jp.prototype,\n    zp = {};\n  [\"ERR_BAD_OPTION_VALUE\", \"ERR_BAD_OPTION\", \"ECONNABORTED\", \"ETIMEDOUT\", \"ERR_NETWORK\", \"ERR_FR_TOO_MANY_REDIRECTS\", \"ERR_DEPRECATED\", \"ERR_BAD_RESPONSE\", \"ERR_BAD_REQUEST\", \"ERR_CANCELED\"].forEach(function (e) {\n    zp[e] = {\n      value: e\n    };\n  }), Object.defineProperties(Jp, zp), Object.defineProperty(Xp, \"isAxiosError\", {\n    value: !0\n  }), Jp.from = function (e, t, i, r, n, o) {\n    var s = Object.create(Xp);\n    return qp.toFlatObject(e, s, function (e) {\n      return e !== Error.prototype;\n    }), Jp.call(s, e.message, t, i, r, n), s.name = e.name, o && Object.assign(s, o), s;\n  };\n  var Qp = Jp,\n    Zp = {\n      silentJSONParsing: !0,\n      forcedJSONParsing: !0,\n      clarifyTimeoutError: !1\n    },\n    $p = jp;\n  var e_ = function (e, t) {\n      t = t || new FormData();\n      var i = [];\n      function r(e) {\n        return null === e ? \"\" : $p.isDate(e) ? e.toISOString() : $p.isArrayBuffer(e) || $p.isTypedArray(e) ? \"function\" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e;\n      }\n      return function e(n, o) {\n        if ($p.isPlainObject(n) || $p.isArray(n)) {\n          if (-1 !== i.indexOf(n)) throw Error(\"Circular reference detected in \" + o);\n          i.push(n), $p.forEach(n, function (i, n) {\n            if (!$p.isUndefined(i)) {\n              var s,\n                a = o ? o + \".\" + n : n;\n              if (i && !o && \"object\" == typeof i) if ($p.endsWith(n, \"{}\")) i = JSON.stringify(i);else if ($p.endsWith(n, \"[]\") && (s = $p.toArray(i))) return void s.forEach(function (e) {\n                !$p.isUndefined(e) && t.append(a, r(e));\n              });\n              e(i, a);\n            }\n          }), i.pop();\n        } else t.append(o, r(n));\n      }(e), t;\n    },\n    t_ = Qp,\n    i_ = jp,\n    r_ = i_.isStandardBrowserEnv() ? {\n      write: function (e, t, i, r, n, o) {\n        var s = [];\n        s.push(e + \"=\" + encodeURIComponent(t)), i_.isNumber(i) && s.push(\"expires=\" + new Date(i).toGMTString()), i_.isString(r) && s.push(\"path=\" + r), i_.isString(n) && s.push(\"domain=\" + n), !0 === o && s.push(\"secure\"), document.cookie = s.join(\"; \");\n      },\n      read: function (e) {\n        var t = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + e + \")=([^;]*)\"));\n        return t ? decodeURIComponent(t[3]) : null;\n      },\n      remove: function (e) {\n        this.write(e, \"\", Date.now() - 864e5);\n      }\n    } : {\n      write: function () {},\n      read: function () {\n        return null;\n      },\n      remove: function () {}\n    },\n    n_ = function (e) {\n      return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(e);\n    },\n    o_ = function (e, t) {\n      return t ? e.replace(/\\/+$/, \"\") + \"/\" + t.replace(/^\\/+/, \"\") : e;\n    },\n    s_ = function (e, t) {\n      return e && !n_(t) ? o_(e, t) : t;\n    },\n    a_ = jp,\n    c_ = [\"age\", \"authorization\", \"content-length\", \"content-type\", \"etag\", \"expires\", \"from\", \"host\", \"if-modified-since\", \"if-unmodified-since\", \"last-modified\", \"location\", \"max-forwards\", \"proxy-authorization\", \"referer\", \"retry-after\", \"user-agent\"],\n    d_ = jp,\n    u_ = d_.isStandardBrowserEnv() ? function () {\n      var e,\n        t = /(msie|trident)/i.test(navigator.userAgent),\n        i = document.createElement(\"a\");\n      function r(e) {\n        var r = e;\n        return t && (i.setAttribute(\"href\", r), r = i.href), i.setAttribute(\"href\", r), {\n          href: i.href,\n          protocol: i.protocol ? i.protocol.replace(/:$/, \"\") : \"\",\n          host: i.host,\n          search: i.search ? i.search.replace(/^\\?/, \"\") : \"\",\n          hash: i.hash ? i.hash.replace(/^#/, \"\") : \"\",\n          hostname: i.hostname,\n          port: i.port,\n          pathname: \"/\" === i.pathname.charAt(0) ? i.pathname : \"/\" + i.pathname\n        };\n      }\n      return e = r(window.location.href), function (t) {\n        var i = d_.isString(t) ? r(t) : t;\n        return i.protocol === e.protocol && i.host === e.host;\n      };\n    }() : function () {\n      return !0;\n    },\n    l_ = Qp;\n  function h_(e) {\n    l_.call(this, null == e ? \"canceled\" : e, l_.ERR_CANCELED), this.name = \"CanceledError\";\n  }\n  jp.inherits(h_, l_, {\n    __CANCEL__: !0\n  });\n  var p_ = h_,\n    __ = jp,\n    E_ = function (e, t, i) {\n      var r = i.config.validateStatus;\n      i.status && r && !r(i.status) ? t(new t_(\"Request failed with status code \" + i.status, [t_.ERR_BAD_REQUEST, t_.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4], i.config, i.request, i)) : e(i);\n    },\n    f_ = r_,\n    m_ = Gp,\n    g_ = s_,\n    S_ = function (e) {\n      var t,\n        i,\n        r,\n        n = {};\n      return e ? (a_.forEach(e.split(\"\\n\"), function (e) {\n        if (r = e.indexOf(\":\"), t = a_.trim(e.substr(0, r)).toLowerCase(), i = a_.trim(e.substr(r + 1)), t) {\n          if (n[t] && c_.indexOf(t) >= 0) return;\n          n[t] = \"set-cookie\" === t ? (n[t] ? n[t] : []).concat([i]) : n[t] ? n[t] + \", \" + i : i;\n        }\n      }), n) : n;\n    },\n    T_ = u_,\n    v_ = Zp,\n    R_ = Qp,\n    I_ = p_,\n    y_ = function (e) {\n      var t = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(e);\n      return t && t[1] || \"\";\n    },\n    C_ = function (e) {\n      return new Promise(function (t, i) {\n        var r,\n          n = e.data,\n          o = e.headers,\n          s = e.responseType;\n        function a() {\n          e.cancelToken && e.cancelToken.unsubscribe(r), e.signal && e.signal.removeEventListener(\"abort\", r);\n        }\n        __.isFormData(n) && __.isStandardBrowserEnv() && delete o[\"Content-Type\"];\n        var c = new XMLHttpRequest();\n        if (e.auth) {\n          var d = e.auth.username || \"\",\n            u = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : \"\";\n          o.Authorization = \"Basic \" + btoa(d + \":\" + u);\n        }\n        var l = g_(e.baseURL, e.url);\n        function h() {\n          if (c) {\n            var r = \"getAllResponseHeaders\" in c ? S_(c.getAllResponseHeaders()) : null,\n              n = {\n                data: s && \"text\" !== s && \"json\" !== s ? c.response : c.responseText,\n                status: c.status,\n                statusText: c.statusText,\n                headers: r,\n                config: e,\n                request: c\n              };\n            E_(function (e) {\n              t(e), a();\n            }, function (e) {\n              i(e), a();\n            }, n), c = null;\n          }\n        }\n        if (c.open(e.method.toUpperCase(), m_(l, e.params, e.paramsSerializer), !0), c.timeout = e.timeout, \"onloadend\" in c ? c.onloadend = h : c.onreadystatechange = function () {\n          c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf(\"file:\")) && setTimeout(h);\n        }, c.onabort = function () {\n          c && (i(new R_(\"Request aborted\", R_.ECONNABORTED, e, c)), c = null);\n        }, c.onerror = function () {\n          i(new R_(\"Network Error\", R_.ERR_NETWORK, e, c, c)), c = null;\n        }, c.ontimeout = function () {\n          var t = e.timeout ? \"timeout of \" + e.timeout + \"ms exceeded\" : \"timeout exceeded\",\n            r = e.transitional || v_;\n          e.timeoutErrorMessage && (t = e.timeoutErrorMessage), i(new R_(t, r.clarifyTimeoutError ? R_.ETIMEDOUT : R_.ECONNABORTED, e, c)), c = null;\n        }, __.isStandardBrowserEnv()) {\n          var p = (e.withCredentials || T_(l)) && e.xsrfCookieName ? f_.read(e.xsrfCookieName) : void 0;\n          p && (o[e.xsrfHeaderName] = p);\n        }\n        \"setRequestHeader\" in c && __.forEach(o, function (e, t) {\n          void 0 === n && \"content-type\" === t.toLowerCase() ? delete o[t] : c.setRequestHeader(t, e);\n        }), __.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), s && \"json\" !== s && (c.responseType = e.responseType), \"function\" == typeof e.onDownloadProgress && c.addEventListener(\"progress\", e.onDownloadProgress), \"function\" == typeof e.onUploadProgress && c.upload && c.upload.addEventListener(\"progress\", e.onUploadProgress), (e.cancelToken || e.signal) && (r = function (e) {\n          c && (i(!e || e && e.type ? new I_() : e), c.abort(), c = null);\n        }, e.cancelToken && e.cancelToken.subscribe(r), e.signal && (e.signal.aborted ? r() : e.signal.addEventListener(\"abort\", r))), n || (n = null);\n        var _ = y_(l);\n        _ && -1 === [\"http\", \"https\", \"file\"].indexOf(_) ? i(new R_(\"Unsupported protocol \" + _ + \":\", R_.ERR_BAD_REQUEST, e)) : c.send(n);\n      });\n    },\n    A_ = jp,\n    O_ = function (e, t) {\n      Yp.forEach(e, function (i, r) {\n        r !== t && r.toUpperCase() === t.toUpperCase() && (e[t] = i, delete e[r]);\n      });\n    },\n    b_ = Qp,\n    w_ = e_,\n    N_ = {\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n  function D_(e, t) {\n    !A_.isUndefined(e) && A_.isUndefined(e[\"Content-Type\"]) && (e[\"Content-Type\"] = t);\n  }\n  var P_,\n    L_ = {\n      transitional: Zp,\n      adapter: ((\"undefined\" != typeof XMLHttpRequest || \"undefined\" != typeof process && \"[object process]\" === Object.prototype.toString.call(process)) && (P_ = C_), P_),\n      transformRequest: [function (e, t) {\n        if (O_(t, \"Accept\"), O_(t, \"Content-Type\"), A_.isFormData(e) || A_.isArrayBuffer(e) || A_.isBuffer(e) || A_.isStream(e) || A_.isFile(e) || A_.isBlob(e)) return e;\n        if (A_.isArrayBufferView(e)) return e.buffer;\n        if (A_.isURLSearchParams(e)) return D_(t, \"application/x-www-form-urlencoded;charset=utf-8\"), e.toString();\n        var i,\n          r = A_.isObject(e),\n          n = t && t[\"Content-Type\"];\n        if ((i = A_.isFileList(e)) || r && \"multipart/form-data\" === n) {\n          var o = this.env && this.env.FormData;\n          return w_(i ? {\n            \"files[]\": e\n          } : e, o && new o());\n        }\n        return r || \"application/json\" === n ? (D_(t, \"application/json\"), function (e, t, i) {\n          if (A_.isString(e)) try {\n            return (t || JSON.parse)(e), A_.trim(e);\n          } catch (e) {\n            if (\"SyntaxError\" !== e.name) throw e;\n          }\n          return (i || JSON.stringify)(e);\n        }(e)) : e;\n      }],\n      transformResponse: [function (e) {\n        var t = this.transitional || L_.transitional,\n          i = t && t.silentJSONParsing,\n          r = t && t.forcedJSONParsing,\n          n = !i && \"json\" === this.responseType;\n        if (n || r && A_.isString(e) && e.length) try {\n          return JSON.parse(e);\n        } catch (e) {\n          if (n) {\n            if (\"SyntaxError\" === e.name) throw b_.from(e, b_.ERR_BAD_RESPONSE, this, null, this.response);\n            throw e;\n          }\n        }\n        return e;\n      }],\n      timeout: 0,\n      xsrfCookieName: \"XSRF-TOKEN\",\n      xsrfHeaderName: \"X-XSRF-TOKEN\",\n      maxContentLength: -1,\n      maxBodyLength: -1,\n      env: {\n        FormData: null\n      },\n      validateStatus: function (e) {\n        return e >= 200 && e < 300;\n      },\n      headers: {\n        common: {\n          Accept: \"application/json, text/plain, */*\"\n        }\n      }\n    };\n  A_.forEach([\"delete\", \"get\", \"head\"], function (e) {\n    L_.headers[e] = {};\n  }), A_.forEach([\"post\", \"put\", \"patch\"], function (e) {\n    L_.headers[e] = A_.merge(N_);\n  });\n  var k_ = L_,\n    M_ = jp,\n    U_ = k_,\n    x_ = function (e) {\n      return !(!e || !e.__CANCEL__);\n    },\n    V_ = jp,\n    j_ = function (e, t, i) {\n      var r = this || U_;\n      return M_.forEach(i, function (i) {\n        e = i.call(r, e, t);\n      }), e;\n    },\n    F_ = x_,\n    B_ = k_,\n    G_ = p_;\n  function W_(e) {\n    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new G_();\n  }\n  var H_ = jp,\n    K_ = function (e, t) {\n      t = t || {};\n      var i = {};\n      function r(e, t) {\n        return H_.isPlainObject(e) && H_.isPlainObject(t) ? H_.merge(e, t) : H_.isPlainObject(t) ? H_.merge({}, t) : H_.isArray(t) ? t.slice() : t;\n      }\n      function n(i) {\n        return H_.isUndefined(t[i]) ? H_.isUndefined(e[i]) ? void 0 : r(void 0, e[i]) : r(e[i], t[i]);\n      }\n      function o(e) {\n        if (!H_.isUndefined(t[e])) return r(void 0, t[e]);\n      }\n      function s(i) {\n        return H_.isUndefined(t[i]) ? H_.isUndefined(e[i]) ? void 0 : r(void 0, e[i]) : r(void 0, t[i]);\n      }\n      function a(i) {\n        return i in t ? r(e[i], t[i]) : i in e ? r(void 0, e[i]) : void 0;\n      }\n      var c = {\n        url: o,\n        method: o,\n        data: o,\n        baseURL: s,\n        transformRequest: s,\n        transformResponse: s,\n        paramsSerializer: s,\n        timeout: s,\n        timeoutMessage: s,\n        withCredentials: s,\n        adapter: s,\n        responseType: s,\n        xsrfCookieName: s,\n        xsrfHeaderName: s,\n        onUploadProgress: s,\n        onDownloadProgress: s,\n        decompress: s,\n        maxContentLength: s,\n        maxBodyLength: s,\n        beforeRedirect: s,\n        transport: s,\n        httpAgent: s,\n        httpsAgent: s,\n        cancelToken: s,\n        socketPath: s,\n        responseEncoding: s,\n        validateStatus: a\n      };\n      return H_.forEach(Object.keys(e).concat(Object.keys(t)), function (e) {\n        var t = c[e] || n,\n          r = t(e);\n        H_.isUndefined(r) && t !== a || (i[e] = r);\n      }), i;\n    },\n    Y_ = \"0.27.2\",\n    q_ = Y_,\n    J_ = Qp,\n    X_ = {};\n  [\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach(function (e, t) {\n    X_[e] = function (i) {\n      return typeof i === e || \"a\" + (t < 1 ? \"n \" : \" \") + e;\n    };\n  });\n  var z_ = {};\n  X_.transitional = function (e, t, i) {\n    function r(e, t) {\n      return \"[Axios v\" + q_ + \"] Transitional option '\" + e + \"'\" + t + (i ? \". \" + i : \"\");\n    }\n    return function (i, n, o) {\n      if (!1 === e) throw new J_(r(n, \" has been removed\" + (t ? \" in \" + t : \"\")), J_.ERR_DEPRECATED);\n      return t && !z_[n] && (z_[n] = !0, console.warn(r(n, \" has been deprecated since v\" + t + \" and will be removed in the near future\"))), !e || e(i, n, o);\n    };\n  };\n  var Q_ = jp,\n    Z_ = Gp,\n    $_ = Kp,\n    eE = function (e) {\n      return W_(e), e.headers = e.headers || {}, e.data = j_.call(e, e.data, e.headers, e.transformRequest), e.headers = V_.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), V_.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"], function (t) {\n        delete e.headers[t];\n      }), (e.adapter || B_.adapter)(e).then(function (t) {\n        return W_(e), t.data = j_.call(e, t.data, t.headers, e.transformResponse), t;\n      }, function (t) {\n        return F_(t) || (W_(e), t && t.response && (t.response.data = j_.call(e, t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t);\n      });\n    },\n    tE = K_,\n    iE = s_,\n    rE = {\n      assertOptions: function (e, t, i) {\n        if (\"object\" != typeof e) throw new J_(\"options must be an object\", J_.ERR_BAD_OPTION_VALUE);\n        for (var r = Object.keys(e), n = r.length; n-- > 0;) {\n          var o = r[n],\n            s = t[o];\n          if (s) {\n            var a = e[o],\n              c = void 0 === a || s(a, o, e);\n            if (!0 !== c) throw new J_(\"option \" + o + \" must be \" + c, J_.ERR_BAD_OPTION_VALUE);\n          } else if (!0 !== i) throw new J_(\"Unknown option \" + o, J_.ERR_BAD_OPTION);\n        }\n      },\n      validators: X_\n    },\n    nE = rE.validators;\n  function oE(e) {\n    this.defaults = e, this.interceptors = {\n      request: new $_(),\n      response: new $_()\n    };\n  }\n  oE.prototype.request = function (e, t) {\n    \"string\" == typeof e ? (t = t || {}).url = e : t = e || {}, (t = tE(this.defaults, t)).method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = \"get\";\n    var i = t.transitional;\n    void 0 !== i && rE.assertOptions(i, {\n      silentJSONParsing: nE.transitional(nE.boolean),\n      forcedJSONParsing: nE.transitional(nE.boolean),\n      clarifyTimeoutError: nE.transitional(nE.boolean)\n    }, !1);\n    var r = [],\n      n = !0;\n    this.interceptors.request.forEach(function (e) {\n      \"function\" == typeof e.runWhen && !1 === e.runWhen(t) || (n = n && e.synchronous, r.unshift(e.fulfilled, e.rejected));\n    });\n    var o,\n      s = [];\n    if (this.interceptors.response.forEach(function (e) {\n      s.push(e.fulfilled, e.rejected);\n    }), !n) {\n      var a = [eE, void 0];\n      for (Array.prototype.unshift.apply(a, r), a = a.concat(s), o = Promise.resolve(t); a.length;) o = o.then(a.shift(), a.shift());\n      return o;\n    }\n    for (var c = t; r.length;) {\n      var d = r.shift(),\n        u = r.shift();\n      try {\n        c = d(c);\n      } catch (e) {\n        u(e);\n        break;\n      }\n    }\n    try {\n      o = eE(c);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    for (; s.length;) o = o.then(s.shift(), s.shift());\n    return o;\n  }, oE.prototype.getUri = function (e) {\n    e = tE(this.defaults, e);\n    var t = iE(e.baseURL, e.url);\n    return Z_(t, e.params, e.paramsSerializer);\n  }, Q_.forEach([\"delete\", \"get\", \"head\", \"options\"], function (e) {\n    oE.prototype[e] = function (t, i) {\n      return this.request(tE(i || {}, {\n        method: e,\n        url: t,\n        data: (i || {}).data\n      }));\n    };\n  }), Q_.forEach([\"post\", \"put\", \"patch\"], function (e) {\n    function t(t) {\n      return function (i, r, n) {\n        return this.request(tE(n || {}, {\n          method: e,\n          headers: t ? {\n            \"Content-Type\": \"multipart/form-data\"\n          } : {},\n          url: i,\n          data: r\n        }));\n      };\n    }\n    oE.prototype[e] = t(), oE.prototype[e + \"Form\"] = t(!0);\n  });\n  var sE = oE,\n    aE = p_;\n  function cE(e) {\n    if (\"function\" != typeof e) throw new TypeError(\"executor must be a function.\");\n    var t;\n    this.promise = new Promise(function (e) {\n      t = e;\n    });\n    var i = this;\n    this.promise.then(function (e) {\n      if (i._listeners) {\n        var t,\n          r = i._listeners.length;\n        for (t = 0; t < r; t++) i._listeners[t](e);\n        i._listeners = null;\n      }\n    }), this.promise.then = function (e) {\n      var t,\n        r = new Promise(function (e) {\n          i.subscribe(e), t = e;\n        }).then(e);\n      return r.cancel = function () {\n        i.unsubscribe(t);\n      }, r;\n    }, e(function (e) {\n      i.reason || (i.reason = new aE(e), t(i.reason));\n    });\n  }\n  cE.prototype.throwIfRequested = function () {\n    if (this.reason) throw this.reason;\n  }, cE.prototype.subscribe = function (e) {\n    this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e];\n  }, cE.prototype.unsubscribe = function (e) {\n    if (this._listeners) {\n      var t = this._listeners.indexOf(e);\n      -1 !== t && this._listeners.splice(t, 1);\n    }\n  }, cE.source = function () {\n    var e;\n    return {\n      token: new cE(function (t) {\n        e = t;\n      }),\n      cancel: e\n    };\n  };\n  var dE = cE,\n    uE = jp,\n    lE = jp,\n    hE = Tp,\n    pE = sE,\n    _E = K_;\n  var EE = function e(t) {\n    var i = new pE(t),\n      r = hE(pE.prototype.request, i);\n    return lE.extend(r, pE.prototype, i), lE.extend(r, i), r.create = function (i) {\n      return e(_E(t, i));\n    }, r;\n  }(k_);\n  EE.Axios = pE, EE.CanceledError = p_, EE.CancelToken = dE, EE.isCancel = x_, EE.VERSION = Y_, EE.toFormData = e_, EE.AxiosError = Qp, EE.Cancel = EE.CanceledError, EE.all = function (e) {\n    return Promise.all(e);\n  }, EE.spread = function (e) {\n    return function (t) {\n      return e.apply(null, t);\n    };\n  }, EE.isAxiosError = function (e) {\n    return uE.isObject(e) && !0 === e.isAxiosError;\n  }, Sp.exports = EE, Sp.exports.default = EE;\n  var fE = Sp.exports;\n  class mE {\n    constructor(e) {\n      mp(this, \"logger\", void 0), mp(this, \"prefixLists\", []), this.logger = e;\n    }\n    debug() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.debug(...this.prefixLists, ...t);\n    }\n    info() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.info(...this.prefixLists, ...t);\n    }\n    warning() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.warning(...this.prefixLists, ...t);\n    }\n    error() {\n      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n      this.logger.error(...this.prefixLists, ...t);\n    }\n    prefix(e) {\n      return this.prefixLists.push(e), this;\n    }\n    popPrefix() {\n      return this.prefixLists.pop(), this;\n    }\n  }\n  class gE {\n    constructor() {\n      mp(this, \"_events\", {}), mp(this, \"addListener\", this.on);\n    }\n    getListeners(e) {\n      return this._events[e] ? this._events[e].map(e => e.listener) : [];\n    }\n    on(e, t) {\n      this._events[e] || (this._events[e] = []);\n      const i = this._events[e];\n      -1 === this._indexOfListener(i, t) && i.push({\n        listener: t,\n        once: !1\n      });\n    }\n    once(e, t) {\n      this._events[e] || (this._events[e] = []);\n      const i = this._events[e];\n      -1 === this._indexOfListener(i, t) && i.push({\n        listener: t,\n        once: !0\n      });\n    }\n    off(e, t) {\n      if (!this._events[e]) return;\n      const i = this._events[e],\n        r = this._indexOfListener(i, t);\n      -1 !== r && i.splice(r, 1), 0 === this._events[e].length && delete this._events[e];\n    }\n    removeAllListeners(e) {\n      e ? delete this._events[e] : this._events = {};\n    }\n    emit(e) {\n      this._events[e] || (this._events[e] = []);\n      const t = this._events[e].map(e => e);\n      for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) r[n - 1] = arguments[n];\n      for (let i = 0; i < t.length; i += 1) {\n        const n = t[i];\n        n.once && this.off(e, n.listener), n.listener.apply(this, r || []);\n      }\n    }\n    _indexOfListener(e, t) {\n      let i = e.length;\n      for (; i--;) if (e[i].listener === t) return i;\n      return -1;\n    }\n  }\n  const SE = new class extends gE {\n    reportLogUploadError(e) {\n      this.emit(\"REPORT_LOG_UPLOAD\", e);\n    }\n  }();\n  let TE;\n  !function (e) {\n    e.UNEXPECTED_ERROR = \"UNEXPECTED_ERROR\", e.UNEXPECTED_RESPONSE = \"UNEXPECTED_RESPONSE\", e.TIMEOUT = \"TIMEOUT\", e.INVALID_PARAMS = \"INVALID_PARAMS\", e.NOT_READABLE = \"NOT_READABLE\", e.NOT_SUPPORTED = \"NOT_SUPPORTED\", e.INVALID_OPERATION = \"INVALID_OPERATION\", e.OPERATION_ABORTED = \"OPERATION_ABORTED\", e.WEB_SECURITY_RESTRICT = \"WEB_SECURITY_RESTRICT\", e.EXCHANGE_SDP_FAILED = \"EXCHANGE_SDP_FAILED\", e.NETWORK_ERROR = \"NETWORK_ERROR\", e.NETWORK_TIMEOUT = \"NETWORK_TIMEOUT\", e.NETWORK_RESPONSE_ERROR = \"NETWORK_RESPONSE_ERROR\", e.API_INVOKE_TIMEOUT = \"API_INVOKE_TIMEOUT\", e.ENUMERATE_DEVICES_FAILED = \"ENUMERATE_DEVICES_FAILED\", e.DEVICE_NOT_FOUND = \"DEVICE_NOT_FOUND\", e.ELECTRON_IS_NULL = \"ELECTRON_IS_NULL\", e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = \"ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR\", e.CHROME_PLUGIN_NO_RESPONSE = \"CHROME_PLUGIN_NO_RESPONSE\", e.CHROME_PLUGIN_NOT_INSTALL = \"CHROME_PLUGIN_NOT_INSTALL\", e.MEDIA_OPTION_INVALID = \"MEDIA_OPTION_INVALID\", e.PERMISSION_DENIED = \"PERMISSION_DENIED\", e.CONSTRAINT_NOT_SATISFIED = \"CONSTRAINT_NOT_SATISFIED\", e.TRACK_IS_DISABLED = \"TRACK_IS_DISABLED\", e.GET_VIDEO_ELEMENT_VISIBLE_ERROR = \"GET_VIDEO_ELEMENT_VISIBLE_ERROR\", e.SHARE_AUDIO_NOT_ALLOWED = \"SHARE_AUDIO_NOT_ALLOWED\", e.LOW_STREAM_ENCODING_ERROR = \"LOW_STREAM_ENCODING_ERROR\", e.SET_ENCODING_PARAMETER_ERROR = \"SET_ENCODING_PARAMETER_ERROR\", e.TRACK_STATE_UNREACHABLE = \"TRACK_STATE_UNREACHABLE\", e.INVALID_UINT_UID_FROM_STRING_UID = \"INVALID_UINT_UID_FROM_STRING_UID\", e.CAN_NOT_GET_PROXY_SERVER = \"CAN_NOT_GET_PROXY_SERVER\", e.CAN_NOT_GET_GATEWAY_SERVER = \"CAN_NOT_GET_GATEWAY_SERVER\", e.VOID_GATEWAY_ADDRESS = \"VOID_GATEWAY_ADDRESS\", e.UID_CONFLICT = \"UID_CONFLICT\", e.MULTI_UNILBS_RESPONSE_ERROR = \"MULTI_UNILBS_RESPONSE_ERROR\", e.UPDATE_TICKET_FAILED = \"UPDATE_TICKET_FAILED\", e.INVALID_LOCAL_TRACK = \"INVALID_LOCAL_TRACK\", e.INVALID_TRACK = \"INVALID_TRACK\", e.SENDER_NOT_FOUND = \"SENDER_NOT_FOUND\", e.CREATE_OFFER_FAILED = \"CREATE_OFFER_FAILED\", e.SET_ANSWER_FAILED = \"SET_ANSWER_FAILED\", e.ICE_FAILED = \"ICE_FAILED\", e.PC_CLOSED = \"PC_CLOSED\", e.SENDER_REPLACE_FAILED = \"SENDER_REPLACE_FAILED\", e.GET_LOCAL_CAPABILITIES_FAILED = \"GET_LOCAL_CAPABILITIES_FAILED\", e.GET_LOCAL_CONNECTION_PARAMS_FAILED = \"GET_LOCAL_CONNECTION_PARAMS_FAILED\", e.SUBSCRIBE_FAILED = \"SUBSCRIBE_FAILED\", e.UNSUBSCRIBE_FAILED = \"UNSUBSCRIBE_FAILED\", e.GATEWAY_P2P_LOST = \"GATEWAY_P2P_LOST\", e.NO_ICE_CANDIDATE = \"NO_ICE_CANDIDATE\", e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = \"CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS\", e.EXIST_DISABLED_VIDEO_TRACK = \"EXIST_DISABLED_VIDEO_TRACK\", e.INVALID_REMOTE_USER = \"INVALID_REMOTE_USER\", e.REMOTE_USER_IS_NOT_PUBLISHED = \"REMOTE_USER_IS_NOT_PUBLISHED\", e.CUSTOM_REPORT_SEND_FAILED = \"CUSTOM_REPORT_SEND_FAILED\", e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = \"CUSTOM_REPORT_FREQUENCY_TOO_HIGH\", e.FETCH_AUDIO_FILE_FAILED = \"FETCH_AUDIO_FILE_FAILED\", e.READ_LOCAL_AUDIO_FILE_ERROR = \"READ_LOCAL_AUDIO_FILE_ERROR\", e.DECODE_AUDIO_FILE_FAILED = \"DECODE_AUDIO_FILE_FAILED\", e.WS_ABORT = \"WS_ABORT\", e.WS_DISCONNECT = \"WS_DISCONNECT\", e.WS_ERR = \"WS_ERR\", e.LIVE_STREAMING_TASK_CONFLICT = \"LIVE_STREAMING_TASK_CONFLICT\", e.LIVE_STREAMING_INVALID_ARGUMENT = \"LIVE_STREAMING_INVALID_ARGUMENT\", e.LIVE_STREAMING_INTERNAL_SERVER_ERROR = \"LIVE_STREAMING_INTERNAL_SERVER_ERROR\", e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = \"LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED\", e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = \"LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED\", e.LIVE_STREAMING_CDN_ERROR = \"LIVE_STREAMING_CDN_ERROR\", e.LIVE_STREAMING_INVALID_RAW_STREAM = \"LIVE_STREAMING_INVALID_RAW_STREAM\", e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = \"LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT\", e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = \"LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE\", e.LIVE_STREAMING_WARN_FREQUENT_REQUEST = \"LIVE_STREAMING_WARN_FREQUENT_REQUEST\", e.WEBGL_INTERNAL_ERROR = \"WEBGL_INTERNAL_ERROR\", e.BEAUTY_PROCESSOR_INTERNAL_ERROR = \"BEAUTY_PROCESSOR_INTERNAL_ERROR\", e.CROSS_CHANNEL_WAIT_STATUS_ERROR = \"CROSS_CHANNEL_WAIT_STATUS_ERROR\", e.CROSS_CHANNEL_FAILED_JOIN_SRC = \"CROSS_CHANNEL_FAILED_JOIN_SEC\", e.CROSS_CHANNEL_FAILED_JOIN_DEST = \"CROSS_CHANNEL_FAILED_JOIN_DEST\", e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = \"CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST\", e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = \"CROSS_CHANNEL_SERVER_ERROR_RESPONSE\", e.METADATA_OUT_OF_RANGE = \"METADATA_OUT_OF_RANGE\", e.LOCAL_AEC_ERROR = \"LOCAL_AEC_ERROR\", e.INVALID_PLUGIN = \"INVALID_PLUGIN\", e.DISCONNECT_P2P = \"DISCONNECT_P2P\", e.INIT_WEBSOCKET_TIMEOUT = \"INIT_WEBSOCKET_TIMEOUT\", e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = \"CONVERTING_IMAGEDATA_TO_BLOB_FAILED\", e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = \"CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED\", e.INIT_DATACHANNEL_TIMEOUT = \"INIT_DATACHANNEL_TIMEOUT\", e.DATACHANNEL_CONNECTION_TIMEOUT = \"DATACHANNEL_CONNECTION_TIMEOUT\";\n  }(TE || (TE = {}));\n  class vE extends Error {\n    constructor(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\",\n        i = arguments.length > 2 ? arguments[2] : void 0;\n      super(t), mp(this, \"code\", void 0), mp(this, \"message\", void 0), mp(this, \"data\", void 0), mp(this, \"name\", \"AgoraRTCException\"), this.code = e, this.message = \"AgoraRTCError \".concat(this.code, \": \").concat(t), this.data = i;\n    }\n    toString() {\n      return this.data ? \"data: \".concat(JSON.stringify(this.data), \"\\n\").concat(this.stack) : \"\".concat(this.stack);\n    }\n    print() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"error\";\n      return \"error\" === e && NE.error(this.toString()), \"warning\" === e && NE.warning(this.toString()), this;\n    }\n    throw() {\n      throw this.print(), this;\n    }\n  }\n  const RE = {\n    timeout: 500,\n    timeoutFactor: 1.5,\n    maxRetryCount: 1 / 0,\n    maxRetryTimeout: 1e4\n  };\n  function IE(e, t) {\n    const i = Math.floor(t.timeout * Math.pow(t.timeoutFactor, e));\n    return Math.min(t.maxRetryTimeout, i);\n  }\n  function yE(e, t, i, r) {\n    const n = Object.assign({}, RE, r);\n    let o = n.timeout;\n    const s = async () => {\n      await function (e) {\n        return new Cl(t => {\n          window.setTimeout(t, e);\n        });\n      }(o), o *= n.timeoutFactor, o = Math.min(n.maxRetryTimeout, o);\n    };\n    let a = !1;\n    const c = new Cl(async (r, o) => {\n      t = t || (() => !1), i = i || (() => !0);\n      for (let c = 0; c < n.maxRetryCount; c += 1) {\n        if (a) return o(new vE(TE.OPERATION_ABORTED));\n        try {\n          const i = await e();\n          if (!t(i, c)) return r(i);\n          if (c + 1 === n.maxRetryCount) return r(i);\n          await s();\n        } catch (e) {\n          if (!i(e, c)) return o(e);\n          if (c + 1 === n.maxRetryCount) return o(e);\n          await s();\n        }\n      }\n    });\n    return c.cancel = () => a = !0, c;\n  }\n  function CE() {\n    const e = new Date();\n    return e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n  }\n  function AE() {\n    const e = new Date(),\n      t = /((\\d+:){2}\\d+)/.exec(new Date().toUTCString());\n    return t ? (null == t ? void 0 : t[0]) + \":\" + e.getUTCMilliseconds() : e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n  }\n  const OE = {\n      DEBUG: 0,\n      INFO: 1,\n      WARNING: 2,\n      ERROR: 3,\n      NONE: 4\n    },\n    bE = Date.now(),\n    wE = e => {\n      for (const t in OE) if (Object.prototype.hasOwnProperty.call(OE, t) && OE[t] === e) return t;\n      return \"DEFAULT\";\n    };\n  const NE = new class {\n      constructor() {\n        mp(this, \"proxyServerURL\", void 0), mp(this, \"logLevel\", OE.DEBUG), mp(this, \"uploadState\", \"collecting\"), mp(this, \"uploadLogWaitingList\", []), mp(this, \"uploadLogUploadingList\", []), mp(this, \"uploadErrorCount\", 0), mp(this, \"currentLogID\", 0), mp(this, \"url\", void 0), mp(this, \"extLog\", (e, t) => {\n          this.appendLogToWaitingList(e, ...t);\n        });\n      }\n      debug() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const r = [OE.DEBUG].concat(t);\n        this.log.apply(this, r);\n      }\n      info() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const r = [OE.INFO].concat(t);\n        this.log.apply(this, r);\n      }\n      warning() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const r = [OE.WARNING].concat(t);\n        this.log.apply(this, r);\n      }\n      error() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const r = [OE.ERROR].concat(t);\n        this.log.apply(this, r);\n      }\n      upload() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const r = [OE.DEBUG].concat(t);\n        this.uploadLog.apply(this, r);\n      }\n      setLogLevel(e) {\n        e = Math.min(Math.max(0, e), 4), this.logLevel = e;\n      }\n      enableLogUpload() {\n        WE(\"UPLOAD_LOG\", !0);\n      }\n      disableLogUpload() {\n        WE(\"UPLOAD_LOG\", !1), this.uploadLogUploadingList = [], this.uploadLogWaitingList = [];\n      }\n      setProxyServer(e) {\n        this.proxyServerURL = e;\n      }\n      prefix(e) {\n        return new mE(this).prefix(e);\n      }\n      log() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        if (Date.now() - bE < 100) return void setTimeout(() => {\n          this.log(...t);\n        }, Date.now() - bE);\n        const r = Math.max(0, Math.min(4, t[0]));\n        if (t[0] = CE() + \" Agora-SDK [\".concat(wE(r), \"]:\"), this.appendLogToWaitingList(r, ...t), r < this.logLevel) return;\n        const n = CE() + \" %cAgora-SDK [\".concat(wE(r), \"]:\");\n        let o = [];\n        if (!HE(\"USE_NEW_LOG\")) switch (r) {\n          case OE.DEBUG:\n            o = [n, \"color: #64B5F6;\"].concat(t.slice(1)), console.log.apply(console, o);\n            break;\n          case OE.INFO:\n            o = [n, \"color: #1E88E5; font-weight: bold;\"].concat(t.slice(1)), console.log.apply(console, o);\n            break;\n          case OE.WARNING:\n            o = [n, \"color: #FB8C00; font-weight: bold;\"].concat(t.slice(1)), console.warn.apply(console, o);\n            break;\n          case OE.ERROR:\n            o = [n, \"color: #B00020; font-weight: bold;\"].concat(t.slice(1)), console.error.apply(console, o);\n        }\n      }\n      uploadLog() {\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        if (Date.now() - bE < 100) return void setTimeout(() => {\n          this.uploadLog(...t);\n        }, Date.now() - bE);\n        const r = Math.max(0, Math.min(4, t[0]));\n        t[0] = CE() + \" Agora-SDK [\".concat(wE(r), \"]:\"), this.appendLogToWaitingList(r, ...t);\n      }\n      appendLogToWaitingList(e) {\n        if (!HE(\"UPLOAD_LOG\")) return;\n        for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];\n        Array.isArray(i[0]) ? i[0][0] = AE() + \" Agora-SDK [\".concat(wE(e), \"]:\") : i[0] = AE() + \" Agora-SDK [\".concat(wE(e), \"]:\");\n        let n = \"\";\n        i.forEach(e => {\n          \"object\" == typeof e && (e = JSON.stringify(e)), n += \"\".concat(e, \" \");\n        }), this.uploadLogWaitingList.push({\n          payload_str: n,\n          log_level: e,\n          log_item_id: this.currentLogID++\n        }), \"uploading\" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n      }\n      startUpload() {\n        this.uploadState = \"uploading\", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval();\n      }\n      async uploadLogs() {\n        const e = this.uploadLogUploadingList,\n          t = {\n            sdk_version: PE,\n            process_id: HE(\"PROCESS_ID\"),\n            payload: JSON.stringify(e)\n          };\n        return yE(async () => {\n          const e = await fE.post(this.url || (this.proxyServerURL ? \"https://\".concat(this.proxyServerURL, \"/ls/?h=\").concat(HE(\"LOG_UPLOAD_SERVER\"), \"&p=443&d=upload/v1\") : \"https://\".concat(HE(\"LOG_UPLOAD_SERVER\"), \"/upload/v1\")), t, {\n            responseType: \"text\"\n          });\n          if (\"OK\" !== e.data) {\n            const t = new Error(\"unexpected upload log response\");\n            throw t.response = e, t;\n          }\n        }, () => (this.uploadLogUploadingList = [], !1), e => (e.response ? SE.reportLogUploadError({\n          status: e.response.status,\n          data: e.response.data,\n          headers: e.response.headers,\n          message: e.message\n        }) : e.request ? SE.reportLogUploadError({\n          status: e.request.status,\n          message: e.message\n        }) : SE.reportLogUploadError({\n          status: -1,\n          message: e.message\n        }), !0), {\n          timeout: HE(\"UPLOAD_LOG_REQUEST_RETRY_INTERVAL\"),\n          maxRetryTimeout: HE(\"UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL\")\n        });\n      }\n      uploadLogInterval() {\n        0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, HE(\"UPLOAD_LOG_LENGTH_EACH_TIME\"))), this.uploadLogs().then(() => {\n          this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), HE(\"UPLOAD_LOG_INTERVAL\"));\n        }).catch(e => {\n          this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), HE(\"UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1\")) : window.setTimeout(() => this.uploadLogInterval(), HE(\"UPLOAD_LOG_RETRY_INTERVAL_V1\"));\n        }));\n      }\n    }(),\n    DE = \"v4.16.1-0-gb268655f-dirty(2/8/2023, 2:53:13 PM)\",\n    PE = function (e) {\n      if (e.match(/[0-9]+\\.[0-9]+\\.[0-9]+$/)) return e;\n      const t = e.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-alpha\\.([0-9]+)/);\n      if (t && t[1] && t[2]) {\n        const e = t[1],\n          i = t[2];\n        return \"\".concat(e, \".\").concat(i);\n      }\n      const i = e.match(/([0-9]+\\.[0-9]+\\.[0-9]+)\\-special\\.([0-9]+)/);\n      if (i && i[1] && i[2]) {\n        const e = i[1],\n          t = i[2];\n        return \"\".concat(e, \".\").concat(100 * (Number(t) + 1));\n      }\n      return \"4.0.0.999\";\n    }(\"4.16.1\"),\n    LE = function () {\n      try {\n        return !0 === JSON.parse(\"true\");\n      } catch (e) {\n        return !0;\n      }\n    }(),\n    kE = function () {\n      const e = \"us\".concat(\"erna\", \"me\"),\n        t = \"pa\".concat(\"sswo\", \"rd\"),\n        i = [\"t\", \"s\", \"t\"];\n      i.splice(1, 0, \"e\");\n      const r = i.join(\"\"),\n        n = [];\n      for (let e = 0; e < 6; e++) n.push(\"1\");\n      const o = n.join(\"\"),\n        s = {};\n      return s[e] = r, s[t] = o, Object.assign(s, {\n        turnServerURL: \"\",\n        tcpport: 3433,\n        udpport: 3478,\n        forceturn: !1\n      });\n    }();\n  window.DEFAULT_TURN_CONFIG = kE;\n  const ME = {\n      \"90p\": JE(160, 90),\n      \"90p_1\": JE(160, 90),\n      \"120p\": JE(160, 120, 15, 30, 65),\n      \"120p_1\": JE(160, 120, 15, 30, 65),\n      \"120p_3\": JE(120, 120, 15, 30, 50),\n      \"120p_4\": JE(212, 120),\n      \"180p\": JE(320, 180, 15, 30, 140),\n      \"180p_1\": JE(320, 180, 15, 30, 140),\n      \"180p_3\": JE(180, 180, 15, 30, 100),\n      \"180p_4\": JE(240, 180, 15, 30, 120),\n      \"240p\": JE(320, 240, 15, 40, 200),\n      \"240p_1\": JE(320, 240, 15, 40, 200),\n      \"240p_3\": JE(240, 240, 15, 40, 140),\n      \"240p_4\": JE(424, 240, 15, 40, 220),\n      \"360p\": JE(640, 360, 15, 80, 400),\n      \"360p_1\": JE(640, 360, 15, 80, 400),\n      \"360p_3\": JE(360, 360, 15, 80, 260),\n      \"360p_4\": JE(640, 360, 30, 80, 600),\n      \"360p_6\": JE(360, 360, 30, 80, 400),\n      \"360p_7\": JE(480, 360, 15, 80, 320),\n      \"360p_8\": JE(480, 360, 30, 80, 490),\n      \"360p_9\": JE(640, 360, 15, 80, 800),\n      \"360p_10\": JE(640, 360, 24, 80, 800),\n      \"360p_11\": JE(640, 360, 24, 80, 1e3),\n      \"480p\": JE(640, 480, 15, 100, 500),\n      \"480p_1\": JE(640, 480, 15, 100, 500),\n      \"480p_2\": JE(640, 480, 30, 100, 1e3),\n      \"480p_3\": JE(480, 480, 15, 100, 400),\n      \"480p_4\": JE(640, 480, 30, 100, 750),\n      \"480p_6\": JE(480, 480, 30, 100, 600),\n      \"480p_8\": JE(848, 480, 15, 100, 610),\n      \"480p_9\": JE(848, 480, 30, 100, 930),\n      \"480p_10\": JE(640, 480, 10, 100, 400),\n      \"720p\": JE(1280, 720, 15, 120, 1130),\n      \"720p_1\": JE(1280, 720, 15, 120, 1130),\n      \"720p_2\": JE(1280, 720, 30, 120, 2e3),\n      \"720p_3\": JE(1280, 720, 30, 120, 1710),\n      \"720p_5\": JE(960, 720, 15, 120, 910),\n      \"720p_6\": JE(960, 720, 30, 120, 1380),\n      \"1080p\": JE(1920, 1080, 15, 120, 2080),\n      \"1080p_1\": JE(1920, 1080, 15, 120, 2080),\n      \"1080p_2\": JE(1920, 1080, 30, 120, 3e3),\n      \"1080p_3\": JE(1920, 1080, 30, 120, 3150),\n      \"1080p_5\": JE(1920, 1080, 60, 120, 4780),\n      \"1440p\": JE(2560, 1440, 30, 120, 4850),\n      \"1440p_1\": JE(2560, 1440, 30, 120, 4850),\n      \"1440p_2\": JE(2560, 1440, 60, 120, 7350),\n      \"4k\": JE(3840, 2160, 30, 120, 8910),\n      \"4k_1\": JE(3840, 2160, 30, 120, 8910),\n      \"4k_3\": JE(3840, 2160, 60, 120, 13500)\n    },\n    UE = {\n      \"480p\": XE(640, 480, 5),\n      \"480p_1\": XE(640, 480, 5),\n      \"480p_2\": XE(640, 480, 30),\n      \"480p_3\": XE(640, 480, 15),\n      \"720p\": XE(1280, 720, 5),\n      \"720p_1\": XE(1280, 720, 5),\n      \"720p_2\": XE(1280, 720, 30),\n      \"720p_3\": XE(1280, 720, 15),\n      \"1080p\": XE(1920, 1080, 5),\n      \"1080p_1\": XE(1920, 1080, 5),\n      \"1080p_2\": XE(1920, 1080, 30),\n      \"1080p_3\": XE(1920, 1080, 15)\n    },\n    xE = {\n      \"1SL1TL\": zE(1, 1),\n      \"3SL3TL\": zE(3, 3),\n      \"2SL3TL\": zE(2, 3)\n    };\n  function VE(e) {\n    return \"string\" == typeof e ? Object.assign({}, ME[e]) : e;\n  }\n  function jE(e) {\n    return \"string\" == typeof e ? Object.assign({}, UE[e]) : e;\n  }\n  function FE(e) {\n    return \"string\" == typeof e ? Object.assign({}, xE[e]) : e;\n  }\n  const BE = {\n    speech_low_quality: qE(16e3, !1),\n    speech_standard: qE(32e3, !1, 18),\n    music_standard: qE(48e3, !1),\n    standard_stereo: qE(48e3, !0, 56),\n    high_quality: qE(48e3, !1, 128),\n    high_quality_stereo: qE(48e3, !0, 192)\n  };\n  function GE(e) {\n    return \"string\" == typeof e ? Object.assign({}, BE[e]) : e;\n  }\n  function WE(e, t, i) {\n    Object.keys(KE).includes(e) && (!i && Object.keys(YE).includes(e) || (KE[e] = t));\n  }\n  function HE(e) {\n    return KE[e];\n  }\n  const KE = {\n      PROCESS_ID: \"\",\n      ENCRYPT_AES: !0,\n      AREAS: [\"CHINA\", \"GLOBAL\"],\n      WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\", \"webrtc2-2.ap.sd-rtn.com\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\", \"webrtc2-4.ap.sd-rtn.com\"],\n      PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n      CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-web-2.ap.sd-rtn.com\", \"cds-ap-web-3.agora.io\", \"cds-web-4.ap.sd-rtn.com\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-web-2.ap.sd-rtn.com\", \"sua-ap-web-3.agora.io\", \"sua-web-4.ap.sd-rtn.com\"],\n      UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-web-2.ap.sd-rtn.com\", \"uap-ap-web-3.agora.io\", \"uap-web-4.ap.sd-rtn.com\"],\n      LOG_UPLOAD_SERVER: \"logservice.agora.io\",\n      EVENT_REPORT_DOMAIN: \"statscollector-1.agora.io\",\n      EVENT_REPORT_BACKUP_DOMAIN: \"web-2.statscollector.sd-rtn.com\",\n      ENABLE_EVENT_REPORT: !0,\n      GATEWAY_ADDRESS: [],\n      GATEWAY_WSS_ADDRESS: \"\",\n      LIVE_STREAMING_ADDRESS: \"\",\n      HTTP_CONNECT_TIMEOUT: 5e3,\n      SIGNAL_REQUEST_TIMEOUT: 1e4,\n      REPORT_STATS: !0,\n      UPLOAD_LOG: !1,\n      NOT_REPORT_EVENT: [],\n      SUBSCRIBE_TCC: !0,\n      PUBLISH_TCC: !1,\n      PING_PONG_TIME_OUT: 10,\n      WEBSOCKET_TIMEOUT_MIN: 1e4,\n      EVENT_REPORT_SEND_INTERVAL: 3e3,\n      CONFIG_DISTRIBUTE_INTERVAL: 3e5,\n      ENABLE_CONFIG_DISTRIBUTE: !0,\n      CANDIDATE_TIMEOUT: 5e3,\n      SHOW_REPORT_INVOKER_LOG: !1,\n      JOIN_EXTEND: \"\",\n      PUB_EXTEND: \"\",\n      SUB_EXTEND: \"\",\n      FORCE_TURN: !1,\n      TURN_ENABLE_TCP: !0,\n      TURN_ENABLE_UDP: !0,\n      MAX_UPLOAD_CACHE: 50,\n      UPLOAD_CACHE_INTERVAL: 2e3,\n      AJAX_REQUEST_CONCURRENT: 3,\n      REPORT_APP_SCENARIO: void 0,\n      GATEWAY_DOMAINS: [\"edge.agora.io\", \"edge.sd-rtn.com\"],\n      WORKER_DOMAIN: \"edge.agora.io\",\n      TURN_DOMAIN: \"edge.agora.io\",\n      EVENT_REPORT_RETRY: !0,\n      CHROME_FORCE_PLAN_B: !1,\n      AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,\n      AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3,\n      AUDIO_VOLUME_INDICATION_INTERVAL: 2e3,\n      VOLUME_VOICE_WEIGHT: 10,\n      GET_VOLUME_OF_MUTED_AUDIO_TRACK: !1,\n      NORMAL_EVENT_QUEUE_CAPACITY: 100,\n      CUSTOM_REPORT: !0,\n      CUSTOM_REPORT_LIMIT: 20,\n      PROXY_SERVER_TYPE2: \"webnginx-proxy.agora.io\",\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\", \"webrtc-cloud-proxy.agora.io\"],\n      CUSTOM_PUB_ANSWER_MODIFIER: null,\n      CUSTOM_SUB_ANSWER_MODIFIER: null,\n      CUSTOM_PUB_OFFER_MODIFIER: null,\n      CUSTOM_SUB_OFFER_MODIFIER: null,\n      DSCP_TYPE: \"high\",\n      REMOVE_NEW_CODECS: !0,\n      FRAGEMENT_LENGTH: 3,\n      WEBSOCKET_COMPRESS: !1,\n      SIMULCAST: !1,\n      PRELOAD_MEDIA_COUNT: 0,\n      USE_RTX: !1,\n      CHECK_VIDEO_VISIBLE_INTERVAL: 3e4,\n      ENUMERATE_DEVICES_INTERVAL: !1,\n      ENUMERATE_DEVICES_INTERVAL_TIME: 1e4,\n      USE_NEW_TOKEN: !1,\n      CLOSE_AFB_FOR_LOCAL_AP: !0,\n      JOIN_WITH_FALLBACK_SIGNAL_PROXY: !0,\n      JOIN_WITH_FALLBACK_MEDIA_PROXY: !0,\n      JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: !1,\n      JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3,\n      USE_TURN_SERVER_OF_GATEWAY: !1,\n      H264_PROFILE_LEVEL_ID: \"\",\n      USE_NEW_LOG: !1,\n      LOG_VERSION: 3,\n      MEDIA_DEVICE_CONSTRAINTS: null,\n      ENCRYPT_PROXY_USERNAME_AND_PSW: !0,\n      SDP_LOGGING: !1,\n      CSP_DETECTED_HOSTNAME_LIST: [\"agora.io\", \"sd-rtn.com\"],\n      REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: !1,\n      LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: !0,\n      BITRATE_ADAPTER_TYPE: \"STANDARD_BITRATE\",\n      AI_DENOISER_PARAMETERS: {},\n      ADJUST_3A_FROM_PLUGINS: !0,\n      RAISE_H264_BASELINE_PRIORITY: !0,\n      FILTER_SEND_H264_BASELINE: !1,\n      ENABLE_PUBLISHED_USER_LIST: !0,\n      MAX_SUBSCRIPTION: 50,\n      X_GOOGLE_START_BITRATE: void 0,\n      NEW_REPORT_SERVER: !1,\n      NEW_REPORT_SERVER_DOMAINS: [\"data-reporting.agora.io\", \"data-reporting.agora.io\"],\n      VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,\n      VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3,\n      VIDEO_INSPECT_QUALITY_RATIO: .9,\n      VIDEO_INSPECT_WORKER_MANAGER_HOST: \"edge.agora.io\",\n      VIDEO_INSPECT_WORKER_MANAGER_PORT: \"\",\n      VIDEO_INSPECT_WORKER_PORT: \"\",\n      SHOW_VIDEO_INSPECT_WORKER_MESSAGE: !1,\n      STATS_COLLECTOR_PORT: 443,\n      FORCE_TURN_TCP: !1,\n      SUBSCRIBE_AUDIO_FILTER_TOPN: void 0,\n      ENABLE_PUBLISH_AUDIO_FILTER: void 0,\n      WEBAUDIO_INIT_OPTIONS: void 0,\n      FILTER_VIDEO_FEC: !0,\n      FILTER_AUDIO_FEC: !1,\n      CHROME_DUAL_STREAM_USE_ENCODING: !0,\n      EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4,\n      ICE_RESTART: !0,\n      ENABLE_USER_LICENSE_CHECK: !0,\n      SIGNAL_CHANNEL: 0,\n      TRANSMITTER_INITIAL_RTT: 30,\n      TRANSMITTER_INITIAL_RTO: 30,\n      TRANSMITTER_MAX_BATCH_ACK_COUNT: 2,\n      TRANSMITTER_MAX_RTO: 500,\n      DATACHANNEL_COMPRESS: !1,\n      FINGERPRINT: null,\n      DC_JOIN_WITH_FAILBACK: 5e3,\n      ENABLE_VIDEO_FRAME_CALLBACK: !0,\n      VIDEO_FREEZE_DURATION: 500,\n      SPATIALIZER_PARAMETERS: {},\n      UPLOAD_LOG_INTERVAL: 3e3,\n      UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3,\n      UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4,\n      UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3,\n      UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4,\n      UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200,\n      UPLOAD_LOG_LENGTH_EACH_TIME: 10,\n      APP_TYPE: 0,\n      DISABLE_WEBAUDIO: !1,\n      CHANNEL_MEDIA_RELAY_SERVERS: void 0,\n      ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,\n      ACCOUNT_REGISTER_RETRY_RATIO: 2,\n      ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4,\n      ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5,\n      AUDIO_CONTEXT: null,\n      WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,\n      PLAYER_STATE_DEFER: 2e3,\n      SIGNAL_REQUEST_WATCH_INTERVAL: 1e3,\n      FILEPATH_LENMAX: 255,\n      DUALSTREAM_OPERATION_CHECK: !0,\n      MEDIA_ELEMENT_EXISTS_DEPTH: 3,\n      SHIM_CANDIDATE: !1,\n      LEAVE_MSG_TIMEOUT: 2e3,\n      STATS_FILTER: {\n        transportId: !0,\n        googTrackId: !0\n      }\n    },\n    YE = {};\n  function qE(e, t, i) {\n    return {\n      sampleRate: e,\n      stereo: t,\n      bitrate: i\n    };\n  }\n  function JE(e, t, i, r, n) {\n    return {\n      width: e,\n      height: t,\n      frameRate: i,\n      bitrateMin: r,\n      bitrateMax: n\n    };\n  }\n  function XE(e, t, i, r, n) {\n    return {\n      width: {\n        max: e\n      },\n      height: {\n        max: t\n      },\n      frameRate: i,\n      bitrateMin: r,\n      bitrateMax: n\n    };\n  }\n  function zE(e, t) {\n    return {\n      numSpatialLayers: e,\n      numTemporalLayers: t\n    };\n  }\n  LE || (KE.WEBCS_DOMAIN = [\"ap-web-1-oversea.agora.io\", \"ap-web-1-north-america.agora.io\"], KE.WEBCS_DOMAIN_BACKUP_LIST = [\"ap-web-2-oversea.agora.io\", \"ap-web-2-north-america.agora.io\"], KE.PROXY_CS = [\"proxy-ap-web-oversea.agora.io\", \"proxy-ap-web-america.agora.io\"], KE.CDS_AP = [\"cds-ap-web-oversea.agora.io\", \"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"], KE.ACCOUNT_REGISTER = [\"sua-ap-web-oversea.agora.io\", \"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"], KE.UAP_AP = [\"uap-ap-web-oversea.agora.io\", \"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"], KE.LOG_UPLOAD_SERVER = \"logservice-oversea.agora.io\", KE.EVENT_REPORT_DOMAIN = \"statscollector-1-oversea.agora.io\", KE.EVENT_REPORT_BACKUP_DOMAIN = \"statscollector-2-oversea.agora.io\", KE.PROXY_SERVER_TYPE3 = \"webrtc-cloud-proxy.agora.io\", KE.AREAS = [\"NORTH_AMERICA\", \"OVERSEA\"]);\n  const QE = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]],\n    ZE = [],\n    $E = [];\n  var ef = Et,\n    tf = Ht,\n    rf = N,\n    nf = function (e, t, i) {\n      var r = ef(t);\n      r in e ? tf.f(e, r, rf(0, i)) : e[r] = i;\n    },\n    of = Mr,\n    sf = wi,\n    af = nf,\n    cf = h.Array,\n    df = Math.max,\n    uf = function (e, t, i) {\n      for (var r = sf(e), n = of(t, r), o = of(void 0 === i ? r : i, r), s = cf(df(o - n, 0)), a = 0; n < o; n++, a++) af(s, a, e[n]);\n      return s.length = a, s;\n    },\n    lf = uf,\n    hf = Math.floor,\n    pf = function (e, t) {\n      var i = e.length,\n        r = hf(i / 2);\n      return i < 8 ? _f(e, t) : Ef(e, pf(lf(e, 0, r), t), pf(lf(e, r), t), t);\n    },\n    _f = function (e, t) {\n      for (var i, r, n = e.length, o = 1; o < n;) {\n        for (r = o, i = e[o]; r && t(e[r - 1], i) > 0;) e[r] = e[--r];\n        r !== o++ && (e[r] = i);\n      }\n      return e;\n    },\n    Ef = function (e, t, i, r) {\n      for (var n = t.length, o = i.length, s = 0, a = 0; s < n || a < o;) e[s + a] = s < n && a < o ? r(t[s], i[a]) <= 0 ? t[s++] : i[a++] : s < n ? t[s++] : i[a++];\n      return e;\n    },\n    ff = pf,\n    mf = ee.match(/firefox\\/(\\d+)/i),\n    gf = !!mf && +mf[1],\n    Sf = /MSIE|Trident/.test(ee),\n    Tf = ee.match(/AppleWebKit\\/(\\d+)\\./),\n    vf = !!Tf && +Tf[1],\n    Rf = Ri,\n    If = d,\n    yf = Ie,\n    Cf = je,\n    Af = wi,\n    Of = Lo,\n    bf = i,\n    wf = ff,\n    Nf = Vi,\n    Df = gf,\n    Pf = Sf,\n    Lf = ae,\n    kf = vf,\n    Mf = [],\n    Uf = If(Mf.sort),\n    xf = If(Mf.push),\n    Vf = bf(function () {\n      Mf.sort(void 0);\n    }),\n    jf = bf(function () {\n      Mf.sort(null);\n    }),\n    Ff = Nf(\"sort\"),\n    Bf = !bf(function () {\n      if (Lf) return Lf < 70;\n      if (!(Df && Df > 3)) {\n        if (Pf) return !0;\n        if (kf) return kf < 603;\n        var e,\n          t,\n          i,\n          r,\n          n = \"\";\n        for (e = 65; e < 76; e++) {\n          switch (t = String.fromCharCode(e), e) {\n            case 66:\n            case 69:\n            case 70:\n            case 72:\n              i = 3;\n              break;\n            case 68:\n            case 71:\n              i = 4;\n              break;\n            default:\n              i = 2;\n          }\n          for (r = 0; r < 47; r++) Mf.push({\n            k: t + r,\n            v: i\n          });\n        }\n        for (Mf.sort(function (e, t) {\n          return t.v - e.v;\n        }), r = 0; r < Mf.length; r++) t = Mf[r].k.charAt(0), n.charAt(n.length - 1) !== t && (n += t);\n        return \"DGBEFHACIJK\" !== n;\n      }\n    });\n  Rf({\n    target: \"Array\",\n    proto: !0,\n    forced: Vf || !jf || !Ff || !Bf\n  }, {\n    sort: function (e) {\n      void 0 !== e && yf(e);\n      var t = Cf(this);\n      if (Bf) return void 0 === e ? Uf(t) : Uf(t, e);\n      var i,\n        r,\n        n = [],\n        o = Af(t);\n      for (r = 0; r < o; r++) r in t && xf(n, t[r]);\n      for (wf(n, function (e) {\n        return function (t, i) {\n          return void 0 === i ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, i) || 0 : Of(t) > Of(i) ? 1 : -1;\n        };\n      }(e)), i = n.length, r = 0; r < i;) t[r] = n[r++];\n      for (; r < o;) delete t[r++];\n      return t;\n    }\n  });\n  var Gf = Hi(\"Array\").sort,\n    Wf = u,\n    Hf = Gf,\n    Kf = Array.prototype,\n    Yf = function (e) {\n      var t = e.sort;\n      return e === Kf || Wf(Kf, e) && t === Kf.sort ? Hf : t;\n    };\n  function qf(e, t) {\n    if (\"boolean\" != typeof e) throw new vE(TE.INVALID_PARAMS, \"Invalid \".concat(t, \": The value is of the boolean type.\"));\n  }\n  function Jf(e, t, i) {\n    if (i.includes(e)) return;\n    throw new vE(TE.INVALID_PARAMS, \"\".concat(t, \" can only be set as \").concat(JSON.stringify(i)));\n  }\n  function Xf(e, t) {\n    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n      r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4,\n      n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];\n    if (e < i || e > r || n && !rm(e)) {\n      throw new vE(TE.INVALID_PARAMS, \"invalid \".concat(t, \": the value range is [\").concat(i, \", \").concat(r, \"]. integer only\"));\n    }\n  }\n  function zf(e, t) {\n    if (\"number\" != typeof e) {\n      if (!(e.min || e.max || e.ideal || e.exact)) {\n        throw new vE(TE.INVALID_PARAMS, \"\".concat(t, \" is not a valid ConstrainLong\"));\n      }\n      void 0 !== e.min && Xf(e.min, \"\".concat(t, \".min\"), 0, 1 / 0), void 0 !== e.max && Xf(e.max, \"\".concat(t, \".max\"), 1, 1 / 0), void 0 !== e.exact && Xf(e.exact, \"\".concat(t, \".exact\"), 1, 1 / 0), void 0 !== e.ideal && Xf(e.ideal, \"\".concat(t, \".ideal\"), 1, 1 / 0);\n    } else Xf(e, t, 1, 1 / 0);\n  }\n  function Qf(e, t) {\n    let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,\n      r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255,\n      n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];\n    if (null == e) throw new vE(TE.INVALID_PARAMS, \"\".concat(t || \"param\", \" cannot be empty\"));\n    if (!im(e, i, r, n)) throw new vE(TE.INVALID_PARAMS, \"Invalid \".concat(t || \"string param\", \": Length of the string: [\").concat(i, \",\").concat(r, \"].\").concat(n ? \" ASCII characters only.\" : \"\"));\n  }\n  function Zf(e, t) {\n    if (!Array.isArray(e)) throw new vE(TE.INVALID_PARAMS, \"\".concat(t, \" should be an array\"));\n  }\n  function $f(e) {\n    if (\"string\" != typeof e || !/^[a-zA-Z0-9 \\!\\#\\$\\%\\&\\(\\)\\+\\-\\:\\;\\<\\=\\.\\>\\?\\@\\[\\]\\^\\_\\{\\}\\|\\~\\,]{1,64}$/.test(e)) throw NE.error(\"Invalid Channel Name \".concat(e)), new vE(TE.INVALID_PARAMS, \"The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,\");\n  }\n  function em(e) {\n    if (!(t = e, \"number\" == typeof t && Math.floor(t) === t && 0 <= t && t <= 4294967295 || im(e, 1, 255))) throw NE.error(\"Invalid UID \".concat(e, \" \").concat(typeof e)), new vE(TE.INVALID_PARAMS, \"[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]\");\n    var t;\n    \"string\" == typeof e && NE.warning(\"You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.\");\n  }\n  function tm(e) {\n    return null == e;\n  }\n  function im(e) {\n    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,\n      i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255,\n      r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];\n    return \"string\" == typeof e && e.length <= i && e.length >= t && (!r || nm(e));\n  }\n  function rm(e) {\n    return \"number\" == typeof e && e % 1 == 0;\n  }\n  function nm(e) {\n    if (\"string\" != typeof e) return !1;\n    for (let t = 0; t < e.length; t += 1) {\n      const i = e.charCodeAt(t);\n      if (i < 0 || i > 255) return !1;\n    }\n    return !0;\n  }\n  let om, sm, am;\n  !function (e) {\n    e.FREE = \"free\", e.UPLOADING = \"uploading\";\n  }(om || (om = {})), function (e) {\n    e[e.MISC = 0] = \"MISC\", e[e.INTERNAL_EVENT = 1] = \"INTERNAL_EVENT\", e[e.PUBLIC_EVENT = 2] = \"PUBLIC_EVENT\", e[e.WEB_EVENT = 3] = \"WEB_EVENT\", e[e.INTERNAL_API = 4] = \"INTERNAL_API\", e[e.WEB_API = 5] = \"WEB_API\", e[e.PUBLIC_API = 6] = \"PUBLIC_API\";\n  }(sm || (sm = {})), function (e) {\n    e.NONE = \"none\", e.INIT = \"init\", e.CANPLAY = \"canplay\", e.PLAYING = \"playing\", e.PAUSED = \"paused\", e.SUSPEND = \"suspend\", e.STALLED = \"stalled\", e.WAITING = \"waiting\", e.ERROR = \"error\", e.DESTROYED = \"destroyed\", e.ABORT = \"abort\", e.ENDED = \"ended\", e.EMPTIED = \"emptied\", e.LOADEDDATA = \"loadeddata\";\n  }(am || (am = {}));\n  const cm = {\n    uninit: 100,\n    none: 110,\n    init: 120,\n    loadeddata: 130,\n    canplay: 200,\n    playing: 210,\n    paused: 220,\n    suspend: 300,\n    stalled: 310,\n    waiting: 320,\n    error: 330,\n    destroyed: 340,\n    abort: 350,\n    ended: 360,\n    emptied: 370\n  };\n  function dm(e) {\n    return Qf(e.reportId, \"params.reportId\", 0, 100, !1), Qf(e.category, \"params.category\", 0, 100, !1), Qf(e.event, \"params.event\", 0, 100, !1), Qf(e.label, \"params.label\", 0, 100, !1), Xf(e.value, \"params.value\", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, !1), !0;\n  }\n  const um = {\n    sid: \"\",\n    lts: 0,\n    success: null,\n    cname: null,\n    uid: null,\n    peer: null,\n    cid: null,\n    elapse: null,\n    extend: null,\n    vid: 0\n  };\n  let lm, hm, pm, _m, Em, fm, mm, gm, Sm, Tm, vm, Rm, Im, ym, Cm, Am, Om, bm, wm, Nm, Dm, Pm, Lm, km;\n  function Mm(e) {\n    return Xf(e.timeout, \"config.timeout\", 0, 1e5), Xf(e.timeoutFactor, \"config.timeoutFactor\", 0, 100, !1), Xf(e.maxRetryCount, \"config.maxRetryConfig\", 0, 1 / 0), Xf(e.maxRetryTimeout, \"config.maxRetryTimeout\", 0, 1 / 0), !0;\n  }\n  function Um(e) {\n    return Jf(e.codec, \"config.codec\", [\"vp8\", \"vp9\", \"av1\", \"h264\"]), Jf(e.mode, \"config.mode\", [\"rtc\", \"live\"]), void 0 !== e.audioCodec && Jf(e.audioCodec, \"config.audioCodec\", [\"opus\", \"pcmu\", \"pcma\", \"g722\"]), void 0 !== e.proxyServer && Qf(e.proxyServer, \"config.proxyServer\", 1, 1e4), void 0 !== e.turnServer && Vm(e.turnServer), void 0 !== e.httpRetryConfig && Mm(e.httpRetryConfig), void 0 !== e.websocketRetryConfig && Mm(e.websocketRetryConfig), !0;\n  }\n  function xm(e) {\n    if (!Array.isArray(e) || e.length < 1) return !1;\n    try {\n      e.forEach(e => {\n        if (!e.urls) throw Error();\n      });\n    } catch (e) {\n      return !1;\n    }\n    return !0;\n  }\n  function Vm(e) {\n    return Qf(e.turnServerURL, \"turnServerURL\"), Qf(e.username, \"username\"), Qf(e.password, \"password\"), e.udpport && Xf(e.udpport, \"udpport\", 1, 99999, !0), e.forceturn && qf(e.forceturn, \"forceturn\"), e.security && qf(e.security, \"security\"), e.tcpport && Xf(e.tcpport, \"tcpport\", 1, 99999, !0), !0;\n  }\n  function jm(e) {\n    return void 0 !== e.level && Jf(e.level, \"level\", [1, 2, 3]), !0;\n  }\n  !function (e) {\n    e.PUBLISH = \"publish\", e.SUBSCRIBE = \"subscribe\", e.WS_COMPRESSOR_INIT = \"ws_compressor_init\", e.SESSION_INIT = \"session_init\", e.JOIN_CHOOSE_SERVER = \"join_choose_server\", e.REQ_USER_ACCOUNT = \"req_user_account\", e.JOIN_GATEWAY = \"join_gateway\", e.REJOIN_GATEWAY = \"rejoin_gateway\", e.STREAM_SWITCH = \"stream_switch\", e.REQUEST_PROXY_WORKER_MANAGER = \"request_proxy_worker_manager\", e.REQUEST_PROXY_APPCENTER = \"request_proxy_appcenter\", e.FIRST_VIDEO_RECEIVED = \"first_video_received\", e.FIRST_AUDIO_RECEIVED = \"first_audio_received\", e.FIRST_VIDEO_DECODE = \"first_video_decode\", e.FIRST_AUDIO_DECODE = \"first_audio_decode\", e.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\", e.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\", e.ON_UPDATE_STREAM = \"on_update_stream\", e.ON_REMOVE_STREAM = \"on_remove_stream\", e.USER_ANALYTICS = \"req_user_analytics\";\n  }(lm || (lm = {})), function (e) {\n    e.SESSION = \"io.agora.pb.Wrtc.Session\", e.JOIN_CHOOSE_SERVER = \"io.agora.pb.Wrtc.JoinChooseServer\", e.REQ_USER_ACCOUNT = \"io.agora.pb.Wrtc.ReqUserAccount\", e.JOIN_GATEWAY = \"io.agora.pb.Wrtc.JoinGateway\", e.RE_JOIN_GATEWAY = \"io.agora.pb.Wrtc.ReJoinGateway\", e.PUBLISH = \"io.agora.pb.Wrtc.Publish\", e.SUBSCRIBE = \"io.agora.pb.Wrtc.Subscribe\", e.WS_COMPRESSOR_INIT = \"io.agora.pb.Wrtc.WsCompressorInit\", e.STREAM_SWITCH = \"io.agora.pb.Wrtc.StreamSwitch\", e.AUDIO_SENDING_STOPPED = \"io.agora.pb.Wrtc.AudioSendingStopped\", e.VIDEO_SENDING_STOPPED = \"io.agora.pb.Wrtc.VideoSendingStopped\", e.REQUEST_PROXY_APPCENTER = \"io.agora.pb.Wrtc.RequestProxyAppCenter\", e.REQUEST_PROXY_WORKER_MANAGER = \"io.agora.pb.Wrtc.RequestProxyWorkerManager\", e.API_INVOKE = \"io.agora.pb.Wrtc.ApiInvoke\", e.FIRST_VIDEO_RECEIVED = \"io.agora.pb.Wrtc.FirstVideoReceived\", e.FIRST_AUDIO_RECEIVED = \"io.agora.pb.Wrtc.FirstAudioReceived\", e.FIRST_VIDEO_DECODE = \"io.agora.pb.Wrtc.FirstVideoDecode\", e.FIRST_AUDIO_DECODE = \"io.agora.pb.Wrtc.FirstAudioDecode\", e.ON_ADD_AUDIO_STREAM = \"io.agora.pb.Wrtc.OnAddAudioStream\", e.ON_ADD_VIDEO_STREAM = \"io.agora.pb.Wrtc.OnAddVideoStream\", e.ON_UPDATE_STREAM = \"io.agora.pb.Wrtc.OnUpdateStream\", e.ON_REMOVE_STREAM = \"io.agora.pb.Wrtc.OnRemoveStream\", e.JOIN_CHANNEL_TIMEOUT = \"io.agora.pb.Wrtc.JoinChannelTimeout\", e.PEER_PUBLISH_STATUS = \"io.agora.pb.Wrtc.PeerPublishStatus\", e.WORKER_EVENT = \"io.agora.pb.Wrtc.WorkerEvent\", e.AP_WORKER_EVENT = \"io.agora.pb.Wrtc.APWorkerEvent\", e.JOIN_WEB_PROXY_AP = \"io.agora.pb.Wrtc.JoinWebProxyAP\", e.WEBSOCKET_QUIT = \"io.agora.pb.Wrtc.WebSocketQuit\", e.USER_ANALYTICS = \"io.agora.pb.Wrtc.UserAnalytics\", e.AUTOPLAY_FAILED = \"io.agora.pb.Wrtc.AutoplayFailed\";\n  }(hm || (hm = {})), function (e) {\n    e[e.WORKER_EVENT = 156] = \"WORKER_EVENT\", e[e.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\";\n  }(pm || (pm = {})), function (e) {\n    e[e.SESSION = 26] = \"SESSION\", e[e.JOIN_CHOOSE_SERVER = 27] = \"JOIN_CHOOSE_SERVER\", e[e.REQ_USER_ACCOUNT = 196] = \"REQ_USER_ACCOUNT\", e[e.JOIN_GATEWAY = 28] = \"JOIN_GATEWAY\", e[e.PUBLISH = 30] = \"PUBLISH\", e[e.SUBSCRIBE = 29] = \"SUBSCRIBE\", e[e.WS_COMPRESSOR_INIT = 9430] = \"WS_COMPRESSOR_INIT\", e[e.STREAM_SWITCH = 32] = \"STREAM_SWITCH\", e[e.AUDIO_SENDING_STOPPED = 33] = \"AUDIO_SENDING_STOPPED\", e[e.VIDEO_SENDING_STOPPED = 34] = \"VIDEO_SENDING_STOPPED\", e[e.REQUEST_PROXY_APPCENTER = 35] = \"REQUEST_PROXY_APPCENTER\", e[e.REQUEST_PROXY_WORKER_MANAGER = 36] = \"REQUEST_PROXY_WORKER_MANAGER\", e[e.API_INVOKE = 41] = \"API_INVOKE\", e[e.FIRST_VIDEO_RECEIVED = 348] = \"FIRST_VIDEO_RECEIVED\", e[e.FIRST_AUDIO_RECEIVED = 349] = \"FIRST_AUDIO_RECEIVED\", e[e.FIRST_VIDEO_DECODE = 350] = \"FIRST_VIDEO_DECODE\", e[e.FIRST_AUDIO_DECODE = 351] = \"FIRST_AUDIO_DECODE\", e[e.ON_ADD_AUDIO_STREAM = 352] = \"ON_ADD_AUDIO_STREAM\", e[e.ON_ADD_VIDEO_STREAM = 353] = \"ON_ADD_VIDEO_STREAM\", e[e.ON_UPDATE_STREAM = 356] = \"ON_UPDATE_STREAM\", e[e.ON_REMOVE_STREAM = 355] = \"ON_REMOVE_STREAM\", e[e.JOIN_CHANNEL_TIMEOUT = 407] = \"JOIN_CHANNEL_TIMEOUT\", e[e.PEER_PUBLISH_STATUS = 408] = \"PEER_PUBLISH_STATUS\", e[e.WORKER_EVENT = 156] = \"WORKER_EVENT\", e[e.AP_WORKER_EVENT = 160] = \"AP_WORKER_EVENT\", e[e.JOIN_WEB_PROXY_AP = 700] = \"JOIN_WEB_PROXY_AP\", e[e.WEBSOCKET_QUIT = 671] = \"WEBSOCKET_QUIT\", e[e.USER_ANALYTICS = 1e4] = \"USER_ANALYTICS\", e[e.AUTOPLAY_FAILED = 9178] = \"AUTOPLAY_FAILED\";\n  }(_m || (_m = {})), function (e) {\n    e.CREATE_CLIENT = \"createClient\", e.CHECK_SYSTEM_REQUIREMENTS = \"checkSystemRequirements\", e.SET_AREA = \"setArea\", e.CHECK_VIDEO_TRACK_IS_ACTIVE = \"checkVideoTrackIsActive\", e.CHECK_AUDIO_TRACK_IS_ACTIVE = \"checkAudioTrackIsActive\", e.CREATE_MIC_AUDIO_TRACK = \"createMicrophoneAudioTrack\", e.CREATE_CUSTOM_AUDIO_TRACK = \"createCustomAudioTrack\", e.CREATE_BUFFER_AUDIO_TRACK = \"createBufferSourceAudioTrack\", e.CREATE_CAM_VIDEO_TRACK = \"createCameraVideoTrack\", e.CREATE_CUSTOM_VIDEO_TRACK = \"createCustomVideoTrack\", e.CREATE_MIC_AND_CAM_TRACKS = \"createMicrophoneAndCameraTracks\", e.CREATE_SCREEN_VIDEO_TRACK = \"createScreenVideoTrack\", e.SET_ENCRYPTION_CONFIG = \"Client.setEncryptionConfig\", e.START_PROXY_SERVER = \"Client.startProxyServer\", e.STOP_PROXY_SERVER = \"Client.stopProxyServer\", e.SET_PROXY_SERVER = \"Client.setProxyServer\", e.SET_TURN_SERVER = \"Client.setTurnServer\", e.SET_CLIENT_ROLE = \"Client.setClientRole\", e.SET_LOW_STREAM_PARAMETER = \"Client.setLowStreamParameter\", e.ENABLE_DUAL_STREAM = \"Client.enableDualStream\", e.DISABLE_DUAL_STREAM = \"Client.disableDualStream\", e.JOIN = \"Client.join\", e.LEAVE = \"Client.leave\", e.PUBLISH = \"Client.publish\", e.UNPUBLISH = \"Client.unpublish\", e.SUBSCRIBE = \"Client.subscribe\", e.MASS_SUBSCRIBE = \"Client.massSubscribe\", e.MASS_UNSUBSCRIBE = \"Client.massUnsubscribe\", e.UNSUBSCRIBE = \"Client.unsubscribe\", e.RENEW_TOKEN = \"Client.renewToken\", e.SET_REMOTE_VIDEO_STREAM_TYPE = \"Client.setRemoteVideoStreamType\", e.SET_STREAM_FALLBACK_OPTION = \"Client.setStreamFallbackOption\", e.ENABLE_AUDIO_VOLUME_INDICATOR = \"Client.enableAudioVolumeIndicator\", e.SEND_CUSTOM_REPORT_MESSAGE = \"Client.sendCustomReportMessage\", e.INSPECT_VIDEO_CONTENT = \"Client.inspectVideoContent\", e.STOP_INSPECT_VIDEO_CONTENT = \"Client.stopInspectVideoContent\", e.JOIN_FALLBACK_TO_PROXY = \"Client._joinFallbackToProxy\", e.DATACHANNEL_FAILBACK = \"Client._datachannelFailback\", e.ON_LIVE_STREAM_WARNING = \"Client.onLiveStreamWarning\", e.ON_LIVE_STREAM_ERROR = \"Client.onLiveStreamingError\", e.START_LIVE_STREAMING = \"Client.startLiveStreaming\", e.SET_LIVE_TRANSCODING = \"Client.setLiveTranscoding\", e.STOP_LIVE_STREAMING = \"Client.stopLiveStreaming\", e.ADD_INJECT_STREAM_URL = \"Client.addInjectStreamUrl\", e.REMOVE_INJECT_STREAM_URL = \"Client.removeInjectStreamUrl\", e.START_CHANNEL_MEDIA_RELAY = \"Client.startChannelMediaRelay\", e.UPDATE_CHANNEL_MEDIA_RELAY = \"Client.updateChannelMediaRelay\", e.STOP_CHANNEL_MEDIA_RELAY = \"Client.stopChannelMediaRelay\", e.REQUEST_CONFIG_DISTRIBUTE = \"_config-distribute-request\", e.SET_CONFIG_DISTRIBUTE = \"_configDistribute\", e.LOCAL_TRACK_SET_MUTED = \"LocalTrack.setMute\", e.LOCAL_AUDIO_TRACK_PLAY = \"LocalAudioTrack.play\", e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = \"LocalAudioTrack.playInElement\", e.LOCAL_AUDIO_TRACK_STOP = \"LocalAudioTrack.stop\", e.LOCAL_AUDIO_TRACK_SET_VOLUME = \"LocalAudioTrack.setVolume\", e.MIC_AUDIO_TRACK_SET_DEVICE = \"MicrophoneAudioTrack.setDevice\", e.BUFFER_AUDIO_TRACK_START = \"BufferSourceAudioTrack.startProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_STOP = \"BufferSourceAudioTrack.stopProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_PAUSE = \"BufferSourceAudioTrack.pauseProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_RESUME = \"BufferSourceAudioTrack.resumeProcessAudioBuffer\", e.BUFFER_AUDIO_TRACK_SEEK = \"BufferSourceAudioTrack.seekAudioBuffer\", e.LOCAL_VIDEO_TRACK_PLAY = \"LocalVideoTrack.play\", e.LOCAL_VIDEO_TRACK_STOP = \"LocalVideoTrack.stop\", e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = \"LocalVideoTrack.getVideoElementVisibleStatus\", e.LOCAL_VIDEO_TRACK_BEAUTY = \"LocalVideoTrack.setBeautyEffect\", e.CAM_VIDEO_TRACK_SET_DEVICE = \"CameraVideoTrack.setDevice\", e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = \"CameraVideoTrack.setEncoderConfiguration\", e.REMOTE_VIDEO_TRACK_PLAY = \"RemoteVideoTrack.play\", e.REMOTE_VIDEO_TRACK_STOP = \"RemoteVideoTrack.stop\", e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = \"RemoteVideoTrack.getVideoElementVisibleStatus\", e.REMOTE_AUDIO_TRACK_PLAY = \"RemoteAudioTrack.play\", e.REMOTE_AUDIO_TRACK_STOP = \"RemoteAudioTrack.stop\", e.REMOTE_AUDIO_SET_VOLUME = \"RemoteAudioTrack.setVolume\", e.REMOTE_AUDIO_SET_OUTPUT_DEVICE = \"RemoteAudioTrack.setOutputDevice\", e.GET_MEDIA_STREAM_TRACK = \"Track.getMediaStreamTrack\", e.STREAM_TYPE_CHANGE = \"streamTypeChange\", e.CONNECTION_STATE_CHANGE = \"connectionStateChange\", e.LOAD_CONFIG_FROM_LOCALSTORAGE = \"loadConfigFromLocalStorage\";\n  }(Em || (Em = {})), function (e) {\n    e.TRACER = \"tracer\";\n  }(fm || (fm = {})), function (e) {\n    e.IDLE = \"IDLE\", e.INITING = \"INITING\", e.INITEND = \"INITEND\";\n  }(mm || (mm = {})), function (e) {\n    e.STATE_CHANGE = \"state_change\", e.RECORDING_DEVICE_CHANGED = \"recordingDeviceChanged\", e.PLAYOUT_DEVICE_CHANGED = \"playoutDeviceChanged\", e.CAMERA_DEVICE_CHANGED = \"cameraDeviceChanged\";\n  }(gm || (gm = {})), function (e) {\n    e[e.ACCESS_POINT = 101] = \"ACCESS_POINT\", e[e.UNILBS = 201] = \"UNILBS\", e[e.STRING_UID_ALLOCATOR = 901] = \"STRING_UID_ALLOCATOR\";\n  }(Sm || (Sm = {})), function (e) {\n    e[e.IIIEGAL_APPID = 1] = \"IIIEGAL_APPID\", e[e.IIIEGAL_UID = 2] = \"IIIEGAL_UID\", e[e.INTERNAL_ERROR = 3] = \"INTERNAL_ERROR\";\n  }(Tm || (Tm = {})), function (e) {\n    e[e.INVALID_VENDOR_KEY = 5] = \"INVALID_VENDOR_KEY\", e[e.INVALID_CHANNEL_NAME = 7] = \"INVALID_CHANNEL_NAME\", e[e.INTERNAL_ERROR = 8] = \"INTERNAL_ERROR\", e[e.NO_AUTHORIZED = 9] = \"NO_AUTHORIZED\", e[e.DYNAMIC_KEY_TIMEOUT = 10] = \"DYNAMIC_KEY_TIMEOUT\", e[e.NO_ACTIVE_STATUS = 11] = \"NO_ACTIVE_STATUS\", e[e.DYNAMIC_KEY_EXPIRED = 13] = \"DYNAMIC_KEY_EXPIRED\", e[e.STATIC_USE_DYNAMIC_KEY = 14] = \"STATIC_USE_DYNAMIC_KEY\", e[e.DYNAMIC_USE_STATIC_KEY = 15] = \"DYNAMIC_USE_STATIC_KEY\", e[e.USER_OVERLOAD = 16] = \"USER_OVERLOAD\", e[e.FORBIDDEN_REGION = 18] = \"FORBIDDEN_REGION\", e[e.CANNOT_MEET_AREA_DEMAND = 19] = \"CANNOT_MEET_AREA_DEMAND\";\n  }(vm || (vm = {})), function (e) {\n    e[e.NO_FLAG_SET = 100] = \"NO_FLAG_SET\", e[e.FLAG_SET_BUT_EMPTY = 101] = \"FLAG_SET_BUT_EMPTY\", e[e.INVALID_FALG_SET = 102] = \"INVALID_FALG_SET\", e[e.FLAG_SET_BUT_NO_RE = 103] = \"FLAG_SET_BUT_NO_RE\", e[e.INVALID_SERVICE_ID = 104] = \"INVALID_SERVICE_ID\", e[e.NO_SERVICE_AVAILABLE = 200] = \"NO_SERVICE_AVAILABLE\", e[e.NO_SERVICE_AVAILABLE_P2P = 201] = \"NO_SERVICE_AVAILABLE_P2P\", e[e.NO_SERVICE_AVAILABLE_VOICE = 202] = \"NO_SERVICE_AVAILABLE_VOICE\", e[e.NO_SERVICE_AVAILABLE_WEBRTC = 203] = \"NO_SERVICE_AVAILABLE_WEBRTC\", e[e.NO_SERVICE_AVAILABLE_CDS = 204] = \"NO_SERVICE_AVAILABLE_CDS\", e[e.NO_SERVICE_AVAILABLE_CDN = 205] = \"NO_SERVICE_AVAILABLE_CDN\", e[e.NO_SERVICE_AVAILABLE_TDS = 206] = \"NO_SERVICE_AVAILABLE_TDS\", e[e.NO_SERVICE_AVAILABLE_REPORT = 207] = \"NO_SERVICE_AVAILABLE_REPORT\", e[e.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = \"NO_SERVICE_AVAILABLE_APP_CENTER\", e[e.NO_SERVICE_AVAILABLE_ENV0 = 209] = \"NO_SERVICE_AVAILABLE_ENV0\", e[e.NO_SERVICE_AVAILABLE_VOET = 210] = \"NO_SERVICE_AVAILABLE_VOET\", e[e.NO_SERVICE_AVAILABLE_STRING_UID = 211] = \"NO_SERVICE_AVAILABLE_STRING_UID\", e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = \"NO_SERVICE_AVAILABLE_WEBRTC_UNILBS\", e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = \"NO_SERVICE_AVAILABLE_UNILBS_FLV\";\n  }(Rm || (Rm = {})), function (e) {\n    e[e.K_TIMESTAMP_EXPIRED = 2] = \"K_TIMESTAMP_EXPIRED\", e[e.K_CHANNEL_PERMISSION_INVALID = 3] = \"K_CHANNEL_PERMISSION_INVALID\", e[e.K_CERTIFICATE_INVALID = 4] = \"K_CERTIFICATE_INVALID\", e[e.K_CHANNEL_NAME_EMPTY = 5] = \"K_CHANNEL_NAME_EMPTY\", e[e.K_CHANNEL_NOT_FOUND = 6] = \"K_CHANNEL_NOT_FOUND\", e[e.K_TICKET_INVALID = 7] = \"K_TICKET_INVALID\", e[e.K_CHANNEL_CONFLICTED = 8] = \"K_CHANNEL_CONFLICTED\", e[e.K_SERVICE_NOT_READY = 9] = \"K_SERVICE_NOT_READY\", e[e.K_SERVICE_TOO_HEAVY = 10] = \"K_SERVICE_TOO_HEAVY\", e[e.K_UID_BANNED = 14] = \"K_UID_BANNED\", e[e.K_IP_BANNED = 15] = \"K_IP_BANNED\", e[e.K_CHANNEL_BANNED = 16] = \"K_CHANNEL_BANNED\", e[e.WARN_NO_AVAILABLE_CHANNEL = 103] = \"WARN_NO_AVAILABLE_CHANNEL\", e[e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = \"WARN_LOOKUP_CHANNEL_TIMEOUT\", e[e.WARN_LOOKUP_CHANNEL_REJECTED = 105] = \"WARN_LOOKUP_CHANNEL_REJECTED\", e[e.WARN_OPEN_CHANNEL_TIMEOUT = 106] = \"WARN_OPEN_CHANNEL_TIMEOUT\", e[e.WARN_OPEN_CHANNEL_REJECTED = 107] = \"WARN_OPEN_CHANNEL_REJECTED\", e[e.WARN_REQUEST_DEFERRED = 108] = \"WARN_REQUEST_DEFERRED\", e[e.ERR_DYNAMIC_KEY_TIMEOUT = 109] = \"ERR_DYNAMIC_KEY_TIMEOUT\", e[e.ERR_NO_AUTHORIZED = 110] = \"ERR_NO_AUTHORIZED\", e[e.ERR_VOM_SERVICE_UNAVAILABLE = 111] = \"ERR_VOM_SERVICE_UNAVAILABLE\", e[e.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = \"ERR_NO_CHANNEL_AVAILABLE_CODE\", e[e.ERR_MASTER_VOCS_UNAVAILABLE = 114] = \"ERR_MASTER_VOCS_UNAVAILABLE\", e[e.ERR_INTERNAL_ERROR = 115] = \"ERR_INTERNAL_ERROR\", e[e.ERR_NO_ACTIVE_STATUS = 116] = \"ERR_NO_ACTIVE_STATUS\", e[e.ERR_INVALID_UID = 117] = \"ERR_INVALID_UID\", e[e.ERR_DYNAMIC_KEY_EXPIRED = 118] = \"ERR_DYNAMIC_KEY_EXPIRED\", e[e.ERR_STATIC_USE_DYANMIC_KE = 119] = \"ERR_STATIC_USE_DYANMIC_KE\", e[e.ERR_DYNAMIC_USE_STATIC_KE = 120] = \"ERR_DYNAMIC_USE_STATIC_KE\", e[e.ERR_NO_VOCS_AVAILABLE = 2e3] = \"ERR_NO_VOCS_AVAILABLE\", e[e.ERR_NO_VOS_AVAILABLE = 2001] = \"ERR_NO_VOS_AVAILABLE\", e[e.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = \"ERR_JOIN_CHANNEL_TIMEOUT\", e[e.ERR_REPEAT_JOIN_CHANNEL = 2003] = \"ERR_REPEAT_JOIN_CHANNEL\", e[e.ERR_JOIN_BY_MULTI_IP = 2004] = \"ERR_JOIN_BY_MULTI_IP\", e[e.ERR_NOT_JOINED = 2011] = \"ERR_NOT_JOINED\", e[e.ERR_REPEAT_JOIN_REQUEST = 2012] = \"ERR_REPEAT_JOIN_REQUEST\", e[e.ERR_INVALID_VENDOR_KEY = 2013] = \"ERR_INVALID_VENDOR_KEY\", e[e.ERR_INVALID_CHANNEL_NAME = 2014] = \"ERR_INVALID_CHANNEL_NAME\", e[e.ERR_INVALID_STRINGUID = 2015] = \"ERR_INVALID_STRINGUID\", e[e.ERR_TOO_MANY_USERS = 2016] = \"ERR_TOO_MANY_USERS\", e[e.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = \"ERR_SET_CLIENT_ROLE_TIMEOUT\", e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = \"ERR_SET_CLIENT_ROLE_NO_PERMISSION\", e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\", e[e.ERR_PUBLISH_REQUEST_INVALID = 2020] = \"ERR_PUBLISH_REQUEST_INVALID\", e[e.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = \"ERR_SUBSCRIBE_REQUEST_INVALID\", e[e.ERR_NOT_SUPPORTED_MESSAGE = 2022] = \"ERR_NOT_SUPPORTED_MESSAGE\", e[e.ERR_ILLEAGAL_PLUGIN = 2023] = \"ERR_ILLEAGAL_PLUGIN\", e[e.ERR_REJOIN_TOKEN_INVALID = 2024] = \"ERR_REJOIN_TOKEN_INVALID\", e[e.ERR_REJOIN_USER_NOT_JOINED = 2025] = \"ERR_REJOIN_USER_NOT_JOINED\", e[e.ERR_INVALID_OPTIONAL_INFO = 2027] = \"ERR_INVALID_OPTIONAL_INFO\", e[e.ILLEGAL_AES_PASSWORD = 2028] = \"ILLEGAL_AES_PASSWORD\", e[e.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = \"ILLEGAL_CLIENT_ROLE_LEVEL\", e[e.ERR_TOO_MANY_BROADCASTERS = 2031] = \"ERR_TOO_MANY_BROADCASTERS\", e[e.ERR_TOO_MANY_SUBSCRIBERS = 2032] = \"ERR_TOO_MANY_SUBSCRIBERS\", e[e.ERR_LICENSE_MISSING = 32769] = \"ERR_LICENSE_MISSING\", e[e.ERR_LICENSE_EXPIRED = 32771] = \"ERR_LICENSE_EXPIRED\", e[e.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = \"ERR_LICENSE_MINUTES_EXCEEDED\", e[e.ERR_LICENSE_PERIOD_INVALID = 32774] = \"ERR_LICENSE_PERIOD_INVALID\", e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = \"ERR_LICENSE_MULTIPLE_SDK_SERVICE\", e[e.ERR_LICENSE_ILLEGAL = 32783] = \"ERR_LICENSE_ILLEGAL\", e[e.ERR_TEST_RECOVER = 9e3] = \"ERR_TEST_RECOVER\", e[e.ERR_TEST_TRYNEXT = 9001] = \"ERR_TEST_TRYNEXT\", e[e.ERR_TEST_RETRY = 9002] = \"ERR_TEST_RETRY\";\n  }(Im || (Im = {})), function (e) {\n    e[e.AUDIENCE_LEVEL_LOW_LATENCY = 1] = \"AUDIENCE_LEVEL_LOW_LATENCY\", e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = \"AUDIENCE_LEVEL_ULTRA_LOW_LATENCY\", e[e.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = \"AUDIENCE_LEVEL_SYNC_LATENCY\";\n  }(ym || (ym = {})), function (e) {\n    e.LEAVE = \"LEAVE\", e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.UID_BANNED = \"UID_BANNED\", e.IP_BANNED = \"IP_BANNED\", e.CHANNEL_BANNED = \"CHANNEL_BANNED\", e.FALLBACK = \"FALLBACK\", e.LICENSE_MISSING = \"LICENSE_MISSING\", e.LICENSE_EXPIRED = \"LICENSE_EXPIRED\", e.LICENSE_MINUTES_EXCEEDED = \"LICENSE_MINUTES_EXCEEDED\", e.LICENSE_PERIOD_INVALID = \"LICENSE_PERIOD_INVALID\", e.LICENSE_MULTIPLE_SDK_SERVICE = \"LICENSE_MULTIPLE_SDK_SERVICE\", e.LICENSE_ILLEGAL = \"LICENSE_ILLEGAL\";\n  }(Cm || (Cm = {})), function (e) {\n    e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.MEDIA_RECONNECT_START = \"media-reconnect-start\", e.MEDIA_RECONNECT_END = \"media-reconnect-end\", e.IS_USING_CLOUD_PROXY = \"is-using-cloud-proxy\", e.USER_JOINED = \"user-joined\", e.USER_LEAVED = \"user-left\", e.USER_PUBLISHED = \"user-published\", e.USER_UNPUBLISHED = \"user-unpublished\", e.USER_INFO_UPDATED = \"user-info-updated\", e.CLIENT_BANNED = \"client-banned\", e.CHANNEL_MEDIA_RELAY_STATE = \"channel-media-relay-state\", e.CHANNEL_MEDIA_RELAY_EVENT = \"channel-media-relay-event\", e.VOLUME_INDICATOR = \"volume-indicator\", e.CRYPT_ERROR = \"crypt-error\", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"token-privilege-will-expire\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"token-privilege-did-expire\", e.NETWORK_QUALITY = \"network-quality\", e.STREAM_TYPE_CHANGED = \"stream-type-changed\", e.STREAM_FALLBACK = \"stream-fallback\", e.RECEIVE_METADATA = \"receive-metadata\", e.STREAM_MESSAGE = \"stream-message\", e.LIVE_STREAMING_ERROR = \"live-streaming-error\", e.LIVE_STREAMING_WARNING = \"live-streaming-warning\", e.INJECT_STREAM_STATUS = \"stream-inject-status\", e.EXCEPTION = \"exception\", e.ERROR = \"error\", e.P2P_LOST = \"p2p_lost\", e.JOIN_FALLBACK_TO_PROXY = \"join-fallback-to-proxy\", e.CHANNEL_FALLBACK_TO_WEBSOCKET = \"channel-fallback-to-websocket\", e.MEDIA_CONNECTION_TYPE_CHANGE = \"media-connection-type-change\", e.PUBLISHED_USER_LIST = \"published-user-list\", e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = \"content-inspect-connection-state-change\", e.CONTENT_INSPECT_ERROR = \"content-inspect-error\", e.CONTENT_INSPECT_RESULT = \"content-inspect-result\";\n  }(Am || (Am = {})), function (e) {\n    e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.MULTI_IP = \"MULTI_IP\", e.TIMEOUT = \"TIMEOUT\", e.OFFLINE = \"OFFLINE\", e.LEAVE = \"LEAVE\", e.P2P_FAILED = \"P2P_FAILED\", e.FALLBACK = \"FALLBACK\";\n  }(Om || (Om = {})), function (e) {\n    e.CONNECTING = \"connecting\", e.CONNECTED = \"connected\", e.RECONNECTING = \"reconnecting\", e.CLOSED = \"closed\";\n  }(bm || (bm = {})), function (e) {\n    e.WS_CONNECTED = \"ws_connected\", e.WS_RECONNECTING = \"ws_reconnecting\", e.WS_CLOSED = \"ws_closed\", e.WS_RECONNECT_WAITTING_FINISH = \"ws_reconnect_waitting_finish\", e.WS_RECONNECT_CREATE_CONNECTION = \"ws_reconnect_create_connection\", e.ON_BINARY_DATA = \"on_binary_data\", e.REQUEST_RECOVER = \"request_recover\", e.REQUEST_JOIN_INFO = \"request_join_info\", e.REQUEST_REJOIN_INFO = \"req_rejoin_info\", e.IS_P2P_DISCONNECTED = \"is_p2p_dis\", e.DISCONNECT_P2P = \"dis_p2p\", e.ABORT_P2P_EXECUTION = \"abort_p2p_execution\", e.NEED_RENEW_SESSION = \"need-sid\", e.REPORT_JOIN_GATEWAY = \"report_join_gateway\", e.REQUEST_TIMEOUT = \"request_timeout\", e.REQUEST_SUCCESS = \"request_success\", e.JOIN_RESPONSE = \"join_response\", e.DATACHANNEL_PRECONNECT = \"datachannel_preconnect\", e.DATACHANNEL_CONNECTING = \"datachannel_connecting\", e.DATACHANNEL_FAILBACK = \"datachannel_failback\";\n  }(wm || (wm = {})), function (e) {\n    e.PING = \"ping\", e.PING_BACK = \"ping_back\", e.JOIN = \"join_v3\", e.REJOIN = \"rejoin_v3\", e.LEAVE = \"leave\", e.SET_CLIENT_ROLE = \"set_client_role\", e.PUBLISH = \"publish\", e.UNPUBLISH = \"unpublish\", e.SUBSCRIBE = \"subscribe\", e.SUBSCRIBE_STREAMS = \"subscribe_streams\", e.UNSUBSCRIBE = \"unsubscribe\", e.UNSUBSCRIBE_STREAMS = \"unsubscribe_streams\", e.SUBSCRIBE_CHANGE = \"subscribe_change\", e.TRAFFIC_STATS = \"traffic_stats\", e.RENEW_TOKEN = \"renew_token\", e.SWITCH_VIDEO_STREAM = \"switch_video_stream\", e.DEFAULT_VIDEO_STREAM = \"default_video_stream\", e.SET_FALLBACK_OPTION = \"set_fallback_option\", e.GATEWAY_INFO = \"gateway_info\", e.CONTROL = \"control\", e.SEND_METADATA = \"send_metadata\", e.DATA_STREAM = \"data_stream\", e.PICK_SVC_LAYER = \"pick_svc_layer\", e.RESTART_ICE = \"restart_ice\", e.CONNECT_PC = \"connect_pc\", e.SET_VIDEO_PROFILE = \"set_video_profile\", e.SET_PARAMETER = \"set_parameter\";\n  }(Nm || (Nm = {})), function (e) {\n    e.PUBLISH_STATS = \"publish_stats\", e.PUBLISH_RELATED_STATS = \"publish_related_stats\", e.SUBSCRIBE_STATS = \"subscribe_stats\", e.SUBSCRIBE_RELATED_STATS = \"subscribe_related_stats\", e.WS_INFLATE_DATA_LENGTH = \"ws_inflate_data_length\", e.DENOISER_STATS = \"denoiser_stats\", e.TRANSPORT_STATS = \"transport_stats\", e.EXTENSION_USAGE_STATS = \"extension_usage_stats\";\n  }(Dm || (Dm = {})), function (e) {\n    e.ON_USER_ONLINE = \"on_user_online\", e.ON_USER_OFFLINE = \"on_user_offline\", e.ON_STREAM_FALLBACK_UPDATE = \"on_stream_fallback_update\", e.ON_PUBLISH_STREAM = \"on_publish_stream\", e.ON_UPLINK_STATS = \"on_uplink_stats\", e.ON_P2P_LOST = \"on_p2p_lost\", e.ON_REMOVE_STREAM = \"on_remove_stream\", e.ON_ADD_AUDIO_STREAM = \"on_add_audio_stream\", e.ON_ADD_VIDEO_STREAM = \"on_add_video_stream\", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = \"on_token_privilege_will_expire\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"on_token_privilege_did_expire\", e.ON_USER_BANNED = \"on_user_banned\", e.ON_USER_LICENSE_BANNED = \"on_user_license_banned\", e.ON_NOTIFICATION = \"on_notification\", e.ON_CRYPT_ERROR = \"on_crypt_error\", e.MUTE_AUDIO = \"mute_audio\", e.MUTE_VIDEO = \"mute_video\", e.UNMUTE_AUDIO = \"unmute_audio\", e.UNMUTE_VIDEO = \"unmute_video\", e.ON_P2P_OK = \"on_p2p_ok\", e.RECEIVE_METADATA = \"receive_metadata\", e.ON_DATA_STREAM = \"on_data_stream\", e.ENABLE_LOCAL_VIDEO = \"enable_local_video\", e.DISABLE_LOCAL_VIDEO = \"disable_local_video\", e.ENABLE_LOCAL_AUDIO = \"enable_local_audio\", e.DISABLE_LOCAL_AUDIO = \"disable_local_audio\", e.ON_PUBLISHED_USER_LIST = \"on_published_user_list\";\n  }(Pm || (Pm = {})), function (e) {\n    e.CONNECTION_STATE_CHANGE = \"CONNECTION_STATE_CHANGE\", e.NEED_ANSWER = \"NEED_ANSWER\", e.NEED_RENEGOTIATE = \"NEED_RENEGOTIATE\", e.P2P_LOST = \"P2P_LOST\", e.GATEWAY_P2P_LOST = \"GATEWAY_P2P_LOST\", e.NEED_UNPUB = \"NEED_UNPUB\", e.NEED_UNSUB = \"NEED_UNSUB\", e.NEED_UPLOAD = \"NEED_UPLOAD\", e.NEED_CONTROL = \"NEED_CONTROL\", e.START_RECONNECT = \"START_RECONNECT\", e.END_RECONNECT = \"END_RECONNECT\", e.NEED_SIGNAL_RTT = \"NEED_SIGNAL_RTT\";\n  }(Lm || (Lm = {})), function (e) {\n    e.AUDIO_SOURCE_STATE_CHANGE = \"audio_source_state_change\", e.RECEIVE_TRACK_BUFFER = \"receive_track_buffer\", e.ON_AUDIO_BUFFER = \"on_audio_buffer\", e.UPDATE_SOURCE = \"update_source\";\n  }(km || (km = {}));\n  const Fm = {\n      sendVolumeLevel: 0,\n      sendBitrate: 0,\n      sendBytes: 0,\n      sendPackets: 0,\n      sendPacketsLost: 0,\n      currentPacketLossRate: 0\n    },\n    Bm = {\n      sendBytes: 0,\n      sendBitrate: 0,\n      sendPackets: 0,\n      sendPacketsLost: 0,\n      sendResolutionHeight: 0,\n      sendResolutionWidth: 0,\n      captureResolutionHeight: 0,\n      captureResolutionWidth: 0,\n      targetSendBitrate: 0,\n      totalDuration: 0,\n      totalFreezeTime: 0,\n      currentPacketLossRate: 0\n    },\n    Gm = {\n      transportDelay: 0,\n      end2EndDelay: 0,\n      receiveBitrate: 0,\n      receiveLevel: 0,\n      receiveBytes: 0,\n      receiveDelay: 0,\n      receivePackets: 0,\n      receivePacketsLost: 0,\n      totalDuration: 0,\n      totalFreezeTime: 0,\n      freezeRate: 0,\n      packetLossRate: 0,\n      currentPacketLossRate: 0,\n      publishDuration: -1\n    },\n    Wm = {\n      uplinkNetworkQuality: 0,\n      downlinkNetworkQuality: 0\n    },\n    Hm = {\n      transportDelay: 0,\n      end2EndDelay: 0,\n      receiveBitrate: 0,\n      receiveBytes: 0,\n      receiveDelay: 0,\n      receivePackets: 0,\n      receivePacketsLost: 0,\n      receiveResolutionHeight: 0,\n      receiveResolutionWidth: 0,\n      totalDuration: 0,\n      totalFreezeTime: 0,\n      freezeRate: 0,\n      packetLossRate: 0,\n      currentPacketLossRate: 0,\n      publishDuration: -1\n    };\n  let Km, Ym, qm;\n  !function (e) {\n    e.CONNECTED = \"websocket:connected\", e.RECONNECTING = \"websocket:reconnecting\", e.WILL_RECONNECT = \"websocket:will_reconnect\", e.CLOSED = \"websocket:closed\", e.FAILED = \"websocket:failed\", e.ON_MESSAGE = \"websocket:on_message\", e.REQUEST_NEW_URLS = \"websocket:request_new_urls\", e.RECONNECT_WAITTING_FINISH = \"websocket:reconnect_waitting_finish\", e.RECONNECT_CREATE_CONNECTION = \"websocket:reconnect_create_connection\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"websocket:on_token_privilege_did_expire\";\n  }(Km || (Km = {})), function (e) {\n    e.TRANSCODE = \"mix_streaming\", e.RAW = \"raw_streaming\", e.INJECT = \"inject_streaming\";\n  }(Ym || (Ym = {})), function (e) {\n    e[e.INJECT_STREAM_STATUS_START_SUCCESS = 0] = \"INJECT_STREAM_STATUS_START_SUCCESS\", e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = \"INJECT_STREAM_STATUS_START_ALREADY_EXISTS\", e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = \"INJECT_STREAM_STATUS_START_UNAUTHORIZED\", e[e.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = \"INJECT_STREAM_STATUS_START_TIMEOUT\", e[e.INJECT_STREAM_STATUS_START_FAILED = 4] = \"INJECT_STREAM_STATUS_START_FAILED\", e[e.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = \"INJECT_STREAM_STATUS_STOP_SUCCESS\", e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = \"INJECT_STREAM_STATUS_STOP_NOT_FOUND\", e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = \"INJECT_STREAM_STATUS_STOP_UNAUTHORIZED\", e[e.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = \"INJECT_STREAM_STATUS_STOP_TIMEOUT\", e[e.INJECT_STREAM_STATUS_STOP_FAILED = 9] = \"INJECT_STREAM_STATUS_STOP_FAILED\", e[e.INJECT_STREAM_STATUS_BROKEN = 10] = \"INJECT_STREAM_STATUS_BROKEN\";\n  }(qm || (qm = {}));\n  const Jm = {\n      alpha: 1,\n      height: 640,\n      width: 360,\n      x: 0,\n      y: 0,\n      zOrder: 0,\n      audioChannel: 0\n    },\n    Xm = {\n      x: 0,\n      y: 0,\n      width: 160,\n      height: 160,\n      zOrder: 255,\n      alpha: 1\n    };\n  function zm(e, t) {\n    Qf(e.url, \"\".concat(t, \".url\"), 1, 1e3, !1), tm(e.x) || Xf(e.x, \"\".concat(t, \".x\"), 0, 1e4), tm(e.y) || Xf(e.y, \"\".concat(t, \".y\"), 0, 1e4), tm(e.width) || Xf(e.width, \"\".concat(t, \".width\"), 0, 1e4), tm(e.height) || Xf(e.height, \"\".concat(t, \".height\"), 0, 1e4), tm(e.zOrder) || Xf(e.zOrder, \"\".concat(t, \".zOrder\"), 0, 255), tm(e.alpha) || Xf(e.alpha, \"\".concat(t, \".alpha\"), 0, 1, !1);\n  }\n  const Qm = {\n      audioBitrate: 48,\n      audioChannels: 1,\n      audioSampleRate: 48e3,\n      backgroundColor: 0,\n      height: 360,\n      lowLatency: !1,\n      videoBitrate: 400,\n      videoCodecProfile: 100,\n      videoCodecType: 1,\n      videoFrameRate: 15,\n      videoGop: 30,\n      width: 640,\n      images: [],\n      userConfigs: [],\n      userConfigExtraInfo: \"\"\n    },\n    Zm = {\n      audioBitrate: 48,\n      audioChannels: 2,\n      audioVolume: 100,\n      audioSampleRate: 48e3,\n      height: 0,\n      width: 0,\n      videoBitrate: 400,\n      videoFramerate: 15,\n      videoGop: 30\n    };\n  let $m, eg, tg, ig, rg, ng, og, sg, ag, cg, dg, ug, lg, hg, pg, _g, Eg, fg;\n  function mg(e) {\n    if (!e.channelName) throw new vE(TE.INVALID_PARAMS, \"invalid channelName in info\");\n    if (\"number\" != typeof e.uid) throw new vE(TE.INVALID_PARAMS, \"invalid uid in info, uid must be a number\");\n    return e.token && Qf(e.token, \"info.token\", 1, 2047), em(e.uid), $f(e.channelName), !0;\n  }\n  function gg(e) {\n    return Jf(e, \"mediaSource\", [\"screen\", \"window\", \"application\"]), !0;\n  }\n  !function (e) {\n    e.WARNING = \"@live_uap-warning\", e.ERROR = \"@line_uap-error\", e.PUBLISH_STREAM_STATUS = \"@live_uap-publish-status\", e.INJECT_STREAM_STATUS = \"@live_uap-inject-status\", e.WORKER_STATUS = \"@live_uap-worker-status\", e.REQUEST_NEW_ADDRESS = \"@live_uap-request-address\";\n  }($m || ($m = {})), function (e) {\n    e.REQUEST_WORKER_MANAGER_LIST = \"@live_req_worker_manager\";\n  }(eg || (eg = {})), function (e) {\n    e[e.LIVE_STREAM_RESPONSE_SUCCEED = 200] = \"LIVE_STREAM_RESPONSE_SUCCEED\", e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = \"LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM\", e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = \"LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR\", e[e.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = \"LIVE_STREAM_RESPONSE_BAD_STREAM\", e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = \"LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR\", e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = \"LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST\", e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = \"LIVE_STREAM_RESPONSE_NOT_AUTHORIZED\", e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = \"LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE\", e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = \"LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN\", e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = \"LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH\", e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = \"LIVE_STREAM_RESPONSE_NOT_SUPPORTED\", e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = \"LIVE_STREAM_RESPONSE_MAX_STREAM_NUM\", e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = \"LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR\", e[e.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = \"LIVE_STREAM_RESPONSE_WORKER_LOST\", e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = \"LIVE_STREAM_RESPONSE_RESOURCE_LIMIT\", e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = \"LIVE_STREAM_RESPONSE_WORKER_QUIT\", e[e.ERROR_FAIL_SEND_MESSAGE = 504] = \"ERROR_FAIL_SEND_MESSAGE\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT\", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = \"PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH\", e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = \"PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN\";\n  }(tg || (tg = {})), function (e) {\n    e.CONNECT_FAILED = \"connect failed\", e.CONNECT_TIMEOUT = \"connect timeout\", e.WS_DISCONNECTED = \"websocket disconnected\", e.REQUEST_TIMEOUT = \"request timeout\", e.REQUEST_FAILED = \"request failed\", e.WAIT_STATUS_TIMEOUT = \"wait status timeout\", e.WAIT_STATUS_ERROR = \"wait status error\", e.BAD_STATE = \"bad state\", e.WS_ABORT = \"ws abort\", e.AP_REQUEST_TIMEOUT = \"AP request timeout\", e.AP_JSON_PARSE_ERROR = \"AP json parse error\", e.AP_REQUEST_ERROR = \"AP request error\", e.AP_REQUEST_ABORT = \"AP request abort\";\n  }(ig || (ig = {})), function (e) {\n    e[e.SetSdkProfile = 0] = \"SetSdkProfile\", e[e.SetSourceChannel = 1] = \"SetSourceChannel\", e[e.SetSourceUserId = 2] = \"SetSourceUserId\", e[e.SetDestChannel = 3] = \"SetDestChannel\", e[e.StartPacketTransfer = 4] = \"StartPacketTransfer\", e[e.StopPacketTransfer = 5] = \"StopPacketTransfer\", e[e.UpdateDestChannel = 6] = \"UpdateDestChannel\", e[e.Reconnect = 7] = \"Reconnect\", e[e.SetVideoProfile = 8] = \"SetVideoProfile\";\n  }(rg || (rg = {})), function (e) {\n    e.NETWORK_DISCONNECTED = \"NETWORK_DISCONNECTED\", e.NETWORK_CONNECTED = \"NETWORK_CONNECTED\", e.PACKET_JOINED_SRC_CHANNEL = \"PACKET_JOINED_SRC_CHANNEL\", e.PACKET_JOINED_DEST_CHANNEL = \"PACKET_JOINED_DEST_CHANNEL\", e.PACKET_SENT_TO_DEST_CHANNEL = \"PACKET_SENT_TO_DEST_CHANNEL\", e.PACKET_RECEIVED_VIDEO_FROM_SRC = \"PACKET_RECEIVED_VIDEO_FROM_SRC\", e.PACKET_RECEIVED_AUDIO_FROM_SRC = \"PACKET_RECEIVED_AUDIO_FROM_SRC\", e.PACKET_UPDATE_DEST_CHANNEL = \"PACKET_UPDATE_DEST_CHANNEL\", e.PACKET_UPDATE_DEST_CHANNEL_REFUSED = \"PACKET_UPDATE_DEST_CHANNEL_REFUSED\", e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = \"PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE\";\n  }(ng || (ng = {})), function (e) {\n    e.RELAY_STATE_IDLE = \"RELAY_STATE_IDLE\", e.RELAY_STATE_CONNECTING = \"RELAY_STATE_CONNECTING\", e.RELAY_STATE_RUNNING = \"RELAY_STATE_RUNNING\", e.RELAY_STATE_FAILURE = \"RELAY_STATE_FAILURE\";\n  }(og || (og = {})), function (e) {\n    e.RELAY_OK = \"RELAY_OK\", e.SERVER_CONNECTION_LOST = \"SERVER_CONNECTION_LOST\", e.SRC_TOKEN_EXPIRED = \"SRC_TOKEN_EXPIRED\", e.DEST_TOKEN_EXPIRED = \"DEST_TOKEN_EXPIRED\";\n  }(sg || (sg = {})), function (e) {\n    e.High = \"high\", e.Low = \"low\", e.Audio = \"audio\", e.Screen = \"screen\", e.ScreenLow = \"screen_low\";\n  }(ag || (ag = {})), function (e) {\n    e.DISCONNECT = \"disconnect\", e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.NETWORK_QUALITY = \"network-quality\", e.STREAM_TYPE_CHANGE = \"stream-type-change\", e.IS_P2P_DISCONNECTED = \"is-p2p-dis\", e.DISCONNECT_P2P = \"dis-p2p\", e.REQUEST_NEW_GATEWAY_LIST = \"req-gate-url\", e.NEED_RENEW_SESSION = \"need-sid\", e.REQUEST_P2P_CONNECTION_PARAMS = \"request-p2p-connection-params\", e.JOIN_RESPONSE = \"join-response\", e.REQUEST_DC_CONNECTION_PARAMS = \"request-dc-connection-params\", e.RESET_CONNECTION_EVENTS = \"reset-connection-events\", e.DATACHANNEL_PRECONNECT = \"datachannel_preconnect\", e.DATACHANNEL_FAILBACK = \"datachannel_failback\";\n  }(cg || (cg = {})), function (e) {\n    e[e.Nothing = 0] = \"Nothing\", e[e.Audio = 1] = \"Audio\", e[e.LwoVideo = 2] = \"LwoVideo\", e[e.Video = 4] = \"Video\", e[e.Data = 8] = \"Data\";\n  }(dg || (dg = {})), function (e) {\n    e.NEED_RENEGOTIATE = \"@need_renegotiate\", e.NEED_REPLACE_TRACK = \"@need_replace_track\", e.NEED_CLOSE = \"@need_close\", e.NEED_ENABLE_TRACK = \"@need_enable_track\", e.NEED_DISABLE_TRACK = \"@need_disable_track\", e.NEED_SESSION_ID = \"@need_sid\", e.SET_OPTIMIZATION_MODE = \"@set_optimization_mode\", e.GET_STATS = \"@get_stats\", e.GET_LOW_VIDEO_TRACK = \"@get_low_video_track\", e.NEED_RESET_REMOTE_SDP = \"@need_reset_remote_sdp\", e.NEED_UPDATE_VIDEO_ENCODER = \"@need_update_video_encoder\", e.NEED_MUTE_TRACK = \"@need_mute_track\", e.NEED_UNMUTE_TRACK = \"@need_unmute_track\";\n  }(ug || (ug = {})), function (e) {\n    e.SCREEN_TRACK = \"screen_track\", e.LOW_STREAM = \"low_stream\";\n  }(lg || (lg = {})), function (e) {\n    e[e.HIGH_STREAM = 0] = \"HIGH_STREAM\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\";\n  }(hg || (hg = {})), function (e) {\n    e[e.DISABLE = 0] = \"DISABLE\", e[e.LOW_STREAM = 1] = \"LOW_STREAM\", e[e.AUDIO_ONLY = 2] = \"AUDIO_ONLY\";\n  }(pg || (pg = {})), function (e) {\n    e.SOURCE_STATE_CHANGE = \"source-state-change\", e.TRACK_ENDED = \"track-ended\", e.BEAUTY_EFFECT_OVERLOAD = \"beauty-effect-overload\", e.VIDEO_ELEMENT_VISIBLE_STATUS = \"video-element-visible-status\", e.CLOSED = \"closed\";\n  }(_g || (_g = {})), function (e) {\n    e.FIRST_FRAME_DECODED = \"first-frame-decoded\", e.VIDEO_ELEMENT_VISIBLE_STATUS = \"video-element-visible-status\";\n  }(Eg || (Eg = {})), function (e) {\n    e.CHINA = \"CHINA\", e.ASIA = \"ASIA\", e.NORTH_AMERICA = \"NORTH_AMERICA\", e.EUROPE = \"EUROPE\", e.JAPAN = \"JAPAN\", e.INDIA = \"INDIA\", e.KOREA = \"KOREA\", e.HKMC = \"HKMC\", e.US = \"US\", e.OCEANIA = \"OCEANIA\", e.SOUTH_AMERICA = \"SOUTH_AMERICA\", e.AFRICA = \"AFRICA\", e.OVERSEA = \"OVERSEA\", e.GLOBAL = \"GLOBAL\";\n  }(fg || (fg = {}));\n  const Sg = [fg.AFRICA, fg.ASIA, fg.CHINA, fg.EUROPE, fg.GLOBAL, fg.INDIA, fg.JAPAN, fg.NORTH_AMERICA, fg.OCEANIA, fg.OVERSEA, fg.SOUTH_AMERICA];\n  let Tg;\n  !function (e) {\n    e.CHINA = \"CN\", e.ASIA = \"AS\", e.NORTH_AMERICA = \"NA\", e.EUROPE = \"EU\", e.JAPAN = \"JP\", e.INDIA = \"IN\", e.KOREA = \"KR\", e.HKMC = \"HK\", e.US = \"US\", e.OCEANIA = \"OC\", e.SOUTH_AMERICA = \"SA\", e.AFRICA = \"AF\", e.OVERSEA = \"OVERSEA\", e.GLOBAL = \"GLOBAL\";\n  }(Tg || (Tg = {}));\n  const vg = {\n    CHINA: {},\n    ASIA: {\n      CODE: Tg.ASIA,\n      WEBCS_DOMAIN: [\"ap-web-1-asia.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-asia.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-asia.agora.io\"],\n      CDS_AP: [\"cds-ap-web-asia.agora.io\", \"cds-ap-web-asia2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-asia.agora.io\", \"sua-ap-web-asia2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-asia.agora.io\", \"uap-ap-web-asia2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-asia.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-asia.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-asia.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"southeast-asia.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    NORTH_AMERICA: {\n      CODE: Tg.NORTH_AMERICA,\n      WEBCS_DOMAIN: [\"ap-web-1-north-america.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-north-america.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-america.agora.io\"],\n      CDS_AP: [\"cds-ap-web-america.agora.io\", \"cds-ap-web-america2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-america.agora.io\", \"sua-ap-web-america2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-america.agora.io\", \"uap-ap-web-america2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-north-america.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-north-america.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-north-america.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"east-usa.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    EUROPE: {\n      CODE: Tg.EUROPE,\n      WEBCS_DOMAIN: [\"ap-web-1-europe.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-europe.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-europe.agora.io\"],\n      CDS_AP: [\"cds-ap-web-europe.agora.io\", \"cds-ap-web-europe2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-europe.agora.io\", \"sua-ap-web-europe.agora.io\"],\n      UAP_AP: [\"uap-ap-web-europe.agora.io\", \"uap-ap-web-europe2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-europe.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-europe.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-europe.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"europe.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    JAPAN: {\n      CODE: Tg.JAPAN,\n      WEBCS_DOMAIN: [\"ap-web-1-japan.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-japan.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-japan.agora.io\"],\n      CDS_AP: [\"cds-ap-web-japan.agora.io\", \"cds-ap-web-japan2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-japan.agora.io\", \"sua-ap-web-japan2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-japan.agora.io\", \"\\tuap-ap-web-japan2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-japan.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-japan.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-japan.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"japan.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    INDIA: {\n      CODE: Tg.INDIA,\n      WEBCS_DOMAIN: [\"ap-web-1-india.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-india.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-india.agora.io\"],\n      CDS_AP: [\"cds-ap-web-india.agora.io\", \"cds-ap-web-india2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-india.agora.io\", \"sua-ap-web-india2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-india.agora.io\", \"uap-ap-web-india2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-india.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-india.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-india.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"india.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    KOREA: {\n      CODE: Tg.KOREA,\n      WEBCS_DOMAIN: [\"ap-web-1-korea.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-korea.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-korea.agora.io\"],\n      CDS_AP: [\"cds-ap-web-korea.agora.io\", \"cds-ap-web-korea2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-korea.agora.io\", \"sua-ap-web-korea2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-korea.agora.io\", \"uap-ap-web-korea2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-korea.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-korea.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-korea.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"korea.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    HKMC: {\n      CODE: Tg.HKMC,\n      WEBCS_DOMAIN: [\"ap-web-1-hkmc.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-hkmc.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-hkmc.agora.io\"],\n      CDS_AP: [\"cds-ap-web-hkmc.agora.io\", \"cds-ap-web-hkmc2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-hkmc.agora.io\", \"sua-ap-web-hkmc2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-hkmc.agora.io\", \"uap-ap-web-hkmc2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-hkmc.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-hkmc.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-hkmc.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"hkmc.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    US: {\n      CODE: Tg.US,\n      WEBCS_DOMAIN: [\"ap-web-1-us.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-us.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-us.agora.io\"],\n      CDS_AP: [\"cds-ap-web-us.agora.io\", \"cds-ap-web-us2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-us.agora.io\", \"sua-ap-web-us2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-us.agora.io\", \"uap-ap-web-us2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-us.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-us.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-us.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"us.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    OVERSEA: {\n      CODE: Tg.OVERSEA,\n      WEBCS_DOMAIN: [\"ap-web-1-oversea.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oversea.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-oversea.agora.io\"],\n      CDS_AP: [\"cds-ap-web-oversea.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-oversea.agora.io\"],\n      UAP_AP: [\"uap-ap-web-oversea.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-oversea.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oversea.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-oversea.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.agora.io\"]\n    },\n    GLOBAL: {\n      CODE: Tg.GLOBAL,\n      WEBCS_DOMAIN: [\"webrtc2-ap-web-1.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-ap-web-3.agora.io\"],\n      PROXY_CS: [\"ap-proxy-1.agora.io\", \"ap-proxy-2.agora.io\"],\n      CDS_AP: [\"cds-ap-web-1.agora.io\", \"cds-ap-web-3.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-1.agora.io\", \"sua-ap-web-3.agora.io\"],\n      UAP_AP: [\"uap-ap-web-1.agora.io\", \"uap-ap-web-3.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    OCEANIA: {\n      CODE: Tg.OCEANIA,\n      WEBCS_DOMAIN: [\"ap-web-1-oceania.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-oceania.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-oceania.agora.io\"],\n      CDS_AP: [\"cds-ap-web-oceania.agora.io\", \"cds-ap-web-oceania2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-oceania.agora.io\", \"sua-ap-web-oceania2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-oceania.agora.io\", \"uap-ap-web-oceania2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-oceania.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-oceania.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-oceania.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"oceania.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    SOUTH_AMERICA: {\n      CODE: Tg.SOUTH_AMERICA,\n      WEBCS_DOMAIN: [\"ap-web-1-south-america.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-south-america.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-south-america.agora.io\"],\n      CDS_AP: [\"cds-ap-web-south-america.agora.io\", \"cds-ap-web-south-america2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-south-america.agora.io\", \"sua-ap-web-south-america2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-south-america.agora.io\", \"uap-ap-web-south-america2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-south-america.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-south-america.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-south-america.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"south-america.webrtc-cloud-proxy.sd-rtn.com\"]\n    },\n    AFRICA: {\n      CODE: Tg.AFRICA,\n      WEBCS_DOMAIN: [\"ap-web-1-africa.agora.io\"],\n      WEBCS_DOMAIN_BACKUP_LIST: [\"ap-web-2-africa.agora.io\"],\n      PROXY_CS: [\"proxy-ap-web-africa.agora.io\"],\n      CDS_AP: [\"cds-ap-web-africa.agora.io\", \"cds-ap-web-africa2.agora.io\"],\n      ACCOUNT_REGISTER: [\"sua-ap-web-africa.agora.io\", \"sua-ap-web-africa2.agora.io\"],\n      UAP_AP: [\"uap-ap-web-africa.agora.io\", \"uap-ap-web-africa2.agora.io\"],\n      EVENT_REPORT_DOMAIN: [\"statscollector-1-africa.agora.io\"],\n      EVENT_REPORT_BACKUP_DOMAIN: [\"statscollector-2-africa.agora.io\"],\n      LOG_UPLOAD_SERVER: [\"logservice-south-africa.agora.io\"],\n      PROXY_SERVER_TYPE3: [\"africa.webrtc-cloud-proxy.sd-rtn.com\"]\n    }\n  };\n  let Rg, Ig, yg, Cg, Ag, Og, bg, wg, Ng, Dg, Pg, Lg, kg, Mg, Ug;\n  LE && (vg.CHINA = {\n    CODE: Tg.CHINA,\n    WEBCS_DOMAIN: [\"webrtc2-2.ap.sd-rtn.com\"],\n    WEBCS_DOMAIN_BACKUP_LIST: [\"webrtc2-4.ap.sd-rtn.com\"],\n    PROXY_CS: [\"proxy-web.ap.sd-rtn.com\"],\n    CDS_AP: [\"cds-web-2.ap.sd-rtn.com\", \"cds-web-4.ap.sd-rtn.com\"],\n    ACCOUNT_REGISTER: [\"sua-web-2.ap.sd-rtn.com\", \"sua-web-4.ap.sd-rtn.com\"],\n    UAP_AP: [\"uap-web-2.ap.sd-rtn.com\", \"uap-web-4.ap.sd-rtn.com\"],\n    EVENT_REPORT_DOMAIN: [\"web-3.statscollector.sd-rtn.com\"],\n    EVENT_REPORT_BACKUP_DOMAIN: [\"web-4.statscollector.sd-rtn.com\"],\n    LOG_UPLOAD_SERVER: [\"logservice-china.agora.io\"],\n    PROXY_SERVER_TYPE3: [\"east-cn.webrtc-cloud-proxy.sd-rtn.com\"]\n  }), function (e) {\n    e.UPDATE_BITRATE_LIMIT = \"update_bitrate_limit\";\n  }(Rg || (Rg = {}));\n  class xg extends gE {\n    constructor(e, t) {\n      super(), mp(this, \"onICEConnectionStateChange\", void 0), mp(this, \"onConnectionStateChange\", void 0), mp(this, \"onDTLSTransportStateChange\", void 0), mp(this, \"onDTLSTransportError\", void 0), mp(this, \"onICETransportStateChange\", void 0), mp(this, \"onFirstAudioReceived\", void 0), mp(this, \"onFirstVideoReceived\", void 0), mp(this, \"onFirstAudioDecoded\", void 0), mp(this, \"onFirstVideoDecoded\", void 0), mp(this, \"onFirstVideoDecodedTimeout\", void 0), mp(this, \"onSelectedLocalCandidateChanged\", void 0), mp(this, \"onSelectedRemoteCandidateChanged\", void 0);\n    }\n  }\n  !function (e) {\n    e.SEND = \"sendonly\", e.RECV = \"recvonly\", e.SENDRECV = \"sendrecv\", e.INACTIVE = \"inactive\";\n  }(Ig || (Ig = {})), function (e) {\n    e.VIDEO = \"video\", e.AUDIO = \"audio\";\n  }(yg || (yg = {})), function (e) {\n    e.LocalVideoTrack = \"videoTrack\", e.LocalAudioTrack = \"audioTrack\", e.LocalVideoLowTrack = \"videoLowTrack\";\n  }(Cg || (Cg = {})), function (e) {\n    e.New = \"new\", e.Connected = \"connected\", e.Reconnecting = \"reconnecting\", e.Disconnected = \"disconnected\";\n  }(Ag || (Ag = {})), function (e) {\n    e.StateChange = \"stateChange\", e.IceConnectionStateChange = \"iceConnectionStateChange\", e.RequestMuteLocal = \"requestMuteLocal\", e.RequestUnmuteLocal = \"requestUnmuteLocal\", e.RequestRePublish = \"requestRePublish\", e.RequestReSubscribe = \"requestReSubscribe\", e.RequestUploadStats = \"requestUploadStats\", e.MediaReconnectStart = \"MediaReconnectStart\", e.MediaReconnectEnd = \"MediaReconnectEnd\", e.NeedSignalRTT = \"NeedSignalRTT\", e.RequestRestartICE = \"RequestRestartIce\", e.PeerConnectionStateChange = \"PeerConnectionStateChange\", e.RequestReconnect = \"RequestReconnect\", e.RequestReconnectPC = \"RequestReconnectPC\", e.RequestUnpublishForReconnectPC = \"RequestUnpublishForReconnectPC\", e.P2PLost = \"P2PLost\", e.UpdateVideoEncoder = \"UpdateVideoEncoder\", e.ConnectionTypeChange = \"ConnectionTypeChange\", e.RequestLowStreamParameter = \"RequestLowStreamParameter\", e.QueryClientConnectionState = \"QueryClientConnectionState\";\n  }(Og || (Og = {})), function (e) {\n    e.ONLINE = \"ONLINE\", e.OFFLINE = \"OFFLINE\";\n  }(bg || (bg = {})), function (e) {\n    e.NETWORK_STATE_CHANGE = \"NETWORK_STATE_CHANGE\", e.ONLINE = \"ONLINE\", e.OFFLINE = \"OFFLINE\";\n  }(wg || (wg = {})), function (e) {\n    e.ON_TRACK = \"on_track\", e.ON_NODE = \"on_node\";\n  }(Ng || (Ng = {})), function (e) {\n    e.REQUEST_UPDATE_CONSTRAINTS = \"request_update_constraints\", e.REQUEST_CONSTRAINTS = \"request_constraints\";\n  }(Dg || (Dg = {})), function (e) {\n    e.CONNECTING = \"CONNECTING\", e.RECONNECTING = \"RECONNECTING\", e.CONNECTED = \"CONNECTED\", e.CLOSED = \"CLOSED\";\n  }(Pg || (Pg = {})), function (e) {\n    e[e.CONNECT_AP = 0] = \"CONNECT_AP\", e[e.AP_CONNECTED = 1] = \"AP_CONNECTED\", e[e.CONNECT_WORKER_MANAGER = 2] = \"CONNECT_WORKER_MANAGER\", e[e.WORKER_MANAGER_CONNECTED = 3] = \"WORKER_MANAGER_CONNECTED\", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = \"GET_WORKER_MANAGER_RESPONSE\", e[e.CONNECT_WORKER = 5] = \"CONNECT_WORKER\", e[e.WORKER_CONNECTED = 6] = \"WORKER_CONNECTED\", e[e.CLOSED = 7] = \"CLOSED\";\n  }(Lg || (Lg = {})), function (e) {\n    e.CONNECTION_STATE_CHANGE = \"connection-state-change\", e.STATE_CHANGE = \"state-change\", e.INSPECT_RESULT = \"inspect-result\", e.CLIENT_LOCAL_VIDEO_TRACK = \"client-local-video-track\", e.REQUEST_NEW_WORKER_URL = \"request-new-worker-url\";\n  }(kg || (kg = {})), function (e) {\n    e.NETWORK_ERROR = \"NETWORK_ERROR\", e.SERVER_ERROR = \"SERVER_ERROR\", e.MULTI_IP = \"MULTI_IP\", e.TIMEOUT = \"TIMEOUT\", e.OFFLINE = \"OFFLINE\", e.LEAVE = \"LEAVE\", e.P2P_FAILED = \"P2P_FAILED\", e.FALLBACK = \"FALLBACK\";\n  }(Mg || (Mg = {})), function (e) {\n    e.CONNECTED = \"transmitter:connected\", e.RECONNECTING = \"transmitter:reconnecting\", e.WILL_RECONNECT = \"transmitter:will_reconnect\", e.CLOSED = \"transmitter:closed\", e.FAILED = \"transmitter:failed\", e.ON_MESSAGE = \"transmitter:on_message\", e.REQUEST_NEW_URLS = \"transmitter:request_new_urls\", e.RECONNECT_WAITTING_FINISH = \"transmitter:reconnect_waitting_finish\", e.RECONNECT_CREATE_CONNECTION = \"transmitter:reconnect_create_connection\", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = \"transmitter:on_token_privilege_did_expire\", e.TO_CONNECT_DATACHANNEL = \"transmitter:to_connect_datachannel\", e.FAILBACK = \"transmitter:failback\";\n  }(Ug || (Ug = {}));\n  const Vg = {\n    getDisplayMedia: !1,\n    getStreamFromExtension: !1,\n    supportUnifiedPlan: !1,\n    supportMinBitrate: !1,\n    supportSetRtpSenderParameters: !1,\n    supportDualStream: !0,\n    webAudioMediaStreamDest: !1,\n    supportReplaceTrack: !1,\n    supportWebGL: !1,\n    webAudioWithAEC: !1,\n    supportRequestFrame: !1,\n    supportShareAudio: !1,\n    supportDualStreamEncoding: !1,\n    supportDataChannel: !1\n  };\n  function jg() {\n    return Vg;\n  }\n  let Fg;\n  !function (e) {\n    e[e.CHOOSE_SERVER = 11] = \"CHOOSE_SERVER\", e[e.CLOUD_PROXY = 18] = \"CLOUD_PROXY\", e[e.CLOUD_PROXY_5 = 20] = \"CLOUD_PROXY_5\", e[e.CLOUD_PROXY_FALLBACK = 26] = \"CLOUD_PROXY_FALLBACK\";\n  }(Fg || (Fg = {}));\n  var Bg = k,\n    Gg = Array.isArray || function (e) {\n      return \"Array\" == Bg(e);\n    },\n    Wg = h,\n    Hg = Gg,\n    Kg = lc,\n    Yg = q,\n    qg = nt(\"species\"),\n    Jg = Wg.Array,\n    Xg = function (e) {\n      var t;\n      return Hg(e) && (t = e.constructor, (Kg(t) && (t === Jg || Hg(t.prototype)) || Yg(t) && null === (t = t[qg])) && (t = void 0)), void 0 === t ? Jg : t;\n    },\n    zg = function (e, t) {\n      return new (Xg(e))(0 === t ? 0 : t);\n    },\n    Qg = Wt,\n    Zg = F,\n    $g = je,\n    eS = wi,\n    tS = zg,\n    iS = d([].push),\n    rS = function (e) {\n      var t = 1 == e,\n        i = 2 == e,\n        r = 3 == e,\n        n = 4 == e,\n        o = 6 == e,\n        s = 7 == e,\n        a = 5 == e || o;\n      return function (c, d, u, l) {\n        for (var h, p, _ = $g(c), E = Zg(_), f = Qg(d, u), m = eS(E), g = 0, S = l || tS, T = t ? S(c, m) : i || s ? S(c, 0) : void 0; m > g; g++) if ((a || g in E) && (p = f(h = E[g], g, _), e)) if (t) T[g] = p;else if (p) switch (e) {\n          case 3:\n            return !0;\n          case 5:\n            return h;\n          case 6:\n            return g;\n          case 2:\n            iS(T, h);\n        } else switch (e) {\n          case 4:\n            return !1;\n          case 7:\n            iS(T, h);\n        }\n        return o ? -1 : r || n ? n : T;\n      };\n    },\n    nS = {\n      forEach: rS(0),\n      map: rS(1),\n      filter: rS(2),\n      some: rS(3),\n      every: rS(4),\n      find: rS(5),\n      findIndex: rS(6),\n      filterReject: rS(7)\n    },\n    oS = nS.forEach,\n    sS = Vi(\"forEach\") ? [].forEach : function (e) {\n      return oS(this, e, arguments.length > 1 ? arguments[1] : void 0);\n    };\n  Ri({\n    target: \"Array\",\n    proto: !0,\n    forced: [].forEach != sS\n  }, {\n    forEach: sS\n  });\n  var aS = Hi(\"Array\").forEach,\n    cS = $n,\n    dS = Ge,\n    uS = u,\n    lS = aS,\n    hS = Array.prototype,\n    pS = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    _S = function (e) {\n      var t = e.forEach;\n      return e === hS || uS(hS, e) && t === hS.forEach || dS(pS, cS(e)) ? lS : t;\n    },\n    ES = je,\n    fS = hn;\n  Ri({\n    target: \"Object\",\n    stat: !0,\n    forced: i(function () {\n      fS(1);\n    })\n  }, {\n    keys: function (e) {\n      return fS(ES(e));\n    }\n  });\n  var mS = J.Object.keys,\n    gS = Xi,\n    SS = Ri,\n    TS = Gg,\n    vS = d([].reverse),\n    RS = [1, 2];\n  SS({\n    target: \"Array\",\n    proto: !0,\n    forced: String(RS) === String(RS.reverse())\n  }, {\n    reverse: function () {\n      return TS(this) && (this.length = this.length), vS(this);\n    }\n  });\n  var IS = Hi(\"Array\").reverse,\n    yS = u,\n    CS = IS,\n    AS = Array.prototype,\n    OS = function (e) {\n      var t = e.reverse;\n      return e === AS || yS(AS, e) && t === AS.reverse ? CS : t;\n    },\n    bS = i,\n    wS = ae,\n    NS = nt(\"species\"),\n    DS = function (e) {\n      return wS >= 51 || !bS(function () {\n        var t = [];\n        return (t.constructor = {})[NS] = function () {\n          return {\n            foo: 1\n          };\n        }, 1 !== t[e](Boolean).foo;\n      });\n    },\n    PS = Ri,\n    LS = h,\n    kS = Gg,\n    MS = lc,\n    US = q,\n    xS = Mr,\n    VS = wi,\n    jS = K,\n    FS = nf,\n    BS = nt,\n    GS = Sc,\n    WS = DS(\"slice\"),\n    HS = BS(\"species\"),\n    KS = LS.Array,\n    YS = Math.max;\n  PS({\n    target: \"Array\",\n    proto: !0,\n    forced: !WS\n  }, {\n    slice: function (e, t) {\n      var i,\n        r,\n        n,\n        o = jS(this),\n        s = VS(o),\n        a = xS(e, s),\n        c = xS(void 0 === t ? s : t, s);\n      if (kS(o) && (i = o.constructor, (MS(i) && (i === KS || kS(i.prototype)) || US(i) && null === (i = i[HS])) && (i = void 0), i === KS || void 0 === i)) return GS(o, a, c);\n      for (r = new (void 0 === i ? KS : i)(YS(c - a, 0)), n = 0; a < c; a++, n++) a in o && FS(r, n, o[a]);\n      return r.length = n, r;\n    }\n  });\n  var qS = Hi(\"Array\").slice,\n    JS = u,\n    XS = qS,\n    zS = Array.prototype,\n    QS = function (e) {\n      var t = e.slice;\n      return e === zS || JS(zS, e) && t === zS.slice ? XS : t;\n    };\n  function ZS(e, t, i, r, n) {\n    var o,\n      s,\n      a,\n      c = {};\n    return _S(o = mS(r)).call(o, function (e) {\n      c[e] = r[e];\n    }), c.enumerable = !!c.enumerable, c.configurable = !!c.configurable, (\"value\" in c || c.initializer) && (c.writable = !0), c = gS(s = OS(a = QS(i).call(i)).call(a)).call(s, function (i, r) {\n      return r(e, t, i) || i;\n    }, c), n && void 0 !== c.initializer && (c.value = c.initializer ? c.initializer.call(n) : void 0, c.initializer = void 0), void 0 === c.initializer && (fp(e, t, c), c = null), c;\n  }\n  var $S = Hi(\"Array\").keys,\n    eT = $n,\n    tT = Ge,\n    iT = u,\n    rT = $S,\n    nT = Array.prototype,\n    oT = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    sT = function (e) {\n      var t = e.keys;\n      return e === nT || iT(nT, e) && t === nT.keys || tT(oT, eT(e)) ? rT : t;\n    };\n  function aT(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function cT(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? aT(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : aT(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let dT = 0,\n    uT = 0;\n  function lT(e, t, i, r) {\n    return new Cl((n, o) => {\n      t.timeout = t.timeout || HE(\"HTTP_CONNECT_TIMEOUT\"), t.responseType = t.responseType || \"json\", t.data && !i ? (t.data = JSON.stringify(t.data), dT += PR(t.data)) : i && (t.data.size ? dT += t.data.size : t.data instanceof FormData ? dT += function (e) {\n        let t = 0;\n        /DingTalk/i.test(navigator.userAgent) && e.realFormData && (e = e.realFormData);\n        return e.forEach(e => {\n          t += \"string\" == typeof e ? PR(e) : e.size;\n        }), t + 138;\n      }(t.data) : dT += PR(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers[\"Content-Type\"] = t.headers[\"Content-Type\"] || \"application/json\", t.method = \"POST\", t.url = e, fE.request(t).then(e => {\n        \"string\" == typeof e.data ? uT += PR(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? uT += e.data.byteLength : uT += PR(JSON.stringify(e.data)), r && n({\n          data: e.data,\n          headers: e.headers\n        }), n(e.data);\n      }).catch(e => {\n        fE.isCancel(e) ? o(new vE(TE.OPERATION_ABORTED, \"cancel token canceled\")) : \"ECONNABORTED\" === e.code ? o(new vE(TE.NETWORK_TIMEOUT, e.message)) : e.response ? o(new vE(TE.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new vE(TE.NETWORK_ERROR, e.message));\n      });\n    });\n  }\n  async function hT(e, t) {\n    const i = new Blob([t.data], {\n      type: \"buffer\"\n    });\n    return await lT(e, cT(cT({}, t), {}, {\n      data: i,\n      headers: {\n        \"Content-Type\": \"application/octet-stream\"\n      }\n    }), !0);\n  }\n  const pT = new class extends gE {\n    set networkState(e) {\n      NE.info(\"[\".concat(this._moduleName, \"]\") + \"network state changed, \" + this._networkState + \" -> \" + e), this.emit(wg.NETWORK_STATE_CHANGE, e, this._networkState), e === bg.ONLINE ? this.emit(wg.ONLINE) : e === bg.OFFLINE && (this.onlineWaiter = new Cl(e => {\n        this.once(wg.ONLINE, () => {\n          this.onlineWaiter = void 0, e(bg.ONLINE);\n        });\n      }), this.emit(wg.OFFLINE)), this._networkState = e;\n    }\n    get networkState() {\n      return this._networkState;\n    }\n    constructor() {\n      super(), mp(this, \"_moduleName\", \"network-indicator\"), mp(this, \"_networkState\", bg.ONLINE), mp(this, \"onlineWaiter\", void 0), window.addEventListener(\"online\", () => {\n        this.networkState = bg.ONLINE;\n      }), window.addEventListener(\"offline\", () => {\n        this.networkState = bg.OFFLINE;\n      });\n    }\n  }();\n  let _T = !1;\n  const ET = new class extends gE {\n    constructor() {\n      super(...arguments), mp(this, \"onAutoplayFailed\", void 0), mp(this, \"onAudioAutoplayFailed\", void 0);\n    }\n  }();\n  function fT() {\n    if (Bh(), !_T) {\n      const e = t => {\n        t.preventDefault(), _T = !1, dp() ? document.body.removeEventListener(\"click\", e, !0) : (document.body.removeEventListener(\"touchstart\", e, !0), document.body.removeEventListener(\"mousedown\", e, !0));\n      };\n      _T = !0, dp() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0)), NE.info(\"detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web\"), ET.onAutoplayFailed ? ET.onAutoplayFailed() : ET.onAudioAutoplayFailed ? NE.warning(\"AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\\n\\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .\") : NE.warning(\"We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\\n\\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\\n\\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .\"), ET.emit(\"autoplay-failed\");\n    }\n  }\n  function mT(e) {\n    return new TextEncoder().encode(e);\n  }\n  const gT = function (e, t) {\n    const i = new Uint8Array(e.byteLength + t.byteLength);\n    return i.set(new Uint8Array(e), 0), i.set(new Uint8Array(t), e.byteLength), i;\n  };\n  const ST = async e => function (e, t) {\n    let i = \"\";\n    return new Uint8Array(e).forEach(e => {\n      i += e.toString(t).padStart(2, \"0\");\n    }), i;\n  }(await crypto.subtle.digest(\"SHA-256\", mT(e)), 16);\n  function TT(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function vT(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? TT(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : TT(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function RT() {\n    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n    return function (t, i, r) {\n      const n = r.value;\n      if (\"function\" == typeof n) {\n        const o = e.className || t.__className__ || (\"AgoraRTCClient\" === t.constructor.name ? \"Client\" : t.constructor.name);\n        r.value = function () {\n          for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++) r[s] = arguments[s];\n          let a = r;\n          if (e.argsMap) try {\n            a = e.argsMap(this, ...r);\n          } catch (e) {\n            NE.warning(e), a = [];\n          }\n          try {\n            JSON.stringify(a);\n          } catch (e) {\n            NE.warning(\"arguments for method \".concat(o, \".\").concat(i, \" not serializable for apiInvoke.\")), a = [];\n          }\n          const c = (e.report || IT).reportApiInvoke(this._sessionId || null, {\n            name: \"\".concat(o, \".\").concat(i),\n            options: a,\n            tag: fm.TRACER,\n            reportResult: e.reportResult\n          }, e.throttleTime);\n          try {\n            const t = n.apply(this, r);\n            return t instanceof Cl ? t.then(t => (c.onSuccess(e.reportResult && t), t)).catch(e => {\n              throw c.onError(e), e;\n            }) : (c.onSuccess(e.reportResult && t), t);\n          } catch (e) {\n            throw c.onError(e), e;\n          }\n        };\n      }\n      return r;\n    };\n  }\n  const IT = new class {\n    constructor() {\n      mp(this, \"baseInfoMap\", new Map()), mp(this, \"proxyServer\", void 0), mp(this, \"clientList\", ZE), mp(this, \"eventUploadTimer\", void 0), mp(this, \"setSessionIdTimer\", void 0), mp(this, \"url\", void 0), mp(this, \"backupUrl\", void 0), mp(this, \"_appId\", void 0), mp(this, \"keyEventUploadPendingItems\", []), mp(this, \"normalEventUploadPendingItems\", []), mp(this, \"apiInvokeUploadPendingItems\", []), mp(this, \"apiInvokeCount\", 0), mp(this, \"ltsList\", []), mp(this, \"lastSendNormalEventTime\", Date.now()), mp(this, \"customReportCounterTimer\", void 0), mp(this, \"customReportCount\", 0), mp(this, \"extApiInvoke\", async e => {\n        for (const t of e) {\n          const e = vT(vT({}, t), {}, {\n            sid: null,\n            invokeId: ++this.apiInvokeCount,\n            tag: fm.TRACER\n          });\n          this.sendApiInvoke(e);\n        }\n      }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), HE(\"EVENT_REPORT_SEND_INTERVAL\")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), HE(\"EVENT_REPORT_SEND_INTERVAL\"));\n    }\n    adjustSessionStartTime(e) {\n      if (!this.baseInfoMap.has(e) && !this.baseInfoMap.get(e)) return void NE.error(\"adjust session \".concat(e, \" start time, sid is not exist or info is undefined\"));\n      const t = this.baseInfoMap.get(e),\n        i = Date.now(),\n        r = t.startTime;\n      t.startTime = i, NE.debug(\"rewrite session \".concat(e, \" startTime: \").concat(i, \" , \").concat(i - r, \"ms\")), this.baseInfoMap.set(e, t);\n    }\n    setAppId(e) {\n      this._appId = e;\n    }\n    reportApiInvoke(e, t, i) {\n      t.timeout = t.timeout || 6e4, t.reportResult = void 0 === t.reportResult || t.reportResult;\n      const r = Date.now();\n      this.apiInvokeCount += 1;\n      const n = this.apiInvokeCount,\n        o = () => ({\n          tag: t.tag,\n          invokeId: n,\n          sid: e,\n          name: t.name,\n          apiInvokeTime: r,\n          options: t.options,\n          states: t.states || null\n        }),\n        s = !!HE(\"SHOW_REPORT_INVOKER_LOG\");\n      s && NE.info(\"\".concat(t.name, \" start\"), t.options);\n      let a = !1;\n      LR(t.timeout).then(() => {\n        a || (this.sendApiInvoke(vT(vT({}, o()), {}, {\n          error: TE.API_INVOKE_TIMEOUT,\n          success: !1\n        })), NE.debug(\"\".concat(t.name, \" timeout\")));\n      });\n      const c = new vE(TE.UNEXPECTED_ERROR, \"\".concat(t.name, \": this api invoke is end\"));\n      return {\n        onSuccess: e => {\n          const r = () => {\n            if (a) throw c;\n            return a = !0, this.sendApiInvoke(vT(vT({}, o()), {}, {\n              success: !0\n            }, t.reportResult && {\n              result: e\n            })), s && NE.info(\"\".concat(t.name, \" onSuccess\")), e;\n          };\n          return i ? $R(r, t.name + \"Success\", i, () => a = !0) : r();\n        },\n        onError: e => {\n          const r = () => {\n            if (a) throw e;\n            a = !0, this.sendApiInvoke(vT(vT({}, o()), {}, {\n              success: !1,\n              error: e\n            })), s && NE.info(\"\".concat(t.name, \" onFailure\"), e.toString());\n          };\n          return i ? $R(r, t.name + \"Error\", i, () => a = !0) : r();\n        }\n      };\n    }\n    sessionInit(e, t) {\n      if (this.baseInfoMap.has(e)) return;\n      const i = Date.now(),\n        r = this.createBaseInfo(e, i);\n      r.cname = t.cname;\n      const n = Object.assign({}, {\n          willUploadConsoleLog: HE(\"UPLOAD_LOG\"),\n          maxTouchPoints: navigator.maxTouchPoints,\n          areaVersion: LE ? \"global\" : \"oversea\",\n          areas: HE(\"AREAS\") && HE(\"AREAS\").join(\",\")\n        }, t.extend),\n        o = Date.now(),\n        s = vT(vT({}, r), {}, {\n          eventType: lm.SESSION_INIT,\n          appid: t.appid,\n          browser: navigator.userAgent,\n          build: DE,\n          lts: o,\n          elapse: o - i,\n          extend: JSON.stringify(n),\n          mode: t.mode,\n          process: HE(\"PROCESS_ID\"),\n          appType: HE(\"APP_TYPE\"),\n          success: !0,\n          version: PE\n        });\n      this.send({\n        type: hm.SESSION,\n        data: s\n      }, !0);\n    }\n    joinChooseServer(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          eventType: lm.JOIN_CHOOSE_SERVER,\n          lts: n,\n          eventElapse: n - t.lts,\n          chooseServerAddr: t.csAddr,\n          errorCode: t.ec,\n          elapse: n - i.startTime,\n          success: t.succ,\n          chooseServerAddrList: JSON.stringify(t.serverList),\n          uid: t.uid ? parseInt(t.uid) : null,\n          cid: t.cid ? parseInt(t.cid) : null,\n          chooseServerIp: t.csIp || \"\",\n          opid: t.opid,\n          unilbsServerIds: t.unilbsServerIds,\n          extend: t.extend || void 0,\n          isHttp3: t.isHttp3\n        });\n      this.send({\n        type: hm.JOIN_CHOOSE_SERVER,\n        data: o\n      }, !0);\n    }\n    reqUserAccount(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          eventType: lm.REQ_USER_ACCOUNT,\n          lts: n,\n          success: t.success,\n          serverAddress: t.serverAddr,\n          stringUid: t.stringUid,\n          uid: t.uid,\n          errorCode: t.errorCode,\n          elapse: n - i.startTime,\n          eventElapse: n - t.lts,\n          extend: JSON.stringify(t.extend)\n        });\n      this.send({\n        type: hm.REQ_USER_ACCOUNT,\n        data: o\n      }, !0);\n    }\n    joinGateway(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info;\n      t.vid && (r.vid = t.vid), r.uid = t.uid, r.cid = t.cid;\n      const n = Date.now(),\n        {\n          firstSuccess: o,\n          avoidJoinStartTime: s,\n          isProxy: a,\n          addr: c\n        } = t,\n        d = n - (o && s ? s : i.startTime),\n        u = vT(vT({}, r), {}, {\n          eventType: lm.JOIN_GATEWAY,\n          lts: n,\n          gatewayAddr: t.addr,\n          success: t.succ,\n          errorCode: t.ec,\n          elapse: d,\n          eventElapse: n - t.lts,\n          firstSuccess: o,\n          signalChannel: t.signalChannel\n        }),\n        l = u.success ? 1 : 0;\n      if (t.succ && (i.lastJoinSuccessTime = n), o) this.send({\n        type: hm.JOIN_GATEWAY,\n        data: u\n      }, !0);else {\n        let e;\n        if (c) {\n          if (a) {\n            const t = c.match(/h=(\\d{1,3}-){3}\\d{1,3}/g),\n              i = c.match(/p=[0-9]{1,6}/g);\n            e = {\n              isSuccess: l,\n              gatewayIp: t && t.length ? t[0].split(\"=\")[1].replace(/-/g, \".\") : \"\",\n              port: i && i.length ? i[0].split(\"=\")[1] : \"\",\n              isProxy: a ? 1 : 0\n            };\n          } else {\n            const t = c.match(/wss:\\/\\/(\\d{1,3}-){3}\\d{1,3}/g),\n              i = c.match(/:[0-9]{1,6}/g);\n            e = {\n              isSuccess: l,\n              gatewayIp: t && t.length ? t[0].split(\"//\")[1].replace(/-/g, \".\") : \"\",\n              port: i && i.length ? i[0].split(\":\")[1] : \"\",\n              isProxy: a ? 1 : 0\n            };\n          }\n        } else e = {\n          isSuccess: l,\n          gatewayIp: \"\",\n          port: \"\",\n          isProxy: a ? 1 : 0\n        };\n        delete u.success, delete u.eventType, delete u.firstSuccess, u.vid = Number(u.vid);\n        const t = Object.assign({}, u, e, {\n          eventType: lm.REJOIN_GATEWAY\n        });\n        this.send({\n          type: hm.RE_JOIN_GATEWAY,\n          data: t\n        }, !0);\n      }\n    }\n    joinChannelTimeout(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = Date.now(),\n        n = vT(vT({}, i.info), {}, {\n          lts: r,\n          timeout: t,\n          elapse: r - i.startTime\n        });\n      this.send({\n        type: hm.JOIN_CHANNEL_TIMEOUT,\n        data: n\n      }, !0);\n    }\n    publish(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          eventType: lm.PUBLISH,\n          lts: n,\n          eventElapse: t.eventElapse,\n          elapse: n - i.startTime,\n          success: t.succ,\n          errorCode: t.ec,\n          videoName: t.videoName,\n          audioName: t.audioName,\n          screenName: t.screenName,\n          screenshare: t.screenshare,\n          audio: t.audio,\n          video: t.video,\n          p2pid: t.p2pid,\n          publishRequestid: t.publishRequestid\n        });\n      this.send({\n        type: hm.PUBLISH,\n        data: o\n      }, !0);\n    }\n    subscribe(e, t, i) {\n      const r = this.baseInfoMap.get(e);\n      if (!r) return;\n      const n = r.info,\n        o = Date.now(),\n        s = vT(vT({}, n), {}, {\n          eventType: lm.SUBSCRIBE,\n          lts: o,\n          eventElapse: t.eventElapse,\n          elapse: o - r.startTime,\n          success: t.succ,\n          errorCode: t.ec,\n          video: t.video,\n          audio: t.audio,\n          subscribeRequestid: t.subscribeRequestid,\n          p2pid: t.p2pid\n        }, i && {\n          extend: JSON.stringify({\n            isMassSubscribe: !0\n          })\n        });\n      \"string\" == typeof t.peerid ? s.peerSuid = t.peerid : s.peer = t.peerid, this.send({\n        type: hm.SUBSCRIBE,\n        data: s\n      }, !0);\n    }\n    wsCompressorInit(e) {\n      var t;\n      const i = [...sT(t = this.baseInfoMap).call(t)],\n        r = i.length ? i[0] : \"UnableToGetSid\",\n        n = this.baseInfoMap.get(r);\n      if (!n) return;\n      const o = n.info,\n        s = Date.now(),\n        a = vT(vT({}, o), {}, {\n          eventType: lm.WS_COMPRESSOR_INIT,\n          lts: s,\n          eventElapse: e.eventElapse,\n          elapse: s - n.startTime,\n          status: e.status ? 1 : 2\n        });\n      this.send({\n        type: hm.WS_COMPRESSOR_INIT,\n        data: a\n      }, !0);\n    }\n    firstRemoteVideoDecode(e, t, i, r) {\n      const n = this.baseInfoMap.get(e);\n      if (!n) return;\n      const o = n.info,\n        s = Date.now(),\n        a = vT(vT(vT({}, o), r), {}, {\n          elapse: s - n.startTime,\n          eventType: t,\n          lts: s,\n          firstDecodeFrame: Math.max(s - n.startTime, 0),\n          apEnd: Math.max(r.apEnd - n.startTime, 0),\n          apStart: Math.max(r.apStart - n.startTime, 0),\n          joinGwEnd: Math.max(r.joinGwEnd - n.startTime, 0),\n          joinGwStart: Math.max(r.joinGwStart - n.startTime, 0),\n          pcEnd: Math.max(r.pcEnd - n.startTime, 0),\n          pcStart: Math.max(r.pcStart - n.startTime, 0),\n          subscriberEnd: Math.max(r.subscriberEnd - n.startTime, 0),\n          subscriberStart: Math.max(r.subscriberStart - n.startTime, 0),\n          videoAddNotify: Math.max(r.videoAddNotify - n.startTime, 0)\n        });\n      this.send({\n        type: i,\n        data: a\n      }, !0);\n    }\n    firstRemoteFrame(e, t, i, r) {\n      const n = this.baseInfoMap.get(e);\n      if (!n) return;\n      const o = n.info,\n        s = Date.now(),\n        a = vT(vT(vT({}, o), r), {}, {\n          elapse: s - n.startTime,\n          eventType: t,\n          lts: s\n        });\n      this.send({\n        type: i,\n        data: a\n      }, !0);\n    }\n    onGatewayStream(e, t, i, r) {\n      const n = this.baseInfoMap.get(e);\n      if (!n) return;\n      const o = n.info,\n        s = Date.now(),\n        a = vT(vT(vT({}, o), r), {}, {\n          eventType: t,\n          lts: s\n        });\n      this.send({\n        type: i,\n        data: a\n      }, !0);\n    }\n    streamSwitch(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          eventType: lm.STREAM_SWITCH,\n          lts: n,\n          isDual: t.isdual,\n          elapse: n - i.startTime,\n          success: t.succ\n        });\n      this.send({\n        type: hm.STREAM_SWITCH,\n        data: o\n      }, !0);\n    }\n    requestProxyAppCenter(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          eventType: lm.REQUEST_PROXY_APPCENTER,\n          lts: n,\n          eventElapse: n - t.lts,\n          elapse: n - i.startTime,\n          APAddr: t.APAddr,\n          workerManagerList: t.workerManagerList,\n          response: t.response,\n          errorCode: t.ec,\n          success: t.succ\n        });\n      this.send({\n        type: hm.REQUEST_PROXY_APPCENTER,\n        data: o\n      }, !0);\n    }\n    requestProxyWorkerManager(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          eventType: lm.REQUEST_PROXY_WORKER_MANAGER,\n          lts: n,\n          eventElapse: n - t.lts,\n          elapse: n - i.startTime,\n          workerManagerAddr: t.workerManagerAddr,\n          response: t.response,\n          errorCode: t.ec,\n          success: t.succ\n        });\n      this.send({\n        type: hm.REQUEST_PROXY_WORKER_MANAGER,\n        data: o\n      }, !0);\n    }\n    setProxyServer(e) {\n      this.proxyServer = e, e ? NE.debug(\"reportProxyServerurl: \".concat(e)) : NE.debug(\"disable reportProxyServerurl: \".concat(e));\n    }\n    peerPublishStatus(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT({}, r), {}, {\n          subscribeElapse: t.subscribeElapse,\n          peer: t.peer,\n          peerPublishDuration: Math.max(t.audioPublishDuration, t.videoPublishDuration),\n          audiotag: t.audioPublishDuration > 0 ? 1 : -1,\n          videotag: t.videoPublishDuration > 0 ? 1 : -1,\n          lts: n,\n          elapse: n - i.startTime,\n          joinChannelSuccessElapse: n - (i.lastJoinSuccessTime || n),\n          peerPublishDurationVideo: t.videoPublishDuration,\n          peerPublishDurationAudio: t.audioPublishDuration\n        });\n      this.send({\n        type: hm.PEER_PUBLISH_STATUS,\n        data: o\n      }, !0);\n    }\n    workerEvent(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now();\n      (function (e, t, i) {\n        const r = e[t];\n        if (!r || \"string\" != typeof r) return [e];\n        e[t] = \"\";\n        const n = PR(JSON.stringify(e));\n        let o = 0;\n        const s = [];\n        let a = 0;\n        for (let c = 0; c < r.length; c++) a += r.charCodeAt(c) <= 127 ? 1 : 3, a <= i - n || (s[s.length] = DR(DR({}, e), {}, {\n          [t]: r.substring(o, c)\n        }), o = c, a = r.charCodeAt(c) <= 127 ? 1 : 3);\n        o !== r.length - 1 && (s[s.length] = DR(DR({}, e), {}, {\n          [t]: r.substring(o)\n        }));\n        return s;\n      })(vT(vT(vT({}, r), t), {}, {\n        elapse: n - i.startTime,\n        lts: n,\n        productType: \"WebRTC\"\n      }), \"payload\", 1300).forEach(e => this.send({\n        type: hm.WORKER_EVENT,\n        data: e\n      }, !0));\n    }\n    apworkerEvent(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT(vT({}, r), t), {}, {\n          elapse: n - i.startTime,\n          lts: n\n        });\n      this.send({\n        type: hm.AP_WORKER_EVENT,\n        data: o\n      }, !0);\n    }\n    joinWebProxyAP(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT(vT({}, r), t), {}, {\n          elapse: n - i.startTime,\n          lts: n,\n          extend: t.extend || void 0\n        });\n      this.send({\n        type: hm.JOIN_WEB_PROXY_AP,\n        data: o\n      }, !0);\n    }\n    WebSocketQuit(e, t) {\n      const i = this.baseInfoMap.get(e);\n      if (!i) return;\n      const r = i.info,\n        n = Date.now(),\n        o = vT(vT(vT({}, r), t), {}, {\n          elapse: n - i.startTime,\n          lts: n\n        });\n      this.send({\n        type: hm.WEBSOCKET_QUIT,\n        data: o\n      }, !0);\n    }\n    async sendCustomReportMessage(e, t) {\n      if (this.customReportCount += t.length, this.customReportCount > HE(\"CUSTOM_REPORT_LIMIT\")) throw new vE(TE.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);\n      this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {\n        this.customReportCount = 0;\n      }, 5e3));\n      const i = t.map(t => ({\n        type: hm.USER_ANALYTICS,\n        data: vT({\n          sid: e\n        }, t)\n      }));\n      try {\n        HE(\"NEW_REPORT_SERVER\") ? await this.postDataToStatsCollector2(i) : await this.postDataToStatsCollector(i);\n      } catch (e) {\n        throw NE.error(\"send custom report message failed\", e.toString()), new vE(TE.CUSTOM_REPORT_SEND_FAILED, e.message);\n      }\n    }\n    autoplayFailed(e, t, i, r) {\n      if (!e) return;\n      const n = this.baseInfoMap.get(e);\n      if (!n) return;\n      const o = n.info,\n        s = Date.now(),\n        a = vT(vT({}, o), {}, {\n          vid: void 0 === o.vid ? 0 : Number(o.vid),\n          lts: s,\n          elapse: s - n.startTime,\n          cbRegistered: ET.onAutoplayFailed || ET.onAudioAutoplayFailed ? 1 : -1,\n          errorMsg: i,\n          mediaType: t,\n          trackId: r,\n          extend: void 0\n        });\n      this.send({\n        type: hm.AUTOPLAY_FAILED,\n        data: a\n      }, !0);\n    }\n    sendApiInvoke(e) {\n      const t = HE(\"NOT_REPORT_EVENT\");\n      if (e.tag && t.includes && t.includes(e.tag)) return !1;\n      if (null === e.sid) return this.apiInvokeUploadPendingItems.push(e), !1;\n      const i = this.baseInfoMap.get(e.sid);\n      if (!i) return this.apiInvokeUploadPendingItems.push(e), !1;\n      const {\n        cname: r,\n        uid: n,\n        cid: o\n      } = i.info;\n      e.lts = e.lts || Date.now();\n      let s = void 0;\n      if (e.error) if (e.error instanceof vE) {\n        const {\n          code: t,\n          message: i\n        } = e.error;\n        s = t || i || e.error.toString();\n      } else s = e.error.toString();\n      const a = {\n        invokeId: e.invokeId,\n        sid: e.sid,\n        cname: r,\n        cid: o,\n        uid: n,\n        lts: e.lts,\n        success: e.success,\n        elapse: e.lts - i.startTime,\n        execElapse: e.lts - e.apiInvokeTime,\n        apiName: e.name,\n        options: e.options ? JSON.stringify(e.options) : void 0,\n        execStates: e.states ? JSON.stringify(e.states) : void 0,\n        execResult: e.result ? JSON.stringify(e.result) : void 0,\n        errorCode: e.error ? s : void 0,\n        errorMsg: e.error ? JSON.stringify(e.error) : void 0\n      };\n      return this.send({\n        type: hm.API_INVOKE,\n        data: a\n      }, !1), !0;\n    }\n    appendSessionId() {\n      this.clientList.forEach(e => {\n        if (e._sessionId) {\n          const t = this.apiInvokeUploadPendingItems.length;\n          for (let i = 0; i < t; i++) {\n            const t = this.apiInvokeUploadPendingItems.shift();\n            t && (t.sid = e._sessionId, this.sendApiInvoke(Object.assign({}, t)));\n          }\n        }\n      });\n    }\n    send(e, t) {\n      if (t) return this.keyEventUploadPendingItems.push(e), void this.sendItems(this.keyEventUploadPendingItems, !0);\n      this.normalEventUploadPendingItems.push(e), this.normalEventUploadPendingItems.length > HE(\"NORMAL_EVENT_QUEUE_CAPACITY\") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, !1);\n    }\n    doSend() {\n      this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, !0), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, !1);\n    }\n    sendItems(e, t) {\n      const i = [],\n        r = [];\n      for (; e.length;) {\n        const t = e.shift();\n        i.length < 20 ? i.push(t) : r.push(t);\n      }\n      e.push(...r);\n      for (const e of [...i]) {\n        var n;\n        if (-1 !== this.ltsList.indexOf(e.data.lts)) e.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e.data.lts);else this.ltsList.push(e.data.lts), Yf(n = this.ltsList).call(n, (e, t) => e - t);\n      }\n      t || (this.lastSendNormalEventTime = Date.now());\n      return HE(\"ENABLE_EVENT_REPORT\") ? (i.length && (HE(\"NEW_REPORT_SERVER\") ? this.postDataToStatsCollector2(i) : this.postDataToStatsCollector(i)).catch((e => i => {\n        HE(\"EVENT_REPORT_RETRY\") && (t ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e), this.normalEventUploadPendingItems.length > HE(\"NORMAL_EVENT_QUEUE_CAPACITY\") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - HE(\"NORMAL_EVENT_QUEUE_CAPACITY\")), NE.warning(\"report: drop normal events\"))));\n      })(i)), e) : e;\n    }\n    async postDataToStatsCollector2(e) {\n      pT.networkState === bg.OFFLINE && (await Cl.race([pT.onlineWaiter, LR(2 * RE.maxRetryTimeout)]));\n      const t = e => {\n          let t = new Uint8Array();\n          return e.forEach(e => {\n            const i = mT(JSON.stringify(e.data)),\n              r = new ArrayBuffer(5),\n              n = (e => {\n                let t = 0;\n                return Object.entries(hm).forEach(i => {\n                  let [r, n] = i;\n                  n === e.type && (t = _m[r]);\n                }), t;\n              })(e),\n              o = new DataView(r);\n            o.setUint16(0, i.byteLength, !0), o.setUint8(2, 255 & n), o.setUint8(3, n >>> 8 & 255), o.setUint8(4, n >>> 16 & 255), t = gT(t, new Uint8Array(r)), t = gT(t, i);\n          }), t;\n        },\n        i = \"event\";\n      let r = this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(HE(\"NEW_REPORT_SERVER_DOMAINS\")[0], \"&p=443&d=\").concat(i) : \"https://\".concat(HE(\"NEW_REPORT_SERVER_DOMAINS\")[0], \"/\").concat(i);\n      for (let n = 0; n < 2; n += 1) {\n        1 === n && (r = this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(HE(\"NEW_REPORT_SERVER_DOMAINS\")[1], \"&p=443&d=\").concat(i) : \"https://\".concat(HE(\"NEW_REPORT_SERVER_DOMAINS\")[1], \"/\").concat(i));\n        try {\n          await lT(r, {\n            timeout: 1e4,\n            data: t(e),\n            headers: vT(vT({\n              token: \"32f24ab2ddb74f508aa9286c356cec84\",\n              biz: \"webrtc\",\n              sendts: Math.round(Date.now() / 1e3),\n              debug: \"false\"\n            }, this._appId && {\n              appid: this._appId\n            }), {}, {\n              \"Content-Type\": \"application/octet-stream\"\n            })\n          }, !0);\n        } catch (e) {\n          if (1 === n) throw e;\n          continue;\n        }\n        return;\n      }\n    }\n    async postDataToStatsCollector(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      const i = {\n        msgType: \"EventMessages\",\n        sentTs: Math.round(Date.now() / 1e3),\n        payloads: e.map(e => JSON.stringify(e)),\n        vid: (e => {\n          const t = e && e.data.sid && this.baseInfoMap.get(e.data.sid);\n          return t && t.info.vid && +t.info.vid || 0;\n        })(e[0])\n      };\n      pT.networkState === bg.OFFLINE && (await Cl.race([pT.onlineWaiter, LR(2 * RE.maxRetryTimeout)]));\n      const r = t ? \"/events/proto-raws\" : \"/events/messages\";\n      let n = this.url || (this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(HE(\"EVENT_REPORT_DOMAIN\"), \"&p=\").concat(HE(\"STATS_COLLECTOR_PORT\"), \"&d=\").concat(r) : \"https://\".concat(HE(\"EVENT_REPORT_DOMAIN\"), \":\").concat(HE(\"STATS_COLLECTOR_PORT\")).concat(r));\n      for (let e = 0; e < 2; e += 1) {\n        1 === e && (n = this.backupUrl || (this.proxyServer ? \"https://\".concat(this.proxyServer, \"/rs/?h=\").concat(HE(\"EVENT_REPORT_BACKUP_DOMAIN\"), \"&p=\").concat(HE(\"STATS_COLLECTOR_PORT\"), \"&d=\").concat(r) : \"https://\".concat(HE(\"EVENT_REPORT_BACKUP_DOMAIN\"), \":\").concat(HE(\"STATS_COLLECTOR_PORT\")).concat(r)));\n        try {\n          t ? await hT(n, {\n            timeout: 1e4,\n            data: i\n          }) : await lT(n, {\n            timeout: 1e4,\n            data: i\n          });\n        } catch (t) {\n          if (1 === e) throw t;\n          continue;\n        }\n        return;\n      }\n    }\n    createBaseInfo(e, t) {\n      const i = Object.assign({}, um);\n      return i.sid = e, this.baseInfoMap.set(e, {\n        info: i,\n        startTime: t\n      }), i;\n    }\n    reportResourceTiming(e, t) {\n      const i = performance.getEntriesByName(e),\n        r = i[i.length - 1];\n      r && this.reportApiInvoke(t, {\n        name: \"Client.resourceTiming\",\n        options: r,\n        tag: fm.TRACER\n      }).onSuccess();\n    }\n  }();\n  SE.on(\"REPORT_LOG_UPLOAD\", e => {\n    e.networkState = pT.networkState, IT.reportApiInvoke(null, {\n      name: \"logUploadError\",\n      options: e,\n      tag: fm.TRACER\n    });\n  });\n  class yT extends gE {\n    constructor(e, t) {\n      super(), mp(this, \"trackMediaType\", void 0), mp(this, \"_ID\", void 0), mp(this, \"_hints\", []), mp(this, \"_isClosed\", !1), mp(this, \"_originMediaStreamTrack\", void 0), mp(this, \"_mediaStreamTrack\", void 0), mp(this, \"_external\", {}), this._ID = t || MR(8, \"track-\"), this._originMediaStreamTrack = e, this._mediaStreamTrack = e, function (e) {\n        $E.includes(e) || $E.push(e);\n      }(this);\n    }\n    toString() {\n      return this._ID;\n    }\n    getTrackId() {\n      return this._ID;\n    }\n    getMediaStreamTrack(e) {\n      if (!e) {\n        const e = IT.reportApiInvoke(null, {\n          name: Em.GET_MEDIA_STREAM_TRACK,\n          options: [],\n          tag: fm.TRACER\n        });\n        this._mediaStreamTrack && \"string\" == typeof this._mediaStreamTrack.label ? e.onSuccess(this._mediaStreamTrack.label) : e.onSuccess(\"\");\n      }\n      return this._mediaStreamTrack;\n    }\n    getMediaStreamTrackSettings() {\n      return this.getMediaStreamTrack(!0).getSettings();\n    }\n    close() {\n      this._isClosed = !0, function (e) {\n        const t = $E.indexOf(e);\n        -1 !== t && $E.splice(t, 1);\n      }(this), this.emit(_g.CLOSED);\n    }\n  }\n  let CT,\n    AT = 1;\n  class OT {\n    constructor(e) {\n      mp(this, \"lockingPromise\", Cl.resolve()), mp(this, \"locks\", 0), mp(this, \"name\", \"\"), mp(this, \"lockId\", void 0), this.lockId = AT++, e && (this.name = e), NE.debug(\"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"] is created.\"));\n    }\n    get isLocked() {\n      return this.locks > 0;\n    }\n    lock(e) {\n      let t;\n      this.locks += 1, NE.debug(\"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"] is locked, current queue \").concat(this.locks, \". \").concat(\"string\" == typeof e ? e : \"\"));\n      const i = new Cl(i => {\n          t = () => {\n            this.locks -= 1, NE.debug(\"[lock-\".concat(this.name, \"-\").concat(this.lockId, \"] is not locked, current queue \").concat(this.locks, \". \").concat(\"string\" == typeof e ? e : \"\")), i();\n          };\n        }),\n        r = this.lockingPromise.then(() => t);\n      return this.lockingPromise = this.lockingPromise.then(() => i), r;\n    }\n  }\n  function bT(e, t) {\n    return function (i, r, n) {\n      const o = n.value;\n      if (\"function\" != typeof o) throw new Error(\"Cannot use mutex on object property.\");\n      return n.value = async function () {\n        const i = this[t];\n        if (!i) throw new Error(\"mutex property key \".concat(t, \" doesn't exist on \").concat(e));\n        const n = await i.lock(\"From \".concat(e, \".\").concat(r));\n        try {\n          for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];\n          return await o.apply(this, a);\n        } finally {\n          n();\n        }\n      }, n;\n    };\n  }\n  class wT extends yT {\n    get muted() {\n      return this._muted;\n    }\n    get enabled() {\n      return this._enabled;\n    }\n    constructor(e, t) {\n      super(e, t), mp(this, \"_enabled\", !0), mp(this, \"_muted\", !1), mp(this, \"_isClosed\", !1), mp(this, \"_enabledMutex\", void 0), mp(this, \"processor\", void 0), mp(this, \"processorContext\", void 0), mp(this, \"_handleTrackEnded\", () => {\n        this.onTrackEnded();\n      }), this._enabledMutex = new OT(\"\".concat(t)), e.addEventListener(\"ended\", this._handleTrackEnded);\n    }\n    getTrackLabel() {\n      return this._originMediaStreamTrack.label;\n    }\n    close() {\n      this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, NE.debug(\"[\".concat(this.getTrackId(), \"] close\")), this.emit(ug.NEED_CLOSE), super.close());\n    }\n    async _updateOriginMediaStreamTrack(e, t) {\n      e !== this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener(\"ended\", this._handleTrackEnded), t && this._originMediaStreamTrack.stop(), e.addEventListener(\"ended\", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await BR(this, ug.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({\n        track: this._originMediaStreamTrack,\n        context: this.processorContext\n      }));\n    }\n    _getDefaultPlayerConfig() {\n      return {};\n    }\n    onTrackEnded() {\n      NE.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.emit(_g.TRACK_ENDED);\n    }\n    stateCheck(e, t) {\n      if (NE.debug(\"check track state, [muted: \".concat(this._muted, \", enabled: \").concat(this._enabled, \"] to [\").concat(e, \": \").concat(t, \"]\")), qf(t, e), this._enabled && this._muted && \"enabled\" === e && !1 === t) throw new vE(TE.TRACK_STATE_UNREACHABLE, \"cannot set enabled while the track is muted\").print();\n      if (!this._enabled && !this._muted && \"muted\" === e && !0 === t) throw new vE(TE.TRACK_STATE_UNREACHABLE, \"cannot set muted while the track is disabled\").print();\n    }\n    getProcessorStats() {\n      return this.processorContext.gatherStats();\n    }\n    getProcessorUsage() {\n      return this.processorContext.gatherUsage();\n    }\n  }\n  function NT(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  !function (e) {\n    e.IOS_15_INTERRUPTION_START = \"ios15-interruption-start\", e.IOS_15_INTERRUPTION_END = \"ios15-interruption-end\", e.IOS_INTERRUPTION_START = \"ios-interruption-start\", e.IOS_INTERRUPTION_END = \"ios-interruption-end\", e.STATE_CHANGE = \"state-change\";\n  }(CT || (CT = {}));\n  const DT = window.AudioContext || window.webkitAudioContext;\n  let PT = null;\n  const LT = new class extends gE {\n    constructor() {\n      super(...arguments), mp(this, \"prevState\", void 0), mp(this, \"curState\", void 0), mp(this, \"currentTime\", void 0), mp(this, \"currentTimeStuckAt\", void 0), mp(this, \"interruptDetectorTrack\", void 0), mp(this, \"onLocalAudioTrackMute\", () => {\n        NE.info(\"ios15-interruption-start\"), this.emit(CT.IOS_15_INTERRUPTION_START);\n      }), mp(this, \"onLocalAudioTrackUnmute\", async () => {\n        NE.info(\"ios15-interruption-end\"), \"running\" !== this.curState || this.duringInterruption ? NE.info(\"ios15-interruption-end-canceled\") : (PT && (await PT.suspend()), this.emit(CT.IOS_15_INTERRUPTION_END));\n      });\n    }\n    get duringInterruption() {\n      return \"running\" === this.prevState && \"interrupted\" === this.curState;\n    }\n    bindInterruptDetectorTrack(e) {\n      NE.debug(\"webaudio bindInterruptDetectorTrack \".concat(e.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute);\n    }\n    unbindInterruptDetectorTrack(e) {\n      NE.debug(\"webaudio unbindInterruptDetectorTrack \".concat(e.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0);\n    }\n  }();\n  function kT() {\n    if (!DT) return void NE.error(\"your browser is not support web audio\");\n    NE.info(\"create audio context\");\n    const e = function (e) {\n      for (var t = 1; t < arguments.length; t++) {\n        var i = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? NT(Object(i), !0).forEach(function (t) {\n          mp(e, t, i[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : NT(Object(i)).forEach(function (t) {\n          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n        });\n      }\n      return e;\n    }({}, HE(\"WEBAUDIO_INIT_OPTIONS\"));\n    NE.debug(\"audio context init option:\", JSON.stringify(e)), PT = new DT(e), LT.curState = PT.state, PT.onstatechange = () => {\n      LT.prevState = LT.curState, LT.curState = PT ? PT.state : void 0, (Zh() || np()) && \"running\" === LT.prevState && \"interrupted\" === LT.curState && (NE.info(\"ios-interruption-start\"), LT.emit(CT.IOS_INTERRUPTION_START)), (Zh() || np()) && \"interrupted\" === LT.prevState && \"running\" === LT.curState && (NE.info(\"ios-interruption-end\"), LT.emit(CT.IOS_INTERRUPTION_END)), LT.prevState !== LT.curState && (NE.debug(\"AudioContext State Change\", \"\".concat(LT.prevState, \"=>\").concat(LT.curState)), LT.emit(CT.STATE_CHANGE));\n    }, setInterval(() => {\n      var e;\n      const t = null === (e = PT) || void 0 === e ? void 0 : e.currentTime;\n      if (LT.currentTime !== t) LT.currentTimeStuckAt && (NE.debug(\"AudioContext current time resume at \".concat(t)), LT.currentTimeStuckAt = void 0), LT.currentTime = t;else {\n        if (t !== LT.currentTimeStuckAt) {\n          IT.reportApiInvoke(null, {\n            name: \"WEB_AUDIO_CURRENT_TIME_STUCK\",\n            options: {\n              currentTime: t\n            },\n            tag: fm.TRACER\n          }).onSuccess(), NE.warning(\"AudioContext current time stuck at \".concat(t));\n        }\n        LT.currentTimeStuckAt = t;\n      }\n    }, 5e3), async function (e) {\n      const t = [\"click\", \"contextmenu\", \"auxclick\", \"dblclick\", \"mousedown\", \"mouseup\", \"touchend\", \"keydown\", \"keyup\"];\n      let i,\n        r = !1,\n        n = !1,\n        o = !1;\n      function s(t) {\n        \"running\" === e.state ? a(!1) : Zh() || np() ? \"suspended\" === e.state && (a(!0), t && e.resume().then(d, d)) : \"closed\" !== e.state && (a(!0), t && e.resume().then(d, d));\n      }\n      function a(e) {\n        if (r !== e) {\n          r = e;\n          for (let i = 0, r = t; i < r.length; i += 1) {\n            const t = r[i];\n            e ? window.addEventListener(t, u, {\n              capture: !0,\n              passive: !0\n            }) : window.removeEventListener(t, u, {\n              capture: !0,\n              passive: !0\n            });\n          }\n        }\n      }\n      function c() {\n        s(!0);\n      }\n      function d() {\n        s(!1);\n      }\n      function u() {\n        s(!0);\n      }\n      function l(e) {\n        if (!o) if (i.paused) {\n          if (e) {\n            h(!1), o = !0;\n            let e = void 0;\n            try {\n              e = i.play(), e ? e.then(p, p) : (i.addEventListener(\"playing\", p), i.addEventListener(\"abort\", p), i.addEventListener(\"error\", p));\n            } catch (e) {\n              p();\n            }\n          } else h(!0);\n        } else h(!1);\n      }\n      function h(e) {\n        if (n !== e) {\n          n = e;\n          for (let i = 0, r = t; i < r.length; i++) {\n            const t = r[i];\n            e ? window.addEventListener(t, _, {\n              capture: !0,\n              passive: !0\n            }) : window.removeEventListener(t, _, {\n              capture: !0,\n              passive: !0\n            });\n          }\n        }\n      }\n      function p() {\n        i.removeEventListener(\"playing\", p), i.removeEventListener(\"abort\", p), i.removeEventListener(\"error\", p), o = !1, l(!1);\n      }\n      function _() {\n        l(!0);\n      }\n      if (Zh()) {\n        const t = e.createMediaStreamDestination(),\n          r = document.createElement(\"div\");\n        r.innerHTML = \"<audio x-webkit-airplay='deny'></audio>\", i = r.children.item(0), i.controls = !1, i.disableRemotePlayback = !0, i.preload = \"auto\", i.srcObject = t.stream, l(!0);\n      }\n      LT.on(CT.STATE_CHANGE, c), s(!1);\n    }(PT);\n  }\n  function MT() {\n    if (!PT) {\n      if (kT(), !PT) throw new vE(TE.NOT_SUPPORTED, \"can not create audio context\");\n      return PT;\n    }\n    return PT;\n  }\n  function UT(e) {\n    if (function () {\n      if (null !== xT) return xT;\n      const e = MT(),\n        t = e.createBufferSource(),\n        i = e.createGain(),\n        r = e.createGain();\n      t.connect(i), t.connect(r), t.disconnect(i);\n      let n = !1;\n      try {\n        t.disconnect(i);\n      } catch (e) {\n        n = !0;\n      }\n      return t.disconnect(), xT = n, n;\n    }()) return;\n    const t = e.connect,\n      i = e.disconnect;\n    e.connect = (i, r, n) => (e._inputNodes || (e._inputNodes = []), e._inputNodes.includes(i) || (i instanceof AudioNode ? (e._inputNodes.push(i), t.call(e, i, r, n)) : t.call(e, i, r)), e), e.disconnect = (r, n, o) => {\n      i.call(e), r ? HR(e._inputNodes, r) : e._inputNodes = [];\n      for (const i of e._inputNodes) t.call(e, i);\n    };\n  }\n  let xT = null;\n  function VT(e, t) {\n    let i = !1;\n    const r = 1 / t;\n    if (HE(\"DISABLE_WEBAUDIO\")) {\n      const t = window.setInterval(() => {\n        i ? window.clearInterval(t) : e(performance.now() / 1e3);\n      }, 1e3 * r);\n    } else {\n      const t = MT();\n      let n = t.createGain();\n      n.gain.value = 0, n.connect(t.destination);\n      const o = () => {\n        if (i) return void (n = null);\n        const s = t.createOscillator();\n        s.onended = o, s.connect(n), s.start(0), s.stop(t.currentTime + r), e(t.currentTime);\n      };\n      o();\n    }\n    return () => {\n      i = !0;\n    };\n  }\n  const jT = NE.prefix(\"[inject-node]\");\n  class FT {\n    constructor() {\n      mp(this, \"nodeLists\", []), mp(this, \"prevNode\", void 0), mp(this, \"nextNode\", void 0);\n    }\n    get firstNode() {\n      return this.nodeLists[0];\n    }\n    get lastNode() {\n      return this.nodeLists[this.nodeLists.length - 1];\n    }\n    get isActive() {\n      return !!this.nodeLists.length;\n    }\n    get isConnected() {\n      return !(!this.prevNode || !this.nextNode);\n    }\n    connect(e, t) {\n      jT.debug(\"connect audio node, current list:\" + this.nodeLists.length), this.nodeLists.length ? (this.prevNode && this.prevNode.disconnect(), e.connect(this.firstNode), this.nextNode && this.lastNode && this.lastNode.disconnect(), this.lastNode.connect(t), this.nodeLists.forEach((e, t) => {\n        const i = this.nodeLists[t + 1];\n        i && e.connect(i);\n      })) : e.connect(t), this.nextNode = t, this.prevNode = e;\n    }\n    disconnect() {\n      var e;\n      jT.debug(\"disconnect audio node, current list:\" + this.nodeLists.length), this.nodeLists.forEach(e => {\n        e.disconnect();\n      }), null === (e = this.prevNode) || void 0 === e || e.disconnect(), this.prevNode = void 0, this.nextNode = void 0;\n    }\n    addNode(e) {\n      jT.debug(\"add node in inject node, current list:\", this.nodeLists.length), this.prevNode && this.nextNode ? (this.firstNode || (jT.debug(\"new node is the first node\"), this.prevNode.disconnect(), this.prevNode.connect(e), e.connect(this.nextNode)), this.nextNode && this.lastNode && (this.lastNode.disconnect(this.nextNode), this.lastNode.connect(e), e.connect(this.nextNode)), this.nodeLists.push(e)) : jT.debug(\"add node is called before inject node connected\");\n    }\n    removeNode(e) {\n      jT.debug(\"remove node in inject node, current list:\", this.nodeLists.length);\n      const t = this.nodeLists.indexOf(e);\n      if (-1 === t) return void jT.debug(\"$[inject-node] cannot find the node to be removed\");\n      const i = this.nodeLists[t + 1],\n        r = this.nodeLists[t - 1];\n      0 === t && this.prevNode && this.nextNode && (this.prevNode.disconnect(e), i ? this.prevNode.connect(i) : this.prevNode.connect(this.nextNode)), t === this.nodeLists.length - 1 && this.nextNode && r && (r.disconnect(e), r.connect(this.nextNode)), 0 !== t && t !== this.nodeLists.length - 1 && (r.disconnect(e), r.connect(i)), jT.debug(\"remove node in inject node success, current list:\", this.nodeLists.length);\n    }\n  }\n  class BT {\n    constructor() {\n      mp(this, \"context\", void 0), mp(this, \"analyserNode\", void 0), mp(this, \"sourceNode\", void 0), this.context = MT(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4;\n    }\n    updateSource(e) {\n      if (e !== this.sourceNode) {\n        if (this.sourceNode) try {\n          this.sourceNode.disconnect(this.analyserNode);\n        } catch (e) {}\n        this.sourceNode = e, null == e || e.connect(this.analyserNode);\n      }\n    }\n    getVolumeLevel() {\n      if (!this.sourceNode) return 0;\n      if (!this.context || Zh() || np() || \"running\" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;\n      const e = new Float32Array(this.analyserNode.fftSize);\n      if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e);else {\n        const t = new Uint8Array(this.analyserNode.fftSize);\n        this.analyserNode.getByteTimeDomainData(t);\n        for (let i = 0; i < e.length; ++i) e[i] = t[i] / 128 - 1;\n      }\n      const t = zi(e).call(e, (e, t) => e + t * t, 0) / e.length;\n      return Math.max(10 * Math.log10(t) + 100, 0) / 100;\n    }\n    getAnalyserNode() {\n      return this.analyserNode;\n    }\n    rebuildAnalyser() {\n      try {\n        var e, t;\n        null === (e = this.sourceNode) || void 0 === e || e.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4, null === (t = this.sourceNode) || void 0 === t || t.connect(this.analyserNode);\n      } catch (e) {\n        NE.warning(\"rebuild analyser node failed.\");\n      }\n    }\n    destroy() {\n      this.updateSource(void 0);\n    }\n  }\n  class GT extends gE {\n    get processSourceNode() {\n      return this.sourceNode;\n    }\n    set processedNode(e) {\n      var t;\n      if (!this.isDestroyed && this._processedNode !== e) {\n        try {\n          var i;\n          null === (i = this.sourceNode) || void 0 === i || i.disconnect(this.outputNode);\n        } catch (e) {}\n        null === (t = this._processedNode) || void 0 === t || t.disconnect(), this._processedNode = e, this.connect();\n      }\n    }\n    get processedNode() {\n      return this._processedNode;\n    }\n    constructor() {\n      super(), mp(this, \"outputNode\", void 0), mp(this, \"outputTrack\", void 0), mp(this, \"isPlayed\", !1), mp(this, \"sourceNode\", void 0), mp(this, \"context\", void 0), mp(this, \"audioBufferNode\", void 0), mp(this, \"destNode\", void 0), mp(this, \"injectNode\", void 0), mp(this, \"audioOutputLevel\", 0), mp(this, \"volumeLevelAnalyser\", void 0), mp(this, \"_processedNode\", void 0), mp(this, \"playNode\", void 0), mp(this, \"isDestroyed\", !1), mp(this, \"onNoAudioInput\", void 0), mp(this, \"isNoAudioInput\", !1), mp(this, \"_noAudioInputCount\", 0), this.context = MT(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), UT(this.outputNode), this.injectNode = new FT(), this.volumeLevelAnalyser = new BT();\n    }\n    startGetAudioBuffer(e) {\n      this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = e => {\n        this.emit(km.ON_AUDIO_BUFFER, function (e) {\n          for (let t = 0; t < e.outputBuffer.numberOfChannels; t += 1) {\n            const i = e.outputBuffer.getChannelData(t);\n            for (let e = 0; e < i.length; e += 1) i[e] = 0;\n          }\n          return e.inputBuffer;\n        }(e));\n      });\n    }\n    stopGetAudioBuffer() {\n      this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0);\n    }\n    createOutputTrack() {\n      if (!jg().webAudioMediaStreamDest) throw new vE(TE.NOT_SUPPORTED, \"your browser is not support audio processor\");\n      return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack;\n    }\n    play(e) {\n      \"running\" !== this.context.state && YR(() => {\n        LT.emit(\"autoplay-failed\");\n      }), this.isPlayed = !0, this.playNode = e || this.context.destination, this.outputNode.connect(this.playNode);\n    }\n    stop() {\n      if (this.isPlayed) try {\n        this.outputNode.disconnect(this.playNode);\n      } catch (e) {}\n      this.isPlayed = !1;\n    }\n    getAccurateVolumeLevel() {\n      return this.volumeLevelAnalyser.getVolumeLevel();\n    }\n    async checkHasAudioInput() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n      if (e > 5) return this.isNoAudioInput = !0, this.onNoAudioInput && this.onNoAudioInput(), !1;\n      Zh() || np() ? \"suspended\" === this.context.state && this.context.resume() : \"running\" !== this.context.state && this.context.resume();\n      const t = this.volumeLevelAnalyser.getAnalyserNode();\n      let i;\n      t.getFloatTimeDomainData ? (i = new Float32Array(t.fftSize), t.getFloatTimeDomainData(i)) : (i = new Uint8Array(t.fftSize), t.getByteTimeDomainData(i));\n      let r = !1;\n      for (let e = 0; e < i.length; e++) 0 !== i[e] && (r = !0);\n      return r ? (this.isNoAudioInput = !1, !0) : (await LR(200), (await this.checkHasAudioInput(e ? e + 1 : 1)) && r);\n    }\n    getAudioVolume() {\n      return this.outputNode.gain.value;\n    }\n    setVolume(e) {\n      this.outputNode.gain.setValueAtTime(e, this.context.currentTime);\n    }\n    destroy() {\n      this.disconnect(), this.stop(), this.isDestroyed = !0, this.onNoAudioInput = void 0;\n    }\n    injectAudioNode(e) {\n      this.injectNode.addNode(e);\n    }\n    removeAudioNode(e) {\n      this.injectNode.removeNode(e);\n    }\n    disconnect() {\n      var e, t;\n      null === (e = this.processedNode) || void 0 === e || e.disconnect(), null === (t = this.sourceNode) || void 0 === t || t.disconnect(), this.outputNode && this.outputNode.disconnect();\n    }\n    connect() {\n      var e;\n      this.processedNode ? null === (e = this.processedNode) || void 0 === e || e.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode);\n      this.volumeLevelAnalyser.updateSource(this.outputNode);\n    }\n  }\n  class WT extends GT {\n    get isFreeze() {\n      return !1;\n    }\n    constructor(e, t, i) {\n      var r;\n      if (super(), mp(this, \"sourceNode\", void 0), mp(this, \"track\", void 0), mp(this, \"clonedTrack\", void 0), mp(this, \"audioElement\", void 0), mp(this, \"isCurrentTrackCloned\", !1), mp(this, \"isRemoteTrack\", !1), mp(this, \"originVolumeLevelAnalyser\", void 0), mp(this, \"rebuildWebAudio\", async () => {\n        if (NE.debug(\"ready to rebuild web audio, state:\", this.context.state), this.isNoAudioInput && (await this.checkHasAudioInput()), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener(\"click\", this.rebuildWebAudio, !0), void NE.debug(\"rebuild web audio success, current volume status\", this.getAccurateVolumeLevel());\n        this.context.resume().then(() => NE.info(\"resume success\")), NE.debug(\"rebuild web audio because of ios 12 bugs\"), this.disconnect();\n        const e = this.track;\n        this.track = this.track.clone(), this.isCurrentTrackCloned ? e.stop() : this.isCurrentTrackCloned = !0;\n        const t = new MediaStream([this.track]);\n        this.sourceNode = this.context.createMediaStreamSource(t), UT(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();\n        const i = this.outputNode.gain.value;\n        this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(i, this.context.currentTime), UT(this.outputNode), this.emit(km.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput();\n      }), \"audio\" !== e.kind) throw new vE(TE.UNEXPECTED_ERROR);\n      this.track = e;\n      const n = new MediaStream([this.track]);\n      if (this.isRemoteTrack = !!t, this.sourceNode = this.context.createMediaStreamSource(n), UT(this.sourceNode), i) {\n        const e = i.clone();\n        e.enabled = !0, this.clonedTrack = e, NE.debug(\"create an unmuted track \".concat(e.id, \" from the original track \").concat(i.id, \" to get the volume\"));\n        const t = this.context.createMediaStreamSource(new MediaStream([e]));\n        UT(t), this.originVolumeLevelAnalyser = new BT(), this.originVolumeLevelAnalyser.updateSource(t);\n      }\n      this.connect(), this.audioElement = document.createElement(\"audio\"), this.audioElement.srcObject = n;\n      const o = Bh();\n      t && o.os === Uh.IOS && Number(null === (r = o.osVersion) || void 0 === r ? void 0 : r.split(\".\")[0]) < 15 && (LT.on(CT.STATE_CHANGE, () => {\n        \"suspended\" === this.context.state ? document.body.addEventListener(\"click\", this.rebuildWebAudio, !0) : \"running\" === this.context.state && this.rebuildWebAudio();\n      }), this.checkHasAudioInput().then(e => {\n        e || document.body.addEventListener(\"click\", this.rebuildWebAudio, !0);\n      }));\n    }\n    updateTrack(e) {\n      this.sourceNode.disconnect(), this.track = e, this.isCurrentTrackCloned = !1;\n      const t = new MediaStream([e]);\n      this.sourceNode = this.context.createMediaStreamSource(t), UT(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(km.UPDATE_SOURCE), this.audioElement.srcObject = t;\n    }\n    destroy() {\n      var e;\n      this.audioElement.srcObject = null, this.audioElement.remove(), LT.off(\"state-change\", this.rebuildWebAudio), null === (e = this.originVolumeLevelAnalyser) || void 0 === e || e.destroy(), this.clonedTrack = void 0, super.destroy();\n    }\n    createMediaStreamSourceNode(e) {\n      return this.context.createMediaStreamSource(new MediaStream([e]));\n    }\n    updateOriginTrack(e) {\n      const t = e.clone();\n      t.enabled = !0, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t), NE.debug(\"create an unmuted track \".concat(t.id, \" from the original track \").concat(e.id, \" to get the volume\"));\n      const i = this.context.createMediaStreamSource(new MediaStream([t]));\n      UT(i), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(i);\n    }\n    getOriginVolumeLevel() {\n      return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel();\n    }\n  }\n  async function HT(e, t) {\n    const i = (e, t) => e ? \"number\" != typeof e ? e.max || e.exact || e.ideal || e.min || t : e : t,\n      r = {\n        audio: !1,\n        video: {\n          mandatory: {\n            chromeMediaSource: \"desktop\",\n            chromeMediaSourceId: e,\n            maxHeight: i(t.height, 1080),\n            maxWidth: i(t.width, 1920)\n          }\n        }\n      };\n    return t.frameRate && \"number\" != typeof t.frameRate ? (r.video.mandatory.maxFrameRate = t.frameRate.max, r.video.mandatory.minFrameRate = t.frameRate.min) : \"number\" == typeof t.frameRate && (r.video.mandatory.maxFrameRate = t.frameRate), await navigator.mediaDevices.getUserMedia(r);\n  }\n  async function KT(e) {\n    const t = await YT(e.mediaSource),\n      i = await function (e) {\n        return new Cl((t, i) => {\n          const r = document.createElement(\"div\");\n          r.innerText = \"share screen\", r.setAttribute(\"style\", \"text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;\");\n          const n = document.createElement(\"div\");\n          n.setAttribute(\"style\", \"width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;\");\n          const o = document.createElement(\"div\");\n          o.innerText = \"Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.\", o.setAttribute(\"style\", \"height: 12%;\");\n          const s = document.createElement(\"div\");\n          s.setAttribute(\"style\", \"width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;\");\n          const a = document.createElement(\"div\");\n          a.setAttribute(\"style\", \"text-align: right; padding: 16px 0;\");\n          const c = document.createElement(\"button\");\n          c.innerHTML = \"cancel\", c.setAttribute(\"style\", \"width: 85px;\"), c.onclick = () => {\n            document.body.removeChild(d);\n            const e = new Error(\"NotAllowedError\");\n            e.name = \"NotAllowedError\", i(e);\n          }, a.appendChild(c), n.appendChild(o), n.appendChild(s), n.appendChild(a);\n          const d = document.createElement(\"div\");\n          d.setAttribute(\"style\", \"position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);\"), d.appendChild(r), d.appendChild(n), document.body.appendChild(d), e.map(e => {\n            if (e.id) {\n              const i = document.createElement(\"div\");\n              i.setAttribute(\"style\", \"width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;\");\n              let r = e.thumbnail;\n              const {\n                width: n\n              } = r.getSize();\n              n > 1920 && (r = r.resize({\n                width: 1920\n              })), i.innerHTML = '<div style=\"height: 120px; display: table-cell; vertical-align: middle;\"><img style=\"width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);\" src=' + r.toDataURL() + ' /></div><span style=\"\\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;\">' + (e.name.replace(/[\\u00A0-\\u9999<>\\&]/g, function (e) {\n                return \"&#\" + e.charCodeAt(0) + \";\";\n              }) + \"</span>\"), i.onclick = () => {\n                document.body.removeChild(d), t(e.id);\n              }, s.appendChild(i);\n            }\n          });\n        });\n      }(t);\n    return await HT(i, e);\n  }\n  async function YT(e) {\n    let t = [\"window\", \"screen\"];\n    \"application\" !== e && \"window\" !== e || (t = [\"window\"]), \"screen\" === e && (t = [\"screen\"]);\n    const i = JT();\n    if (!i) throw new vE(TE.ELECTRON_IS_NULL);\n    let r = null;\n    try {\n      var n;\n      r = (null === (n = i.desktopCapturer) || void 0 === n ? void 0 : n.getSources({\n        types: t\n      })) || i.ipcRenderer.invoke(\"DESKTOP_CAPTURER_GET_SOURCES\", {\n        types: t\n      });\n    } catch (e) {\n      r = null;\n    }\n    r && r.then || (r = new Cl((e, r) => {\n      i.desktopCapturer.getSources({\n        types: t\n      }, (t, i) => {\n        t ? r(t) : e(i);\n      });\n    }));\n    try {\n      return await r;\n    } catch (e) {\n      throw new vE(TE.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e.toString());\n    }\n  }\n  let qT = null;\n  function JT() {\n    if (qT) return qT;\n    try {\n      return qT = window.require(\"electron\"), qT;\n    } catch (e) {\n      return null;\n    }\n  }\n  const XT = new OT(\"safari\");\n  let zT = !1,\n    QT = !1;\n  async function ZT(e, t) {\n    let i = 0,\n      r = null;\n    for (; i < 2;) try {\n      r = await $T(e, t, i > 0);\n      break;\n    } catch (e) {\n      if (e instanceof vE) throw NE.error(\"[\".concat(t, \"] \").concat(e.toString())), e;\n      const r = ev(e.name || e.code || e, e.message);\n      if (r.code === TE.MEDIA_OPTION_INVALID) {\n        NE.debug(\"[\".concat(t, \"] detect media option invalid, retry\")), i += 1, await LR(500);\n        continue;\n      }\n      throw NE.error(\"[\".concat(t, \"] \").concat(r.toString())), r;\n    }\n    if (!r) throw new vE(TE.UNEXPECTED_ERROR, \"can not find stream after getUserMedia\");\n    return r;\n  }\n  async function $T(e, t, i) {\n    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new vE(TE.NOT_SUPPORTED, \"can not find getUserMedia\");\n    i && (e.video && (delete e.video.width, delete e.video.height), e.screen && (delete e.screen.width, delete e.screen.height));\n    const r = jg(),\n      n = new MediaStream();\n    if (e.audioSource && n.addTrack(e.audioSource), e.videoSource && n.addTrack(e.videoSource), !e.audio && !e.video && !e.screen) return NE.debug(\"Using Video Source/ Audio Source\"), n;\n    if (e.screen) if (JT()) {\n      if (e.screen.sourceId) {\n        tv(n, await HT(e.screen.sourceId, e.screen));\n      } else {\n        tv(n, await KT(e.screen));\n      }\n    } else if (Xh() && e.screen.extensionId && e.screen.mandatory) {\n      if (!r.getStreamFromExtension) throw new vE(TE.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n      NE.debug(\"[\".concat(t, '] Screen access on chrome stable, looking for extension\"'));\n      const i = await (o = e.screen.extensionId, s = t, new Cl((e, t) => {\n        try {\n          chrome.runtime.sendMessage(o, {\n            getStream: !0\n          }, i => {\n            if (!i || !i.streamId) return NE.error(\"[\".concat(s, \"] No response from Chrome Plugin. Plugin not installed properly\"), i), void t(new vE(TE.CHROME_PLUGIN_NO_RESPONSE, \"No response from Chrome Plugin. Plugin not installed properly\"));\n            e(i.streamId);\n          });\n        } catch (e) {\n          NE.error(\"[\".concat(s, \"] AgoraRTC screensharing plugin is not accessible(\").concat(o, \")\"), e.toString()), t(new vE(TE.CHROME_PLUGIN_NOT_INSTALL));\n        }\n      }));\n      e.screen.mandatory.chromeMediaSourceId = i;\n      tv(n, await navigator.mediaDevices.getUserMedia({\n        video: {\n          mandatory: e.screen.mandatory\n        }\n      }));\n    } else if (r.getDisplayMedia) {\n      e.screen.mediaSource && gg(e.screen.mediaSource);\n      const i = {\n        width: e.screen.width,\n        height: e.screen.height,\n        frameRate: e.screen.frameRate,\n        displaySurface: \"screen\" === e.screen.mediaSource ? \"monitor\" : e.screen.mediaSource\n      };\n      NE.debug(\"[\".concat(t, \"] getDisplayMedia:\"), JSON.stringify({\n        video: i,\n        audio: !!e.screenAudio\n      }));\n      tv(n, await navigator.mediaDevices.getDisplayMedia({\n        video: i,\n        audio: !!e.screenAudio\n      }));\n    } else {\n      if (!Qh()) throw NE.error(\"[\".concat(t, \"] This browser does not support screenSharing\")), new vE(TE.NOT_SUPPORTED, \"This browser does not support screen sharing\");\n      {\n        e.screen.mediaSource && gg(e.screen.mediaSource);\n        const i = {\n          video: {\n            mediaSource: e.screen.mediaSource,\n            width: e.screen.width,\n            height: e.screen.height,\n            frameRate: e.screen.frameRate\n          }\n        };\n        NE.debug(\"[\".concat(t, \"] getUserMedia: \").concat(JSON.stringify(i)));\n        tv(n, await navigator.mediaDevices.getUserMedia(i));\n      }\n    }\n    var o, s;\n    if (!e.video && !e.audio) return n;\n    let a = {\n        video: e.video,\n        audio: e.audio\n      },\n      c = HE(\"MEDIA_DEVICE_CONSTRAINTS\");\n    if (c) try {\n      \"string\" == typeof c && (c = JSON.parse(c)), a = function e(t, i) {\n        if (!tI(t) || !tI(i)) return i;\n        if (Array.isArray(t) && !Array.isArray(i) || !Array.isArray(t) && Array.isArray(i)) return i;\n        if (Array.isArray(i) && Array.isArray(t)) {\n          const r = [...t];\n          for (let n = 0; n < i.length; n++) r[n] = e(t[n], i[n]);\n          return r;\n        }\n        {\n          const r = DR({}, t);\n          for (const n in i) Object.prototype.hasOwnProperty.call(i, n) && (Object.prototype.hasOwnProperty.call(t, n) ? r[n] = e(t[n], i[n]) : r[n] = i[n]);\n          return r;\n        }\n      }(a, c);\n    } catch (e) {}\n    NE.debug(\"[\".concat(t, \"] GetUserMedia\"), JSON.stringify(a)), Bh();\n    let d,\n      u = null;\n    (zh() || Zh() || Yh()) && (u = await XT.lock());\n    try {\n      d = await navigator.mediaDevices.getUserMedia(a);\n    } catch (e) {\n      throw u && u(), e;\n    }\n    return a.audio && (zT = !0), a.video && (QT = !0), tv(n, d), u && u(), n;\n  }\n  function ev(e, t) {\n    switch (e) {\n      case \"Starting video failed\":\n      case \"OverconstrainedError\":\n      case \"TrackStartError\":\n        return new vE(TE.MEDIA_OPTION_INVALID, \"\".concat(e, \": \").concat(t));\n      case \"NotFoundError\":\n      case \"DevicesNotFoundError\":\n        return new vE(TE.DEVICE_NOT_FOUND, \"\".concat(e, \": \").concat(t));\n      case \"NotSupportedError\":\n        return new vE(TE.NOT_SUPPORTED, \"\".concat(e, \": \").concat(t));\n      case \"NotReadableError\":\n        return new vE(TE.NOT_READABLE, \"\".concat(e, \": \").concat(t));\n      case \"InvalidStateError\":\n      case \"NotAllowedError\":\n      case \"PERMISSION_DENIED\":\n      case \"PermissionDeniedError\":\n        return new vE(TE.PERMISSION_DENIED, \"\".concat(e, \": \").concat(t));\n      case \"ConstraintNotSatisfiedError\":\n        return new vE(TE.CONSTRAINT_NOT_SATISFIED, \"\".concat(e, \": \").concat(t));\n      default:\n        return NE.error(\"getUserMedia unexpected error\", e), new vE(TE.UNEXPECTED_ERROR, \"\".concat(e, \": \").concat(t));\n    }\n  }\n  function tv(e, t) {\n    const i = e.getVideoTracks()[0],\n      r = e.getAudioTracks()[0],\n      n = t.getVideoTracks()[0],\n      o = t.getAudioTracks()[0];\n    o && (r && e.removeTrack(r), e.addTrack(o)), n && (i && e.removeTrack(i), e.addTrack(n));\n  }\n  const iv = new class extends gE {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      e !== this._state && (this.emit(gm.STATE_CHANGE, e), this._state = e);\n    }\n    constructor() {\n      super(), mp(this, \"_state\", mm.IDLE), mp(this, \"isAccessMicrophonePermission\", !1), mp(this, \"isAccessCameraPermission\", !1), mp(this, \"lastAccessMicrophonePermission\", !1), mp(this, \"lastAccessCameraPermission\", !1), mp(this, \"checkdeviceMatched\", !1), mp(this, \"deviceInfoMap\", new Map()), this.init().then(() => {\n        navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener(\"devicechange\", this.updateDevicesInfo.bind(this)), window.setInterval(() => {\n          (HE(\"ENUMERATE_DEVICES_INTERVAL\") || cp() && ap()) && this.updateDevicesInfo();\n        }, HE(\"ENUMERATE_DEVICES_INTERVAL_TIME\"));\n      }).catch(e => NE.error(e.toString()));\n    }\n    async enumerateDevices(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        return new vE(TE.NOT_SUPPORTED, \"enumerateDevices() not supported.\").throw();\n      }\n      const r = await navigator.mediaDevices.enumerateDevices(),\n        n = this.checkMediaDeviceInfoIsOk(r);\n      let o = !this.isAccessMicrophonePermission && e,\n        s = !this.isAccessCameraPermission && t;\n      n.audio && (o = !1), n.video && (s = !1);\n      let a = null,\n        c = null,\n        d = null;\n      if (!i && (o || s)) {\n        if (XT.isLocked) {\n          NE.debug(\"[device manager] wait GUM lock\");\n          (await XT.lock())(), NE.debug(\"[device manager] GUM unlock\");\n        }\n        if (zT && (o = !1, this.isAccessMicrophonePermission = !0), QT && (s = !1, this.isAccessCameraPermission = !0), NE.debug(\"[device manager] check media device permissions\", e, t, o, s), o && s) {\n          try {\n            d = await navigator.mediaDevices.getUserMedia({\n              audio: !0,\n              video: !0\n            });\n          } catch (e) {\n            const t = ev(e.name || e.code || e, e.message);\n            if (t.code === TE.PERMISSION_DENIED) throw t;\n            NE.warning(\"getUserMedia failed in getDevices\", t);\n          }\n          this.isAccessCameraPermission = !0, this.isAccessMicrophonePermission = !0;\n        } else if (o) {\n          try {\n            a = await navigator.mediaDevices.getUserMedia({\n              audio: e\n            });\n          } catch (e) {\n            const t = ev(e.name || e.code || e, e.message);\n            if (t.code === TE.PERMISSION_DENIED) throw t;\n            NE.warning(\"getUserMedia failed in getDevices\", t);\n          }\n          this.isAccessMicrophonePermission = !0;\n        } else if (s) {\n          try {\n            c = await navigator.mediaDevices.getUserMedia({\n              video: t\n            });\n          } catch (e) {\n            const t = ev(e.name || e.code || e, e.message);\n            if (t.code === TE.PERMISSION_DENIED) throw t;\n            NE.warning(\"getUserMedia failed in getDevices\", t);\n          }\n          this.isAccessCameraPermission = !0;\n        }\n        NE.debug(\"[device manager] mic permission\", e, \"cam permission\", t);\n      }\n      try {\n        const e = await navigator.mediaDevices.enumerateDevices();\n        return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), d && d.getTracks().forEach(e => e.stop()), a = null, c = null, d = null, e;\n      } catch (e) {\n        a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), d && d.getTracks().forEach(e => e.stop()), a = null, c = null, d = null;\n        return new vE(TE.ENUMERATE_DEVICES_FAILED, e.toString()).throw();\n      }\n    }\n    async getRecordingDevices() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      return (await this.enumerateDevices(!0, !1, e)).filter(e => \"audioinput\" === e.kind);\n    }\n    async getCamerasDevices() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      return (await this.enumerateDevices(!1, !0, e)).filter(e => \"videoinput\" === e.kind);\n    }\n    async getSpeakers() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      return (await this.enumerateDevices(!0, !1, e)).filter(e => \"audiooutput\" === e.kind);\n    }\n    searchDeviceIdByName(e) {\n      let t = null;\n      return this.deviceInfoMap.forEach(i => {\n        i.device.label === e && (t = i.device.deviceId);\n      }), t;\n    }\n    async getDeviceById(e) {\n      const t = (await this.enumerateDevices(!0, !0, !0)).find(t => t.deviceId === e);\n      if (!t) throw new vE(TE.DEVICE_NOT_FOUND, \"deviceId: \".concat(e));\n      return t;\n    }\n    async init() {\n      this.state = mm.INITING;\n      try {\n        await this.updateDevicesInfo(), this.state = mm.INITEND;\n      } catch (e) {\n        if (NE.warning(\"Device Detection functionality cannot start properly.\", e.toString()), this.state = mm.IDLE, !function () {\n          if (\"boolean\" == typeof isSecureContext) return isSecureContext;\n          return \"https:\" === location.protocol || \"file:\" === location.protocol || \"localhost\" === location.hostname || \"127.0.0.1\" === location.hostname || \"::1\" === location.hostname;\n        }()) {\n          new vE(TE.WEB_SECURITY_RESTRICT, \"Your context is limited by web security, please try using https protocol or localhost.\").throw();\n        }\n        throw e;\n      }\n    }\n    async updateDevicesInfo() {\n      const e = await this.enumerateDevices(!0, !0, !0),\n        t = Date.now(),\n        i = [];\n      if (e[0] && e[0].label && !1 === this.checkdeviceMatched) {\n        this.checkdeviceMatched = !0;\n        const t = e.find(e => \"audioinput\" === e.kind && \"default\" === e.deviceId),\n          i = e.find(e => \"audiooutput\" === e.kind && \"default\" === e.deviceId);\n        t && i ? i.groupId === t.groupId ? NE.debug(\"[device-check] default input \".concat(t.label, \" and output \").concat(i.label, \" is the same group\")) : NE.warning(\"[device-check] default input \".concat(t.label, \" and output \").concat(i.label, \" is not the same group\")) : NE.debug(\"[device-check] default input or output not found\");\n      }\n      const r = this.checkMediaDeviceInfoIsOk(e);\n      if (e.forEach(e => {\n        if (!e.deviceId) return;\n        const r = this.deviceInfoMap.get(\"\".concat(e.kind, \"_\").concat(e.deviceId));\n        if (\"ACTIVE\" !== (r ? r.state : \"INACTIVE\")) {\n          const r = {\n            initAt: t,\n            updateAt: t,\n            device: e,\n            state: \"ACTIVE\"\n          };\n          this.deviceInfoMap.set(\"\".concat(e.kind, \"_\").concat(e.deviceId), r), i.push(r);\n        }\n        r && (r.updateAt = t);\n      }), this.deviceInfoMap.forEach((e, r) => {\n        \"ACTIVE\" === e.state && e.updateAt !== t && (e.state = \"INACTIVE\", i.push(e));\n      }), this.state !== mm.INITEND) return r.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), void (r.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0));\n      i.forEach(e => {\n        switch (e.device.kind) {\n          case \"audioinput\":\n            this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(gm.RECORDING_DEVICE_CHANGED, e);\n            break;\n          case \"videoinput\":\n            this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(gm.CAMERA_DEVICE_CHANGED, e);\n            break;\n          case \"audiooutput\":\n            this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(gm.PLAYOUT_DEVICE_CHANGED, e);\n        }\n      }), r.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), r.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0);\n    }\n    checkMediaDeviceInfoIsOk(e) {\n      const t = e.filter(e => \"audioinput\" === e.kind),\n        i = e.filter(e => \"videoinput\" === e.kind),\n        r = {\n          audio: !1,\n          video: !1\n        };\n      for (const e of t) if (e.label && e.deviceId) {\n        r.audio = !0;\n        break;\n      }\n      for (const e of i) if (e.label && e.deviceId) {\n        r.video = !0;\n        break;\n      }\n      return r;\n    }\n  }();\n  const rv = [\"play\", \"playing\", \"loadeddata\", \"canplay\", \"pause\", \"stalled\", \"suspend\", \"waiting\", \"abort\", \"emptied\", \"ended\", \"error\"],\n    nv = new class {\n      constructor() {\n        mp(this, \"onAutoplayFailed\", void 0), mp(this, \"elementMap\", new Map()), mp(this, \"elementStateMap\", new Map()), mp(this, \"elementsNeedToResume\", []), mp(this, \"sinkIdMap\", new Map()), mp(this, \"autoResumeAfterInterruption\", () => {\n          Array.from(this.elementMap.entries()).forEach(e => {\n            let [t, i] = e;\n            const r = this.elementStateMap.get(t),\n              n = i.srcObject.getAudioTracks()[0];\n            ep() ? n && \"live\" === n.readyState && \"running\" === LT.curState && (NE.debug(\"auto resume after interruption for iOS 15\"), i.pause(), i.play()) : r && \"paused\" === r && n && \"live\" === n.readyState && \"running\" === LT.curState && (NE.debug(\"auto resume after interruption for iOS\"), i.play());\n          });\n        }), mp(this, \"autoResumeAfterInterruptionOnIOS15\", () => {\n          Array.from(this.elementMap.entries()).forEach(e => {\n            let [t, i] = e;\n            const r = i.srcObject.getAudioTracks()[0];\n            r && \"live\" === r.readyState && (NE.debug(\"auto resume after interruption inside autoResumeAfterInterruptionOnIOS15\"), i.pause(), i.play());\n          });\n        }), this.autoResumeAudioElement(), LT.on(CT.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), LT.on(CT.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), LT.on(CT.STATE_CHANGE, () => {\n          Zh() && \"suspended\" === LT.prevState && \"running\" === LT.curState && this.autoResumeAfterInterruption();\n        });\n      }\n      async setSinkID(e, t) {\n        const i = this.elementMap.get(e);\n        if (this.sinkIdMap.set(e, t), i) try {\n          await i.setSinkId(t);\n        } catch (e) {\n          throw new vE(TE.PERMISSION_DENIED, \"can not set sink id: \" + e.toString());\n        }\n      }\n      play(e, t, i, r) {\n        if (this.elementMap.has(t)) return;\n        const n = document.createElement(\"audio\");\n        n.autoplay = !0, n.srcObject = new MediaStream([e]), this.bindAudioElementEvents(t, n), this.elementMap.set(t, n), this.elementStateMap.set(t, am.INIT), this.setVolume(t, i);\n        const o = this.sinkIdMap.get(t);\n        if (o) try {\n          n.setSinkId(o).catch(e => {\n            NE.warning(\"[\".concat(t, \"] set sink id failed\"), e.toString());\n          });\n        } catch (e) {\n          NE.warning(\"[\".concat(t, \"] set sink id failed\"), e.toString());\n        }\n        const s = n.play();\n        s && s.then && s.catch(e => {\n          r && IT.autoplayFailed(r, \"audio\", e.message, t), NE.warning(\"audio element play warning\", e.toString()), this.elementMap.has(t) && \"NotAllowedError\" === e.name && (NE.warning(\"detected audio element autoplay failed\"), this.elementsNeedToResume.push(n), YR(() => {\n            this.onAutoplayFailed && this.onAutoplayFailed(), fT();\n          }));\n        });\n      }\n      updateTrack(e, t) {\n        const i = this.elementMap.get(e);\n        i && (i.srcObject = new MediaStream([t]));\n      }\n      isPlaying(e) {\n        return this.elementMap.has(e);\n      }\n      setVolume(e, t) {\n        const i = this.elementMap.get(e);\n        i && (t = Math.max(0, Math.min(100, t)), i.volume = t / 100);\n      }\n      stop(e) {\n        const t = this.elementMap.get(e);\n        if (this.sinkIdMap.delete(e), !t) return;\n        const i = this.elementsNeedToResume.indexOf(t);\n        this.elementsNeedToResume.splice(i, 1), t.srcObject = null, t.remove(), this.elementMap.delete(e), this.elementStateMap.delete(e);\n      }\n      bindAudioElementEvents(e, t) {\n        rv.forEach(i => {\n          t.addEventListener(i, i => {\n            const r = this.elementStateMap.get(e),\n              n = \"pause\" === i.type ? \"paused\" : i.type;\n            if (NE.debug(\"[\".concat(e, \"] audio-element-status change \").concat(r, \" => \").concat(n)), \"error\" === i.type) {\n              const i = null == t ? void 0 : t.error;\n              i && NE.error(\"[\".concat(e, \"] media error, code: \").concat(i.code, \", message: \").concat(i.message));\n            }\n            this.elementStateMap.set(e, n);\n          });\n        });\n      }\n      getPlayerState(e) {\n        return this.elementStateMap.get(e) || \"uninit\";\n      }\n      autoResumeAudioElement() {\n        const e = () => {\n          this.elementsNeedToResume.forEach(e => {\n            e.play().then(e => {\n              NE.debug(\"Auto resume audio element success\");\n            }).catch(e => {\n              NE.warning(\"Auto resume audio element failed!\", e);\n            });\n          }), this.elementsNeedToResume = [];\n        };\n        new Cl(e => {\n          document.body ? e() : window.addEventListener(\"load\", () => e());\n        }).then(() => {\n          dp() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0));\n        });\n      }\n    }();\n  function ov() {\n    return function (e, t, i) {\n      const r = i.value;\n      return \"function\" == typeof r && (i.value = function () {\n        this._isClosed && new vE(TE.INVALID_OPERATION, \"[\".concat(this.getTrackId(), \"] cannot operate a closed track\")).print(\"warning\");\n        for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n        const n = r.apply(this, t);\n        return n instanceof Cl ? new Cl((e, t) => {\n          n.then(e).catch(t);\n        }) : n;\n      }), i;\n    };\n  }\n  var sv,\n    av,\n    cv,\n    dv,\n    uv,\n    lv,\n    hv,\n    pv,\n    _v,\n    Ev,\n    fv,\n    mv,\n    gv,\n    Sv,\n    Tv,\n    vv,\n    Rv,\n    Iv,\n    yv,\n    Cv,\n    Av,\n    Ov,\n    bv,\n    wv,\n    Nv,\n    Dv,\n    Pv,\n    Lv,\n    kv,\n    Mv,\n    Uv,\n    xv,\n    Vv,\n    jv,\n    Fv,\n    Bv,\n    Gv,\n    Wv = Hi(\"Array\").values,\n    Hv = $n,\n    Kv = Ge,\n    Yv = u,\n    qv = Wv,\n    Jv = Array.prototype,\n    Xv = {\n      DOMTokenList: !0,\n      NodeList: !0\n    },\n    zv = function (e) {\n      var t = e.values;\n      return e === Jv || Yv(Jv, e) && t === Jv.values || Kv(Xv, Hv(e)) ? qv : t;\n    };\n  function Qv(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function Zv(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? Qv(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : Qv(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class $v extends gE {\n    constructor(e) {\n      super(), mp(this, \"name\", \"VideoProcessorDestination\"), mp(this, \"ID\", \"0\"), mp(this, \"_source\", void 0), mp(this, \"videoContext\", void 0), mp(this, \"inputTrack\", void 0), this.videoContext = e;\n    }\n    get kind() {\n      return \"video\";\n    }\n    get enabled() {\n      return !0;\n    }\n    pipe() {\n      throw new vE(TE.NOT_SUPPORTED, \"VideoProcessor cannot pipe to any other Processor\");\n    }\n    unpipe() {\n      throw new vE(TE.NOT_SUPPORTED, \"VideoProcessor cannot unpipe to any other Processor\");\n    }\n    enable() {}\n    disable() {}\n    updateInput(e) {\n      if (e.context !== this.videoContext) throw new Error(\"ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\\nProbably you are making pipeline like this:\\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).\");\n      e.track && e.track !== this.inputTrack && (this.videoContext.chained = !0, this.inputTrack = e.track, this.emit(Ng.ON_TRACK, e.track));\n    }\n    reset() {\n      this.inputTrack = void 0, this.videoContext.chained = !1, this.emit(Ng.ON_TRACK, void 0);\n    }\n  }\n  class eR extends gE {\n    set chained(e) {\n      this._chained = e;\n    }\n    get chained() {\n      return this._chained;\n    }\n    constructor(e, t) {\n      super(), mp(this, \"constraintsMap\", new Map()), mp(this, \"statsRegistry\", []), mp(this, \"usageRegistry\", []), mp(this, \"trackId\", void 0), mp(this, \"direction\", void 0), mp(this, \"_chained\", !1), this.trackId = e, this.direction = t;\n    }\n    async getConstraints() {\n      return await FR(this, Dg.REQUEST_CONSTRAINTS);\n    }\n    async requestApplyConstraints(e, t) {\n      var i;\n      return NE.info(\"processor \".concat(t.name, \" requestApplyConstraints for \").concat(this.trackId)), e && this.constraintsMap.set(t, e), BR(this, Dg.REQUEST_UPDATE_CONSTRAINTS, Array.from(zv(i = this.constraintsMap).call(i)));\n    }\n    async requestRevertConstraints(e) {\n      var t;\n      if (this.constraintsMap.has(e)) return NE.info(\"processor \".concat(e.name, \" requestRevertConstraints for \").concat(this.trackId)), this.constraintsMap.delete(e), BR(this, Dg.REQUEST_UPDATE_CONSTRAINTS, Array.from(zv(t = this.constraintsMap).call(t)));\n    }\n    registerStats(e, t, i) {\n      this.statsRegistry.find(i => i.processorID === e.ID && i.processorName === e.name && i.type === t) || this.statsRegistry.push({\n        processorName: e.name,\n        processorID: e.ID,\n        type: t,\n        cb: i\n      });\n    }\n    unregisterStats(e, t) {\n      const i = this.statsRegistry.findIndex(i => i.processorID === e.ID && i.processorName === e.name && i.type === t);\n      -1 !== i && this.statsRegistry.splice(i, 1);\n    }\n    gatherStats() {\n      const e = [];\n      for (const {\n        processorID: t,\n        processorName: i,\n        type: r,\n        cb: n\n      } of this.statsRegistry) try {\n        const o = n();\n        e.push({\n          processorID: t,\n          processorName: i,\n          type: r,\n          stats: o\n        });\n      } catch (e) {\n        NE.error(new vE(TE.UNEXPECTED_ERROR, e.message));\n      }\n      return e;\n    }\n    registerUsage(e, t) {\n      this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({\n        processorID: e.ID,\n        processorName: e.name,\n        cb: t\n      });\n    }\n    unregisterUsage(e) {\n      const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);\n      -1 !== t && this.usageRegistry.splice(t, 1);\n    }\n    async gatherUsage() {\n      const e = [];\n      if (!this.chained) return [];\n      for (const {\n        cb: t\n      } of this.usageRegistry) try {\n        let i = t();\n        i instanceof Cl && (i = await i), e.push(Zv(Zv({}, i), {}, {\n          direction: this.direction\n        }));\n      } catch (e) {\n        NE.error(\"gather extension usage error\", e);\n      }\n      return e;\n    }\n    getDirection() {\n      return this.direction;\n    }\n  }\n  class tR extends gE {\n    constructor(e) {\n      super(), mp(this, \"name\", \"AudioProcessorDestination\"), mp(this, \"ID\", \"0\"), mp(this, \"inputTrack\", void 0), mp(this, \"inputNode\", void 0), mp(this, \"audioProcessorContext\", void 0), mp(this, \"_source\", void 0), this.audioProcessorContext = e;\n    }\n    get kind() {\n      return \"audio\";\n    }\n    get enabled() {\n      return !0;\n    }\n    pipe() {\n      throw new vE(TE.NOT_SUPPORTED, \"AudioProcessorDestination cannot pipe to any other Processor\");\n    }\n    unpipe() {\n      throw new vE(TE.NOT_SUPPORTED, \"AudioProcessor cannot unpipe to any other Processor\");\n    }\n    enable() {}\n    disable() {}\n    reset() {\n      this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = !1, this.emit(Ng.ON_TRACK, void 0), this.emit(Ng.ON_NODE, void 0);\n    }\n    updateInput(e) {\n      if (e.context !== this.audioProcessorContext) throw new Error(\"ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).\");\n      e.track && this.inputTrack !== e.track && (this.audioProcessorContext.chained = !0, this.inputTrack = e.track, this.emit(Ng.ON_TRACK, this.inputTrack)), e.node && this.inputNode !== e.node && (this.audioProcessorContext.chained = !0, this.inputNode = e.node, this.emit(Ng.ON_NODE, this.inputNode));\n    }\n  }\n  class iR extends gE {\n    set chained(e) {\n      this._chained = e;\n    }\n    get chained() {\n      return this._chained;\n    }\n    constructor(e, t, i) {\n      super(), mp(this, \"constraintsMap\", new Map()), mp(this, \"statsRegistry\", []), mp(this, \"audioContext\", void 0), mp(this, \"trackId\", void 0), mp(this, \"direction\", void 0), mp(this, \"usageRegistry\", []), mp(this, \"_chained\", !1), this.audioContext = e, this.trackId = t, this.direction = i;\n    }\n    async getConstraints() {\n      return FR(this, Dg.REQUEST_CONSTRAINTS);\n    }\n    getAudioContext() {\n      return this.audioContext;\n    }\n    async requestApplyConstraints(e, t) {\n      var i;\n      return NE.info(\"processor \".concat(t.name, \" requestApplyConstraints for \").concat(this.trackId)), e && this.constraintsMap.set(t, e), BR(this, Dg.REQUEST_UPDATE_CONSTRAINTS, Array.from(zv(i = this.constraintsMap).call(i)));\n    }\n    async requestRevertConstraints(e) {\n      var t;\n      if (this.constraintsMap.has(e)) return this.constraintsMap.delete(e), BR(this, Dg.REQUEST_UPDATE_CONSTRAINTS, Array.from(zv(t = this.constraintsMap).call(t)));\n    }\n    registerStats(e, t, i) {\n      this.statsRegistry.find(i => i.processorID === e.ID && i.processorName === e.name && i.type === t) || this.statsRegistry.push({\n        processorName: e.name,\n        processorID: e.ID,\n        type: t,\n        cb: i\n      });\n    }\n    unregisterStats(e, t) {\n      const i = this.statsRegistry.findIndex(i => i.processorID === e.ID && i.processorName === e.name && i.type === t);\n      -1 !== i && this.statsRegistry.splice(i, 1);\n    }\n    gatherStats() {\n      const e = [];\n      for (const {\n        processorID: t,\n        processorName: i,\n        type: r,\n        cb: n\n      } of this.statsRegistry) try {\n        const o = n();\n        e.push({\n          processorID: t,\n          processorName: i,\n          type: r,\n          stats: o\n        });\n      } catch (e) {\n        NE.error(new vE(TE.UNEXPECTED_ERROR, e.message));\n      }\n      return e;\n    }\n    registerUsage(e, t) {\n      this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({\n        processorID: e.ID,\n        processorName: e.name,\n        cb: t\n      });\n    }\n    unregisterUsage(e) {\n      const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);\n      -1 !== t && this.usageRegistry.splice(t, 1);\n    }\n    async gatherUsage() {\n      const e = [];\n      if (!this.chained) return [];\n      for (const {\n        cb: t\n      } of this.usageRegistry) try {\n        let i = t();\n        i instanceof Cl && (i = await i), e.push(Zv(Zv({}, i), {}, {\n          direction: this.direction\n        }));\n      } catch (e) {\n        NE.error(\"gather extension usage error\", e);\n      }\n      return e;\n    }\n    getDirection() {\n      return this.direction;\n    }\n  }\n  class rR extends gE {\n    get isPlayed() {\n      return !0;\n    }\n    get isFreeze() {\n      return !1;\n    }\n    constructor() {\n      super(), mp(this, \"context\", void 0), mp(this, \"processSourceNode\", void 0), mp(this, \"outputTrack\", void 0), mp(this, \"processedNode\", void 0), mp(this, \"clonedTrack\", void 0), mp(this, \"outputNode\", void 0), this.outputNode = new nR();\n    }\n    setVolume() {}\n    createOutputTrack() {\n      throw new vE(TE.NOT_SUPPORTED, \"can not create output MediaStreamTrack when WebAudio disabled\");\n    }\n    getOriginVolumeLevel() {\n      return 0;\n    }\n    getAccurateVolumeLevel() {\n      return 0;\n    }\n    stopGetAudioBuffer() {}\n    startGetAudioBuffer() {}\n    play() {}\n    stop() {}\n    destroy() {}\n    updateTrack() {}\n    updateOriginTrack() {}\n    createMediaStreamSourceNode() {}\n  }\n  class nR {\n    disconnect() {}\n    connect() {}\n  }\n  function oR(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function sR(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? oR(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : oR(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let aR = (sv = RT({\n      argsMap: (e, t) => [e.getTrackId(), t],\n      throttleTime: 300\n    }), av = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), cv = ov(), dv = bT(\"LocalAudioTrack\", \"_enabledMutex\"), uv = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), lv = ov(), hv = bT(\"LocalAudioTrack\", \"_enabledMutex\"), pv = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), _v = ov(), Ev = ov(), fv = ov(), mv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), gv = ov(), Sv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), Tv = ov(), vv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), Rv = RT({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), Iv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), ZS((yv = class extends wT {\n      get isPlaying() {\n        return this._useAudioElement ? nv.isPlaying(this.getTrackId()) : this._source.isPlayed;\n      }\n      get __className__() {\n        return \"LocalAudioTrack\";\n      }\n      constructor(e, t, i, r) {\n        super(e, i), mp(this, \"trackMediaType\", \"audio\"), mp(this, \"_encoderConfig\", void 0), mp(this, \"_source\", void 0), mp(this, \"_enabled\", !0), mp(this, \"_volume\", 100), mp(this, \"_useAudioElement\", !1), mp(this, \"_bypassWebAudio\", !1), mp(this, \"processor\", void 0), mp(this, \"processorContext\", void 0), mp(this, \"processorDestination\", void 0), mp(this, \"_getOriginVolumeLevel\", void 0), this._encoderConfig = t, this._getOriginVolumeLevel = !!r, HE(\"DISABLE_WEBAUDIO\") ? (this._source = new rR(), this._useAudioElement = !0, this._bypassWebAudio = !0) : (this._source = new WT(e, !1, this._getOriginVolumeLevel ? e : void 0), HE(\"LOCAL_AUDIO_TRACK_USES_WEB_AUDIO\") || (this._useAudioElement = !0)), this.processorContext = new iR(this._source.context, this.getTrackId(), \"local\"), this.processorDestination = new tR(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(km.UPDATE_SOURCE, () => {\n          this.processor && this.processor.updateInput({\n            node: this._source.processSourceNode,\n            context: this.processorContext\n          });\n        });\n      }\n      setVolume(e) {\n        Xf(e, \"volume\", 0, 1e3), this._volume = e, this._source.setVolume(e / 100), this._useAudioElement && nv.setVolume(this.getTrackId(), e);\n        try {\n          if (this._bypassWebAudio) return void NE.debug(\"[\".concat(this.getTrackId(), \"] setVolume returned because no pass through WebAudio.\"));\n          const e = this._source.createOutputTrack();\n          this._mediaStreamTrack !== e && (this._mediaStreamTrack = e, BR(this, ug.NEED_REPLACE_TRACK, this).then(() => {\n            NE.debug(\"[\".concat(this.getTrackId(), \"] replace web audio track success\"));\n          }).catch(e => {\n            NE.warning(\"[\".concat(this.getTrackId(), \"] replace web audio track failed\"), e);\n          }));\n        } catch (e) {}\n      }\n      getVolumeLevel() {\n        return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel();\n      }\n      async setPlaybackDevice(e) {\n        if (!this._useAudioElement) throw new vE(TE.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n        await nv.setSinkID(this.getTrackId(), e);\n      }\n      async setEnabled(e, t, i) {\n        return this._setEnabled(e, t, i);\n      }\n      async _setEnabled(e, t, i) {\n        if (!i) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (NE.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), e) {\n          this._originMediaStreamTrack.enabled = !0;\n          try {\n            i || (this._enabled = !0), await BR(this, ug.NEED_ENABLE_TRACK, this), NE.info(\"[\".concat(this.getTrackId(), \"] setEnabled to \").concat(e, \" success\"));\n          } catch (e) {\n            throw i || (this._enabled = !1), NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled to true error\"), e.toString()), e;\n          }\n        } else {\n          this._originMediaStreamTrack.enabled = !1, i || (this._enabled = !1);\n          try {\n            await BR(this, ug.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw i || (this._enabled = !0), NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n          }\n        }\n      }\n      async setMuted(e) {\n        e !== this._muted && (this.stateCheck(\"muted\", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, NE.debug(\"[\".concat(this.getTrackId(), \"] start set muted: \").concat(e)), e ? await BR(this, ug.NEED_MUTE_TRACK, this) : await BR(this, ug.NEED_UNMUTE_TRACK, this));\n      }\n      getStats() {\n        XR(() => {\n          NE.warning(\"[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead\");\n        }, \"localAudioTrackGetStatsWarning\");\n        const e = GR(this, ug.GET_STATS);\n        return e || sR({}, Fm);\n      }\n      setAudioFrameCallback(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;\n        if (!e) return this._source.removeAllListeners(km.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n        this._source.startGetAudioBuffer(t), this._source.removeAllListeners(km.ON_AUDIO_BUFFER), this._source.on(km.ON_AUDIO_BUFFER, t => e(t));\n      }\n      play() {\n        NE.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\")), this._useAudioElement ? (NE.debug(\"[\".concat(this.getTrackId(), \"] start audio playback in element\")), nv.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play();\n      }\n      stop() {\n        NE.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\")), this._useAudioElement ? nv.stop(this.getTrackId()) : this._source.stop();\n      }\n      close() {\n        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy();\n      }\n      _updatePlayerSource() {\n        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n        NE.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && nv.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n      }\n      async _updateOriginMediaStreamTrack(e, t) {\n        this._originMediaStreamTrack !== e && (this._originMediaStreamTrack.removeEventListener(\"ended\", this._handleTrackEnded), e.addEventListener(\"ended\", this._handleTrackEnded), t && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this.processor && this.processor.updateInput({\n          track: e,\n          context: this.processorContext\n        }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await BR(this, ug.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e));\n      }\n      renewMediaStreamTrack(e) {\n        return Cl.resolve(void 0);\n      }\n      pipe(e) {\n        if (this._bypassWebAudio) throw new vE(TE.INVALID_OPERATION, \"Can not process AudioTrack when bypassWebAudio set to true.\");\n        if (this.processor === e) return e;\n        if (e._source) throw new vE(TE.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          node: this._source.processSourceNode,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        var e;\n        if (!this.processor) return;\n        const t = this.processor;\n        null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset();\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(Ng.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e), await BR(this, ug.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await BR(this, ug.NEED_REPLACE_TRACK, this));\n        }), this.processorDestination.on(Ng.ON_NODE, e => {\n          this._source.processedNode = e;\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(Ng.ON_TRACK), this.processorDestination.removeAllListeners(Ng.ON_NODE);\n      }\n      unbindProcessorContextEvents() {\n        this.processorContext.removeAllListeners(Dg.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(Dg.REQUEST_CONSTRAINTS);\n      }\n    }).prototype, \"setVolume\", [sv], Object.getOwnPropertyDescriptor(yv.prototype, \"setVolume\"), yv.prototype), ZS(yv.prototype, \"setPlaybackDevice\", [av, cv], Object.getOwnPropertyDescriptor(yv.prototype, \"setPlaybackDevice\"), yv.prototype), ZS(yv.prototype, \"setEnabled\", [dv, uv, lv], Object.getOwnPropertyDescriptor(yv.prototype, \"setEnabled\"), yv.prototype), ZS(yv.prototype, \"setMuted\", [hv, pv, _v], Object.getOwnPropertyDescriptor(yv.prototype, \"setMuted\"), yv.prototype), ZS(yv.prototype, \"getStats\", [Ev], Object.getOwnPropertyDescriptor(yv.prototype, \"getStats\"), yv.prototype), ZS(yv.prototype, \"setAudioFrameCallback\", [fv], Object.getOwnPropertyDescriptor(yv.prototype, \"setAudioFrameCallback\"), yv.prototype), ZS(yv.prototype, \"play\", [mv, gv], Object.getOwnPropertyDescriptor(yv.prototype, \"play\"), yv.prototype), ZS(yv.prototype, \"stop\", [Sv, Tv], Object.getOwnPropertyDescriptor(yv.prototype, \"stop\"), yv.prototype), ZS(yv.prototype, \"close\", [vv], Object.getOwnPropertyDescriptor(yv.prototype, \"close\"), yv.prototype), ZS(yv.prototype, \"pipe\", [Rv], Object.getOwnPropertyDescriptor(yv.prototype, \"pipe\"), yv.prototype), ZS(yv.prototype, \"unpipe\", [Iv], Object.getOwnPropertyDescriptor(yv.prototype, \"unpipe\"), yv.prototype), yv),\n    cR = (Cv = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), Av = ov(), Ov = bT(\"MicrophoneAudioTrack\", \"_enabledMutex\"), bv = RT({\n      argsMap: (e, t, i) => [e.getTrackId(), t, i]\n    }), wv = ov(), Nv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), ZS((Dv = class extends aR {\n      get __className__() {\n        return \"MicrophoneAudioTrack\";\n      }\n      constructor(e, t, i, r) {\n        super(e, t.encoderConfig ? GE(t.encoderConfig) : {}, r, HE(\"GET_VOLUME_OF_MUTED_AUDIO_TRACK\")), mp(this, \"_config\", void 0), mp(this, \"_deviceName\", \"default\"), mp(this, \"_constraints\", void 0), mp(this, \"_originalConstraints\", void 0), mp(this, \"_enabled\", !0), this._config = t, this._constraints = i, this._originalConstraints = i, this._deviceName = e.label, \"boolean\" == typeof t.bypassWebAudio && (this._bypassWebAudio = t.bypassWebAudio), ep() && LT.bindInterruptDetectorTrack(this), this.bindProcessorContextEvents();\n      }\n      async setDevice(e) {\n        if (NE.info(\"[\".concat(this.getTrackId(), \"] start set device to \").concat(e)), this._enabled) try {\n          const t = await iv.getDeviceById(e),\n            i = {};\n          i.audio = sR({}, this._constraints), i.audio.deviceId = {\n            exact: e\n          }, this._originMediaStreamTrack.stop();\n          let r = null;\n          try {\n            r = await ZT(i, this.getTrackId());\n          } catch (e) {\n            throw NE.error(\"[\".concat(this.getTrackId(), \"] setDevice failed\"), e.toString()), r = await ZT({\n              video: this._constraints\n            }, this.getTrackId()), await this._updateOriginMediaStreamTrack(r.getAudioTracks()[0], !1), e;\n          }\n          await this._updateOriginMediaStreamTrack(r.getAudioTracks()[0], !1), this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        } else try {\n          const t = await iv.getDeviceById(e);\n          this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        }\n        NE.info(\"[\".concat(this.getTrackId(), \"] set device to \").concat(e, \" success\"));\n      }\n      async setEnabled(e, t, i) {\n        if (t) return NE.debug(\"[\".concat(this.getTrackId(), \"] setEnabled false (do not close microphone)\")), await super._setEnabled(e);\n        if (!i) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (NE.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), !e) {\n          var r;\n          this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (r = this._source.clonedTrack) || void 0 === r || r.stop(), i || (this._enabled = !1);\n          try {\n            await BR(this, ug.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled false failed\"), e.toString()), e;\n          }\n          return;\n        }\n        const n = sR({}, this._constraints),\n          o = iv.searchDeviceIdByName(this._deviceName);\n        o && !n.deviceId && (n.deviceId = o);\n        try {\n          i || (this._enabled = !0);\n          const e = await ZT({\n            audio: this._constraints\n          }, this.getTrackId());\n          await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !1), await BR(this, ug.NEED_ENABLE_TRACK, this);\n        } catch (e) {\n          throw i || (this._enabled = !1), NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled true failed\"), e.toString()), e;\n        }\n        NE.info(\"[\".concat(this.getTrackId(), \"] setEnabled success\"));\n      }\n      close() {\n        super.close(), ep() && LT.unbindInterruptDetectorTrack(this);\n      }\n      onTrackEnded() {\n        if ((Zh() || np()) && this._enabled && !this._isClosed && LT.duringInterruption) {\n          const e = async () => {\n            LT.off(CT.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (NE.debug(\"[\".concat(this.getTrackId(), \"] try capture microphone media device for interrupted iOS device.\")), await this.setEnabled(!1), await this.setEnabled(!0));\n          };\n          LT.on(CT.IOS_INTERRUPTION_END, e);\n        } else NE.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.emit(_g.TRACK_ENDED);\n      }\n      async renewMediaStreamTrack(e) {\n        const t = e || this._constraints,\n          i = iv.searchDeviceIdByName(this._deviceName);\n        if (i && !t.deviceId && (t.deviceId = i), this._constraints = t, this._enabled) {\n          this._originMediaStreamTrack.stop();\n          const e = await ZT({\n            audio: this._constraints\n          }, this.getTrackId());\n          await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !0);\n        }\n      }\n      bindProcessorContextEvents() {\n        this.processorContext.on(Dg.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {\n          try {\n            const i = Object.assign({}, this._originalConstraints, ...e);\n            await this.renewMediaStreamTrack(i), t();\n          } catch (e) {\n            i(e);\n          }\n        }), this.processorContext.on(Dg.REQUEST_CONSTRAINTS, async e => {\n          e(this._originMediaStreamTrack.getSettings());\n        });\n      }\n    }).prototype, \"setDevice\", [Cv, Av], Object.getOwnPropertyDescriptor(Dv.prototype, \"setDevice\"), Dv.prototype), ZS(Dv.prototype, \"setEnabled\", [Ov, bv, wv], Object.getOwnPropertyDescriptor(Dv.prototype, \"setEnabled\"), Dv.prototype), ZS(Dv.prototype, \"close\", [Nv], Object.getOwnPropertyDescriptor(Dv.prototype, \"close\"), Dv.prototype), Dv),\n    dR = (Pv = RT({\n      argsMap: (e, t) => [e.getTrackId(), t, e.duration]\n    }), Lv = ov(), kv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), Mv = ov(), Uv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), xv = ov(), Vv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), jv = ov(), Fv = RT({\n      argsMap: e => [e.getTrackId()]\n    }), Bv = ov(), ZS((Gv = class extends aR {\n      get __className__() {\n        return \"BufferSourceAudioTrack\";\n      }\n      constructor(e, t, i, r) {\n        super(t.createOutputTrack(), i, r), mp(this, \"source\", void 0), mp(this, \"_bufferSource\", void 0), this.source = e, this._bufferSource = t, this._bufferSource.on(km.AUDIO_SOURCE_STATE_CHANGE, e => {\n          this.emit(_g.SOURCE_STATE_CHANGE, e);\n        });\n        try {\n          this._mediaStreamTrack = this._source.createOutputTrack();\n        } catch (e) {}\n      }\n      get currentState() {\n        return this._bufferSource.currentState;\n      }\n      get duration() {\n        return this._bufferSource.duration;\n      }\n      getCurrentTime() {\n        return this._bufferSource.currentTime;\n      }\n      startProcessAudioBuffer(e) {\n        e && this._bufferSource.updateOptions(e), this._bufferSource.startProcessAudioBuffer();\n      }\n      pauseProcessAudioBuffer() {\n        this._bufferSource.pauseProcessAudioBuffer();\n      }\n      seekAudioBuffer(e) {\n        this._bufferSource.seekAudioBuffer(e);\n      }\n      resumeProcessAudioBuffer() {\n        this._bufferSource.resumeProcessAudioBuffer();\n      }\n      stopProcessAudioBuffer() {\n        this._bufferSource.stopProcessAudioBuffer();\n      }\n    }).prototype, \"startProcessAudioBuffer\", [Pv, Lv], Object.getOwnPropertyDescriptor(Gv.prototype, \"startProcessAudioBuffer\"), Gv.prototype), ZS(Gv.prototype, \"pauseProcessAudioBuffer\", [kv, Mv], Object.getOwnPropertyDescriptor(Gv.prototype, \"pauseProcessAudioBuffer\"), Gv.prototype), ZS(Gv.prototype, \"seekAudioBuffer\", [Uv, xv], Object.getOwnPropertyDescriptor(Gv.prototype, \"seekAudioBuffer\"), Gv.prototype), ZS(Gv.prototype, \"resumeProcessAudioBuffer\", [Vv, jv], Object.getOwnPropertyDescriptor(Gv.prototype, \"resumeProcessAudioBuffer\"), Gv.prototype), ZS(Gv.prototype, \"stopProcessAudioBuffer\", [Fv, Bv], Object.getOwnPropertyDescriptor(Gv.prototype, \"stopProcessAudioBuffer\"), Gv.prototype), Gv);\n  class uR extends aR {\n    get __className__() {\n      return \"MixingAudioTrack\";\n    }\n    get isActive() {\n      for (const e of this.trackList) if (e._enabled && !e._isClosed && !e.muted) return !0;\n      return !1;\n    }\n    constructor() {\n      const e = MT().createMediaStreamDestination();\n      super(e.stream.getAudioTracks()[0], void 0, MR(8, \"track-mix-\")), mp(this, \"trackList\", void 0), mp(this, \"destNode\", void 0);\n      try {\n        this._mediaStreamTrack = this._source.createOutputTrack();\n      } catch (e) {}\n      this.destNode = e, this.trackList = [];\n    }\n    hasAudioTrack(e) {\n      return -1 !== this.trackList.indexOf(e);\n    }\n    addAudioTrack(e) {\n      -1 === this.trackList.indexOf(e) ? (NE.debug(\"add \".concat(e.getTrackId(), \" to mixing track\")), e._source.outputNode.connect(this.destNode), this.trackList.push(e), this.updateEncoderConfig()) : NE.debug(\"track \".concat(e.getTrackId(), \" is already added\"));\n    }\n    removeAudioTrack(e) {\n      if (-1 !== this.trackList.indexOf(e)) {\n        NE.debug(\"remove \".concat(e.getTrackId(), \" from mixing track\"));\n        try {\n          e._source.outputNode.disconnect(this.destNode);\n        } catch (e) {}\n        HR(this.trackList, e), this.updateEncoderConfig();\n      }\n    }\n    updateEncoderConfig() {\n      const e = {};\n      this.trackList.forEach(t => {\n        t._encoderConfig && ((t._encoderConfig.bitrate || 0) > (e.bitrate || 0) && (e.bitrate = t._encoderConfig.bitrate), (t._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) && (e.sampleRate = t._encoderConfig.sampleRate), (t._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) && (e.sampleSize = t._encoderConfig.sampleSize), t._encoderConfig.stereo && (e.stereo = !0));\n      }), this._encoderConfig = e;\n    }\n  }\n  class lR extends gE {\n    constructor() {\n      super(...arguments), mp(this, \"resultStorage\", new Map());\n    }\n    setLocalAudioStats(e, t, i) {\n      this.record(\"AUDIO_INPUT_LEVEL_TOO_LOW\", e, this.checkAudioInputLevel(i, t)), this.record(\"SEND_AUDIO_BITRATE_TOO_LOW\", e, this.checkSendAudioBitrate(i, t));\n    }\n    setLocalVideoStats(e, t, i) {\n      this.record(\"SEND_VIDEO_BITRATE_TOO_LOW\", e, this.checkSendVideoBitrate(i, t)), this.record(\"FRAMERATE_INPUT_TOO_LOW\", e, this.checkFramerateInput(i, t)), this.record(\"FRAMERATE_SENT_TOO_LOW\", e, this.checkFramerateSent(i));\n    }\n    setRemoteAudioStats(e, t) {\n      const i = e.getUserId();\n      this.record(\"AUDIO_OUTPUT_LEVEL_TOO_LOW\", i, this.checkAudioOutputLevel(t));\n    }\n    setRemoteVideoStats(e, t) {\n      const i = e.getUserId();\n      this.record(\"RECV_VIDEO_DECODE_FAILED\", i, this.checkVideoDecode(t));\n    }\n    record(e, t, i) {\n      this.resultStorage.has(e) || this.resultStorage.set(e, {\n        result: [],\n        isPrevNormal: !0\n      });\n      const r = this.resultStorage.get(e);\n      if (r && (r.result.push(i), r.result.length >= 5)) {\n        const i = r.result.includes(!0);\n        r.isPrevNormal && !i && this.emit(\"exception\", hR[e], e, t), !r.isPrevNormal && i && this.emit(\"exception\", hR[e] + 2e3, e + \"_RECOVER\", t), r.isPrevNormal = i, r.result = [];\n      }\n    }\n    checkAudioOutputLevel(e) {\n      return !(e.receiveBitrate > 0 && 0 === e.receiveLevel);\n    }\n    checkAudioInputLevel(e, t) {\n      return t instanceof uR && !t.isActive || !!t.muted || 0 !== e.sendVolumeLevel;\n    }\n    checkFramerateInput(e, t) {\n      let i = null;\n      t._encoderConfig && t._encoderConfig.frameRate && (i = RR(t._encoderConfig.frameRate));\n      const r = e.captureFrameRate;\n      return !i || !r || !(i > 10 && r < 5 || i < 10 && i >= 5 && r <= 1);\n    }\n    checkFramerateSent(e) {\n      return !(e.captureFrameRate && e.sendFrameRate && e.captureFrameRate > 5 && e.sendFrameRate <= 1);\n    }\n    checkSendVideoBitrate(e, t) {\n      return !!t.muted || 0 !== e.sendBitrate;\n    }\n    checkSendAudioBitrate(e, t) {\n      return t instanceof uR && !t.isActive || !!t.muted || 0 !== e.sendBitrate;\n    }\n    checkVideoDecode(e) {\n      return 0 === e.receiveBitrate || 0 !== e.decodeFrameRate;\n    }\n  }\n  const hR = {\n    FRAMERATE_INPUT_TOO_LOW: 1001,\n    FRAMERATE_SENT_TOO_LOW: 1002,\n    SEND_VIDEO_BITRATE_TOO_LOW: 1003,\n    RECV_VIDEO_DECODE_FAILED: 1005,\n    AUDIO_INPUT_LEVEL_TOO_LOW: 2001,\n    AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,\n    SEND_AUDIO_BITRATE_TOO_LOW: 2003\n  };\n  const pR = new class {\n    markSubscribeStart(e, t) {\n      performance.mark(\"agora-web-sdk/\".concat(e, \"/subscribe-\").concat(t));\n    }\n    markPublishStart(e, t) {\n      performance.mark(\"agora-web-sdk/\".concat(e, \"/publish-\").concat(t));\n    }\n    measureFromSubscribeStart(e, t) {\n      const i = performance.getEntriesByName(\"agora-web-sdk/\".concat(e, \"/subscribe-\").concat(t));\n      if (i.length > 0) {\n        const e = i[i.length - 1];\n        return Math.round(performance.now() - e.startTime);\n      }\n      return 0;\n    }\n    measureFromPublishStart(e, t) {\n      const i = performance.getEntriesByName(\"agora-web-sdk/\".concat(e, \"/publish-\").concat(t));\n      if (i.length > 0) {\n        const e = i[i.length - 1];\n        return Math.round(performance.now() - e.startTime);\n      }\n      return 0;\n    }\n  }();\n  function _R(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function ER(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? _R(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : _R(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class fR {\n    constructor(e) {\n      mp(this, \"store\", void 0), mp(this, \"onStatsException\", void 0), mp(this, \"onUploadPublishDuration\", void 0), mp(this, \"localStats\", new Map()), mp(this, \"remoteStats\", new Map()), mp(this, \"updateStatsInterval\", void 0), mp(this, \"trafficStats\", void 0), mp(this, \"trafficStatsPeerList\", []), mp(this, \"uplinkStats\", void 0), mp(this, \"exceptionMonitor\", void 0), mp(this, \"p2pChannel\", void 0), mp(this, \"updateStats\", () => {\n        this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel));\n      }), this.store = e, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new lR(), this.exceptionMonitor.on(\"exception\", (e, t, i) => {\n        this.onStatsException && this.onStatsException(e, t, i);\n      });\n    }\n    reset() {\n      this.localStats = new Map(), this.remoteStats = new Map(), this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0;\n    }\n    getLocalAudioTrackStats() {\n      return this.localStats.get(Cg.LocalAudioTrack) || ER({}, Fm);\n    }\n    getLocalVideoTrackStats() {\n      return this.localStats.get(Cg.LocalVideoTrack) || ER({}, Bm);\n    }\n    getRemoteAudioTrackStats(e) {\n      const t = (e, t) => {\n          if (!this.trafficStats) return t;\n          const i = this.trafficStats.peer_delay.find(t => t.peer_uid === e);\n          return i && (t.publishDuration = i.B_ppad + (Date.now() - this.trafficStats.timestamp)), t;\n        },\n        i = {};\n      if (e) {\n        var r;\n        const n = null === (r = this.remoteStats.get(e)) || void 0 === r ? void 0 : r.audioStats;\n        n && (i[e] = t(e, n));\n      } else Array.from(this.remoteStats.entries()).forEach(e => {\n        let [r, {\n          audioStats: n\n        }] = e;\n        n && (i[r] = t(r, n));\n      });\n      return i;\n    }\n    getRemoteNetworkQualityStats(e) {\n      const t = {};\n      if (e) {\n        var i;\n        const r = null === (i = this.remoteStats.get(e)) || void 0 === i ? void 0 : i.networkStats;\n        r && (t[e] = r);\n      } else Array.from(this.remoteStats.entries()).forEach(e => {\n        let [i, {\n          networkStats: r\n        }] = e;\n        r && (t[i] = r);\n      });\n      return t;\n    }\n    getRemoteVideoTrackStats(e) {\n      const t = (e, t) => {\n          if (!this.trafficStats) return t;\n          const i = this.trafficStats.peer_delay.find(t => t.peer_uid === e);\n          return i && (t.publishDuration = i.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t;\n        },\n        i = {};\n      if (e) {\n        var r;\n        const n = null === (r = this.remoteStats.get(e)) || void 0 === r ? void 0 : r.videoStats;\n        n && (i[e] = t(e, n));\n      } else Array.from(this.remoteStats.entries()).forEach(e => {\n        let [r, {\n          videoStats: n\n        }] = e;\n        n && (i[r] = t(r, n));\n      });\n      return i;\n    }\n    getRTCStats() {\n      let e = 0,\n        t = 0,\n        i = 0,\n        r = 0;\n      const n = this.localStats.get(Cg.LocalAudioTrack);\n      n && (e += n.sendBytes, t += n.sendBitrate);\n      const o = this.localStats.get(Cg.LocalVideoTrack);\n      o && (e += o.sendBytes, t += o.sendBitrate);\n      const s = this.localStats.get(Cg.LocalVideoLowTrack);\n      s && (e += s.sendBytes, t += s.sendBitrate), this.remoteStats.forEach(e => {\n        let {\n          audioStats: t,\n          videoStats: n\n        } = e;\n        t && (i += t.receiveBytes, r += t.receiveBitrate), n && (i += n.receiveBytes, r += n.receiveBitrate);\n      });\n      let a = 1;\n      return this.trafficStats && (a += this.trafficStats.peer_delay.length), {\n        Duration: 0,\n        UserCount: a,\n        SendBitrate: t,\n        SendBytes: e,\n        RecvBytes: i,\n        RecvBitrate: r,\n        OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0,\n        RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0\n      };\n    }\n    addLocalStats(e) {\n      this.localStats.set(e, void 0);\n    }\n    removeLocalStats(e) {\n      e ? this.localStats.delete(e) : this.localStats.clear();\n    }\n    addRemoteStats(e) {\n      this.remoteStats.set(e, {});\n    }\n    removeRemoteStats(e) {\n      e ? this.remoteStats.delete(e) : this.remoteStats.clear();\n    }\n    addP2PChannel(e) {\n      this.p2pChannel = e;\n    }\n    updateTrafficStats(e) {\n      e.peer_delay = e.peer_delay.filter(e => void 0 !== e.B_ppad || void 0 !== e.B_ppvd);\n      e.peer_delay.filter(e => -1 === this.trafficStatsPeerList.indexOf(e.peer_uid)).forEach(e => {\n        var t;\n        const i = null === (t = this.p2pChannel) || void 0 === t ? void 0 : t.getRemoteMedia(e.peer_uid),\n          r = null != i && i.videoSSRC ? pR.measureFromSubscribeStart(this.store.clientId, i.videoSSRC) : 0,\n          n = null != i && i.audioSSRC ? pR.measureFromSubscribeStart(this.store.clientId, i.audioSSRC) : 0;\n        void 0 !== e.B_ppad && void 0 !== e.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e.peer_uid, e.B_ppad, e.B_ppvd, r > n ? r : n), this.trafficStatsPeerList.push(e.peer_uid));\n      }), this.trafficStats = e;\n    }\n    updateUplinkStats(e) {\n      this.uplinkStats && this.uplinkStats.B_fir !== e.B_fir && NE.debug(\"[\".concat(this.store.clientId, \"]: Period fir changes to \").concat(e.B_fir)), this.uplinkStats = e;\n    }\n    static isRemoteVideoFreeze(e, t, i) {\n      if (!e) return !1;\n      const r = !!i && t.framesDecodeFreezeTime > i.framesDecodeFreezeTime,\n        n = !i || t.framesDecodeCount > i.framesDecodeCount;\n      return r || !n;\n    }\n    static isRemoteAudioFreeze(e) {\n      return !!e && e._isFreeze();\n    }\n    isLocalVideoFreeze(e) {\n      return !(!e.inputFrame || !e.sentFrame) && e.inputFrame.frameRate > 5 && e.sentFrame.frameRate < 3;\n    }\n    updateLocalStats(e) {\n      Array.from(this.localStats.entries()).forEach(t => {\n        let [i, r] = t;\n        switch (i) {\n          case Cg.LocalVideoTrack:\n          case Cg.LocalVideoLowTrack:\n            {\n              const t = r,\n                n = ER({}, Bm),\n                o = e.getStats(),\n                s = e.getLocalMedia(i);\n              if (o) {\n                const i = o.videoSend.find(e => e.ssrc === (null == s ? void 0 : s.ssrcs[0].ssrcId));\n                if (i) {\n                  const r = e.getLocalVideoSize(),\n                    o = e.getEncoderConfig(Cg.LocalVideoTrack);\n                  \"H264\" !== i.codec && \"VP8\" !== i.codec && \"VP9\" !== i.codec && \"AV1X\" !== i.codec && \"AV1\" !== i.codec || (n.codecType = i.codec), n.sendBytes = i.bytes, n.sendBitrate = t ? 8 * Math.max(0, n.sendBytes - t.sendBytes) : 0, i.inputFrame ? (n.captureFrameRate = i.inputFrame.frameRate, n.captureResolutionHeight = i.inputFrame.height, n.captureResolutionWidth = i.inputFrame.width) : r && (n.captureResolutionWidth = r.width, n.captureResolutionHeight = r.height), i.sentFrame ? (n.sendFrameRate = i.sentFrame.frameRate, n.sendResolutionHeight = i.sentFrame.height, n.sendResolutionWidth = i.sentFrame.width) : r && (n.sendResolutionWidth = r.width, n.sendResolutionHeight = r.height), i.avgEncodeMs && (n.encodeDelay = i.avgEncodeMs), o && o.bitrateMax && (n.targetSendBitrate = 1e3 * o.bitrateMax), n.sendPackets = i.packets, n.sendPacketsLost = i.packetsLost, n.totalDuration = t ? t.totalDuration + 1 : 1, n.totalFreezeTime = t ? t.totalFreezeTime : 0, this.isLocalVideoFreeze(i) && (n.totalFreezeTime += 1);\n                }\n                this.trafficStats && (n.sendPacketsLost = this.trafficStats.B_pvlr4 / 100);\n              }\n              this.localStats.set(i, n), n && s && this.exceptionMonitor.setLocalVideoStats(this.store.uid, s.track, n);\n              break;\n            }\n          case Cg.LocalAudioTrack:\n            {\n              const t = r,\n                n = ER({}, Fm),\n                o = e.getStats(),\n                s = e.getLocalMedia(i);\n              if (o) {\n                const i = o.audioSend.find(e => e.ssrc === (null == s ? void 0 : s.ssrcs[0].ssrcId));\n                if (i) {\n                  if (\"opus\" !== i.codec && \"aac\" !== i.codec && \"PCMU\" !== i.codec && \"PCMA\" !== i.codec && \"G722\" !== i.codec || (n.codecType = i.codec), i.inputLevel) n.sendVolumeLevel = Math.round(32767 * i.inputLevel);else {\n                    const t = e.getLocalAudioVolume();\n                    t && (n.sendVolumeLevel = Math.round(32767 * t));\n                  }\n                  n.sendBytes = i.bytes, n.sendPackets = i.packets, n.sendPacketsLost = i.packetsLost, n.sendBitrate = t ? 8 * Math.max(0, n.sendBytes - t.sendBytes) : 0;\n                }\n              }\n              this.trafficStats && (n.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(Cg.LocalAudioTrack, n), n && s && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s.track, n);\n              break;\n            }\n        }\n      });\n    }\n    updateRemoteStats(e) {\n      Array.from(this.remoteStats.entries()).forEach(t => {\n        let [i, {\n          videoStats: r,\n          audioStats: n,\n          videoPcStats: o\n        }] = t;\n        const s = n,\n          a = r,\n          c = o,\n          d = ER({}, Gm),\n          u = ER({}, Hm),\n          l = ER({}, Wm),\n          {\n            audioTrack: h,\n            videoTrack: p,\n            audioSSRC: _,\n            videoSSRC: E\n          } = e.getRemoteMedia(i),\n          f = e.getStats(),\n          m = null == f ? void 0 : f.audioRecv.find(e => e.ssrc === _),\n          g = null == f ? void 0 : f.videoRecv.find(e => e.ssrc === E),\n          S = this.trafficStats && this.trafficStats.peer_delay.find(e => e.peer_uid === i);\n        if (m && (\"opus\" !== m.codec && \"aac\" !== m.codec && \"PCMU\" !== m.codec && \"PCMA\" !== m.codec && \"G722\" !== m.codec || (d.codecType = m.codec), m.outputLevel ? d.receiveLevel = Math.round(32767 * m.outputLevel) : h && (d.receiveLevel = Math.round(32767 * h.getVolumeLevel())), d.receiveBytes = m.bytes, d.receivePackets = m.packets, d.receivePacketsLost = m.packetsLost, d.packetLossRate = d.receivePacketsLost / (d.receivePackets + d.receivePacketsLost), d.receiveBitrate = s ? 8 * Math.max(0, d.receiveBytes - s.receiveBytes) : 0, d.totalDuration = s ? s.totalDuration + 1 : 1, d.totalFreezeTime = s ? s.totalFreezeTime : 0, d.freezeRate = d.totalFreezeTime / d.totalDuration, d.receiveDelay = m.jitterBufferMs, d.totalDuration > 10 && fR.isRemoteAudioFreeze(h) && (d.totalFreezeTime += 1)), g) {\n          \"H264\" !== g.codec && \"VP8\" !== g.codec && \"VP9\" !== g.codec && \"AV1X\" !== g.codec && \"AV1\" !== g.codec || (u.codecType = g.codec), u.receiveBytes = g.bytes, u.receiveBitrate = a ? 8 * Math.max(0, u.receiveBytes - a.receiveBytes) : 0, u.decodeFrameRate = g.decodeFrameRate < 0 ? 0 : g.decodeFrameRate, u.renderFrameRate = g.decodeFrameRate < 0 ? 0 : g.decodeFrameRate, g.outputFrame && (u.renderFrameRate = g.outputFrame.frameRate), g.receivedFrame ? (u.receiveFrameRate = g.receivedFrame.frameRate, u.receiveResolutionHeight = g.receivedFrame.height, u.receiveResolutionWidth = g.receivedFrame.width) : p && (u.receiveResolutionHeight = p._videoHeight || 0, u.receiveResolutionWidth = p._videoWidth || 0), void 0 !== g.framesRateFirefox && (u.receiveFrameRate = Math.round(g.framesRateFirefox)), u.receivePackets = g.packets, u.receivePacketsLost = g.packetsLost, u.packetLossRate = u.receivePacketsLost / (u.receivePackets + u.receivePacketsLost), u.totalDuration = a ? a.totalDuration + 1 : 1, u.totalFreezeTime = a ? a.totalFreezeTime : 0, u.receiveDelay = g.jitterBufferMs || 0;\n          const t = !!E && e.getRemoteVideoIsReady(E);\n          p && t && fR.isRemoteVideoFreeze(p, g, c) && (u.totalFreezeTime += 1), u.freezeRate = u.totalFreezeTime / u.totalDuration;\n        }\n        S && (d.end2EndDelay = S.B_ad, u.end2EndDelay = S.B_vd, d.transportDelay = S.B_ed, u.transportDelay = S.B_ed, d.currentPacketLossRate = S.B_ealr4 / 100, u.currentPacketLossRate = S.B_evlr4 / 100, l.uplinkNetworkQuality = S.B_punq ? S.B_punq : 0, l.downlinkNetworkQuality = S.B_pdnq ? S.B_pdnq : 0), this.remoteStats.set(i, {\n          audioStats: d,\n          videoStats: u,\n          videoPcStats: g,\n          networkStats: l\n        }), h && this.exceptionMonitor.setRemoteAudioStats(h, d), p && this.exceptionMonitor.setRemoteVideoStats(p, u);\n      });\n    }\n  }\n  const mR = new class extends gE {\n    get visibility() {\n      return document.visibilityState;\n    }\n    get lastHiddenTime() {\n      return this._lastHiddenTime;\n    }\n    get lastVisibleTime() {\n      return this._lastVisibleTime;\n    }\n    constructor() {\n      super(), mp(this, \"_lastHiddenTime\", 0), mp(this, \"_lastVisibleTime\", 0), document.addEventListener(\"visibilitychange\", () => {\n        \"hidden\" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), NE.debug(\"document visibility went \".concat(document.visibilityState)), this.emit(\"VISIBILITY_CHANGE\", document.visibilityState);\n      });\n    }\n  }();\n  function gR(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function SR(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? gR(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : gR(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function TR(e) {\n    return e.match(/^[\\.\\:\\d]+$/) ? \"\".concat(e.replace(/[^\\d]/g, \"-\"), \".\").concat(HE(\"TURN_DOMAIN\")) : (NE.info(\"Cannot recognized as IP address \".concat(e, \". Used As Host instead\")), e);\n  }\n  function vR(e, t) {\n    var i, r;\n    const n = HE(\"GATEWAY_DOMAINS\");\n    let o = n[1] && -1 !== t.indexOf(n[1]) ? 1 : 0;\n    e.addresses = e.addresses || [];\n    const s = e.addresses.map(e => e.domain_prefix ? {\n      address: \"\".concat(e.domain_prefix, \".\").concat(n[o++ % n.length], \":\").concat(e.port)\n    } : e.ip.match(/^[\\.\\:\\d]+$/) ? {\n      ip: e.ip,\n      port: e.port,\n      address: \"\".concat(e.ip.replace(/[^\\d]/g, \"-\"), \".\").concat(n[o++ % n.length], \":\").concat(e.port)\n    } : (NE.info(\"Cannot recognized as IP address \".concat(e.ip, \". Used As Host instead\")), {\n      ip: e.ip,\n      port: e.port,\n      address: \"\".concat(e.ip, \":\").concat(e.port)\n    }));\n    if (null !== (i = e.detail) && void 0 !== i && i[18] && \"string\" == typeof (null === (r = e.detail) || void 0 === r ? void 0 : r[18])) {\n      const t = e.detail[18],\n        i = null == t ? void 0 : t.split(\";\");\n      for (let e = 0; e < i.length; e++) {\n        var a;\n        const t = Ih(a = i[e]).call(a);\n        s[e] && t && (s[e].ip6 = t);\n      }\n    }\n    return {\n      gatewayAddrs: s,\n      uid: e.uid,\n      cid: e.cid,\n      cert: e.cert,\n      vid: e.detail && e.detail[8],\n      uni_lbs_ip: e.detail && e.detail[1],\n      res: e,\n      csIp: e.detail && e.detail[502]\n    };\n  }\n  function RR(e) {\n    return \"number\" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0;\n  }\n  function IR(e) {\n    const t = e._encoderConfig;\n    if (!t) return {};\n    const i = {\n      resolution: t.width && t.height ? \"\".concat(RR(t.width), \"x\").concat(RR(t.height)) : void 0,\n      maxVideoBW: t.bitrateMax,\n      minVideoBW: t.bitrateMin\n    };\n    return \"number\" == typeof t.frameRate ? (i.maxFrameRate = t.frameRate, i.minFrameRate = t.frameRate) : t.frameRate && (i.maxFrameRate = t.frameRate.max || t.frameRate.ideal || t.frameRate.exact || t.frameRate.min, i.minFrameRate = t.frameRate.min || t.frameRate.ideal || t.frameRate.exact || t.frameRate.max), i;\n  }\n  function yR(e, t, i) {\n    var r;\n    const n = t.videoSend.find(t => t.ssrc === e);\n    if (!n) return null;\n    const o = null == i || null === (r = i.videoSend.find(t => t.ssrc === e)) || void 0 === r ? void 0 : r.inputFrame,\n      s = {\n        id: MR(10, \"\"),\n        timestamp: new Date(t.timestamp).toISOString(),\n        mediaType: \"video\",\n        type: \"ssrc\",\n        ssrc: n.ssrc.toString()\n      };\n    return n.inputFrame && (o && n.inputFrame.height === o.height || (s.A_fhi = n.inputFrame.height ? n.inputFrame.height.toString() : \"0\"), o && n.inputFrame.width === o.width || (s.A_fwi = n.inputFrame.width ? n.inputFrame.width.toString() : \"0\"), o && n.inputFrame.frameRate === o.frameRate || (s.A_fri = n.inputFrame.frameRate ? n.inputFrame.frameRate.toString() : \"0\")), s;\n  }\n  function CR(e) {\n    return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0;\n  }\n  function AR(e, t) {\n    let i,\n      r,\n      n = void 0;\n    switch (t) {\n      case Fg.CHOOSE_SERVER:\n        i = 4096, r = \"choose server\";\n        break;\n      case Fg.CLOUD_PROXY:\n        i = 1048576, r = \"proxy\";\n        break;\n      case Fg.CLOUD_PROXY_5:\n        i = 4194304, r = \"proxy5\";\n        break;\n      case Fg.CLOUD_PROXY_FALLBACK:\n        i = 4194310, r = \"proxy fallback\";\n        break;\n      default:\n        throw new vE(TE.UNEXPECTED_ERROR, \"multi unlibs response transformer get unknown service id\", {\n          csIp: e.detail && e.detail[502],\n          retry: !1\n        });\n    }\n    if (e.response_body.forEach(t => {\n      t.buffer && t.buffer.flag === i && (n = {\n        code: t.buffer.code,\n        addresses: (t.buffer.edges_services || []).map(e => SR(SR({}, e), {}, {\n          ticket: t.buffer.cert\n        })),\n        server_ts: e.enter_ts,\n        uid: t.buffer.uid,\n        cid: t.buffer.cid,\n        cname: t.buffer.cname,\n        detail: SR(SR({}, t.buffer.detail), e.detail),\n        flag: t.buffer.flag,\n        opid: e.opid,\n        cert: t.buffer.cert\n      });\n    }), !n) throw new vE(TE.MULTI_UNILBS_RESPONSE_ERROR, \"cannot parse response \".concat(r, \" from multi unilbs response\"), {\n      csIp: e.detail && e.detail[502]\n    });\n    return n;\n  }\n  async function OR(e, t) {\n    return await Cl.all(e.addresses.map(async e => ({\n      address: TR(e.ip),\n      tcpport: e.port,\n      udpport: e.port,\n      username: t && HE(\"ENCRYPT_PROXY_USERNAME_AND_PSW\") && window.isSecureContext ? t.toString() : kE.username,\n      password: t && HE(\"ENCRYPT_PROXY_USERNAME_AND_PSW\") && window.isSecureContext ? await ST(t.toString()) : kE.password\n    })));\n  }\n  function bR(e, t) {\n    const i = t._videoWidth || t.getMediaStreamTrack(!0).getSettings().width;\n    return i || NE.warning(\"cannot get original video track's width, default scale down 4 times for low stream\"), i ? i / RR(e.width) : 4;\n  }\n  function wR(e) {\n    let {\n      candidateType: t,\n      relayProtocol: i,\n      type: r,\n      address: n,\n      port: o,\n      protocol: s\n    } = e;\n    return \"local-candidate\" === r ? {\n      candidateType: t,\n      relayProtocol: i,\n      protocol: s\n    } : {\n      candidateType: t,\n      relayProtocol: i,\n      address: n,\n      port: o,\n      protocol: s\n    };\n  }\n  function NR(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function DR(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? NR(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : NR(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function PR(e) {\n    return window.TextEncoder ? new TextEncoder().encode(e).length : e.length;\n  }\n  function LR(e) {\n    return new Cl(t => {\n      window.setTimeout(t, e);\n    });\n  }\n  function kR(e) {\n    const t = new vE(TE.TIMEOUT, \"timeout\");\n    return new Cl((i, r) => {\n      window.setTimeout(() => r(t), e);\n    });\n  }\n  function MR() {\n    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,\n      t = arguments.length > 1 ? arguments[1] : void 0;\n    const i = Math.random().toString(16).substr(2, e).toLowerCase();\n    return i.length === e ? \"\".concat(t).concat(i) : \"\".concat(t).concat(i) + MR(e - i.length, \"\");\n  }\n  function UR() {\n    return MR(32, \"\").toUpperCase();\n  }\n  const xR = () => {};\n  function VR(e) {\n    return new Cl((t, i) => {\n      let r = !1;\n      const n = document.createElement(\"video\");\n      n.setAttribute(\"autoplay\", \"\"), n.setAttribute(\"muted\", \"\"), n.muted = !0, n.autoplay = !0, n.setAttribute(\"playsinline\", \"\"), n.setAttribute(\"style\", \"position: fixed; top: 0; left: 0; width: 1px; height: 1px\"), document.body.appendChild(n);\n      const o = Zh() ? \"canplay\" : \"playing\";\n      n.addEventListener(o, () => {\n        const e = n.videoWidth,\n          i = n.videoHeight;\n        !e && Qh() || (r = !0, n.srcObject = null, n.remove(), t([e, i]));\n      }), n.srcObject = new MediaStream([e]), n.play().catch(xR), setTimeout(() => {\n        r || (n.srcObject = null, n.remove(), t([n.videoWidth, n.videoHeight]));\n      }, 4e3);\n    });\n  }\n  function jR(e) {\n    return Cl.all(e.map(e => e.then(e => {\n      throw e;\n    }, e => e))).then(e => {\n      throw e;\n    }, e => e);\n  }\n  function FR(e, t) {\n    for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), n = 2; n < i; n++) r[n - 2] = arguments[n];\n    return 0 === e.getListeners(t).length ? Cl.reject(new vE(TE.UNEXPECTED_ERROR, \"can not emit promise\")) : new Cl((i, n) => {\n      e.emit(t, ...r, i, n);\n    });\n  }\n  function BR(e, t) {\n    if (0 === e.getListeners(t).length) return Cl.resolve();\n    for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), n = 2; n < i; n++) r[n - 2] = arguments[n];\n    return FR(e, t, ...r);\n  }\n  function GR(e, t) {\n    if (0 === e.getListeners(t).length) return null;\n    for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), n = 2; n < i; n++) r[n - 2] = arguments[n];\n    return WR(e, t, ...r);\n  }\n  function WR(e, t) {\n    let i = null,\n      r = null;\n    for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), s = 2; s < n; s++) o[s - 2] = arguments[s];\n    if (e.emit(t, ...o, e => {\n      i = e;\n    }, e => {\n      r = e;\n    }), null !== r) throw r;\n    if (null === i) throw new vE(TE.UNEXPECTED_ERROR, \"handler is not sync\");\n    return i;\n  }\n  function HR(e, t) {\n    const i = e.indexOf(t);\n    -1 !== i && e.splice(i, 1);\n  }\n  function KR(e) {\n    const t = [];\n    return e.forEach(e => {\n      -1 === t.indexOf(e) && t.push(e);\n    }), t;\n  }\n  function YR(e) {\n    Cl.resolve().then(e);\n  }\n  function qR(e) {\n    return JSON.parse(JSON.stringify(e));\n  }\n  const JR = {};\n  function XR(e, t) {\n    JR[t] || (JR[t] = !0, e());\n  }\n  function zR(e) {\n    const t = window.atob(e),\n      i = new Uint8Array(new ArrayBuffer(t.length));\n    for (let e = 0; e < t.length; e += 1) i[e] = t.charCodeAt(e);\n    return i;\n  }\n  function QR(e) {\n    let t = \"\";\n    for (let i = 0; i < e.length; i += 1) t += String.fromCharCode(e[i]);\n    return window.btoa(t);\n  }\n  const ZR = new class {\n      constructor() {\n        mp(this, \"fnMap\", new Map());\n      }\n      throttleByKey(e, t, i, r) {\n        for (var n = arguments.length, o = new Array(n > 4 ? n - 4 : 0), s = 4; s < n; s++) o[s - 4] = arguments[s];\n        if (this.fnMap.has(t)) {\n          const n = this.fnMap.get(t);\n          if (n.threshold !== i) {\n            n.fn(...n.args), clearTimeout(n.timer);\n            const s = window.setTimeout(() => {\n              const e = this.fnMap.get(t);\n              e && e.fn(...e.args), this.fnMap.delete(t);\n            }, i);\n            this.fnMap.set(t, {\n              fn: e,\n              threshold: i,\n              timer: s,\n              args: o,\n              skipFn: r\n            });\n          } else n.skipFn && n.skipFn(...n.args), this.fnMap.set(t, DR(DR({}, n), {}, {\n            fn: e,\n            args: o,\n            skipFn: r\n          }));\n        } else {\n          const n = window.setTimeout(() => {\n            const e = this.fnMap.get(t);\n            e && e.fn(...e.args), this.fnMap.delete(t);\n          }, i);\n          this.fnMap.set(t, {\n            fn: e,\n            threshold: i,\n            timer: n,\n            args: o,\n            skipFn: r\n          });\n        }\n      }\n    }(),\n    $R = ZR.throttleByKey.bind(ZR),\n    eI = async e => {\n      let {\n          fragementLength: t,\n          referenceList: i,\n          asyncMapHandler: r,\n          allFailedhandler: n,\n          promisesCollector: o\n        } = e,\n        s = 0;\n      const a = t;\n      let c,\n        d = 0;\n      const u = async () => {\n        const e = (() => {\n          const e = s * a,\n            t = e + a;\n          return i.slice(e, t).map(r);\n        })();\n        o && o.push(...e);\n        try {\n          c = await jR(e);\n        } catch (e) {\n          if (d += a, s++, !(d >= i.length)) return void (await u());\n          n(e);\n        }\n        e.forEach(e => e.cancel());\n      };\n      return await u(), c;\n    };\n  function tI(e) {\n    return \"object\" == typeof e && null !== e && !(e instanceof RegExp);\n  }\n  var iI = i,\n    rI = nt(\"iterator\"),\n    nI = !iI(function () {\n      var e = new URL(\"b?a=1&b=2&c=3\", \"http://a\"),\n        t = e.searchParams,\n        i = \"\";\n      return e.pathname = \"c%20d\", t.forEach(function (e, r) {\n        t.delete(\"b\"), i += r + e;\n      }), !e.toJSON || !t.sort || \"http://a/c%20d?a=1&c=3\" !== e.href || \"3\" !== t.get(\"c\") || \"a=1\" !== String(new URLSearchParams(\"?a=1\")) || !t[rI] || \"a\" !== new URL(\"https://a@b\").username || \"b\" !== new URLSearchParams(new URLSearchParams(\"a=b\")).get(\"a\") || \"xn--e1aybc\" !== new URL(\"http://ÑÐµÑÑ\").host || \"#%D0%B1\" !== new URL(\"http://a#Ð±\").hash || \"a1c3\" !== i || \"x\" !== new URL(\"http://x\", void 0).host;\n    }),\n    oI = T,\n    sI = d,\n    aI = I,\n    cI = i,\n    dI = hn,\n    uI = Qr,\n    lI = y,\n    hI = je,\n    pI = F,\n    _I = Object.assign,\n    EI = Object.defineProperty,\n    fI = sI([].concat),\n    mI = !_I || cI(function () {\n      if (oI && 1 !== _I({\n        b: 1\n      }, _I(EI({}, \"a\", {\n        enumerable: !0,\n        get: function () {\n          EI(this, \"b\", {\n            value: 3,\n            enumerable: !1\n          });\n        }\n      }), {\n        b: 2\n      })).b) return !0;\n      var e = {},\n        t = {},\n        i = Symbol(),\n        r = \"abcdefghijklmnopqrst\";\n      return e[i] = 7, r.split(\"\").forEach(function (e) {\n        t[e] = e;\n      }), 7 != _I({}, e)[i] || dI(_I({}, t)).join(\"\") != r;\n    }) ? function (e, t) {\n      for (var i = hI(e), r = arguments.length, n = 1, o = uI.f, s = lI.f; r > n;) for (var a, c = pI(arguments[n++]), d = o ? fI(dI(c), o(c)) : dI(c), u = d.length, l = 0; u > l;) a = d[l++], oI && !aI(s, c, a) || (i[a] = c[a]);\n      return i;\n    } : _I,\n    gI = zt,\n    SI = fo,\n    TI = Wt,\n    vI = I,\n    RI = je,\n    II = function (e, t, i, r) {\n      try {\n        return r ? t(gI(i)[0], i[1]) : t(i);\n      } catch (t) {\n        SI(e, \"throw\", t);\n      }\n    },\n    yI = Wn,\n    CI = lc,\n    AI = wi,\n    OI = nf,\n    bI = ho,\n    wI = no,\n    NI = h.Array,\n    DI = d,\n    PI = 2147483647,\n    LI = /[^\\0-\\u007E]/,\n    kI = /[.\\u3002\\uFF0E\\uFF61]/g,\n    MI = \"Overflow: input needs wider integers to process\",\n    UI = h.RangeError,\n    xI = DI(kI.exec),\n    VI = Math.floor,\n    jI = String.fromCharCode,\n    FI = DI(\"\".charCodeAt),\n    BI = DI([].join),\n    GI = DI([].push),\n    WI = DI(\"\".replace),\n    HI = DI(\"\".split),\n    KI = DI(\"\".toLowerCase),\n    YI = function (e) {\n      return e + 22 + 75 * (e < 26);\n    },\n    qI = function (e, t, i) {\n      var r = 0;\n      for (e = i ? VI(e / 700) : e >> 1, e += VI(e / t); e > 455;) e = VI(e / 35), r += 36;\n      return VI(r + 36 * e / (e + 38));\n    },\n    JI = function (e) {\n      var t,\n        i,\n        r = [],\n        n = (e = function (e) {\n          for (var t = [], i = 0, r = e.length; i < r;) {\n            var n = FI(e, i++);\n            if (n >= 55296 && n <= 56319 && i < r) {\n              var o = FI(e, i++);\n              56320 == (64512 & o) ? GI(t, ((1023 & n) << 10) + (1023 & o) + 65536) : (GI(t, n), i--);\n            } else GI(t, n);\n          }\n          return t;\n        }(e)).length,\n        o = 128,\n        s = 0,\n        a = 72;\n      for (t = 0; t < e.length; t++) (i = e[t]) < 128 && GI(r, jI(i));\n      var c = r.length,\n        d = c;\n      for (c && GI(r, \"-\"); d < n;) {\n        var u = PI;\n        for (t = 0; t < e.length; t++) (i = e[t]) >= o && i < u && (u = i);\n        var l = d + 1;\n        if (u - o > VI((PI - s) / l)) throw UI(MI);\n        for (s += (u - o) * l, o = u, t = 0; t < e.length; t++) {\n          if ((i = e[t]) < o && ++s > PI) throw UI(MI);\n          if (i == o) {\n            for (var h = s, p = 36;;) {\n              var _ = p <= a ? 1 : p >= a + 26 ? 26 : p - a;\n              if (h < _) break;\n              var E = h - _,\n                f = 36 - _;\n              GI(r, jI(YI(_ + E % f))), h = VI(E / f), p += 36;\n            }\n            GI(r, jI(YI(h))), a = qI(s, l, d == c), s = 0, d++;\n          }\n        }\n        s++, o++;\n      }\n      return BI(r, \"\");\n    },\n    XI = h.TypeError,\n    zI = Ri,\n    QI = h,\n    ZI = $,\n    $I = I,\n    ey = d,\n    ty = nI,\n    iy = Fs,\n    ry = Ua,\n    ny = na,\n    oy = la,\n    sy = Ps,\n    ay = Wa,\n    cy = g,\n    dy = Ge,\n    uy = Wt,\n    ly = $n,\n    hy = zt,\n    py = q,\n    _y = Lo,\n    Ey = Pn,\n    fy = N,\n    my = ho,\n    gy = no,\n    Sy = function (e, t) {\n      if (e < t) throw XI(\"Not enough arguments\");\n      return e;\n    },\n    Ty = ff,\n    vy = nt(\"iterator\"),\n    Ry = \"URLSearchParams\",\n    Iy = \"URLSearchParamsIterator\",\n    yy = sy.set,\n    Cy = sy.getterFor(Ry),\n    Ay = sy.getterFor(Iy),\n    Oy = ZI(\"fetch\"),\n    by = ZI(\"Request\"),\n    wy = ZI(\"Headers\"),\n    Ny = by && by.prototype,\n    Dy = wy && wy.prototype,\n    Py = QI.RegExp,\n    Ly = QI.TypeError,\n    ky = QI.decodeURIComponent,\n    My = QI.encodeURIComponent,\n    Uy = ey(\"\".charAt),\n    xy = ey([].join),\n    Vy = ey([].push),\n    jy = ey(\"\".replace),\n    Fy = ey([].shift),\n    By = ey([].splice),\n    Gy = ey(\"\".split),\n    Wy = ey(\"\".slice),\n    Hy = /\\+/g,\n    Ky = Array(4),\n    Yy = function (e) {\n      return Ky[e - 1] || (Ky[e - 1] = Py(\"((?:%[\\\\da-f]{2}){\" + e + \"})\", \"gi\"));\n    },\n    qy = function (e) {\n      try {\n        return ky(e);\n      } catch (t) {\n        return e;\n      }\n    },\n    Jy = function (e) {\n      var t = jy(e, Hy, \" \"),\n        i = 4;\n      try {\n        return ky(t);\n      } catch (e) {\n        for (; i;) t = jy(t, Yy(i--), qy);\n        return t;\n      }\n    },\n    Xy = /[!'()~]|%20/g,\n    zy = {\n      \"!\": \"%21\",\n      \"'\": \"%27\",\n      \"(\": \"%28\",\n      \")\": \"%29\",\n      \"~\": \"%7E\",\n      \"%20\": \"+\"\n    },\n    Qy = function (e) {\n      return zy[e];\n    },\n    Zy = function (e) {\n      return jy(My(e), Xy, Qy);\n    },\n    $y = oy(function (e, t) {\n      yy(this, {\n        type: Iy,\n        iterator: my(Cy(e).entries),\n        kind: t\n      });\n    }, \"Iterator\", function () {\n      var e = Ay(this),\n        t = e.kind,\n        i = e.iterator.next(),\n        r = i.value;\n      return i.done || (i.value = \"keys\" === t ? r.key : \"values\" === t ? r.value : [r.key, r.value]), i;\n    }, !0),\n    eC = function (e) {\n      this.entries = [], this.url = null, void 0 !== e && (py(e) ? this.parseObject(e) : this.parseQuery(\"string\" == typeof e ? \"?\" === Uy(e, 0) ? Wy(e, 1) : e : _y(e)));\n    };\n  eC.prototype = {\n    type: Ry,\n    bindURL: function (e) {\n      this.url = e, this.update();\n    },\n    parseObject: function (e) {\n      var t,\n        i,\n        r,\n        n,\n        o,\n        s,\n        a,\n        c = gy(e);\n      if (c) for (i = (t = my(e, c)).next; !(r = $I(i, t)).done;) {\n        if (o = (n = my(hy(r.value))).next, (s = $I(o, n)).done || (a = $I(o, n)).done || !$I(o, n).done) throw Ly(\"Expected sequence with length 2\");\n        Vy(this.entries, {\n          key: _y(s.value),\n          value: _y(a.value)\n        });\n      } else for (var d in e) dy(e, d) && Vy(this.entries, {\n        key: d,\n        value: _y(e[d])\n      });\n    },\n    parseQuery: function (e) {\n      if (e) for (var t, i, r = Gy(e, \"&\"), n = 0; n < r.length;) (t = r[n++]).length && (i = Gy(t, \"=\"), Vy(this.entries, {\n        key: Jy(Fy(i)),\n        value: Jy(xy(i, \"=\"))\n      }));\n    },\n    serialize: function () {\n      for (var e, t = this.entries, i = [], r = 0; r < t.length;) e = t[r++], Vy(i, Zy(e.key) + \"=\" + Zy(e.value));\n      return xy(i, \"&\");\n    },\n    update: function () {\n      this.entries.length = 0, this.parseQuery(this.url.query);\n    },\n    updateURL: function () {\n      this.url && this.url.update();\n    }\n  };\n  var tC = function () {\n      ay(this, iC);\n      var e = arguments.length > 0 ? arguments[0] : void 0;\n      yy(this, new eC(e));\n    },\n    iC = tC.prototype;\n  if (ry(iC, {\n    append: function (e, t) {\n      Sy(arguments.length, 2);\n      var i = Cy(this);\n      Vy(i.entries, {\n        key: _y(e),\n        value: _y(t)\n      }), i.updateURL();\n    },\n    delete: function (e) {\n      Sy(arguments.length, 1);\n      for (var t = Cy(this), i = t.entries, r = _y(e), n = 0; n < i.length;) i[n].key === r ? By(i, n, 1) : n++;\n      t.updateURL();\n    },\n    get: function (e) {\n      Sy(arguments.length, 1);\n      for (var t = Cy(this).entries, i = _y(e), r = 0; r < t.length; r++) if (t[r].key === i) return t[r].value;\n      return null;\n    },\n    getAll: function (e) {\n      Sy(arguments.length, 1);\n      for (var t = Cy(this).entries, i = _y(e), r = [], n = 0; n < t.length; n++) t[n].key === i && Vy(r, t[n].value);\n      return r;\n    },\n    has: function (e) {\n      Sy(arguments.length, 1);\n      for (var t = Cy(this).entries, i = _y(e), r = 0; r < t.length;) if (t[r++].key === i) return !0;\n      return !1;\n    },\n    set: function (e, t) {\n      Sy(arguments.length, 1);\n      for (var i, r = Cy(this), n = r.entries, o = !1, s = _y(e), a = _y(t), c = 0; c < n.length; c++) (i = n[c]).key === s && (o ? By(n, c--, 1) : (o = !0, i.value = a));\n      o || Vy(n, {\n        key: s,\n        value: a\n      }), r.updateURL();\n    },\n    sort: function () {\n      var e = Cy(this);\n      Ty(e.entries, function (e, t) {\n        return e.key > t.key ? 1 : -1;\n      }), e.updateURL();\n    },\n    forEach: function (e) {\n      for (var t, i = Cy(this).entries, r = uy(e, arguments.length > 1 ? arguments[1] : void 0), n = 0; n < i.length;) r((t = i[n++]).value, t.key, this);\n    },\n    keys: function () {\n      return new $y(this, \"keys\");\n    },\n    values: function () {\n      return new $y(this, \"values\");\n    },\n    entries: function () {\n      return new $y(this, \"entries\");\n    }\n  }, {\n    enumerable: !0\n  }), iy(iC, vy, iC.entries, {\n    name: \"entries\"\n  }), iy(iC, \"toString\", function () {\n    return Cy(this).serialize();\n  }, {\n    enumerable: !0\n  }), ny(tC, Ry), zI({\n    global: !0,\n    forced: !ty\n  }, {\n    URLSearchParams: tC\n  }), !ty && cy(wy)) {\n    var rC = ey(Dy.has),\n      nC = ey(Dy.set),\n      oC = function (e) {\n        if (py(e)) {\n          var t,\n            i = e.body;\n          if (ly(i) === Ry) return t = e.headers ? new wy(e.headers) : new wy(), rC(t, \"content-type\") || nC(t, \"content-type\", \"application/x-www-form-urlencoded;charset=UTF-8\"), Ey(e, {\n            body: fy(0, _y(i)),\n            headers: fy(0, t)\n          });\n        }\n        return e;\n      };\n    if (cy(Oy) && zI({\n      global: !0,\n      enumerable: !0,\n      forced: !0\n    }, {\n      fetch: function (e) {\n        return Oy(e, arguments.length > 1 ? oC(arguments[1]) : {});\n      }\n    }), cy(by)) {\n      var sC = function (e) {\n        return ay(this, Ny), new by(e, arguments.length > 1 ? oC(arguments[1]) : {});\n      };\n      Ny.constructor = sC, sC.prototype = Ny, zI({\n        global: !0,\n        forced: !0\n      }, {\n        Request: sC\n      });\n    }\n  }\n  var aC,\n    cC = {\n      URLSearchParams: tC,\n      getState: Cy\n    },\n    dC = Ri,\n    uC = T,\n    lC = nI,\n    hC = h,\n    pC = Wt,\n    _C = d,\n    EC = dn.f,\n    fC = Fs,\n    mC = Wa,\n    gC = Ge,\n    SC = mI,\n    TC = function (e) {\n      var t = RI(e),\n        i = CI(this),\n        r = arguments.length,\n        n = r > 1 ? arguments[1] : void 0,\n        o = void 0 !== n;\n      o && (n = TI(n, r > 2 ? arguments[2] : void 0));\n      var s,\n        a,\n        c,\n        d,\n        u,\n        l,\n        h = wI(t),\n        p = 0;\n      if (!h || this == NI && yI(h)) for (s = AI(t), a = i ? new this(s) : NI(s); s > p; p++) l = o ? n(t[p], p) : t[p], OI(a, p, l);else for (u = (d = bI(t, h)).next, a = i ? new this() : []; !(c = vI(u, d)).done; p++) l = o ? II(d, n, [c.value, p], !0) : c.value, OI(a, p, l);\n      return a.length = p, a;\n    },\n    vC = uf,\n    RC = sl.codeAt,\n    IC = function (e) {\n      var t,\n        i,\n        r = [],\n        n = HI(WI(KI(e), kI, \".\"), \".\");\n      for (t = 0; t < n.length; t++) i = n[t], GI(r, xI(LI, i) ? \"xn--\" + JI(i) : i);\n      return BI(r, \".\");\n    },\n    yC = Lo,\n    CC = na,\n    AC = cC,\n    OC = Ps,\n    bC = OC.set,\n    wC = OC.getterFor(\"URL\"),\n    NC = AC.URLSearchParams,\n    DC = AC.getState,\n    PC = hC.URL,\n    LC = hC.TypeError,\n    kC = hC.parseInt,\n    MC = Math.floor,\n    UC = Math.pow,\n    xC = _C(\"\".charAt),\n    VC = _C(/./.exec),\n    jC = _C([].join),\n    FC = _C(1..toString),\n    BC = _C([].pop),\n    GC = _C([].push),\n    WC = _C(\"\".replace),\n    HC = _C([].shift),\n    KC = _C(\"\".split),\n    YC = _C(\"\".slice),\n    qC = _C(\"\".toLowerCase),\n    JC = _C([].unshift),\n    XC = \"Invalid scheme\",\n    zC = \"Invalid host\",\n    QC = \"Invalid port\",\n    ZC = /[a-z]/i,\n    $C = /[\\d+-.a-z]/i,\n    eA = /\\d/,\n    tA = /^0x/i,\n    iA = /^[0-7]+$/,\n    rA = /^\\d+$/,\n    nA = /^[\\da-f]+$/i,\n    oA = /[\\0\\t\\n\\r #%/:<>?@[\\\\\\]^|]/,\n    sA = /[\\0\\t\\n\\r #/:<>?@[\\\\\\]^|]/,\n    aA = /^[\\u0000-\\u0020]+|[\\u0000-\\u0020]+$/g,\n    cA = /[\\t\\n\\r]/g,\n    dA = function (e) {\n      var t, i, r, n;\n      if (\"number\" == typeof e) {\n        for (t = [], i = 0; i < 4; i++) JC(t, e % 256), e = MC(e / 256);\n        return jC(t, \".\");\n      }\n      if (\"object\" == typeof e) {\n        for (t = \"\", r = function (e) {\n          for (var t = null, i = 1, r = null, n = 0, o = 0; o < 8; o++) 0 !== e[o] ? (n > i && (t = r, i = n), r = null, n = 0) : (null === r && (r = o), ++n);\n          return n > i && (t = r, i = n), t;\n        }(e), i = 0; i < 8; i++) n && 0 === e[i] || (n && (n = !1), r === i ? (t += i ? \":\" : \"::\", n = !0) : (t += FC(e[i], 16), i < 7 && (t += \":\")));\n        return \"[\" + t + \"]\";\n      }\n      return e;\n    },\n    uA = {},\n    lA = SC({}, uA, {\n      \" \": 1,\n      '\"': 1,\n      \"<\": 1,\n      \">\": 1,\n      \"`\": 1\n    }),\n    hA = SC({}, lA, {\n      \"#\": 1,\n      \"?\": 1,\n      \"{\": 1,\n      \"}\": 1\n    }),\n    pA = SC({}, hA, {\n      \"/\": 1,\n      \":\": 1,\n      \";\": 1,\n      \"=\": 1,\n      \"@\": 1,\n      \"[\": 1,\n      \"\\\\\": 1,\n      \"]\": 1,\n      \"^\": 1,\n      \"|\": 1\n    }),\n    _A = function (e, t) {\n      var i = RC(e, 0);\n      return i > 32 && i < 127 && !gC(t, e) ? e : encodeURIComponent(e);\n    },\n    EA = {\n      ftp: 21,\n      file: null,\n      http: 80,\n      https: 443,\n      ws: 80,\n      wss: 443\n    },\n    fA = function (e, t) {\n      var i;\n      return 2 == e.length && VC(ZC, xC(e, 0)) && (\":\" == (i = xC(e, 1)) || !t && \"|\" == i);\n    },\n    mA = function (e) {\n      var t;\n      return e.length > 1 && fA(YC(e, 0, 2)) && (2 == e.length || \"/\" === (t = xC(e, 2)) || \"\\\\\" === t || \"?\" === t || \"#\" === t);\n    },\n    gA = function (e) {\n      return \".\" === e || \"%2e\" === qC(e);\n    },\n    SA = {},\n    TA = {},\n    vA = {},\n    RA = {},\n    IA = {},\n    yA = {},\n    CA = {},\n    AA = {},\n    OA = {},\n    bA = {},\n    wA = {},\n    NA = {},\n    DA = {},\n    PA = {},\n    LA = {},\n    kA = {},\n    MA = {},\n    UA = {},\n    xA = {},\n    VA = {},\n    jA = {},\n    FA = function (e, t, i) {\n      var r,\n        n,\n        o,\n        s = yC(e);\n      if (t) {\n        if (n = this.parse(s)) throw LC(n);\n        this.searchParams = null;\n      } else {\n        if (void 0 !== i && (r = new FA(i, !0)), n = this.parse(s, null, r)) throw LC(n);\n        (o = DC(new NC())).bindURL(this), this.searchParams = o;\n      }\n    };\n  FA.prototype = {\n    type: \"URL\",\n    parse: function (e, t, i) {\n      var r,\n        n,\n        o,\n        s,\n        a,\n        c = this,\n        d = t || SA,\n        u = 0,\n        l = \"\",\n        h = !1,\n        p = !1,\n        _ = !1;\n      for (e = yC(e), t || (c.scheme = \"\", c.username = \"\", c.password = \"\", c.host = null, c.port = null, c.path = [], c.query = null, c.fragment = null, c.cannotBeABaseURL = !1, e = WC(e, aA, \"\")), e = WC(e, cA, \"\"), r = TC(e); u <= r.length;) {\n        switch (n = r[u], d) {\n          case SA:\n            if (!n || !VC(ZC, n)) {\n              if (t) return XC;\n              d = vA;\n              continue;\n            }\n            l += qC(n), d = TA;\n            break;\n          case TA:\n            if (n && (VC($C, n) || \"+\" == n || \"-\" == n || \".\" == n)) l += qC(n);else {\n              if (\":\" != n) {\n                if (t) return XC;\n                l = \"\", d = vA, u = 0;\n                continue;\n              }\n              if (t && (c.isSpecial() != gC(EA, l) || \"file\" == l && (c.includesCredentials() || null !== c.port) || \"file\" == c.scheme && !c.host)) return;\n              if (c.scheme = l, t) return void (c.isSpecial() && EA[c.scheme] == c.port && (c.port = null));\n              l = \"\", \"file\" == c.scheme ? d = PA : c.isSpecial() && i && i.scheme == c.scheme ? d = RA : c.isSpecial() ? d = AA : \"/\" == r[u + 1] ? (d = IA, u++) : (c.cannotBeABaseURL = !0, GC(c.path, \"\"), d = xA);\n            }\n            break;\n          case vA:\n            if (!i || i.cannotBeABaseURL && \"#\" != n) return XC;\n            if (i.cannotBeABaseURL && \"#\" == n) {\n              c.scheme = i.scheme, c.path = vC(i.path), c.query = i.query, c.fragment = \"\", c.cannotBeABaseURL = !0, d = jA;\n              break;\n            }\n            d = \"file\" == i.scheme ? PA : yA;\n            continue;\n          case RA:\n            if (\"/\" != n || \"/\" != r[u + 1]) {\n              d = yA;\n              continue;\n            }\n            d = OA, u++;\n            break;\n          case IA:\n            if (\"/\" == n) {\n              d = bA;\n              break;\n            }\n            d = UA;\n            continue;\n          case yA:\n            if (c.scheme = i.scheme, n == aC) c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = vC(i.path), c.query = i.query;else if (\"/\" == n || \"\\\\\" == n && c.isSpecial()) d = CA;else if (\"?\" == n) c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = vC(i.path), c.query = \"\", d = VA;else {\n              if (\"#\" != n) {\n                c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = vC(i.path), c.path.length--, d = UA;\n                continue;\n              }\n              c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, c.path = vC(i.path), c.query = i.query, c.fragment = \"\", d = jA;\n            }\n            break;\n          case CA:\n            if (!c.isSpecial() || \"/\" != n && \"\\\\\" != n) {\n              if (\"/\" != n) {\n                c.username = i.username, c.password = i.password, c.host = i.host, c.port = i.port, d = UA;\n                continue;\n              }\n              d = bA;\n            } else d = OA;\n            break;\n          case AA:\n            if (d = OA, \"/\" != n || \"/\" != xC(l, u + 1)) continue;\n            u++;\n            break;\n          case OA:\n            if (\"/\" != n && \"\\\\\" != n) {\n              d = bA;\n              continue;\n            }\n            break;\n          case bA:\n            if (\"@\" == n) {\n              h && (l = \"%40\" + l), h = !0, o = TC(l);\n              for (var E = 0; E < o.length; E++) {\n                var f = o[E];\n                if (\":\" != f || _) {\n                  var m = _A(f, pA);\n                  _ ? c.password += m : c.username += m;\n                } else _ = !0;\n              }\n              l = \"\";\n            } else if (n == aC || \"/\" == n || \"?\" == n || \"#\" == n || \"\\\\\" == n && c.isSpecial()) {\n              if (h && \"\" == l) return \"Invalid authority\";\n              u -= TC(l).length + 1, l = \"\", d = wA;\n            } else l += n;\n            break;\n          case wA:\n          case NA:\n            if (t && \"file\" == c.scheme) {\n              d = kA;\n              continue;\n            }\n            if (\":\" != n || p) {\n              if (n == aC || \"/\" == n || \"?\" == n || \"#\" == n || \"\\\\\" == n && c.isSpecial()) {\n                if (c.isSpecial() && \"\" == l) return zC;\n                if (t && \"\" == l && (c.includesCredentials() || null !== c.port)) return;\n                if (s = c.parseHost(l)) return s;\n                if (l = \"\", d = MA, t) return;\n                continue;\n              }\n              \"[\" == n ? p = !0 : \"]\" == n && (p = !1), l += n;\n            } else {\n              if (\"\" == l) return zC;\n              if (s = c.parseHost(l)) return s;\n              if (l = \"\", d = DA, t == NA) return;\n            }\n            break;\n          case DA:\n            if (!VC(eA, n)) {\n              if (n == aC || \"/\" == n || \"?\" == n || \"#\" == n || \"\\\\\" == n && c.isSpecial() || t) {\n                if (\"\" != l) {\n                  var g = kC(l, 10);\n                  if (g > 65535) return QC;\n                  c.port = c.isSpecial() && g === EA[c.scheme] ? null : g, l = \"\";\n                }\n                if (t) return;\n                d = MA;\n                continue;\n              }\n              return QC;\n            }\n            l += n;\n            break;\n          case PA:\n            if (c.scheme = \"file\", \"/\" == n || \"\\\\\" == n) d = LA;else {\n              if (!i || \"file\" != i.scheme) {\n                d = UA;\n                continue;\n              }\n              if (n == aC) c.host = i.host, c.path = vC(i.path), c.query = i.query;else if (\"?\" == n) c.host = i.host, c.path = vC(i.path), c.query = \"\", d = VA;else {\n                if (\"#\" != n) {\n                  mA(jC(vC(r, u), \"\")) || (c.host = i.host, c.path = vC(i.path), c.shortenPath()), d = UA;\n                  continue;\n                }\n                c.host = i.host, c.path = vC(i.path), c.query = i.query, c.fragment = \"\", d = jA;\n              }\n            }\n            break;\n          case LA:\n            if (\"/\" == n || \"\\\\\" == n) {\n              d = kA;\n              break;\n            }\n            i && \"file\" == i.scheme && !mA(jC(vC(r, u), \"\")) && (fA(i.path[0], !0) ? GC(c.path, i.path[0]) : c.host = i.host), d = UA;\n            continue;\n          case kA:\n            if (n == aC || \"/\" == n || \"\\\\\" == n || \"?\" == n || \"#\" == n) {\n              if (!t && fA(l)) d = UA;else if (\"\" == l) {\n                if (c.host = \"\", t) return;\n                d = MA;\n              } else {\n                if (s = c.parseHost(l)) return s;\n                if (\"localhost\" == c.host && (c.host = \"\"), t) return;\n                l = \"\", d = MA;\n              }\n              continue;\n            }\n            l += n;\n            break;\n          case MA:\n            if (c.isSpecial()) {\n              if (d = UA, \"/\" != n && \"\\\\\" != n) continue;\n            } else if (t || \"?\" != n) {\n              if (t || \"#\" != n) {\n                if (n != aC && (d = UA, \"/\" != n)) continue;\n              } else c.fragment = \"\", d = jA;\n            } else c.query = \"\", d = VA;\n            break;\n          case UA:\n            if (n == aC || \"/\" == n || \"\\\\\" == n && c.isSpecial() || !t && (\"?\" == n || \"#\" == n)) {\n              if (\"..\" === (a = qC(a = l)) || \"%2e.\" === a || \".%2e\" === a || \"%2e%2e\" === a ? (c.shortenPath(), \"/\" == n || \"\\\\\" == n && c.isSpecial() || GC(c.path, \"\")) : gA(l) ? \"/\" == n || \"\\\\\" == n && c.isSpecial() || GC(c.path, \"\") : (\"file\" == c.scheme && !c.path.length && fA(l) && (c.host && (c.host = \"\"), l = xC(l, 0) + \":\"), GC(c.path, l)), l = \"\", \"file\" == c.scheme && (n == aC || \"?\" == n || \"#\" == n)) for (; c.path.length > 1 && \"\" === c.path[0];) HC(c.path);\n              \"?\" == n ? (c.query = \"\", d = VA) : \"#\" == n && (c.fragment = \"\", d = jA);\n            } else l += _A(n, hA);\n            break;\n          case xA:\n            \"?\" == n ? (c.query = \"\", d = VA) : \"#\" == n ? (c.fragment = \"\", d = jA) : n != aC && (c.path[0] += _A(n, uA));\n            break;\n          case VA:\n            t || \"#\" != n ? n != aC && (\"'\" == n && c.isSpecial() ? c.query += \"%27\" : c.query += \"#\" == n ? \"%23\" : _A(n, uA)) : (c.fragment = \"\", d = jA);\n            break;\n          case jA:\n            n != aC && (c.fragment += _A(n, lA));\n        }\n        u++;\n      }\n    },\n    parseHost: function (e) {\n      var t, i, r;\n      if (\"[\" == xC(e, 0)) {\n        if (\"]\" != xC(e, e.length - 1)) return zC;\n        if (!(t = function (e) {\n          var t,\n            i,\n            r,\n            n,\n            o,\n            s,\n            a,\n            c = [0, 0, 0, 0, 0, 0, 0, 0],\n            d = 0,\n            u = null,\n            l = 0,\n            h = function () {\n              return xC(e, l);\n            };\n          if (\":\" == h()) {\n            if (\":\" != xC(e, 1)) return;\n            l += 2, u = ++d;\n          }\n          for (; h();) {\n            if (8 == d) return;\n            if (\":\" != h()) {\n              for (t = i = 0; i < 4 && VC(nA, h());) t = 16 * t + kC(h(), 16), l++, i++;\n              if (\".\" == h()) {\n                if (0 == i) return;\n                if (l -= i, d > 6) return;\n                for (r = 0; h();) {\n                  if (n = null, r > 0) {\n                    if (!(\".\" == h() && r < 4)) return;\n                    l++;\n                  }\n                  if (!VC(eA, h())) return;\n                  for (; VC(eA, h());) {\n                    if (o = kC(h(), 10), null === n) n = o;else {\n                      if (0 == n) return;\n                      n = 10 * n + o;\n                    }\n                    if (n > 255) return;\n                    l++;\n                  }\n                  c[d] = 256 * c[d] + n, 2 != ++r && 4 != r || d++;\n                }\n                if (4 != r) return;\n                break;\n              }\n              if (\":\" == h()) {\n                if (l++, !h()) return;\n              } else if (h()) return;\n              c[d++] = t;\n            } else {\n              if (null !== u) return;\n              l++, u = ++d;\n            }\n          }\n          if (null !== u) for (s = d - u, d = 7; 0 != d && s > 0;) a = c[d], c[d--] = c[u + s - 1], c[u + --s] = a;else if (8 != d) return;\n          return c;\n        }(YC(e, 1, -1)))) return zC;\n        this.host = t;\n      } else if (this.isSpecial()) {\n        if (e = IC(e), VC(oA, e)) return zC;\n        if (null === (t = function (e) {\n          var t,\n            i,\n            r,\n            n,\n            o,\n            s,\n            a,\n            c = KC(e, \".\");\n          if (c.length && \"\" == c[c.length - 1] && c.length--, (t = c.length) > 4) return e;\n          for (i = [], r = 0; r < t; r++) {\n            if (\"\" == (n = c[r])) return e;\n            if (o = 10, n.length > 1 && \"0\" == xC(n, 0) && (o = VC(tA, n) ? 16 : 8, n = YC(n, 8 == o ? 1 : 2)), \"\" === n) s = 0;else {\n              if (!VC(10 == o ? rA : 8 == o ? iA : nA, n)) return e;\n              s = kC(n, o);\n            }\n            GC(i, s);\n          }\n          for (r = 0; r < t; r++) if (s = i[r], r == t - 1) {\n            if (s >= UC(256, 5 - t)) return null;\n          } else if (s > 255) return null;\n          for (a = BC(i), r = 0; r < i.length; r++) a += i[r] * UC(256, 3 - r);\n          return a;\n        }(e))) return zC;\n        this.host = t;\n      } else {\n        if (VC(sA, e)) return zC;\n        for (t = \"\", i = TC(e), r = 0; r < i.length; r++) t += _A(i[r], uA);\n        this.host = t;\n      }\n    },\n    cannotHaveUsernamePasswordPort: function () {\n      return !this.host || this.cannotBeABaseURL || \"file\" == this.scheme;\n    },\n    includesCredentials: function () {\n      return \"\" != this.username || \"\" != this.password;\n    },\n    isSpecial: function () {\n      return gC(EA, this.scheme);\n    },\n    shortenPath: function () {\n      var e = this.path,\n        t = e.length;\n      !t || \"file\" == this.scheme && 1 == t && fA(e[0], !0) || e.length--;\n    },\n    serialize: function () {\n      var e = this,\n        t = e.scheme,\n        i = e.username,\n        r = e.password,\n        n = e.host,\n        o = e.port,\n        s = e.path,\n        a = e.query,\n        c = e.fragment,\n        d = t + \":\";\n      return null !== n ? (d += \"//\", e.includesCredentials() && (d += i + (r ? \":\" + r : \"\") + \"@\"), d += dA(n), null !== o && (d += \":\" + o)) : \"file\" == t && (d += \"//\"), d += e.cannotBeABaseURL ? s[0] : s.length ? \"/\" + jC(s, \"/\") : \"\", null !== a && (d += \"?\" + a), null !== c && (d += \"#\" + c), d;\n    },\n    setHref: function (e) {\n      var t = this.parse(e);\n      if (t) throw LC(t);\n      this.searchParams.update();\n    },\n    getOrigin: function () {\n      var e = this.scheme,\n        t = this.port;\n      if (\"blob\" == e) try {\n        return new BA(e.path[0]).origin;\n      } catch (e) {\n        return \"null\";\n      }\n      return \"file\" != e && this.isSpecial() ? e + \"://\" + dA(this.host) + (null !== t ? \":\" + t : \"\") : \"null\";\n    },\n    getProtocol: function () {\n      return this.scheme + \":\";\n    },\n    setProtocol: function (e) {\n      this.parse(yC(e) + \":\", SA);\n    },\n    getUsername: function () {\n      return this.username;\n    },\n    setUsername: function (e) {\n      var t = TC(yC(e));\n      if (!this.cannotHaveUsernamePasswordPort()) {\n        this.username = \"\";\n        for (var i = 0; i < t.length; i++) this.username += _A(t[i], pA);\n      }\n    },\n    getPassword: function () {\n      return this.password;\n    },\n    setPassword: function (e) {\n      var t = TC(yC(e));\n      if (!this.cannotHaveUsernamePasswordPort()) {\n        this.password = \"\";\n        for (var i = 0; i < t.length; i++) this.password += _A(t[i], pA);\n      }\n    },\n    getHost: function () {\n      var e = this.host,\n        t = this.port;\n      return null === e ? \"\" : null === t ? dA(e) : dA(e) + \":\" + t;\n    },\n    setHost: function (e) {\n      this.cannotBeABaseURL || this.parse(e, wA);\n    },\n    getHostname: function () {\n      var e = this.host;\n      return null === e ? \"\" : dA(e);\n    },\n    setHostname: function (e) {\n      this.cannotBeABaseURL || this.parse(e, NA);\n    },\n    getPort: function () {\n      var e = this.port;\n      return null === e ? \"\" : yC(e);\n    },\n    setPort: function (e) {\n      this.cannotHaveUsernamePasswordPort() || (\"\" == (e = yC(e)) ? this.port = null : this.parse(e, DA));\n    },\n    getPathname: function () {\n      var e = this.path;\n      return this.cannotBeABaseURL ? e[0] : e.length ? \"/\" + jC(e, \"/\") : \"\";\n    },\n    setPathname: function (e) {\n      this.cannotBeABaseURL || (this.path = [], this.parse(e, MA));\n    },\n    getSearch: function () {\n      var e = this.query;\n      return e ? \"?\" + e : \"\";\n    },\n    setSearch: function (e) {\n      \"\" == (e = yC(e)) ? this.query = null : (\"?\" == xC(e, 0) && (e = YC(e, 1)), this.query = \"\", this.parse(e, VA)), this.searchParams.update();\n    },\n    getSearchParams: function () {\n      return this.searchParams.facade;\n    },\n    getHash: function () {\n      var e = this.fragment;\n      return e ? \"#\" + e : \"\";\n    },\n    setHash: function (e) {\n      \"\" != (e = yC(e)) ? (\"#\" == xC(e, 0) && (e = YC(e, 1)), this.fragment = \"\", this.parse(e, jA)) : this.fragment = null;\n    },\n    update: function () {\n      this.query = this.searchParams.serialize() || null;\n    }\n  };\n  var BA = function (e) {\n      var t = mC(this, GA),\n        i = arguments.length > 1 ? arguments[1] : void 0,\n        r = bC(t, new FA(e, !1, i));\n      uC || (t.href = r.serialize(), t.origin = r.getOrigin(), t.protocol = r.getProtocol(), t.username = r.getUsername(), t.password = r.getPassword(), t.host = r.getHost(), t.hostname = r.getHostname(), t.port = r.getPort(), t.pathname = r.getPathname(), t.search = r.getSearch(), t.searchParams = r.getSearchParams(), t.hash = r.getHash());\n    },\n    GA = BA.prototype,\n    WA = function (e, t) {\n      return {\n        get: function () {\n          return wC(this)[e]();\n        },\n        set: t && function (e) {\n          return wC(this)[t](e);\n        },\n        configurable: !0,\n        enumerable: !0\n      };\n    };\n  if (uC && EC(GA, {\n    href: WA(\"serialize\", \"setHref\"),\n    origin: WA(\"getOrigin\"),\n    protocol: WA(\"getProtocol\", \"setProtocol\"),\n    username: WA(\"getUsername\", \"setUsername\"),\n    password: WA(\"getPassword\", \"setPassword\"),\n    host: WA(\"getHost\", \"setHost\"),\n    hostname: WA(\"getHostname\", \"setHostname\"),\n    port: WA(\"getPort\", \"setPort\"),\n    pathname: WA(\"getPathname\", \"setPathname\"),\n    search: WA(\"getSearch\", \"setSearch\"),\n    searchParams: WA(\"getSearchParams\"),\n    hash: WA(\"getHash\", \"setHash\")\n  }), fC(GA, \"toJSON\", function () {\n    return wC(this).serialize();\n  }, {\n    enumerable: !0\n  }), fC(GA, \"toString\", function () {\n    return wC(this).serialize();\n  }, {\n    enumerable: !0\n  }), PC) {\n    var HA = PC.createObjectURL,\n      KA = PC.revokeObjectURL;\n    HA && fC(BA, \"createObjectURL\", pC(HA, PC)), KA && fC(BA, \"revokeObjectURL\", pC(KA, PC));\n  }\n  CC(BA, \"URL\"), dC({\n    global: !0,\n    forced: !lC,\n    sham: !uC\n  }, {\n    URL: BA\n  });\n  var YA = J.URL;\n  const qA = {\n    [Sm.ACCESS_POINT]: {\n      [Rm.NO_FLAG_SET]: {\n        desc: \"flag is zero\",\n        retry: !1\n      },\n      [Rm.FLAG_SET_BUT_EMPTY]: {\n        desc: \"flag is empty\",\n        retry: !1\n      },\n      [Rm.INVALID_FALG_SET]: {\n        desc: \"invalid flag\",\n        retry: !1\n      },\n      [Rm.FLAG_SET_BUT_NO_RE]: {\n        desc: \"flag set unilbs but no request\",\n        retry: !1\n      },\n      [Rm.INVALID_SERVICE_ID]: {\n        desc: \"invalid service id\",\n        retry: !1\n      },\n      [Rm.NO_SERVICE_AVAILABLE]: {\n        desc: \"no service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_P2P]: {\n        desc: \"no unilbs p2p service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_VOET]: {\n        desc: \"no unilbs voice service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_WEBRTC]: {\n        desc: \"no unilbs webrtc service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_CDS]: {\n        desc: \"no cds service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_CDN]: {\n        desc: \"no cdn dispatcher service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_TDS]: {\n        desc: \"no tds service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_REPORT]: {\n        desc: \"no unilbs report service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_APP_CENTER]: {\n        desc: \"no app center service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_ENV0]: {\n        desc: \"no unilbs sig env0 service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_VOET]: {\n        desc: \"no unilbs voet service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_STRING_UID]: {\n        desc: \"no string uid service available\",\n        retry: !0\n      },\n      [Rm.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: {\n        desc: \"no webrtc unilbs service available\",\n        retry: !0\n      }\n    },\n    [Sm.UNILBS]: {\n      [vm.INVALID_VENDOR_KEY]: {\n        desc: \"invalid vendor key, can not find appid\",\n        retry: !1\n      },\n      [vm.INVALID_CHANNEL_NAME]: {\n        desc: \"invalid channel name\",\n        retry: !1\n      },\n      [vm.INTERNAL_ERROR]: {\n        desc: \"unilbs internal error\",\n        retry: !1\n      },\n      [vm.NO_AUTHORIZED]: {\n        desc: \"invalid token, authorized failed\",\n        retry: !1\n      },\n      [vm.DYNAMIC_KEY_TIMEOUT]: {\n        desc: \"dynamic key or token timeout\",\n        retry: !1\n      },\n      [vm.NO_ACTIVE_STATUS]: {\n        desc: \"no active status\",\n        retry: !1\n      },\n      [vm.DYNAMIC_KEY_EXPIRED]: {\n        desc: \"dynamic key expired\",\n        retry: !1\n      },\n      [vm.STATIC_USE_DYNAMIC_KEY]: {\n        desc: \"static use dynamic key\",\n        retry: !1\n      },\n      [vm.DYNAMIC_USE_STATIC_KEY]: {\n        desc: \"dynamic use static key\",\n        retry: !1\n      },\n      [vm.USER_OVERLOAD]: {\n        desc: \"amount of users over load\",\n        retry: !1\n      },\n      [vm.FORBIDDEN_REGION]: {\n        desc: \"the request is forbidden in this area\",\n        retry: !1\n      },\n      [vm.CANNOT_MEET_AREA_DEMAND]: {\n        desc: \"unable to allocate services in this area\",\n        retry: !1\n      }\n    },\n    [Sm.STRING_UID_ALLOCATOR]: {\n      [Tm.IIIEGAL_APPID]: {\n        desc: \"invalid appid\",\n        retry: !1\n      },\n      [Tm.IIIEGAL_UID]: {\n        desc: \"invalid string uid\",\n        retry: !1\n      },\n      [Tm.INTERNAL_ERROR]: {\n        desc: \"string uid allocator internal error\",\n        retry: !0\n      }\n    }\n  };\n  function JA(e) {\n    const t = qA[Math.floor(e / 1e4)];\n    if (!t) return {\n      desc: \"unkonw error\",\n      retry: !1\n    };\n    const i = t[e % 1e4];\n    if (!i) {\n      if (Math.floor(e / 1e4) === Sm.ACCESS_POINT) {\n        const t = e % 1e4;\n        if (\"1\" === t.toString()[0]) return {\n          desc: e.toString(),\n          retry: !1\n        };\n        if (\"2\" === t.toString()[0]) return {\n          desc: e.toString(),\n          retry: !0\n        };\n      }\n      return {\n        desc: \"unkonw error\",\n        retry: !1\n      };\n    }\n    return i;\n  }\n  const XA = {\n    [Im.K_TIMESTAMP_EXPIRED]: {\n      desc: \"K_TIMESTAMP_EXPIRED\",\n      action: \"failed\"\n    },\n    [Im.K_CHANNEL_PERMISSION_INVALID]: {\n      desc: \"K_CHANNEL_PERMISSION_INVALID\",\n      action: \"failed\"\n    },\n    [Im.K_CERTIFICATE_INVALID]: {\n      desc: \"K_CERTIFICATE_INVALID\",\n      action: \"failed\"\n    },\n    [Im.K_CHANNEL_NAME_EMPTY]: {\n      desc: \"K_CHANNEL_NAME_EMPTY\",\n      action: \"failed\"\n    },\n    [Im.K_CHANNEL_NOT_FOUND]: {\n      desc: \"K_CHANNEL_NOT_FOUND\",\n      action: \"failed\"\n    },\n    [Im.K_TICKET_INVALID]: {\n      desc: \"K_TICKET_INVALID\",\n      action: \"failed\"\n    },\n    [Im.K_CHANNEL_CONFLICTED]: {\n      desc: \"K_CHANNEL_CONFLICTED\",\n      action: \"failed\"\n    },\n    [Im.K_SERVICE_NOT_READY]: {\n      desc: \"K_SERVICE_NOT_READY\",\n      action: \"tryNext\"\n    },\n    [Im.K_SERVICE_TOO_HEAVY]: {\n      desc: \"K_SERVICE_TOO_HEAVY\",\n      action: \"tryNext\"\n    },\n    [Im.K_UID_BANNED]: {\n      desc: \"K_UID_BANNED\",\n      action: \"failed\"\n    },\n    [Im.K_IP_BANNED]: {\n      desc: \"K_IP_BANNED\",\n      action: \"failed\"\n    },\n    [Im.ERR_INVALID_VENDOR_KEY]: {\n      desc: \"ERR_INVALID_VENDOR_KEY\",\n      action: \"failed\"\n    },\n    [Im.ERR_INVALID_CHANNEL_NAME]: {\n      desc: \"ERR_INVALID_CHANNEL_NAME\",\n      action: \"failed\"\n    },\n    [Im.WARN_NO_AVAILABLE_CHANNEL]: {\n      desc: \"WARN_NO_AVAILABLE_CHANNEL\",\n      action: \"failed\"\n    },\n    [Im.WARN_LOOKUP_CHANNEL_TIMEOUT]: {\n      desc: \"WARN_LOOKUP_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [Im.WARN_LOOKUP_CHANNEL_REJECTED]: {\n      desc: \"WARN_LOOKUP_CHANNEL_REJECTED\",\n      action: \"failed\"\n    },\n    [Im.WARN_OPEN_CHANNEL_TIMEOUT]: {\n      desc: \"WARN_OPEN_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [Im.WARN_OPEN_CHANNEL_REJECTED]: {\n      desc: \"WARN_OPEN_CHANNEL_REJECTED\",\n      action: \"failed\"\n    },\n    [Im.WARN_REQUEST_DEFERRED]: {\n      desc: \"WARN_REQUEST_DEFERRED\",\n      action: \"failed\"\n    },\n    [Im.ERR_DYNAMIC_KEY_TIMEOUT]: {\n      desc: \"ERR_DYNAMIC_KEY_TIMEOUT\",\n      action: \"failed\"\n    },\n    [Im.ERR_NO_AUTHORIZED]: {\n      desc: \"ERR_NO_AUTHORIZED\",\n      action: \"failed\"\n    },\n    [Im.ERR_VOM_SERVICE_UNAVAILABLE]: {\n      desc: \"ERR_VOM_SERVICE_UNAVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_NO_CHANNEL_AVAILABLE_CODE]: {\n      desc: \"ERR_NO_CHANNEL_AVAILABLE_CODE\",\n      action: \"failed\"\n    },\n    [Im.ERR_MASTER_VOCS_UNAVAILABLE]: {\n      desc: \"ERR_MASTER_VOCS_UNAVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_INTERNAL_ERROR]: {\n      desc: \"ERR_INTERNAL_ERROR\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_NO_ACTIVE_STATUS]: {\n      desc: \"ERR_NO_ACTIVE_STATUS\",\n      action: \"failed\"\n    },\n    [Im.ERR_INVALID_UID]: {\n      desc: \"ERR_INVALID_UID\",\n      action: \"failed\"\n    },\n    [Im.ERR_DYNAMIC_KEY_EXPIRED]: {\n      desc: \"ERR_DYNAMIC_KEY_EXPIRED\",\n      action: \"failed\"\n    },\n    [Im.ERR_STATIC_USE_DYANMIC_KE]: {\n      desc: \"ERR_STATIC_USE_DYANMIC_KE\",\n      action: \"failed\"\n    },\n    [Im.ERR_DYNAMIC_USE_STATIC_KE]: {\n      desc: \"ERR_DYNAMIC_USE_STATIC_KE\",\n      action: \"failed\"\n    },\n    [Im.ERR_NO_VOCS_AVAILABLE]: {\n      desc: \"ERR_NO_VOCS_AVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_NO_VOS_AVAILABLE]: {\n      desc: \"ERR_NO_VOS_AVAILABLE\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_JOIN_CHANNEL_TIMEOUT]: {\n      desc: \"ERR_JOIN_CHANNEL_TIMEOUT\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_JOIN_BY_MULTI_IP]: {\n      desc: \"ERR_JOIN_BY_MULTI_IP\",\n      action: \"recover\"\n    },\n    [Im.ERR_NOT_JOINED]: {\n      desc: \"ERR_NOT_JOINED\",\n      action: \"failed\"\n    },\n    [Im.ERR_REPEAT_JOIN_REQUEST]: {\n      desc: \"ERR_REPEAT_JOIN_REQUEST\",\n      action: \"quit\"\n    },\n    [Im.ERR_REPEAT_JOIN_CHANNEL]: {\n      desc: \"ERR_REPEAT_JOIN_CHANNEL\",\n      action: \"quit\"\n    },\n    [Im.ERR_INVALID_VENDOR_KEY]: {\n      desc: \"ERR_INVALID_VENDOR_KEY\",\n      action: \"failed\"\n    },\n    [Im.ERR_INVALID_CHANNEL_NAME]: {\n      desc: \"ERR_INVALID_CHANNEL_NAME\",\n      action: \"failed\"\n    },\n    [Im.ERR_INVALID_STRINGUID]: {\n      desc: \"ERR_INVALID_STRINGUID\",\n      action: \"failed\"\n    },\n    [Im.ERR_TOO_MANY_USERS]: {\n      desc: \"ERR_TOO_MANY_USERS\",\n      action: \"tryNext\"\n    },\n    [Im.ERR_SET_CLIENT_ROLE_TIMEOUT]: {\n      desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n      action: \"failed\"\n    },\n    [Im.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: {\n      desc: \"ERR_SET_CLIENT_ROLE_TIMEOUT\",\n      action: \"failed\"\n    },\n    [Im.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: {\n      desc: \"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE\",\n      action: \"success\"\n    },\n    [Im.ERR_PUBLISH_REQUEST_INVALID]: {\n      desc: \"ERR_PUBLISH_REQUEST_INVALID\",\n      action: \"failed\"\n    },\n    [Im.ERR_SUBSCRIBE_REQUEST_INVALID]: {\n      desc: \"ERR_SUBSCRIBE_REQUEST_INVALID\",\n      action: \"failed\"\n    },\n    [Im.ERR_NOT_SUPPORTED_MESSAGE]: {\n      desc: \"ERR_NOT_SUPPORTED_MESSAGE\",\n      action: \"failed\"\n    },\n    [Im.ERR_ILLEAGAL_PLUGIN]: {\n      desc: \"ERR_ILLEAGAL_PLUGIN\",\n      action: \"failed\"\n    },\n    [Im.ILLEGAL_CLIENT_ROLE_LEVEL]: {\n      desc: \"ILLEGAL_CLIENT_ROLE_LEVEL\",\n      action: \"failed\"\n    },\n    [Im.ERR_REJOIN_TOKEN_INVALID]: {\n      desc: \"ERR_REJOIN_TOKEN_INVALID\",\n      action: \"failed\"\n    },\n    [Im.ERR_REJOIN_USER_NOT_JOINED]: {\n      desc: \"ERR_REJOIN_NOT_JOINED\",\n      action: \"failed\"\n    },\n    [Im.ERR_INVALID_OPTIONAL_INFO]: {\n      desc: \"ERR_INVALID_OPTIONAL_INFO\",\n      action: \"quit\"\n    },\n    [Im.ERR_TEST_RECOVER]: {\n      desc: \"ERR_TEST_RECOVER\",\n      action: \"recover\"\n    },\n    [Im.ERR_TEST_TRYNEXT]: {\n      desc: \"ERR_TEST_TRYNEXT\",\n      action: \"recover\"\n    },\n    [Im.ERR_TEST_RETRY]: {\n      desc: \"ERR_TEST_RETRY\",\n      action: \"recover\"\n    },\n    [Im.ILLEGAL_AES_PASSWORD]: {\n      desc: \"ERR_TEST_RETRY\",\n      action: \"failed\"\n    },\n    [Im.ERR_TOO_MANY_BROADCASTERS]: {\n      desc: \"ERR_TOO_MANY_BROADCASTERS\",\n      action: \"failed\"\n    },\n    [Im.ERR_TOO_MANY_SUBSCRIBERS]: {\n      desc: \"ERR_TOO_MANY_SUBSCRIBERS\",\n      action: \"failed\"\n    },\n    [Im.ERR_LICENSE_ILLEGAL]: {\n      desc: \"ERR_LICENSE_ILLEGAL\",\n      action: \"quit\"\n    },\n    [Im.ERR_LICENSE_MISSING]: {\n      desc: \"ERR_LICENSE_MISSING\",\n      action: \"quit\"\n    },\n    [Im.ERR_LICENSE_EXPIRED]: {\n      desc: \"ERR_LICENSE_EXPIRED\",\n      action: \"quit\"\n    },\n    [Im.ERR_LICENSE_MINUTES_EXCEEDED]: {\n      desc: \"ERR_LICENSE_MINUTES_EXCEEDED\",\n      action: \"quit\"\n    },\n    [Im.ERR_LICENSE_PERIOD_INVALID]: {\n      desc: \"ERR_LICENSE_PERIOD_INVALID\",\n      action: \"quit\"\n    },\n    [Im.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: {\n      desc: \"ERR_LICENSE_MULTIPLE_SDK_SERVICE\",\n      action: \"quit\"\n    }\n  };\n  function zA(e) {\n    const t = XA[e];\n    return t || {\n      desc: \"UNKNOW_ERROR_\".concat(e),\n      action: \"failed\"\n    };\n  }\n  class QA extends gE {\n    get queue() {\n      return [...this.highPriorityQueue, ...this.lowPriorityQueue];\n    }\n    constructor(e) {\n      super(), mp(this, \"lowPriorityQueue\", []), mp(this, \"highPriorityQueue\", []), mp(this, \"AgoraWebSocketManager\", void 0), this.AgoraWebSocketManager = e;\n    }\n    reset() {\n      this.lowPriorityQueue = [], this.highPriorityQueue = [];\n    }\n    pushMessage(e) {\n      arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? this.highPriorityQueue.push(e) : this.lowPriorityQueue.push(e), this.sendMessage();\n    }\n    sendMessage() {\n      const e = this.queue.length;\n      let t = 0;\n      t = e < 5 ? 15 * e : 60 + 3 * (e - 4), setTimeout(() => {\n        this._sendMessage();\n      }, t);\n    }\n    _sendMessage() {\n      if (!this.queue.length) return;\n      const e = this.AgoraWebSocketManager.getConnection();\n      if (!e || 1 !== e.readyState) return;\n      const t = this.queue.shift();\n      return this.lowPriorityQueue.includes(t) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e.send(t.compressed), t;\n    }\n  }\n  function ZA(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  class $A extends gE {\n    get url() {\n      return this.websocket ? this.websocket.url : null;\n    }\n    get reconnectMode() {\n      return this._reconnectMode;\n    }\n    set reconnectMode(e) {\n      [\"tryNext\", \"recover\"].includes(e) && this.resetReconnectCount(e), this._reconnectMode = e;\n    }\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      e !== this._state && (this._state = e, \"reconnecting\" === this._state ? this.emit(Km.RECONNECTING, this.reconnectReason) : \"connected\" === this._state ? this.emit(Km.CONNECTED) : \"closed\" === this._state ? this.emit(Km.CLOSED) : \"failed\" === this._state && this.emit(Km.FAILED));\n    }\n    resetReconnectCount(e) {\n      NE.debug(\"websocket reset reconnect count, reason: \" + e), this.reconnectCount = 0;\n    }\n    constructor(e, t) {\n      let i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n        r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],\n        n = arguments.length > 4 ? arguments[4] : void 0;\n      super(), mp(this, \"connectionID\", 0), mp(this, \"currentURLIndex\", 0), mp(this, \"urls\", void 0), mp(this, \"_reconnectMode\", \"tryNext\"), mp(this, \"reconnectReason\", void 0), mp(this, \"_initMutex\", new OT(\"websocket\")), mp(this, \"name\", void 0), mp(this, \"_state\", \"closed\"), mp(this, \"reconnectInterrupter\", void 0), mp(this, \"websocket\", void 0), mp(this, \"retryConfig\", void 0), mp(this, \"reconnectCount\", 0), mp(this, \"forceCloseTimeout\", 5e3), mp(this, \"onlineReconnectListener\", void 0), mp(this, \"messageSender\", void 0), mp(this, \"useCompress\", void 0), mp(this, \"tryDoubleDomain\", !1), mp(this, \"wsInflateLength\", 0), mp(this, \"wsDeflateLength\", 0), mp(this, \"closeEstablishingWs\", () => {}), mp(this, \"store\", void 0), mp(this, \"joinChannelServiceRecordIndex\", void 0), this.store = n, this.name = e, this.retryConfig = function (e) {\n        for (var t = 1; t < arguments.length; t++) {\n          var i = null != arguments[t] ? arguments[t] : {};\n          t % 2 ? ZA(Object(i), !0).forEach(function (t) {\n            mp(e, t, i[t]);\n          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ZA(Object(i)).forEach(function (t) {\n            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n          });\n        }\n        return e;\n      }({}, t), this.useCompress = i, this.tryDoubleDomain = r;\n      const {\n          timeout: o,\n          timeoutFactor: s\n        } = t,\n        a = Math.max(300, Math.floor(3 * o / 5)),\n        c = Math.max(1.2, Math.floor(8 * s) / 10);\n      bg.ONLINE && (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c), pT.on(wg.NETWORK_STATE_CHANGE, (e, t) => {\n        e !== t && (this.resetReconnectCount(\"network state change: \".concat(t, \" -> \").concat(e)), e === bg.ONLINE ? (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c) : (this.retryConfig.timeout = o, this.retryConfig.timeoutFactor = s));\n      });\n    }\n    getConnection() {\n      return this.websocket || void 0;\n    }\n    init(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n      this.forceCloseTimeout = t;\n      const i = (t, i) => {\n        this.urls = e;\n        const r = this.urls[this.currentURLIndex];\n        this.state = \"connecting\", this.messageSender = new QA(this), this.createWebSocketConnection(r).then(t).catch(i), this.once(Km.CLOSED, () => i(new vE(TE.WS_DISCONNECT))), this.once(Km.CONNECTED, () => t());\n      };\n      return this._initMutex.lock().then(e => new Cl((e, t) => {\n        i(e, t);\n      }).then(() => {\n        e();\n      }).catch(() => {\n        e();\n      }));\n    }\n    close(e, t) {\n      if (this.currentURLIndex = 0, this.resetReconnectCount(\"close\"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {\n        this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;\n        const e = this.websocket;\n        t ? setTimeout(() => e.close(), 500) : e.close(), this.websocket = void 0;\n      }\n      this.state = e ? \"failed\" : \"closed\", this.closeEstablishingWs && this.closeEstablishingWs();\n    }\n    reconnect(e, t) {\n      if (!this.websocket) return void NE.warning(\"[\".concat(this.name, \"] can not reconnect, no websocket\"));\n      var i;\n      (void 0 !== e && (this.reconnectMode = e), NE.debug(\"[\".concat(this.name, \"] reconnect is triggered initiative\")), \"number\" == typeof this.joinChannelServiceRecordIndex) && (null === (i = this.store) || void 0 === i || i.recordJoinChannelService({\n        status: \"error\",\n        errors: [new Error(t)]\n      }, this.joinChannelServiceRecordIndex));\n      const r = this.websocket.onclose;\n      this.websocket.onclose = null, this.websocket.close(), r && r.bind(this.websocket)({\n        code: 9999,\n        reason: t\n      });\n    }\n    sendMessageWithJSON(e) {\n      const t = JSON.stringify(e);\n      return {\n        compressed: t,\n        compressedLength: t.length,\n        origin: e\n      };\n    }\n    sendMessageWithUint8Array(e) {\n      return {\n        compressed: e,\n        compressedLength: e.byteLength,\n        origin: e\n      };\n    }\n    sendMessage(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n        i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new vE(TE.WS_ABORT, \"websocket is not ready\");\n      try {\n        let r = null;\n        r = i ? this.sendMessageWithUint8Array(e) : this.sendMessageWithJSON(e), t ? this.websocket.send(r.compressed) : this.messageSender.pushMessage(r);\n      } catch (e) {\n        throw new vE(TE.WS_ERR, \"send websocket message error\" + e.toString());\n      }\n    }\n    setWsInflateData(e) {\n      this.wsDeflateLength = this.wsDeflateLength + e.originLength, this.wsInflateLength = this.wsInflateLength + e.compressedLength;\n    }\n    getWsInflateData() {\n      const e = this.wsInflateLength,\n        t = this.wsDeflateLength;\n      return this.clearWsInflateData(), {\n        wsInflateLength: e,\n        wsDeflateLength: t\n      };\n    }\n    clearWsInflateData() {\n      this.wsInflateLength = 0, this.wsDeflateLength = 0;\n    }\n    async createWebSocketConnection(e, t) {\n      return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new Cl((i, r) => {\n        var n;\n        const o = e => {\n            var t;\n            null === (t = this.store) || void 0 === t || t.signalChannelOpen(), NE.debug(\"[\".concat(this.name, \"] websocket opened:\"), e), this.reconnectMode = \"retry\", this.state = \"connected\", this.resetReconnectCount(\"opened\"), i();\n          },\n          s = async e => {\n            if (NE.debug(\"[\".concat(this.name, \"] websocket close \").concat(this.websocket && this.websocket.url, \", code: \").concat(e.code, \", reason: \").concat(e.reason, \", current mode: \").concat(this.reconnectMode)), this.reconnectCount < this.retryConfig.maxRetryCount) {\n              \"connected\" === this.state && (this.reconnectReason = e.reason, this.state = \"reconnecting\");\n              const t = GR(this, Km.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode,\n                n = await this.reconnectWithAction(t);\n              if (\"closed\" === this.state) return void NE.debug(\"[\".concat(this.connectionID, \"] ws is closed, no need to reconnect\"));\n              if (!n) return r(new vE(TE.WS_DISCONNECT, \"websocket reconnect failed: \".concat(e.code))), void this.close(!0);\n              i();\n            } else r(new vE(TE.WS_DISCONNECT, \"websocket close: \".concat(e.code))), this.close();\n          },\n          a = e => {\n            this.emit(Km.ON_MESSAGE, e);\n          };\n        this.websocket && (this.websocket.onclose = null, this.websocket.close()), HE(\"GATEWAY_WSS_ADDRESS\") && this.name.startsWith(\"gateway\") && (e = HE(\"GATEWAY_WSS_ADDRESS\")), NE.debug(\"[\".concat(this.name, \"] start connect, url: \").concat(e));\n        const c = null === (n = this.store) || void 0 === n ? void 0 : n.recordJoinChannelService({\n          startTs: Date.now(),\n          status: \"pending\",\n          service: \"gateway\"\n        });\n        this.chooseBestWebsocketConnection(e, !!t, c).then(e => {\n          var t;\n          this.websocket = e, o && o(e.url), e.onclose = s, e.onmessage = a, null === (t = this.store) || void 0 === t || t.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, c), this.joinChannelServiceRecordIndex = c;\n        }).catch(e => {\n          var t;\n          if (null === (t = this.store) || void 0 === t || t.recordJoinChannelService({\n            endTs: Date.now(),\n            status: e instanceof vE && e.code === TE.WS_ABORT ? \"aborted\" : \"error\",\n            errors: [e]\n          }, c), \"closed\" !== this.state) {\n            if (e instanceof vE && e.code === TE.WS_ERR) {\n              const t = new vE(TE.WS_ERR, \"init websocket failed! Error: \".concat(e.toString()));\n              return NE.error(\"[\".concat(this.name, \"]\").concat(t)), void r(t);\n            }\n            s && s(e);\n          } else r(new vE(TE.WS_DISCONNECT, \"websocket is closed: \".concat(e.toString())));\n        });\n      });\n    }\n    async reconnectWithAction(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (this.reconnectCount >= this.retryConfig.maxRetryCount) return !1;\n      if (!this.urls) return !1;\n      if (\"closed\" === this.state) return !1;\n      this.onlineReconnectListener || pT.networkState !== bg.OFFLINE || (this.onlineReconnectListener = pT.onlineWaiter && pT.onlineWaiter.then(() => {\n        this.onlineReconnectListener = void 0;\n      }));\n      let i = !0;\n      if (this.reconnectInterrupter = () => {\n        i = !1;\n      }, t) {\n        const t = IE(this.reconnectCount, this.retryConfig);\n        NE.debug(\"[\".concat(this.name, \"] wait \").concat(t, \"ms to reconnect websocket, mode: \").concat(e)), await Cl.race([LR(t), this.onlineReconnectListener || new Cl(() => {})]);\n      }\n      if (\"closed\" === this.state || !i) return !1;\n      this.reconnectCount += 1;\n      const r = async (e, t) => {\n        this.emit(Km.RECONNECT_CREATE_CONNECTION, t), await this.createWebSocketConnection(e);\n      };\n      try {\n        if (\"retry\" === e) {\n          const t = this.urls[this.currentURLIndex];\n          this.emit(Km.RECONNECT_WAITTING_FINISH, e), await r(t, e);\n        } else if (\"tryNext\" === e) {\n          if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return await this.reconnectWithAction(\"recover\", !1);\n          NE.debug(\"[\".concat(this.name, \"] websocket url length: \").concat(this.urls.length, \" current index: \").concat(this.currentURLIndex));\n          const t = this.urls[this.currentURLIndex];\n          this.emit(Km.RECONNECT_WAITTING_FINISH, e), await r(t, e);\n        } else if (\"recover\" === e) {\n          NE.debug(\"[\".concat(this.name, \"] request new urls\")), this.resetReconnectCount(\"recover mode\"), this.emit(Km.RECONNECT_WAITTING_FINISH, e), this.urls = await FR(this, Km.REQUEST_NEW_URLS), this.currentURLIndex = 0;\n          const t = this.urls[this.currentURLIndex];\n          await r(t, e);\n        }\n        return !0;\n      } catch (i) {\n        var n;\n        return NE.error(\"[\".concat(this.name, \"] reconnect failed\"), i.toString()), null != i && null !== (n = i.data) && void 0 !== n && n.desc && Array.isArray(i.data.desc) && i.data.desc.length && i.data.desc.includes(\"dynamic key expired\") ? (this.emit(Km.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t);\n      }\n    }\n    async chooseBestWebsocketConnection(e, t, i) {\n      return new Cl((r, n) => {\n        let o = !1;\n        const s = [];\n        this.closeEstablishingWs = () => {\n          NE.debug(\"[choose-best-ws] close establishing websockets\"), s.forEach(e => {\n            e.onclose = null, e.onopen = null, e.onmessage = null, e.close();\n          }), n(new vE(TE.WS_ABORT, \"choose best websocket aborted\"));\n        };\n        const a = HE(\"GATEWAY_DOMAINS\");\n        let c;\n        const d = e.indexOf(\"?h=\"),\n          u = a.find(t => -1 !== d ? e.includes(t, d) : e.includes(t));\n        NE.debug(\"[choose-best-ws] currentDomain: \", u, \", domains: \", a);\n        let l = !this.tryDoubleDomain || t || !u;\n        if (!l && u) {\n          var h;\n          const t = Date.now();\n          try {\n            a.forEach(t => {\n              const i = -1 === d ? e.replace(u, t) : e.substr(0, d) + e.substr(d).replace(u, t),\n                r = new WebSocket(i);\n              r.binaryType = \"arraybuffer\", s.push(r), NE.debug(\"[choose-best-ws] ws is connecting:\", r.url);\n            });\n          } catch (e) {\n            for (NE.debug(\"[choose-best-ws] ws create failed, fallback to single url\"), s.forEach(e => e.close()); s.length;) s.pop();\n            l = !0;\n          }\n          null === (h = this.store) || void 0 === h || h.recordJoinChannelService({\n            urls: s.map(e => e.url),\n            service: \"gateway\"\n          }, i), s.forEach(e => {\n            e.onopen = () => {\n              if (o) return;\n              const i = Date.now() - t;\n              NE.debug(\"[choose-best-ws] ws open cost \".concat(i, \"ms\")), s.filter(t => t !== e).forEach(e => {\n                NE.debug(\"[choose-best-ws]close backup websocket: \".concat(e.url)), e.close();\n              }), o = !0, r(e);\n            }, e.onclose = e => {\n              if (c = e, o) return;\n              s.find(e => !(e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING)) || (NE.debug(\"[choose-best-ws] all websocket is closed\"), o = !0, n(c));\n            }, e.onmessage = t => {\n              NE.debug(\"[choose-best-ws]\".concat(e.url, \" onmessage: \").concat(t.data));\n            };\n          }), LR(this.forceCloseTimeout).then(() => {\n            s.forEach(e => {\n              e.readyState !== WebSocket.OPEN && e.close();\n            });\n          });\n        }\n        if (l) {\n          var p;\n          let t;\n          NE.debug(\"[choose-best-ws] use single url: \", e), null === (p = this.store) || void 0 === p || p.recordJoinChannelService({\n            urls: [e],\n            service: \"gateway\"\n          }, i);\n          try {\n            t = new WebSocket(e), s.push(t), t.binaryType = \"arraybuffer\";\n          } catch (e) {\n            const t = new vE(TE.WS_ERR, \"init websocket failed! Error: \".concat(e.toString()));\n            return NE.error(\"[\".concat(this.name, \"]\").concat(t)), void n(t);\n          }\n          t.onopen = () => {\n            r(t);\n          }, t.onclose = e => {\n            n(e);\n          }, t.onmessage = e => {\n            NE.debug(\"[choose-best-ws]\".concat(t.url, \" onmessage: \").concat(e.data));\n          }, LR(this.forceCloseTimeout).then(() => {\n            t && t.readyState !== WebSocket.OPEN && t.close();\n          });\n        }\n      }).then(e => (this.closeEstablishingWs = void 0, e)).catch(e => {\n        throw this.closeEstablishingWs = void 0, e;\n      });\n    }\n  }\n  class eO {\n    constructor(e) {\n      mp(this, \"input\", []), mp(this, \"size\", void 0), this.size = e;\n    }\n    add(e) {\n      this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);\n    }\n    mean() {\n      var e;\n      return 0 === this.input.length ? 0 : zi(e = this.input).call(e, (e, t) => e + t) / this.input.length;\n    }\n  }\n  class tO extends gE {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      e !== this._connectionState && (this._connectionState = e, e === bm.CONNECTED ? this.emit(wm.WS_CONNECTED) : e === bm.RECONNECTING ? this.emit(wm.WS_RECONNECTING, this._websocketReconnectReason) : e === bm.CLOSED && this.emit(wm.WS_CLOSED, this._disconnectedReason));\n    }\n    get currentURLIndex() {\n      return this.websocket.currentURLIndex;\n    }\n    get url() {\n      return this.websocket ? this.websocket.url : null;\n    }\n    get rtt() {\n      return this.rttRolling.mean();\n    }\n    constructor(e, t) {\n      super(), mp(this, \"_disconnectedReason\", void 0), mp(this, \"_websocketReconnectReason\", void 0), mp(this, \"_connectionState\", bm.CLOSED), mp(this, \"reconnectToken\", void 0), mp(this, \"websocket\", void 0), mp(this, \"openConnectionTime\", void 0), mp(this, \"clientId\", void 0), mp(this, \"lastMsgTime\", Date.now()), mp(this, \"uploadCache\", []), mp(this, \"uploadCacheInterval\", void 0), mp(this, \"rttRolling\", new eO(5)), mp(this, \"pingpongTimer\", void 0), mp(this, \"wsInflateDataTimer\", void 0), mp(this, \"pingpongTimeoutCount\", 0), mp(this, \"joinResponse\", void 0), mp(this, \"multiIpOption\", void 0), mp(this, \"initError\", void 0), mp(this, \"spec\", void 0), mp(this, \"store\", void 0), mp(this, \"onWebsocketMessage\", e => {\n        if (e.data instanceof ArrayBuffer) return void this.emit(wm.ON_BINARY_DATA, e.data);\n        const t = JSON.parse(e.data);\n        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, \"_id\")) {\n          const e = \"res-@\".concat(t._id);\n          this.emit(e, t._result, t._message);\n        } else if (Object.prototype.hasOwnProperty.call(t, \"_type\")) {\n          if (this.emit(t._type, t._message), t._type === Pm.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Pm.ON_USER_BANNED) switch (t._message.error_code) {\n            case 14:\n              this.close(Cm.UID_BANNED);\n              break;\n            case 15:\n              this.close(Cm.IP_BANNED);\n              break;\n            case 16:\n              this.close(Cm.CHANNEL_BANNED);\n          }\n          if (t._type === Pm.ON_USER_LICENSE_BANNED) switch (t._message.error_code) {\n            case Im.ERR_LICENSE_MISSING:\n              this.close(Cm.LICENSE_MISSING);\n              break;\n            case Im.ERR_LICENSE_EXPIRED:\n              this.close(Cm.LICENSE_EXPIRED);\n              break;\n            case Im.ERR_LICENSE_MINUTES_EXCEEDED:\n              this.close(Cm.LICENSE_MINUTES_EXCEEDED);\n              break;\n            case Im.ERR_LICENSE_PERIOD_INVALID:\n              this.close(Cm.LICENSE_PERIOD_INVALID);\n              break;\n            case Im.ERR_LICENSE_MULTIPLE_SDK_SERVICE:\n              this.close(Cm.LICENSE_MULTIPLE_SDK_SERVICE);\n              break;\n            case Im.ERR_LICENSE_ILLEGAL:\n              this.close(Cm.LICENSE_ILLEGAL);\n              break;\n            default:\n              this.close();\n          }\n        }\n      }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new $A(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, !0, t), this.handleWebsocketEvents(), window.addEventListener(\"offline\", () => {\n        this.connectionState === bm.CONNECTED && this.reconnect(\"retry\", Om.OFFLINE);\n      });\n    }\n    async request(e, t, i, r) {\n      const n = MR(6, \"\"),\n        o = {\n          _id: n,\n          _type: e,\n          _message: t\n        },\n        s = this.websocket.connectionID,\n        a = () => new Cl((t, i) => {\n          if (this.connectionState === bm.CONNECTED) return t();\n          const r = () => {\n              this.off(wm.WS_CLOSED, n), t();\n            },\n            n = () => {\n              this.off(wm.WS_CONNECTED, r), i(new vE(TE.WS_ABORT));\n            };\n          this.once(wm.WS_CONNECTED, r), this.once(wm.WS_CLOSED, n), e !== Nm.PUBLISH && e !== Nm.SUBSCRIBE && e !== Nm.UNSUBSCRIBE && e !== Nm.UNPUBLISH && e !== Nm.CONTROL && e !== Nm.RESTART_ICE || this.once(wm.DISCONNECT_P2P, () => {\n            i(new vE(TE.DISCONNECT_P2P));\n          }), e !== Nm.PUBLISH && e !== Nm.RESTART_ICE || this.once(wm.ABORT_P2P_EXECUTION, () => {\n            i(new vE(TE.DISCONNECT_P2P));\n          });\n        });\n      if (this.connectionState !== bm.CONNECTING && this.connectionState !== bm.RECONNECTING || e === Nm.JOIN || e === Nm.REJOIN || (await a()), this.websocket.sendMessage(o, !0), r) return;\n      const c = new Cl((i, r) => {\n        let o = !1;\n        const a = (r, n) => {\n          o = !0, i({\n            isSuccess: \"success\" === r,\n            message: n || {}\n          }), this.off(wm.WS_CLOSED, c), this.off(wm.WS_RECONNECTING, c), this.emit(wm.REQUEST_SUCCESS, e, t);\n        };\n        this.once(\"res-@\".concat(n), a);\n        const c = () => {\n          r(new vE(TE.WS_ABORT, \"type: \".concat(e))), this.off(wm.WS_CLOSED, c), this.off(wm.WS_RECONNECTING, c), this.off(\"res-@\".concat(n), a);\n        };\n        this.once(wm.WS_CLOSED, c), this.once(wm.WS_RECONNECTING, c), LR(HE(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n          this.websocket.connectionID !== s || o || (NE.warning(\"ws request timeout, type: \".concat(e)), this.emit(wm.REQUEST_TIMEOUT, e, t));\n        });\n      });\n      let d = null;\n      try {\n        d = await c;\n      } catch (r) {\n        if (this.connectionState === bm.CLOSED || e === Nm.LEAVE) throw new vE(TE.WS_ABORT);\n        return !this.spec.forceWaitGatewayResponse || i ? r.throw() : e === Nm.JOIN || e === Nm.REJOIN ? null : (await a(), await this.request(e, t));\n      }\n      if (d.isSuccess) return d.message;\n      const u = Number(d.message.error_code || d.message.code),\n        l = zA(u),\n        h = new vE(TE.UNEXPECTED_RESPONSE, \"\".concat(l.desc, \": \").concat(d.message.error_str), {\n          code: u,\n          data: d.message\n        });\n      return \"success\" === l.action ? d.message : (NE.warning(\"[\".concat(this.websocket.connectionID, \"] unexpected response from type \").concat(e, \", error_code: \").concat(u, \", message: \").concat(l.desc, \", action: \").concat(l.action)), u === Im.ERR_TOO_MANY_BROADCASTERS ? e === Nm.JOIN || e === Nm.REJOIN ? (this.initError = h, this.close(), h.throw()) : h.throw() : \"failed\" === l.action ? h.throw() : \"quit\" === l.action ? (this.initError = h, this.close(), h.throw()) : (u === Im.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d.message.option, NE.warning(\"[\".concat(this.clientId, \"] detect multi ip, recover\")), this.reconnect(\"recover\", Om.MULTI_IP)) : this.reconnect(l.action, Om.SERVER_ERROR), e === Nm.JOIN || e === Nm.REJOIN ? null : await this.request(e, t)));\n    }\n    waitMessage(e, t) {\n      return new Cl(i => {\n        const r = n => {\n          (!t || t(n)) && (this.off(e, r), i(n));\n        };\n        this.on(e, r);\n      });\n    }\n    upload(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      try {\n        this.websocket.sendMessage(i);\n      } catch (e) {\n        const t = HE(\"MAX_UPLOAD_CACHE\") || 50;\n        this.uploadCache.push(i), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n          if (this.connectionState !== bm.CONNECTED) return;\n          const e = this.uploadCache.splice(0, 1)[0];\n          0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message);\n        }, HE(\"UPLOAD_CACHE_INTERVAL\") || 2e3));\n      }\n    }\n    send(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      this.websocket.sendMessage(i);\n    }\n    init(e, t) {\n      return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Cl((i, r) => {\n        this.once(wm.WS_CONNECTED, () => i(this.joinResponse)), this.once(wm.WS_CLOSED, () => r(this.initError || new vE(TE.WS_ABORT))), this.connectionState = bm.CONNECTING, this.websocket.init(e).catch(r), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {\n          this.handleWsInflateData();\n        }, 2e4), setTimeout(() => {\n          t && void 0 === this.openConnectionTime && (NE.debug(\"[\".concat(this.clientId, \"] init websocket timeout while join with fallback to proxy\")), r(new vE(TE.INIT_WEBSOCKET_TIMEOUT)));\n        }, HE(\"JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION\"));\n      });\n    }\n    close(e) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || Cm.LEAVE, this.connectionState = bm.CLOSED, NE.debug(\"[\".concat(this.clientId, \"] \") + \"will close websocket in signal\"), this.websocket.close(), e === Cm.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new $A(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, !0, this.store), this.handleWebsocketEvents());\n    }\n    async join() {\n      if (!this.joinResponse) {\n        this.emit(wm.ABORT_P2P_EXECUTION);\n        const e = await FR(this, wm.REQUEST_JOIN_INFO),\n          t = await this.request(Nm.JOIN, e);\n        if (!t) return this.emit(wm.REPORT_JOIN_GATEWAY, TE.TIMEOUT, this.url || \"\"), !1;\n        this.joinResponse = t, this.emit(wm.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;\n      }\n      return this.connectionState = bm.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0;\n    }\n    async rejoin() {\n      if (!this.reconnectToken) throw new vE(TE.UNEXPECTED_ERROR, \"can not rejoin, no rejoin token\");\n      const e = WR(this, wm.REQUEST_REJOIN_INFO);\n      e.token = this.reconnectToken;\n      const t = await this.request(Nm.REJOIN, e);\n      return !!t && (this.connectionState = bm.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {\n        this.emit(Pm.ON_USER_ONLINE, {\n          uid: e.uid\n        }), e.audio && this.emit(Pm.ON_ADD_AUDIO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          audio: !0,\n          ssrcId: e.audio_ssrc\n        }), e.video && this.emit(Pm.ON_ADD_VIDEO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          video: !0,\n          ssrcId: e.video_ssrc\n        }), e.audio_mute ? this.emit(Pm.MUTE_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Pm.UNMUTE_AUDIO, {\n          uid: e.uid\n        }), e.video_mute ? this.emit(Pm.MUTE_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Pm.UNMUTE_VIDEO, {\n          uid: e.uid\n        }), e.audio_enable_local ? this.emit(Pm.ENABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Pm.DISABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }), e.video_enable_local ? this.emit(Pm.ENABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Pm.DISABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }), e.audio || e.video || this.emit(Pm.ON_REMOVE_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id\n        });\n      }), !0);\n    }\n    reconnect(e, t) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t);\n    }\n    handleNotification(e) {\n      NE.debug(\"[\".concat(this.clientId, \"] receive notification: \"), e);\n      const t = zA(e.code);\n      if (\"success\" !== t.action) {\n        if (\"failed\" !== t.action) return \"quit\" === t.action ? (\"ERR_REPEAT_JOIN_CHANNEL\" === t.desc && this.close(Cm.UID_BANNED), void this.close()) : void this.reconnect(t.action, Om.SERVER_ERROR);\n        NE.error(\"[\".concat(this.clientId, \"] ignore error: \"), t.desc);\n      }\n    }\n    handlePingPong() {\n      if (!this.websocket || \"connected\" !== this.websocket.state) return;\n      this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;\n      const e = HE(\"PING_PONG_TIME_OUT\"),\n        t = Date.now();\n      this.pingpongTimeoutCount >= e && (NE.warning(\"PINGPONG Timeout. Last Socket Message: \".concat(t - this.lastMsgTime, \"ms\")), t - this.lastMsgTime > HE(\"WEBSOCKET_TIMEOUT_MIN\")) ? this.reconnect(\"retry\", Om.TIMEOUT) : this.request(Nm.PING, void 0, !0).then(() => {\n        this.pingpongTimeoutCount = 0;\n        const e = Date.now() - t;\n        this.rttRolling.add(e), HE(\"REPORT_STATS\") && this.send(Nm.PING_BACK, {\n          pingpongElapse: e\n        });\n      }).catch(e => {});\n    }\n    handleWsInflateData() {\n      const {\n        wsInflateLength: e,\n        wsDeflateLength: t\n      } = this.websocket.getWsInflateData();\n      0 !== e && 0 !== t && this.upload(Dm.WS_INFLATE_DATA_LENGTH, {\n        ws_deflate_length: t,\n        ws_inflate_length: e\n      });\n    }\n    handleWebsocketEvents() {\n      this.websocket.on(Km.RECONNECT_WAITTING_FINISH, e => {\n        this.emit(wm.WS_RECONNECT_WAITTING_FINISH, e);\n      }), this.websocket.on(Km.RECONNECT_CREATE_CONNECTION, e => {\n        this.emit(wm.WS_RECONNECT_CREATE_CONNECTION, e);\n      }), this.websocket.on(Km.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Km.CLOSED, () => {\n        this.connectionState = bm.CLOSED;\n      }), this.websocket.on(Km.FAILED, () => {\n        this._disconnectedReason = Cm.NETWORK_ERROR, this.connectionState = bm.CLOSED;\n      }), this.websocket.on(Km.RECONNECTING, e => {\n        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === bm.CONNECTED ? this.connectionState = bm.RECONNECTING : this.connectionState = bm.CONNECTING;\n      }), this.websocket.on(Km.WILL_RECONNECT, (e, t) => {\n        if (WR(this, wm.IS_P2P_DISCONNECTED) && \"retry\" === e) return NE.debug(\"\".concat(this.clientId, \" reconnect mode is retry, but p2p lost, change to tryNext\")), this.reconnectToken = void 0, this.emit(wm.NEED_RENEW_SESSION), this.emit(wm.DISCONNECT_P2P), t(\"tryNext\");\n        \"retry\" !== e && (NE.debug(\"\".concat(this.clientId, \" websockt will_connect event, renewSession reconnectMode is \").concat(e)), this.reconnectToken = void 0, this.emit(wm.NEED_RENEW_SESSION), this.emit(wm.DISCONNECT_P2P)), t(e);\n      }), this.websocket.on(Km.CONNECTED, () => {\n        this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {\n          NE.warning(\"[\".concat(this.clientId, \"] rejoin failed \").concat(e)), this.reconnect(\"tryNext\", Om.SERVER_ERROR);\n        }) : this.join().catch(e => {\n          if (this.emit(wm.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || \"\"), e instanceof vE && e.code === TE.UNEXPECTED_RESPONSE && e.data.code === Im.ERR_NO_AUTHORIZED) return NE.warning(\"[\".concat(this.clientId, \"] reconnect no authorized, recover\")), void this.reconnect(\"recover\", Om.SERVER_ERROR);\n          NE.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", Om.SERVER_ERROR) : (this.initError = e, this.close());\n        });\n      }), this.websocket.on(Km.REQUEST_NEW_URLS, (e, t) => {\n        FR(this, wm.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t);\n      }), this.websocket.on(Km.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        this.emit(Pm.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n      });\n    }\n  }\n  function iO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  class rO extends gE {\n    get url() {\n      return this._url ? this._url : null;\n    }\n    get reconnectMode() {\n      return this._reconnectMode;\n    }\n    set reconnectMode(e) {\n      [\"tryNext\", \"recover\"].includes(e) && this.resetReconnectCount(e), this._reconnectMode = e;\n    }\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      e !== this._state && (this._state = e, \"reconnecting\" === this._state ? this.emit(Ug.RECONNECTING, this.reconnectReason) : \"connected\" === this._state ? this.emit(Ug.CONNECTED) : \"closed\" === this._state ? this.emit(Ug.CLOSED) : \"failed\" === this._state && this.emit(Ug.FAILED));\n    }\n    constructor(e, t, i, r) {\n      super(), mp(this, \"connectionID\", 0), mp(this, \"currentURLIndex\", 0), mp(this, \"reconnectReason\", void 0), mp(this, \"_reconnectMode\", \"tryNext\"), mp(this, \"_initMutex\", void 0), mp(this, \"_name\", void 0), mp(this, \"_state\", \"closed\"), mp(this, \"_reconnectInterrupter\", void 0), mp(this, \"_url\", void 0), mp(this, \"_retryConfig\", void 0), mp(this, \"_reconnectCount\", 0), mp(this, \"_forceCloseTimeout\", 5e3), mp(this, \"_onlineReconnectListener\", void 0), mp(this, \"_messageSender\", void 0), mp(this, \"_closeEstablishingTransmitter\", () => {}), mp(this, \"_store\", void 0), mp(this, \"_joinChannelServiceRecordIndex\", void 0), mp(this, \"_transmitter\", void 0), mp(this, \"_useCompress\", void 0), mp(this, \"_inflateLength\", 0), mp(this, \"_deflateLength\", 0), this._store = r, this._name = e, this._retryConfig = function (e) {\n        for (var t = 1; t < arguments.length; t++) {\n          var i = null != arguments[t] ? arguments[t] : {};\n          t % 2 ? iO(Object(i), !0).forEach(function (t) {\n            mp(e, t, i[t]);\n          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : iO(Object(i)).forEach(function (t) {\n            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n          });\n        }\n        return e;\n      }({}, t), this._useCompress = i;\n    }\n    resetReconnectCount(e) {\n      NE.debug(\"\".concat(this._name, \" reset reconnect count, reason: \").concat(e)), this._reconnectCount = 0;\n    }\n    close(e, t) {\n      var i;\n      if (this.currentURLIndex = 0, this.resetReconnectCount(\"close\"), null === (i = this._messageSender) || void 0 === i || i.reset(), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {\n        this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;\n        const e = this._transmitter;\n        t ? setTimeout(() => e.close(), 500) : e.close(), this._transmitter = void 0;\n      }\n      this.state = e ? \"failed\" : \"closed\", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter();\n    }\n    reconnect(e, t) {\n      if (!this._transmitter) return void NE.warning(\"[\".concat(this._name, \"] can not reconnect, no websocket\"));\n      var i;\n      (void 0 !== e && (this.reconnectMode = e), NE.debug(\"[\".concat(this._name, \"] reconnect is triggered initiative\")), \"number\" == typeof this._joinChannelServiceRecordIndex) && (null === (i = this._store) || void 0 === i || i.recordJoinChannelService({\n        status: \"error\",\n        errors: [new Error(t)]\n      }, this._joinChannelServiceRecordIndex));\n      const r = this._transmitter.onclose;\n      this._transmitter.onclose = null, this._transmitter.close(), r && r.bind(this._transmitter)({\n        code: 9999,\n        reason: t\n      });\n    }\n    getInflateData() {\n      const e = this._inflateLength,\n        t = this._deflateLength;\n      return this.clearInflateData(), {\n        inflateLength: e,\n        deflateLength: t\n      };\n    }\n    setInflateData(e) {\n      this._deflateLength = this._deflateLength + e.originLength, this._inflateLength = this._inflateLength + e.compressedLength;\n    }\n    clearInflateData() {\n      this._inflateLength = 0, this._deflateLength = 0;\n    }\n  }\n  function nO(e, t, i) {\n    if (\"getBigUint64\" in DataView.prototype) return e.getBigUint64(t, i);\n    const r = e.getUint32(t, i),\n      n = e.getUint32(t + 4, i),\n      o = Number(!!i),\n      s = Number(!i);\n    return BigInt(r * s + n * o) << BigInt(32) | BigInt(r * o + n * s);\n  }\n  function oO(e, t, i, r) {\n    if (\"setBigUint64\" in DataView.prototype) return e.setBigUint64(t, i, r);\n    const n = Number(i >> BigInt(32)),\n      o = Number(i & BigInt(4294967295));\n    r ? (e.setUint32(t + 4, n, r), e.setUint32(t, o, r)) : (e.setUint32(t, n, r), e.setUint32(t + 4, o, r));\n  }\n  let sO;\n  !function (e) {\n    e[e.Default = 0] = \"Default\", e[e.Ack = 1] = \"Ack\";\n  }(sO || (sO = {}));\n  class aO {\n    constructor(e, t, i) {\n      mp(this, \"version\", 1), mp(this, \"initialRTO\", void 0), mp(this, \"maxBatchAckCount\", void 0), mp(this, \"maxRTO\", void 0), mp(this, \"initialRTT\", void 0), mp(this, \"ID\", void 0), mp(this, \"rtt\", void 0), mp(this, \"packetNumber\", 1), mp(this, \"rtoRatioMap\", new Map()), mp(this, \"timeoutMap\", new Map()), mp(this, \"unorderedPacketQueue\", []), mp(this, \"batchAckPacketQueue\", []), mp(this, \"lastOrderedPacketNumber\", 0), mp(this, \"batchAckTimer\", void 0), mp(this, \"sendImpl\", void 0), mp(this, \"receiveImpl\", void 0), this.sendImpl = e, this.receiveImpl = t, this.ID = MR(7, \"transmitter-\"), this.initialRTO = void 0 !== (null == i ? void 0 : i.initialRTO) ? i.initialRTO : HE(\"TRANSMITTER_INITIAL_RTO\"), this.initialRTT = void 0 !== (null == i ? void 0 : i.initialRTT) ? i.initialRTT : HE(\"TRANSMITTER_INITIAL_RTT\"), this.rtt = void 0 !== (null == i ? void 0 : i.initialRTT) ? i.initialRTT : HE(\"TRANSMITTER_INITIAL_RTT\"), this.maxBatchAckCount = void 0 !== (null == i ? void 0 : i.maxBatchAckCount) ? i.maxBatchAckCount : HE(\"TRANSMITTER_MAX_BATCH_ACK_COUNT\"), this.maxRTO = void 0 !== (null == i ? void 0 : i.maxRTO) ? i.maxRTO : HE(\"TRANSMITTER_MAX_RTO\");\n    }\n    packetize(e, t) {\n      return {\n        type: sO.Default,\n        version: this.version,\n        packetNumber: t,\n        payload: e\n      };\n    }\n    serialize(e) {\n      switch (e.type) {\n        case sO.Default:\n          {\n            let t;\n            if (\"string\" == typeof e.payload) {\n              t = new TextEncoder().encode(e.payload);\n            } else t = e.payload;\n            const i = new ArrayBuffer(t.length + 15),\n              r = new DataView(i);\n            r.setUint16(0, e.version), r.setUint8(2, e.type), r.setUint32(3, e.packetNumber), oO(r, 7, BigInt(e.sendTs));\n            return new Uint8Array(r.buffer).set(t, 15), i;\n          }\n        case sO.Ack:\n          {\n            const t = new ArrayBuffer(16),\n              i = new DataView(t);\n            return i.setUint16(0, e.version), i.setUint8(2, e.type), i.setUint32(3, e.maxAckPacketNumber), i.setUint8(7, e.shift), oO(i, 8, BigInt(e.ackSendTs)), t;\n          }\n      }\n    }\n    deserialize(e) {\n      const t = new DataView(e),\n        i = t.getUint16(0),\n        r = t.getUint8(2);\n      switch (r) {\n        case sO.Default:\n          {\n            const n = t.getUint32(3),\n              o = nO(t, 7),\n              s = e.slice(15),\n              a = new TextDecoder().decode(s);\n            return {\n              version: i,\n              type: r,\n              packetNumber: n,\n              sendTs: Number(o),\n              payload: a\n            };\n          }\n        case sO.Ack:\n          {\n            const e = t.getUint32(3),\n              n = t.getUint8(7),\n              o = nO(t, 8);\n            return {\n              version: i,\n              type: r,\n              maxAckPacketNumber: e,\n              shift: n,\n              ackSendTs: Number(o)\n            };\n          }\n        default:\n          throw NE.error(\"[\".concat(this.ID, \"] Unrecognized packet type \").concat(r)), new Error(\"Unrecognized packet type \".concat(r));\n      }\n    }\n    sendMessage(e) {\n      const t = this.packetize(e, this.packetNumber);\n      this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;\n      const i = this.calculateRTO(t),\n        r = window.setTimeout(() => {\n          this.resendMessage(t);\n        }, i);\n      this.timeoutMap.set(t.packetNumber, r), this.sendPacket(t);\n    }\n    onData(e) {\n      const t = this.deserialize(e);\n      t.type === sO.Default ? this.ack(t) : t.type === sO.Ack && (this.updateRTT(t, Math.round(performance.now())), this.clearRTO(t));\n    }\n    close() {\n      this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach(e => {\n        let [t, i] = e;\n        window.clearTimeout(i);\n      }), this.timeoutMap = new Map(), this.rtoRatioMap = new Map(), this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer);\n    }\n    resendMessage(e) {\n      const t = this.calculateRTO(e),\n        i = window.setTimeout(() => {\n          this.resendMessage(e);\n        }, t);\n      this.timeoutMap.set(e.packetNumber, i), this.sendPacket(e);\n    }\n    calculateRTO(e) {\n      const t = this.rtoRatioMap.get(e.packetNumber);\n      if (void 0 === t) return this.rtoRatioMap.set(e.packetNumber, 1), this.initialRTO;\n      {\n        const i = 9 * this.rtt / 8 * t;\n        return this.rtoRatioMap.set(e.packetNumber, t + 1), i > this.maxRTO ? this.maxRTO : i;\n      }\n    }\n    updateRTT(e, t) {\n      const i = e.ackSendTs;\n      this.rtt = this.rtt * (7 / 8) + (t - i - this.rtt) / 8;\n    }\n    ack(e) {\n      if (e.packetNumber === this.lastOrderedPacketNumber + 1) for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e) : (this.batchAckPacketQueue.push(e), this.batchAckTimer = window.setTimeout(() => {\n        this.batchAck();\n      }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e.payload);;) {\n        const e = this.unorderedPacketQueue[0];\n        if (!e) {\n          this.unorderedPacketQueue.shift();\n          break;\n        }\n        this.batchAckTimer && this.batchAck(), this.receiveImpl(e.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1;\n      } else if (e.packetNumber <= this.lastOrderedPacketNumber) {\n        const t = {\n          ackSendTs: e.sendTs,\n          maxAckPacketNumber: e.packetNumber,\n          shift: 0,\n          type: sO.Ack,\n          version: this.version\n        };\n        this.sendPacket(t);\n      } else if (e.packetNumber > this.lastOrderedPacketNumber) {\n        this.unorderedPacketQueue[e.packetNumber - this.lastOrderedPacketNumber - 2] = e;\n        const t = {\n          ackSendTs: e.sendTs,\n          maxAckPacketNumber: e.packetNumber,\n          shift: 0,\n          type: sO.Ack,\n          version: this.version\n        };\n        this.sendPacket(t);\n      }\n    }\n    batchAck() {\n      window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;\n      const e = {\n        ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs,\n        maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber,\n        shift: this.batchAckPacketQueue.length - 1,\n        type: sO.Ack,\n        version: this.version\n      };\n      this.sendPacket(e), this.batchAckPacketQueue = [];\n    }\n    sendPacket(e) {\n      e.type === sO.Default && (e.sendTs = Math.round(performance.now()));\n      const t = this.serialize(e);\n      this.sendImpl(t);\n    }\n    clearRTO(e) {\n      for (let t = e.maxAckPacketNumber - e.shift; t <= e.maxAckPacketNumber; t++) {\n        const e = this.timeoutMap.get(t);\n        void 0 !== e && window.clearTimeout(e), this.timeoutMap.delete(t), this.rtoRatioMap.delete(t);\n      }\n    }\n  }\n  class cO extends gE {\n    get queue() {\n      return [...this.highPriorityQueue, ...this.lowPriorityQueue];\n    }\n    constructor(e) {\n      super(), mp(this, \"lowPriorityQueue\", []), mp(this, \"highPriorityQueue\", []), mp(this, \"AgoraTransmissionManager\", void 0), this.AgoraTransmissionManager = e;\n    }\n    reset() {\n      this.lowPriorityQueue = [], this.highPriorityQueue = [];\n    }\n    pushMessage(e) {\n      arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? this.highPriorityQueue.push(e) : this.lowPriorityQueue.push(e), this.sendMessage();\n    }\n    sendMessage() {\n      const e = this.queue.length;\n      let t = 0;\n      t = e < 5 ? 15 * e : 60 + 3 * (e - 4), setTimeout(() => {\n        this._sendMessage();\n      }, t);\n    }\n    _sendMessage() {\n      if (!this.queue.length) return;\n      const e = this.AgoraTransmissionManager.getConnection();\n      if (!e) return;\n      const t = this.queue.shift();\n      return this.lowPriorityQueue.includes(t) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e.sendMessage(t.compressed), t;\n    }\n  }\n  class dO extends rO {\n    constructor(e, t) {\n      super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), mp(this, \"_initMutex\", void 0), mp(this, \"_reconnectInterrupter\", void 0), mp(this, \"_url\", void 0), mp(this, \"_transmitter\", void 0), mp(this, \"_addresses\", void 0), mp(this, \"_reliableTransmission\", void 0), this._initMutex = new OT(\"datachannel\");\n      const {\n          timeout: i,\n          timeoutFactor: r\n        } = t,\n        n = Math.max(300, Math.floor(3 * i / 5)),\n        o = Math.max(1.2, Math.floor(8 * r) / 10);\n      bg.ONLINE && (this._retryConfig.timeout = n, this._retryConfig.timeoutFactor = o), pT.on(wg.NETWORK_STATE_CHANGE, (e, t) => {\n        e !== t && (this.resetReconnectCount(\"network state change: \".concat(t, \" -> \").concat(e)), e === bg.ONLINE ? (this._retryConfig.timeout = n, this._retryConfig.timeoutFactor = o) : (this._retryConfig.timeout = i, this._retryConfig.timeoutFactor = r));\n      });\n    }\n    getConnection() {\n      if (this._reliableTransmission) return this._reliableTransmission;\n    }\n    async init(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n      this._forceCloseTimeout = t;\n      const i = (t, i) => {\n        this._addresses = e, this.currentURLIndex = this._addresses.findIndex(e => e.fingerprint || HE(\"FINGERPRINT\"));\n        const r = this._addresses[this.currentURLIndex];\n        this.state = \"connecting\", this._messageSender = new cO(this), this.createTransmitterConnection(r).then(t).catch(i), this.once(Ug.CLOSED, () => i(new vE(TE.WS_DISCONNECT))), this.once(Ug.CONNECTED, () => t());\n      };\n      return this._initMutex.lock().then(e => new Cl((e, t) => {\n        i(e, t);\n      }).then(() => {\n        e();\n      }).catch(() => {\n        e();\n      }));\n    }\n    sendMessage(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n        i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];\n      if (!this._transmitter || !this._reliableTransmission) throw new vE(TE.WS_ABORT, \"datachannel is not ready\");\n      try {\n        let r = null;\n        r = i ? this.sendMessageWithUint8Array(e) : this.sendMessageWithJSON(e), t ? this._reliableTransmission.sendMessage(r.compressed) : this._messageSender.pushMessage(r);\n      } catch (e) {\n        throw new vE(TE.WS_ERR, \"send datachannel signal message error\" + e.toString());\n      }\n    }\n    unbindDcCloseEventListener() {\n      this._transmitter && (this._transmitter.onclose = null);\n    }\n    sendMessageWithJSON(e) {\n      const t = JSON.stringify(e);\n      return {\n        compressed: t,\n        compressedLength: t.length,\n        origin: e\n      };\n    }\n    sendMessageWithUint8Array(e) {\n      return {\n        compressed: e,\n        compressedLength: e.byteLength,\n        origin: e\n      };\n    }\n    createTransmitterConnection(e) {\n      return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = \"dc://\".concat(e.ip, \":\").concat(e.port), new Cl((t, i) => {\n        var r;\n        const n = () => {\n            NE.debug(\"[\".concat(this._name, \"] datachannel opened:\"), this._url), this.reconnectMode = \"retry\", this.state = \"connected\", this.resetReconnectCount(\"opened\"), t();\n          },\n          o = async e => {\n            var r;\n            if (null === (r = this._closeEstablishingTransmitter) || void 0 === r || r.call(this), NE.debug(\"[\".concat(this._name, \"] datachannel close \").concat(this._url, \", code: \").concat(e.code, \", reason: \").concat(e.reason, \", current mode: \").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {\n              \"connected\" === this.state && (this.reconnectReason = e.reason, this.state = \"reconnecting\");\n              const r = GR(this, Ug.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode,\n                n = await this.reconnectWithAction(r);\n              if (\"closed\" === this.state) return void NE.debug(\"[\".concat(this.connectionID, \"] dc is closed, no need to reconnect\"));\n              if (!n) return i(new vE(TE.WS_DISCONNECT, \"datachannel reconnect failed: \".concat(e.code))), void this.close(!0);\n              t();\n            } else i(new vE(TE.WS_DISCONNECT, \"datachannel close: \".concat(e.code))), this.close();\n          },\n          s = e => {\n            var t;\n            null === (t = this._reliableTransmission) || void 0 === t || t.onData(e.data);\n          };\n        this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), NE.debug(\"[\".concat(this._name, \"] start connect, address: \").concat(JSON.stringify(e)));\n        const a = null === (r = this._store) || void 0 === r ? void 0 : r.recordJoinChannelService({\n            startTs: Date.now(),\n            status: \"pending\",\n            service: \"gateway\"\n          }),\n          c = Date.now();\n        FR(this, Ug.TO_CONNECT_DATACHANNEL, e).then(e => {\n          var t, i;\n          if (!e) throw new Error(\"transmissonInfo not exist yet\");\n          const {\n            transmitter: r,\n            close: d\n          } = e;\n          this._transmitter = r, null === (t = this._store) || void 0 === t || t.signalChannelOpen();\n          const u = Date.now() - c;\n          NE.debug(\"[choose dc] dc open cost \".concat(u, \"ms\"));\n          this._reliableTransmission = new aO(e => {\n            var t;\n            this._transmitter && \"open\" === this._transmitter.readyState && (null === (t = this._transmitter) || void 0 === t || t.send(e));\n          }, e => {\n            \"string\" == typeof e && this.emit(Ug.ON_MESSAGE, e);\n          }), this._closeEstablishingTransmitter = () => {\n            var e;\n            null === (e = this._reliableTransmission) || void 0 === e || e.close(), this._reliableTransmission = void 0, d();\n          }, n && n(), r.onclose = o, r.onmessage = s, null === (i = this._store) || void 0 === i || i.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, a), this._joinChannelServiceRecordIndex = a;\n        }).catch(e => {\n          var t;\n          if (null === (t = this._store) || void 0 === t || t.recordJoinChannelService({\n            endTs: Date.now(),\n            status: e instanceof vE && e.code === TE.WS_ABORT ? \"aborted\" : \"error\",\n            errors: [e]\n          }, a), \"closed\" !== this.state) {\n            if (e instanceof vE && e.code === TE.WS_ERR) {\n              const t = new vE(TE.WS_ERR, \"init datachannel failed! Error: \".concat(e.toString()));\n              return NE.error(\"[\".concat(this._name, \"]\").concat(t)), void i(t);\n            }\n            o && o(e);\n          } else i(new vE(TE.WS_DISCONNECT, \"datachannel is closed: \".concat(e.toString())));\n        });\n      });\n    }\n    async reconnectWithAction(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (this._reconnectCount >= this._retryConfig.maxRetryCount) return !1;\n      if (!this._addresses) return !1;\n      if (\"closed\" === this.state) return !1;\n      this._onlineReconnectListener || pT.networkState !== bg.OFFLINE || (this._onlineReconnectListener = pT.onlineWaiter && pT.onlineWaiter.then(() => {\n        this._onlineReconnectListener = void 0;\n      }));\n      let i = !0;\n      if (this._reconnectInterrupter = () => {\n        i = !1;\n      }, t) {\n        const t = IE(this._reconnectCount, this._retryConfig);\n        NE.debug(\"[\".concat(this._name, \"] wait \").concat(t, \"ms to reconnect datachannel, mode: \").concat(e)), await Cl.race([LR(t), this._onlineReconnectListener || new Cl(() => {})]);\n      }\n      if (\"closed\" === this.state || !i) return !1;\n      this._reconnectCount += 1;\n      const r = async (e, t) => {\n        this.emit(Ug.RECONNECT_CREATE_CONNECTION, t), await this.createTransmitterConnection(e);\n      };\n      try {\n        if (\"retry\" === e) {\n          const t = this._addresses[this.currentURLIndex];\n          this.emit(Ug.RECONNECT_WAITTING_FINISH, e), await r(t, e);\n        } else if (\"tryNext\" === e) {\n          this.currentURLIndex += 1;\n          for (let e = this.currentURLIndex; e < this._addresses.length; e++) {\n            if (this._addresses[e].fingerprint || HE(\"FINGERPRINT\")) {\n              this.currentURLIndex = e;\n              break;\n            }\n            this.currentURLIndex += 1;\n          }\n          if (this.currentURLIndex >= this._addresses.length) return NE.debug(\"[\".concat(this._name, \"] the available addresses are exhausted, change to recover\")), await this.reconnectWithAction(\"recover\", !1);\n          NE.debug(\"[\".concat(this._name, \"] datachannel url length: \").concat(this._addresses.length, \" current index: \").concat(this.currentURLIndex));\n          const t = this._addresses[this.currentURLIndex];\n          this.emit(Ug.RECONNECT_WAITTING_FINISH, e), await r(t, e);\n        } else \"recover\" === e && (NE.debug(\"[\".concat(this._name, \"] start to failback to websocket\")), this.resetReconnectCount(\"recover mode\"), this.emit(Ug.RECONNECT_WAITTING_FINISH, e), this.emit(Ug.FAILBACK));\n        return !0;\n      } catch (i) {\n        var n;\n        return NE.error(\"[\".concat(this._name, \"] reconnect failed\"), i.toString()), null != i && null !== (n = i.data) && void 0 !== n && n.desc && Array.isArray(i.data.desc) && i.data.desc.length && i.data.desc.includes(\"dynamic key expired\") ? (this.emit(Ug.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t);\n      }\n    }\n  }\n  class uO extends gE {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      e !== this._connectionState && (this._connectionState = e, e === bm.CONNECTED ? this.emit(wm.WS_CONNECTED) : e === bm.RECONNECTING ? this.emit(wm.WS_RECONNECTING, this._websocketReconnectReason) : e === bm.CLOSED && this.emit(wm.WS_CLOSED, this._disconnectedReason));\n    }\n    get currentURLIndex() {\n      return this.websocket.currentURLIndex;\n    }\n    get url() {\n      return this.websocket ? this.websocket.url : null;\n    }\n    get rtt() {\n      return this.rttRolling.mean();\n    }\n    constructor(e, t) {\n      super(), mp(this, \"_disconnectedReason\", void 0), mp(this, \"_websocketReconnectReason\", void 0), mp(this, \"_connectionState\", bm.CLOSED), mp(this, \"reconnectToken\", void 0), mp(this, \"websocket\", void 0), mp(this, \"openConnectionTime\", void 0), mp(this, \"clientId\", void 0), mp(this, \"lastMsgTime\", Date.now()), mp(this, \"uploadCache\", []), mp(this, \"uploadCacheInterval\", void 0), mp(this, \"rttRolling\", new eO(5)), mp(this, \"pingpongTimer\", void 0), mp(this, \"inflateDataTimer\", void 0), mp(this, \"pingpongTimeoutCount\", 0), mp(this, \"joinResponse\", void 0), mp(this, \"multiIpOption\", void 0), mp(this, \"initError\", void 0), mp(this, \"spec\", void 0), mp(this, \"store\", void 0), mp(this, \"onWebsocketMessage\", e => {\n        if (e instanceof ArrayBuffer) return void this.emit(wm.ON_BINARY_DATA, e);\n        const t = JSON.parse(e);\n        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, \"_id\")) {\n          const e = \"res-@\".concat(t._id);\n          this.emit(e, t._result, t._message);\n        } else if (Object.prototype.hasOwnProperty.call(t, \"_type\") && (this.emit(t._type, t._message), t._type === Pm.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Pm.ON_USER_BANNED)) switch (t._message.error_code) {\n          case 14:\n            this.close(Cm.UID_BANNED);\n            break;\n          case 15:\n            this.close(Cm.IP_BANNED);\n            break;\n          case 16:\n            this.close(Cm.CHANNEL_BANNED);\n        }\n      }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new dO(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, t), this.handleWebsocketEvents(), window.addEventListener(\"offline\", () => {\n        this.connectionState === bm.CONNECTED && this.reconnect(\"retry\", Mg.OFFLINE);\n      });\n    }\n    async request(e, t, i, r) {\n      const n = MR(6, \"\"),\n        o = {\n          _id: n,\n          _type: e,\n          _message: t\n        },\n        s = this.websocket.connectionID,\n        a = () => new Cl((t, i) => {\n          if (this.connectionState === bm.CONNECTED) return t();\n          const r = () => {\n              this.off(wm.WS_CLOSED, n), t();\n            },\n            n = () => {\n              this.off(wm.WS_CONNECTED, r), i(new vE(TE.WS_ABORT));\n            };\n          this.once(wm.WS_CONNECTED, r), this.once(wm.WS_CLOSED, n), e !== Nm.PUBLISH && e !== Nm.SUBSCRIBE && e !== Nm.UNSUBSCRIBE && e !== Nm.UNPUBLISH && e !== Nm.CONTROL && e !== Nm.RESTART_ICE || this.once(wm.DISCONNECT_P2P, () => {\n            i(new vE(TE.DISCONNECT_P2P));\n          }), e !== Nm.PUBLISH && e !== Nm.RESTART_ICE || this.once(wm.ABORT_P2P_EXECUTION, () => {\n            i(new vE(TE.DISCONNECT_P2P));\n          });\n        });\n      if (this.connectionState !== bm.CONNECTING && this.connectionState !== bm.RECONNECTING || e === Nm.JOIN || e === Nm.REJOIN || (await a()), e === Nm.LEAVE && (this.websocket.unbindDcCloseEventListener(), r = !0), this.websocket.sendMessage(o, !0, !1), r) return;\n      const c = new Cl((i, r) => {\n        let o = !1;\n        const a = (r, n) => {\n          o = !0, i({\n            isSuccess: \"success\" === r,\n            message: n || {}\n          }), this.off(wm.WS_CLOSED, c), this.off(wm.WS_RECONNECTING, c), this.emit(wm.REQUEST_SUCCESS, e, t);\n        };\n        this.once(\"res-@\".concat(n), a);\n        const c = () => {\n          r(new vE(TE.WS_ABORT, \"type: \".concat(e))), this.off(wm.WS_CLOSED, c), this.off(wm.WS_RECONNECTING, c), this.off(\"res-@\".concat(n), a);\n        };\n        this.once(wm.WS_CLOSED, c), this.once(wm.WS_RECONNECTING, c), LR(HE(\"SIGNAL_REQUEST_TIMEOUT\")).then(() => {\n          this.websocket.connectionID !== s || o || (NE.warning(\"dc request timeout, type: \".concat(e)), this.emit(wm.REQUEST_TIMEOUT, e, t));\n        });\n      });\n      let d = null;\n      try {\n        d = await c;\n      } catch (r) {\n        if (this.connectionState === bm.CLOSED || e === Nm.LEAVE) throw new vE(TE.WS_ABORT);\n        return !this.spec.forceWaitGatewayResponse || i ? r.throw() : e === Nm.JOIN || e === Nm.REJOIN ? null : (await a(), await this.request(e, t));\n      }\n      if (d.isSuccess) return d.message;\n      const u = Number(d.message.error_code || d.message.code),\n        l = zA(u),\n        h = new vE(TE.UNEXPECTED_RESPONSE, \"\".concat(l.desc, \": \").concat(d.message.error_str), {\n          code: u,\n          data: d.message\n        });\n      return \"success\" === l.action ? d.message : (NE.warning(\"[\".concat(this.websocket.connectionID, \"] unexpected response from type \").concat(e, \", error_code: \").concat(u, \", message: \").concat(l.desc, \", action: \").concat(l.action)), u === Im.ERR_TOO_MANY_BROADCASTERS ? e === Nm.JOIN || e === Nm.REJOIN ? (this.initError = h, this.close(), h.throw()) : h.throw() : \"failed\" === l.action ? h.throw() : \"quit\" === l.action ? (this.initError = h, this.close(), h.throw()) : (u === Im.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = d.message.option, NE.warning(\"[\".concat(this.clientId, \"] detect multi ip, recover\")), this.reconnect(\"recover\", Mg.MULTI_IP)) : this.reconnect(l.action, Mg.SERVER_ERROR), e === Nm.JOIN || e === Nm.REJOIN ? null : await this.request(e, t)));\n    }\n    waitMessage(e, t) {\n      return new Cl(i => {\n        const r = n => {\n          (!t || t(n)) && (this.off(e, r), i(n));\n        };\n        this.on(e, r);\n      });\n    }\n    upload(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      try {\n        this.websocket.sendMessage(i);\n      } catch (e) {\n        const t = HE(\"MAX_UPLOAD_CACHE\") || 50;\n        this.uploadCache.push(i), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {\n          if (this.connectionState !== bm.CONNECTED) return;\n          const e = this.uploadCache.splice(0, 1)[0];\n          0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message);\n        }, HE(\"UPLOAD_CACHE_INTERVAL\") || 2e3));\n      }\n    }\n    send(e, t) {\n      const i = {\n        _type: e,\n        _message: t\n      };\n      this.websocket.sendMessage(i);\n    }\n    init(e, t) {\n      return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new Cl((i, r) => {\n        this.once(wm.WS_CONNECTED, () => i(this.joinResponse)), this.once(wm.WS_CLOSED, () => r(this.initError || new vE(TE.WS_ABORT))), this.connectionState = bm.CONNECTING, this.websocket.init(e).catch(r), this.websocket.once(Ug.FAILBACK, () => {\n          void 0 === this.openConnectionTime && r(new vE(TE.INIT_DATACHANNEL_TIMEOUT));\n        }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {\n          this.handleInflateData();\n        }, 2e4), setTimeout(() => {\n          t && void 0 === this.openConnectionTime && (NE.debug(\"[\".concat(this.clientId, \"] init datachannel timeout while join with failback to websocket\")), r(new vE(TE.INIT_DATACHANNEL_TIMEOUT)));\n        }, HE(\"DC_JOIN_WITH_FAILBACK\"));\n      });\n    }\n    close(e) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || Cm.LEAVE, this.connectionState = bm.CLOSED, NE.debug(\"[\".concat(this.clientId, \"] \") + \"will close datachannel in signal\"), this.websocket.close(), e === Cm.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new dO(\"gateway-\".concat(this.clientId), this.spec.retryConfig, !0, this.store), this.handleWebsocketEvents());\n    }\n    async join() {\n      if (!this.joinResponse) {\n        this.emit(wm.ABORT_P2P_EXECUTION);\n        const e = await FR(this, wm.DATACHANNEL_CONNECTING),\n          t = await this.request(Nm.JOIN, e);\n        if (!t) return this.emit(wm.REPORT_JOIN_GATEWAY, TE.TIMEOUT, this.url || \"\"), !1;\n        this.joinResponse = t, this.emit(wm.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token;\n      }\n      return this.connectionState = bm.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0;\n    }\n    async rejoin() {\n      if (!this.reconnectToken) throw new vE(TE.UNEXPECTED_ERROR, \"can not rejoin, no rejoin token\");\n      const e = WR(this, wm.REQUEST_REJOIN_INFO);\n      e.token = this.reconnectToken;\n      const t = await this.request(Nm.REJOIN, e);\n      return !!t && (this.connectionState = bm.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {\n        this.emit(Pm.ON_USER_ONLINE, {\n          uid: e.uid\n        }), e.audio && this.emit(Pm.ON_ADD_AUDIO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          audio: !0,\n          ssrcId: e.audio_ssrc\n        }), e.video && this.emit(Pm.ON_ADD_VIDEO_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id,\n          video: !0,\n          ssrcId: e.video_ssrc\n        }), e.audio_mute ? this.emit(Pm.MUTE_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Pm.UNMUTE_AUDIO, {\n          uid: e.uid\n        }), e.video_mute ? this.emit(Pm.MUTE_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Pm.UNMUTE_VIDEO, {\n          uid: e.uid\n        }), e.audio_enable_local ? this.emit(Pm.ENABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }) : this.emit(Pm.DISABLE_LOCAL_AUDIO, {\n          uid: e.uid\n        }), e.video_enable_local ? this.emit(Pm.ENABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }) : this.emit(Pm.DISABLE_LOCAL_VIDEO, {\n          uid: e.uid\n        }), e.audio || e.video || this.emit(Pm.ON_REMOVE_STREAM, {\n          uid: e.uid,\n          uint_id: e.uint_id\n        });\n      }), !0);\n    }\n    reconnect(e, t) {\n      this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t);\n    }\n    handleNotification(e) {\n      NE.debug(\"[\".concat(this.clientId, \"] receive notification: \"), e);\n      const t = zA(e.code);\n      if (\"success\" !== t.action) {\n        if (\"failed\" !== t.action) return \"quit\" === t.action ? (\"ERR_REPEAT_JOIN_CHANNEL\" === t.desc && this.close(Cm.UID_BANNED), void this.close()) : void this.reconnect(t.action, Mg.SERVER_ERROR);\n        NE.error(\"[\".concat(this.clientId, \"] ignore error: \"), t.desc);\n      }\n    }\n    handlePingPong() {\n      if (!this.websocket || \"connected\" !== this.websocket.state) return;\n      this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;\n      const e = HE(\"PING_PONG_TIME_OUT\"),\n        t = Date.now();\n      this.pingpongTimeoutCount >= e && (NE.warning(\"PINGPONG Timeout. Last Socket Message: \".concat(t - this.lastMsgTime, \"ms\")), t - this.lastMsgTime > HE(\"WEBSOCKET_TIMEOUT_MIN\")) ? this.reconnect(\"retry\", Mg.TIMEOUT) : this.request(Nm.PING, void 0, !0).then(() => {\n        this.pingpongTimeoutCount = 0;\n        const e = Date.now() - t;\n        this.rttRolling.add(e), HE(\"REPORT_STATS\") && this.send(Nm.PING_BACK, {\n          pingpongElapse: e\n        });\n      }).catch(e => {});\n    }\n    handleInflateData() {\n      const {\n        inflateLength: e,\n        deflateLength: t\n      } = this.websocket.getInflateData();\n      0 !== e && 0 !== t && this.upload(Dm.WS_INFLATE_DATA_LENGTH, {\n        ws_deflate_length: t,\n        ws_inflate_length: e\n      });\n    }\n    handleWebsocketEvents() {\n      this.websocket.on(Ug.RECONNECT_WAITTING_FINISH, e => {\n        this.emit(wm.WS_RECONNECT_WAITTING_FINISH, e);\n      }), this.websocket.on(Ug.RECONNECT_CREATE_CONNECTION, e => {\n        this.emit(wm.WS_RECONNECT_CREATE_CONNECTION, e);\n      }), this.websocket.on(Ug.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(Ug.CLOSED, () => {\n        this.connectionState = bm.CLOSED;\n      }), this.websocket.on(Ug.FAILED, () => {\n        this._disconnectedReason = Cm.NETWORK_ERROR, this.connectionState = bm.CLOSED;\n      }), this.websocket.on(Ug.RECONNECTING, e => {\n        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === bm.CONNECTED ? this.connectionState = bm.RECONNECTING : this.connectionState = bm.CONNECTING;\n      }), this.websocket.on(Ug.WILL_RECONNECT, (e, t) => {\n        if (WR(this, wm.IS_P2P_DISCONNECTED) && \"retry\" === e) return NE.debug(\"\".concat(this.clientId, \" reconnect mode is retry, but p2p lost, change to tryNext\")), this.reconnectToken = void 0, this.emit(wm.NEED_RENEW_SESSION), this.emit(wm.DISCONNECT_P2P), t(\"tryNext\");\n        \"retry\" !== e && (NE.debug(\"\".concat(this.clientId, \" websockt will_connect event, renewSession reconnectMode is \").concat(e)), this.reconnectToken = void 0, this.emit(wm.NEED_RENEW_SESSION), this.emit(wm.DISCONNECT_P2P)), t(e);\n      }), this.websocket.on(Ug.CONNECTED, () => {\n        this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {\n          NE.warning(\"[\".concat(this.clientId, \"] rejoin failed \").concat(e)), this.reconnect(\"tryNext\", Mg.SERVER_ERROR);\n        }) : this.join().catch(e => {\n          if (this.emit(wm.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || \"\"), e instanceof vE && e.code === TE.UNEXPECTED_RESPONSE && e.data.code === Im.ERR_NO_AUTHORIZED) return NE.warning(\"[\".concat(this.clientId, \"] reconnect no authorized, recover\")), void this.reconnect(\"recover\", Mg.SERVER_ERROR);\n          NE.error(\"[\".concat(this.clientId, \"] join gateway request failed\"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect(\"tryNext\", Mg.SERVER_ERROR) : (this.initError = e, this.close());\n        });\n      }), this.websocket.on(Ug.REQUEST_NEW_URLS, (e, t) => {\n        FR(this, wm.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t);\n      }), this.websocket.on(Ug.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        this.emit(Pm.ON_TOKEN_PRIVILEGE_DID_EXPIRE);\n      }), this.websocket.on(Ug.TO_CONNECT_DATACHANNEL, async (e, t, i) => FR(this, wm.DATACHANNEL_PRECONNECT, e).then(t).catch(i)), this.websocket.on(Ug.FAILBACK, () => {\n        void 0 !== this.openConnectionTime && this.emit(wm.DATACHANNEL_FAILBACK);\n      });\n    }\n  }\n  function lO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function hO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? lO(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : lO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  const pO = new Map();\n  class _O extends gE {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      if (e === this._state) return;\n      const t = this._state;\n      this._state = e, \"DISCONNECTED\" === e && this._disconnectedReason ? this.emit(cg.CONNECTION_STATE_CHANGE, e, t, this._disconnectedReason) : this.emit(cg.CONNECTION_STATE_CHANGE, e, t);\n    }\n    get joinGatewayStartTime() {\n      return this._joinGatewayStartTime;\n    }\n    set joinGatewayStartTime(e) {\n      NE.debug(\"[\".concat(this.store.clientId, \"] set joinGatewayStartTime at \").concat(e)), this._joinGatewayStartTime = e;\n    }\n    constructor(e, t) {\n      super(), mp(this, \"store\", void 0), mp(this, \"joinInfo\", void 0), mp(this, \"key\", void 0), mp(this, \"signal\", void 0), mp(this, \"role\", void 0), mp(this, \"inChannelInfo\", {\n        joinAt: null,\n        duration: 0\n      }), mp(this, \"spec\", void 0), mp(this, \"_state\", \"DISCONNECTED\"), mp(this, \"_statsCollector\", void 0), mp(this, \"_disconnectedReason\", void 0), mp(this, \"isSignalRecover\", !1), mp(this, \"hasChangeBGPAddress\", !1), mp(this, \"trafficStatsInterval\", void 0), mp(this, \"networkQualityInterval\", void 0), mp(this, \"_joinGatewayStartTime\", 0), mp(this, \"_signalTimeout\", !1), mp(this, \"_clientRoleOptions\", void 0), mp(this, \"_isProactiveJoin\", !1), this.store = e, this.spec = t;\n      const i = jg().supportDataChannel && HE(\"SIGNAL_CHANNEL\");\n      this.signal = i ? new uO(hO(hO({}, t), {}, {\n        retryConfig: t.websocketRetryConfig\n      }), e) : new tO(hO(hO({}, t), {}, {\n        retryConfig: t.websocketRetryConfig\n      }), e), this._statsCollector = t.statsCollector, this.role = t.role || \"audience\", this._clientRoleOptions = t.clientRoleOptions, this.handleSignalEvents();\n    }\n    async join(e, t, i) {\n      if (this.signal instanceof uO) {\n        let t = !1;\n        \"disabled\" !== e.cloudProxyServer ? (NE.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because cloudProxyServer are not supported (\").concat(e.cloudProxyServer, \")\")), t = !0) : \"\".concat(e.apResponse.cid, \"_\").concat(e.apResponse.cert).length > 255 || \"\".concat(e.apResponse.cid, \"_\").concat(e.apResponse.cert).length < 22 ? (NE.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255\")), t = !0) : e.apResponse.addresses.some(e => e.fingerprint) || HE(\"FINGERPRINT\") || (NE.debug(\"[\".concat(this.store.clientId, \"] Dc is not supported, because fingerprint does not exist\")), t = !0), t && this.resetSignal();\n      }\n      this.store.joinGatewayStart(), \"disabled\" !== e.cloudProxyServer && (this.hasChangeBGPAddress = !0);\n      const r = Date.now();\n      let n = pO.get(e.cname);\n      if (n || (n = new Map(), pO.set(e.cname, n)), this._isProactiveJoin = !0, n.has(e.uid)) {\n        const t = new vE(TE.UID_CONFLICT);\n        throw IT.joinGateway(e.sid, {\n          lts: r,\n          succ: !1,\n          ec: t.message,\n          addr: null,\n          uid: e.uid,\n          cid: e.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!e.proxyServer,\n          signalChannel: this.signal instanceof uO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1, t;\n      }\n      n.set(e.uid, !0), this.joinInfo = e, this.key = t;\n      let o = 0;\n      this.joinGatewayStartTime = r;\n      const s = e.proxyServer;\n      try {\n        let t;\n        if (NE.debug(\"[\".concat(this.store.clientId, \"] use \").concat(this.signal instanceof uO ? \"datachannel\" : \"websocket\", \" join uid \").concat(o)), this.signal instanceof uO) t = await this.signal.init(e.apResponse.addresses, i);else {\n          const r = e.proxyServer,\n            n = r ? e.gatewayAddrs.map(e => {\n              const t = e.address.split(\":\");\n              return \"wss://\".concat(r, \"/ws/?h=\").concat(t[0], \"&p=\").concat(t[1]);\n            }) : e.gatewayAddrs.map(e => \"wss://\".concat(e.address));\n          t = await this.signal.init(n, i);\n        }\n        o = t.uid, NE.debug(\"[\".concat(this.store.clientId, \"] \").concat(this.signal instanceof uO ? \"datachannel\" : \"websocket\", \" join uid \").concat(o, \" cost \").concat(Date.now() - this.joinGatewayStartTime));\n      } catch (t) {\n        if (t && t.code === TE.INIT_WEBSOCKET_TIMEOUT) throw NE.warning(\"[\".concat(this.store.clientId, \"] User join failed\"), t.toString()), t;\n        if (t && t.code === TE.INIT_DATACHANNEL_TIMEOUT) throw NE.warning(\"[\".concat(this.store.clientId, \"] User join datachannel failed\"), t.toString()), this.resetSignal(), t;\n        throw NE.error(\"[\".concat(this.store.clientId, \"] User join failed\"), t.toString()), IT.joinGateway(e.sid, {\n          lts: r,\n          succ: !1,\n          ec: t.message,\n          addr: this.signal.url,\n          uid: e.uid,\n          cid: e.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!s,\n          signalChannel: this.signal instanceof uO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1, n.delete(e.uid), this.signal.close(), t;\n      }\n      return this.state = \"CONNECTED\", this.inChannelInfo.joinAt = Date.now(), NE.debug(\"[\".concat(this.store.clientId, \"] Connected to gateway server\")), this.trafficStatsInterval = window.setInterval(() => {\n        this.updateTrafficStats().catch(e => {\n          NE.warning(\"[\".concat(this.store.clientId, \"] get traffic stats error\"), e.toString());\n        });\n      }, 3e3), this.networkQualityInterval = window.setInterval(() => {\n        navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(cg.NETWORK_QUALITY, {\n          downlinkNetworkQuality: 6,\n          uplinkNetworkQuality: 6\n        }) : this._signalTimeout ? this.emit(cg.NETWORK_QUALITY, {\n          downlinkNetworkQuality: 5,\n          uplinkNetworkQuality: 5\n        }) : \"CONNECTED\" === this.state && this._statsCollector.trafficStats ? this.emit(cg.NETWORK_QUALITY, {\n          uplinkNetworkQuality: CR(this._statsCollector.trafficStats.B_unq),\n          downlinkNetworkQuality: CR(this._statsCollector.trafficStats.B_dnq)\n        }) : this.emit(cg.NETWORK_QUALITY, {\n          uplinkNetworkQuality: 0,\n          downlinkNetworkQuality: 0\n        });\n      }, 2e3), this.store.joinGatewayEnd(), o;\n    }\n    async leave() {\n      let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n        t = arguments.length > 1 ? arguments[1] : void 0;\n      if (\"DISCONNECTED\" !== this.state) {\n        t !== Cm.FALLBACK && (this.state = \"DISCONNECTING\");\n        try {\n          e || this.signal.connectionState !== bm.CONNECTED || (await function (e, t) {\n            return t === 1 / 0 ? e : Cl.race([e, kR(t)]);\n          }(this.signal.request(Nm.LEAVE, void 0, !0), 3e3));\n        } catch (e) {\n          NE.warning(\"[\".concat(this.store.clientId, \"] leave request failed, ignore\"), e);\n        }\n        this.signal.close(t), t !== Cm.FALLBACK && (this.state = \"DISCONNECTED\"), this.reset();\n      }\n    }\n    async publish(e, t, i) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new vE(TE.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n      const r = {\n        state: \"offer\",\n        p2p_id: this.store.p2pId,\n        ortc: t,\n        mode: this.spec.mode,\n        extend: HE(\"PUB_EXTEND\"),\n        tcc: !!HE(\"PUBLISH_TCC\")\n      };\n      try {\n        return (await this.signal.request(Nm.PUBLISH, r, !0))._message;\n      } catch (r) {\n        if (i && r.data && r.data.code === Im.ERR_PUBLISH_REQUEST_INVALID) return NE.warning(\"[\".concat(this.store.clientId, \"] receive publish error code, retry\"), r.toString()), await this.tryUnpubBeforeRepub(e, t), this.publish(e, t, !1);\n        throw r;\n      }\n    }\n    async unpublish(e, t) {\n      try {\n        if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new vE(TE.INVALID_OPERATION, \"can not publish when connection state is \".concat(this.state));\n        await this.signal.request(Nm.UNPUBLISH, {\n          stream_id: t,\n          ortc: e\n        }, !0);\n      } catch (e) {\n        NE.warning(\"unpublish warning: \", e);\n      }\n    }\n    async subscribe(e, t, i) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new vE(TE.INVALID_OPERATION, \"can not subscribe when connection state is \".concat(this.state));\n      const r = {\n        stream_id: e,\n        stream_type: t.stream_type,\n        mode: this.spec.mode,\n        codec: this.spec.codec,\n        p2p_id: this.store.p2pId,\n        tcc: !!HE(\"SUBSCRIBE_TCC\"),\n        extend: HE(\"SUB_EXTEND\"),\n        ssrcId: t.ssrcId\n      };\n      try {\n        return (await this.signal.request(Nm.SUBSCRIBE, r, !0))._message;\n      } catch (r) {\n        if (i && r.data && r.data.code === Im.ERR_SUBSCRIBE_REQUEST_INVALID) return NE.warning(\"[\".concat(this.store.clientId, \"] receiver subscribe error code, retry\"), r.toString()), await this.tryUnsubBeforeResub(e, t), await this.subscribe(e, t, !1);\n        throw r;\n      }\n    }\n    async subscribeAll(e, t) {\n      if (\"CONNECTED\" !== this.state && \"RECONNECTING\" !== this.state) throw new vE(TE.INVALID_OPERATION, \"can not massSubscribe when connection state is \".concat(this.state));\n      const i = {\n        p2p_id: this.store.p2pId,\n        users: e,\n        dtx: !1\n      };\n      try {\n        return await this.signal.request(Nm.SUBSCRIBE_STREAMS, i, !0);\n      } catch (i) {\n        if (t && i.data && i.data.code === Im.ERR_SUBSCRIBE_REQUEST_INVALID) return NE.warning(\"[\".concat(this.store.clientId, \"] receiver massSubscribe error code, retry\"), i.toString()), await this.tryMassUnsubBeforeResub(e), await this.subscribeAll(e, !1);\n        throw i;\n      }\n    }\n    async setVideoProfile(e) {\n      const t = function (e) {\n        if (!(e.bitrateMax && e.bitrateMin && e.frameRate && e.height && e.width)) return;\n        let t = e.frameRate,\n          i = e.width,\n          r = e.height,\n          n = !0;\n        return \"number\" != typeof t && (t = t.exact || t.ideal || t.max || t.min || 0, t || (n = !1)), \"number\" != typeof i && (i = i.exact || i.ideal || i.max || i.min || 0, i || (n = !1)), \"number\" != typeof r && (r = r.exact || r.ideal || r.max || r.min || 0, t || (n = !1)), n ? {\n          stream_type: 0,\n          width: i,\n          height: r,\n          fps: t,\n          start_bps: 1e3 * e.bitrateMax,\n          min_bps: 1e3 * e.bitrateMin,\n          target_bps: 1e3 * e.bitrateMax\n        } : void 0;\n      }(e);\n      if (t) return this.signal.request(Nm.SET_VIDEO_PROFILE, t);\n      NE.debug(\"[\".concat(this.store.clientId, \"] encoder config is not complete, do not report to gateway\"));\n    }\n    async unsubscribe(e, t) {\n      try {\n        await this.signal.request(Nm.UNSUBSCRIBE, {\n          p2p_id: this.store.p2pId,\n          ortc: e,\n          stream_id: t\n        }, !0);\n      } catch (e) {\n        NE.warning(\"unsubscribe warning: \", e);\n      }\n    }\n    async massUnsubscribe(e) {\n      try {\n        await this.signal.request(Nm.UNSUBSCRIBE_STREAMS, e, !0);\n      } catch (e) {\n        NE.warning(\"unsubscribeAll warning: \", e);\n      }\n    }\n    async reconnectPC(e) {\n      const {\n        iceParameters: t,\n        dtlsParameters: i,\n        rtpCapabilities: r\n      } = e;\n      return {\n        gatewayEstablishParams: await this.signal.request(Nm.CONNECT_PC, {\n          p2p_id: this.store.p2pId,\n          stream_id: this.store.uid,\n          ortc: {\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: r\n          }\n        }, !0),\n        gatewayAddress: this.getCurrentGatewayAddress()\n      };\n    }\n    getGatewayInfo() {\n      return this.signal.request(Nm.GATEWAY_INFO);\n    }\n    renewToken(e) {\n      return this.signal.request(Nm.RENEW_TOKEN, e);\n    }\n    async setClientRole(e, t) {\n      if (t && (this._clientRoleOptions = Object.assign({}, t)), \"CONNECTED\" !== this.state) return void (this.role = e);\n      let i = void 0;\n      i = \"audience\" === e ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(Nm.SET_CLIENT_ROLE, {\n        role: e,\n        level: i,\n        client_ts: Date.now()\n      }), this.role = e;\n    }\n    async setRemoteVideoStreamType(e, t) {\n      await this.signal.request(Nm.SWITCH_VIDEO_STREAM, {\n        stream_id: e,\n        stream_type: t\n      });\n    }\n    async setDefaultRemoteVideoStreamType(e) {\n      await this.signal.request(Nm.DEFAULT_VIDEO_STREAM, {\n        stream_type: e\n      });\n    }\n    async setStreamFallbackOption(e, t) {\n      await this.signal.request(Nm.SET_FALLBACK_OPTION, {\n        stream_id: e,\n        fallback_type: t\n      });\n    }\n    async pickSVCLayer(e, t) {\n      await this.signal.request(Nm.PICK_SVC_LAYER, {\n        stream_id: e,\n        spatial_layer: t.spatialLayer,\n        temporal_layer: t.temporalLayer\n      });\n    }\n    getInChannelInfo() {\n      return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), hO({}, this.inChannelInfo);\n    }\n    async getGatewayVersion() {\n      return (await this.signal.request(Nm.GATEWAY_INFO)).version;\n    }\n    reset() {\n      if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {\n        const e = pO.get(this.joinInfo.cname);\n        e && e.delete(this.joinInfo.uid);\n      }\n      this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0);\n    }\n    updateTurnConfigFromSignal() {\n      if (!this.joinInfo) return;\n      const e = function (e) {\n        let t;\n        return t = e.startsWith(\"dc\") ? e.match(/(dc\\:\\/\\/)?([^:]+):(\\d+)/) : e.match(/(wss\\:\\/\\/)?([^:]+):(\\d+)/), t ? {\n          username: kE.username,\n          password: kE.password,\n          turnServerURL: t[2],\n          tcpport: parseInt(t[3]) + 30,\n          udpport: parseInt(t[3]) + 30,\n          forceturn: !1\n        } : null;\n      }((\"disabled\" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || \"\");\n      this.joinInfo.turnServer.serversFromGateway = [], e && \"off\" !== this.joinInfo.turnServer.mode && \"disabled\" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(hO(hO({}, kE), {}, {\n        turnServerURL: e.turnServerURL,\n        tcpport: e.tcpport,\n        udpport: e.udpport,\n        username: this.joinInfo.uid.toString(),\n        password: this.joinInfo.token\n      }));\n    }\n    async updateTrafficStats() {\n      if (\"CONNECTED\" !== this.state) return;\n      const e = await this.signal.request(Nm.TRAFFIC_STATS, void 0, !0);\n      e.timestamp = Date.now(), e.peer_delay.forEach(e => {\n        const t = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find(t => t.peer_uid === e.peer_uid);\n        t && t.B_st !== e.B_st && YR(() => {\n          this.emit(cg.STREAM_TYPE_CHANGE, e.peer_uid, e.B_st);\n        });\n      }), this._statsCollector.updateTrafficStats(e);\n    }\n    getJoinMessage(e) {\n      if (!this.joinInfo || !this.key) throw new vE(TE.UNEXPECTED_ERROR, \"can not generate join message, no join info\");\n      const t = Object.assign({}, this.joinInfo.apResponse);\n      let i = HE(\"REPORT_APP_SCENARIO\");\n      if (\"string\" != typeof i) try {\n        i = JSON.stringify(i);\n      } catch (e) {\n        i = void 0;\n      }\n      i && i.length > 128 && (i = void 0);\n      const r = hO({\n        license: this.joinInfo.license,\n        p2p_id: this.store.p2pId,\n        session_id: this.joinInfo.sid,\n        app_id: this.joinInfo.appId,\n        channel_key: this.key,\n        channel_name: this.joinInfo.cname,\n        sdk_version: PE,\n        browser: navigator.userAgent,\n        process_id: HE(\"PROCESS_ID\"),\n        mode: this.spec.mode,\n        codec: this.spec.codec,\n        role: this.role,\n        has_changed_gateway: this.hasChangeBGPAddress,\n        ap_response: t,\n        extend: HE(\"JOIN_EXTEND\"),\n        details: {\n          6: this.joinInfo.stringUid,\n          cservice_map: \"proxy3\" === this.joinInfo.cloudProxyServer ? \"1\" : \"proxy5\" === this.joinInfo.cloudProxyServer ? \"2\" : void 0\n        },\n        features: {\n          rejoin: !0\n        },\n        optionalInfo: this.joinInfo.optionalInfo,\n        appScenario: i,\n        attributes: {\n          userAttributes: {\n            enablePublishedUserList: HE(\"ENABLE_PUBLISHED_USER_LIST\"),\n            maxSubscription: HE(\"MAX_SUBSCRIPTION\"),\n            subscribeAudioFilterTopN: \"number\" == typeof HE(\"SUBSCRIBE_AUDIO_FILTER_TOPN\") ? HE(\"SUBSCRIBE_AUDIO_FILTER_TOPN\") : void 0,\n            enablePublishAudioFilter: \"boolean\" == typeof HE(\"ENABLE_PUBLISH_AUDIO_FILTER\") ? HE(\"ENABLE_PUBLISH_AUDIO_FILTER\") : void 0,\n            enableUserLicenseCheck: \"boolean\" == typeof HE(\"ENABLE_USER_LICENSE_CHECK\") ? HE(\"ENABLE_USER_LICENSE_CHECK\") : void 0\n          }\n        },\n        join_ts: this.joinGatewayStartTime\n      }, e);\n      return this.joinInfo.stringUid && (r.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (r.aes_mode = this.joinInfo.aesmode, HE(\"ENCRYPT_AES\") ? (r.aes_secret = this.joinInfo.aespassword, r.aes_encrypt = !0) : r.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (r.aes_salt = this.joinInfo.aessalt)), t.addresses[this.signal.websocket.currentURLIndex] && (r.ap_response.ticket = t.addresses[this.signal.websocket.currentURLIndex].ticket, delete t.addresses), void 0 !== this.joinInfo.defaultVideoStream && (r.default_video_stream = this.joinInfo.defaultVideoStream), r;\n    }\n    getRejoinMessage() {\n      if (!this.joinInfo) throw new vE(TE.UNEXPECTED_ERROR, \"can not generate rejoin message, no join info\");\n      return {\n        session_id: this.joinInfo.sid,\n        channel_name: this.joinInfo.cname,\n        cid: this.joinInfo.cid,\n        uid: this.joinInfo.uid,\n        vid: Number(this.joinInfo.vid)\n      };\n    }\n    handleSignalEvents() {\n      this.signal.on(wm.WS_RECONNECT_WAITTING_FINISH, e => {\n        [\"tryNext\", \"recover\"].includes(e) && this.joinInfo && IT.adjustSessionStartTime(this.joinInfo.sid);\n      }), this.signal.on(wm.WS_RECONNECT_CREATE_CONNECTION, e => {\n        this.joinGatewayStartTime = Date.now();\n      }), this.signal.on(wm.WS_RECONNECTING, e => {\n        this.joinInfo && IT.WebSocketQuit(this.joinInfo.sid, {\n          lts: Date.now(),\n          succ: -1,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          errorCode: e || Om.NETWORK_ERROR\n        }), this.joinInfo && (this.state = \"RECONNECTING\", IT.sessionInit(this.joinInfo.sid, {\n          lts: new Date().getTime(),\n          extend: this.isSignalRecover ? {\n            recover: !0\n          } : {\n            rejoin: !0\n          },\n          cname: this.joinInfo.cname,\n          appid: this.joinInfo.appId,\n          mode: this.spec.mode\n        }), this.isSignalRecover = !1, this.joinGatewayStartTime = Date.now());\n      }), this.signal.on(wm.WS_CLOSED, e => {\n        let t;\n        switch (e) {\n          case Cm.LEAVE:\n            t = Om.LEAVE;\n            break;\n          case Cm.UID_BANNED:\n          case Cm.IP_BANNED:\n          case Cm.CHANNEL_BANNED:\n          case Cm.SERVER_ERROR:\n            t = Om.SERVER_ERROR;\n            break;\n          case Cm.FALLBACK:\n            t = Om.FALLBACK;\n            break;\n          case Cm.LICENSE_MISSING:\n          case Cm.LICENSE_EXPIRED:\n          case Cm.LICENSE_MINUTES_EXCEEDED:\n          case Cm.LICENSE_PERIOD_INVALID:\n          case Cm.LICENSE_MULTIPLE_SDK_SERVICE:\n          case Cm.LICENSE_ILLEGAL:\n            t = e;\n            break;\n          default:\n            t = Om.NETWORK_ERROR;\n        }\n        NE.debug(\"[signal] websocket closed, reason: \".concat(t || \"undefined -> \" + Om.NETWORK_ERROR)), this.joinInfo && IT.WebSocketQuit(this.joinInfo.sid, {\n          lts: Date.now(),\n          succ: e === Cm.LEAVE ? 1 : -1,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          errorCode: t\n        }), this._disconnectedReason = e, e !== Cm.FALLBACK && (this.state = \"DISCONNECTED\"), this.reset();\n      }), this.signal.on(wm.WS_CONNECTED, () => {\n        if (this.updateTurnConfigFromSignal(), this.state = \"CONNECTED\", this.joinInfo && (\"audience\" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (NE.debug(\"[\".concat(this.store.clientId, \"] patch to send set client role, role: \").concat(this.role, \", mode: \").concat(this.spec.mode, \", level: \").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), IT.joinGateway(this.joinInfo.sid, {\n          lts: this.joinGatewayStartTime,\n          succ: !0,\n          ec: null,\n          vid: this.joinInfo.vid,\n          addr: this.signal.url,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!this.joinInfo.proxyServer,\n          signalChannel: this.signal instanceof uO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {\n          const e = this.signal.url && this.signal.url.match(/wss\\:\\/\\/([^:]+):(\\d+)/);\n          if (!e) return void NE.error(\"[\".concat(this.store.clientId, \"] set local access point after joined failed: \").concat(e));\n          WE(\"EVENT_REPORT_DOMAIN\", e[1]), WE(\"EVENT_REPORT_BACKUP_DOMAIN\", e[1]), WE(\"LOG_UPLOAD_SERVER\", \"\".concat(e[1], \":6444\"));\n        }\n      }), this.signal.on(Pm.ON_UPLINK_STATS, e => {\n        this._statsCollector.updateUplinkStats(e);\n      }), this.signal.on(wm.REQUEST_RECOVER, (e, t, i) => {\n        if (!this.joinInfo) return i(new vE(TE.UNEXPECTED_ERROR, \"gateway: can not recover, no join info\"));\n        e && (this.joinInfo.multiIP = e, this.hasChangeBGPAddress = !0), this.isSignalRecover = !0, FR(this, cg.REQUEST_NEW_GATEWAY_LIST).then(t).catch(i);\n      }), this.signal.on(wm.REQUEST_JOIN_INFO, async e => {\n        var t;\n        this.updateTurnConfigFromSignal();\n        const {\n          iceParameters: i,\n          dtlsParameters: r,\n          rtpCapabilities: n\n        } = await FR(this, cg.REQUEST_P2P_CONNECTION_PARAMS, {\n          turnServer: null === (t = this.joinInfo) || void 0 === t ? void 0 : t.turnServer\n        });\n        e(this.getJoinMessage({\n          ortc: {\n            iceParameters: i,\n            dtlsParameters: r,\n            rtpCapabilities: n,\n            version: \"2\"\n          }\n        }));\n      }), this.signal.on(wm.REQUEST_REJOIN_INFO, e => {\n        e(this.getRejoinMessage());\n      }), this.signal.on(wm.REPORT_JOIN_GATEWAY, (e, t) => {\n        this.joinInfo && (IT.joinGateway(this.joinInfo.sid, {\n          lts: this.joinGatewayStartTime,\n          succ: !1,\n          ec: e,\n          addr: t,\n          uid: this.joinInfo.uid,\n          cid: this.joinInfo.cid,\n          firstSuccess: this._isProactiveJoin,\n          avoidJoinStartTime: this.store.avoidJoinStart,\n          isProxy: !!this.joinInfo.proxyServer,\n          signalChannel: this.signal instanceof uO ? \"1\" : \"0\"\n        }), this._isProactiveJoin = !1);\n      }), this.signal.on(wm.IS_P2P_DISCONNECTED, e => {\n        e(WR(this, cg.IS_P2P_DISCONNECTED));\n      }), this.signal.on(wm.DISCONNECT_P2P, () => {\n        this.emit(cg.DISCONNECT_P2P);\n      }), this.signal.on(wm.NEED_RENEW_SESSION, () => {\n        this.emit(cg.NEED_RENEW_SESSION);\n      }), this.signal.on(wm.REQUEST_SUCCESS, () => {\n        this._signalTimeout = !1;\n      }), this.signal.on(wm.REQUEST_TIMEOUT, () => {\n        this._signalTimeout = !0;\n      }), this.signal.on(wm.JOIN_RESPONSE, e => {\n        const t = this.getCurrentGatewayAddress();\n        this.emit(cg.JOIN_RESPONSE, e, t);\n      }), this.signal.on(wm.DATACHANNEL_PRECONNECT, async (e, t, i) => {\n        this.updateTurnConfigFromSignal();\n        const r = this.getCurrentGatewayAddress();\n        return FR(this, cg.DATACHANNEL_PRECONNECT, e, r).then(t).catch(i);\n      }), this.signal.on(wm.DATACHANNEL_CONNECTING, async e => {\n        const {\n          iceParameters: t,\n          dtlsParameters: i,\n          rtpCapabilities: r\n        } = await FR(this, cg.REQUEST_DC_CONNECTION_PARAMS);\n        e(this.getJoinMessage({\n          ortc: {\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: r,\n            version: \"2\"\n          }\n        }));\n      }), this.signal.on(wm.DATACHANNEL_FAILBACK, () => {\n        NE.warning(\"[\".concat(this.store.clientId, \"] User join datachannel failed\")), this.reset(), this.resetSignal(), this.emit(cg.DATACHANNEL_FAILBACK);\n      });\n    }\n    async tryUnsubBeforeResub(e, t) {\n      try {\n        await this.signal.request(Nm.UNSUBSCRIBE, {\n          p2p_id: this.store.p2pId,\n          stream_id: e,\n          ortc: [t]\n        }, !0);\n      } catch (e) {\n        throw NE.warning(\"unsubscribe warning\", e), e;\n      }\n    }\n    async tryUnpubBeforeRepub(e, t) {\n      try {\n        await this.signal.request(Nm.UNPUBLISH, {\n          stream_id: e,\n          ortc: t\n        }, !0);\n      } catch (e) {\n        throw NE.warning(\"unpublish warning: \", e), e;\n      }\n    }\n    async tryMassUnsubBeforeResub(e) {\n      const t = {\n        users: e.map(e => ({\n          stream_id: e.stream_id,\n          stream_type: e.stream_type\n        }))\n      };\n      try {\n        await this.signal.request(Nm.UNSUBSCRIBE_STREAMS, t, !0);\n      } catch (e) {\n        throw NE.warning(\"massUnsubscribe warning\", e), e;\n      }\n    }\n    async muteLocal(e, t) {\n      const i = {\n        action: e.find(e => e.stream_type === ag.Audio) ? \"mute_local_audio\" : \"mute_local_video\",\n        p2p_id: this.store.p2pId,\n        ortc: e,\n        stream_id: t\n      };\n      try {\n        await this.signal.request(Nm.CONTROL, i, !0, !0);\n      } catch (e) {\n        throw NE.warning(\"gateway unmuteLocal warning: \", e), e;\n      }\n    }\n    async unmuteLocal(e, t) {\n      const i = {\n        action: e.find(e => e.stream_type === ag.Audio) ? \"unmute_local_audio\" : \"unmute_local_video\",\n        p2p_id: this.store.p2pId,\n        ortc: e,\n        stream_id: t\n      };\n      try {\n        await this.signal.request(Nm.CONTROL, i, !0, !0);\n      } catch (e) {\n        throw NE.warning(\"gateway muteLocal warning: \", e), e;\n      }\n    }\n    uploadStats(e, t) {\n      this.signal.upload(e, t);\n    }\n    getSignalRTT() {\n      return this.signal.rtt;\n    }\n    async restartICE(e) {\n      const t = {\n        p2p_id: this.store.p2pId,\n        stream_id: this.store.uid,\n        ortc: e\n      };\n      try {\n        return await this.signal.request(Nm.RESTART_ICE, t, !0);\n      } catch (e) {\n        throw NE.warning(\"P2PChannel.restartICE warning: \", e), e;\n      }\n    }\n    reconnect() {\n      \"CONNECTED\" === this.state && this.signal.reconnect(void 0, Om.P2P_FAILED);\n    }\n    getCurrentGatewayAddress() {\n      var e;\n      if (!HE(\"GATEWAY_WSS_ADDRESS\")) return null !== (e = this.joinInfo) && void 0 !== e && e.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0;\n    }\n    async setPublishAudioFilterEnabled(e) {\n      await this.signal.request(Nm.SET_PARAMETER, {\n        enablePublishAudioFilter: e\n      });\n    }\n    resetSignal() {\n      this.signal && (this.signal.removeAllListeners(), this.signal.close(Cm.FALLBACK)), this.signal = new tO(hO(hO({}, this.spec), {}, {\n        retryConfig: this.spec.websocketRetryConfig\n      }), this.store), this.handleSignalEvents(), this.emit(cg.RESET_CONNECTION_EVENTS);\n    }\n  }\n  /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */\n  function EO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function fO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? EO(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : EO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  !function () {\n    var e;\n    function i(e) {\n      var t = 0;\n      return function () {\n        return t < e.length ? {\n          done: !1,\n          value: e[t++]\n        } : {\n          done: !0\n        };\n      };\n    }\n    var r = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, i) {\n      return e == Array.prototype || e == Object.prototype || (e[t] = i.value), e;\n    };\n    var n,\n      o = function (e) {\n        e = [\"object\" == typeof globalThis && globalThis, e, \"object\" == typeof window && window, \"object\" == typeof self && self, \"object\" == typeof t && t];\n        for (var i = 0; i < e.length; ++i) {\n          var r = e[i];\n          if (r && r.Math == Math) return r;\n        }\n        throw Error(\"Cannot find global object\");\n      }(this);\n    function s(e, t) {\n      if (t) e: {\n        var i = o;\n        e = e.split(\".\");\n        for (var n = 0; n < e.length - 1; n++) {\n          var s = e[n];\n          if (!(s in i)) break e;\n          i = i[s];\n        }\n        (t = t(n = i[e = e[e.length - 1]])) != n && null != t && r(i, e, {\n          configurable: !0,\n          writable: !0,\n          value: t\n        });\n      }\n    }\n    function a(e) {\n      return (e = {\n        next: e\n      })[Symbol.iterator] = function () {\n        return this;\n      }, e;\n    }\n    function c(e) {\n      var t = \"undefined\" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];\n      return t ? t.call(e) : {\n        next: i(e)\n      };\n    }\n    if (s(\"Symbol\", function (e) {\n      function t(e, t) {\n        this.A = e, r(this, \"description\", {\n          configurable: !0,\n          writable: !0,\n          value: t\n        });\n      }\n      if (e) return e;\n      t.prototype.toString = function () {\n        return this.A;\n      };\n      var i = \"jscomp_symbol_\" + (1e9 * Math.random() >>> 0) + \"_\",\n        n = 0;\n      return function e(r) {\n        if (this instanceof e) throw new TypeError(\"Symbol is not a constructor\");\n        return new t(i + (r || \"\") + \"_\" + n++, r);\n      };\n    }), s(\"Symbol.iterator\", function (e) {\n      if (e) return e;\n      e = Symbol(\"Symbol.iterator\");\n      for (var t = \"Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \"), n = 0; n < t.length; n++) {\n        var s = o[t[n]];\n        \"function\" == typeof s && \"function\" != typeof s.prototype[e] && r(s.prototype, e, {\n          configurable: !0,\n          writable: !0,\n          value: function () {\n            return a(i(this));\n          }\n        });\n      }\n      return e;\n    }), \"function\" == typeof Object.setPrototypeOf) n = Object.setPrototypeOf;else {\n      var d;\n      e: {\n        var u = {};\n        try {\n          u.__proto__ = {\n            a: !0\n          }, d = u.a;\n          break e;\n        } catch (e) {}\n        d = !1;\n      }\n      n = d ? function (e, t) {\n        if (e.__proto__ = t, e.__proto__ !== t) throw new TypeError(e + \" is not extensible\");\n        return e;\n      } : null;\n    }\n    var l = n;\n    function h() {\n      this.m = !1, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null;\n    }\n    function p(e) {\n      if (e.m) throw new TypeError(\"Generator is already running\");\n      e.m = !0;\n    }\n    function _(e, t) {\n      return e.h = 3, {\n        value: t\n      };\n    }\n    function E(e) {\n      this.g = new h(), this.G = e;\n    }\n    function f(e, t, i, r) {\n      try {\n        var n = t.call(e.g.j, i);\n        if (!(n instanceof Object)) throw new TypeError(\"Iterator result \" + n + \" is not an object\");\n        if (!n.done) return e.g.m = !1, n;\n        var o = n.value;\n      } catch (t) {\n        return e.g.j = null, e.g.s(t), m(e);\n      }\n      return e.g.j = null, r.call(e.g, o), m(e);\n    }\n    function m(e) {\n      for (; e.g.h;) try {\n        var t = e.G(e.g);\n        if (t) return e.g.m = !1, {\n          value: t.value,\n          done: !1\n        };\n      } catch (t) {\n        e.g.v = void 0, e.g.s(t);\n      }\n      if (e.g.m = !1, e.g.l) {\n        if (t = e.g.l, e.g.l = null, t.F) throw t.D;\n        return {\n          value: t.return,\n          done: !0\n        };\n      }\n      return {\n        value: void 0,\n        done: !0\n      };\n    }\n    function g(e) {\n      this.next = function (t) {\n        return e.o(t);\n      }, this.throw = function (t) {\n        return e.s(t);\n      }, this.return = function (t) {\n        return function (e, t) {\n          p(e.g);\n          var i = e.g.j;\n          return i ? f(e, \"return\" in i ? i.return : function (e) {\n            return {\n              value: e,\n              done: !0\n            };\n          }, t, e.g.return) : (e.g.return(t), m(e));\n        }(e, t);\n      }, this[Symbol.iterator] = function () {\n        return this;\n      };\n    }\n    function S(e, t) {\n      return t = new g(new E(t)), l && e.prototype && l(t, e.prototype), t;\n    }\n    if (h.prototype.o = function (e) {\n      this.v = e;\n    }, h.prototype.s = function (e) {\n      this.l = {\n        D: e,\n        F: !0\n      }, this.h = this.C || this.u;\n    }, h.prototype.return = function (e) {\n      this.l = {\n        return: e\n      }, this.h = this.u;\n    }, E.prototype.o = function (e) {\n      return p(this.g), this.g.j ? f(this, this.g.j.next, e, this.g.o) : (this.g.o(e), m(this));\n    }, E.prototype.s = function (e) {\n      return p(this.g), this.g.j ? f(this, this.g.j.throw, e, this.g.o) : (this.g.s(e), m(this));\n    }, s(\"Array.prototype.entries\", function (e) {\n      return e || function () {\n        return function (e, t) {\n          e instanceof String && (e += \"\");\n          var i = 0,\n            r = !1,\n            n = {\n              next: function () {\n                if (!r && i < e.length) {\n                  var n = i++;\n                  return {\n                    value: t(n, e[n]),\n                    done: !1\n                  };\n                }\n                return r = !0, {\n                  done: !0,\n                  value: void 0\n                };\n              }\n            };\n          return n[Symbol.iterator] = function () {\n            return n;\n          }, n;\n        }(this, function (e, t) {\n          return [e, t];\n        });\n      };\n    }), \"undefined\" != typeof Blob && (\"undefined\" == typeof FormData || !FormData.prototype.keys)) {\n      var T = function (e, t) {\n          for (var i = 0; i < e.length; i++) t(e[i]);\n        },\n        v = function (e) {\n          return e.replace(/\\r?\\n|\\r/g, \"\\r\\n\");\n        },\n        R = function (e, t, i) {\n          return t instanceof Blob ? (i = void 0 !== i ? String(i + \"\") : \"string\" == typeof t.name ? t.name : \"blob\", t.name === i && \"[object Blob]\" !== Object.prototype.toString.call(t) || (t = new File([t], i)), [String(e), t]) : [String(e), String(t)];\n        },\n        I = function (e, t) {\n          if (e.length < t) throw new TypeError(t + \" argument required, but only \" + e.length + \" present.\");\n        },\n        y = \"object\" == typeof globalThis ? globalThis : \"object\" == typeof window ? window : \"object\" == typeof self ? self : this,\n        C = y.FormData,\n        A = y.XMLHttpRequest && y.XMLHttpRequest.prototype.send,\n        O = y.Request && y.fetch,\n        b = y.navigator && y.navigator.sendBeacon,\n        w = y.Element && y.Element.prototype,\n        N = y.Symbol && Symbol.toStringTag;\n      N && (Blob.prototype[N] || (Blob.prototype[N] = \"Blob\"), \"File\" in y && !File.prototype[N] && (File.prototype[N] = \"File\"));\n      try {\n        new File([], \"\");\n      } catch (e) {\n        y.File = function (e, t, i) {\n          return e = new Blob(e, i || {}), Object.defineProperties(e, {\n            name: {\n              value: t\n            },\n            lastModified: {\n              value: +(i && void 0 !== i.lastModified ? new Date(i.lastModified) : new Date())\n            },\n            toString: {\n              value: function () {\n                return \"[object File]\";\n              }\n            }\n          }), N && Object.defineProperty(e, N, {\n            value: \"File\"\n          }), e;\n        };\n      }\n      var D = function (e) {\n          return e.replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\");\n        },\n        P = function (e) {\n          this.i = [];\n          var t = this;\n          e && T(e.elements, function (e) {\n            if (e.name && !e.disabled && \"submit\" !== e.type && \"button\" !== e.type && !e.matches(\"form fieldset[disabled] *\")) if (\"file\" === e.type) {\n              var i = e.files && e.files.length ? e.files : [new File([], \"\", {\n                type: \"application/octet-stream\"\n              })];\n              T(i, function (i) {\n                t.append(e.name, i);\n              });\n            } else \"select-multiple\" === e.type || \"select-one\" === e.type ? T(e.options, function (i) {\n              !i.disabled && i.selected && t.append(e.name, i.value);\n            }) : \"checkbox\" === e.type || \"radio\" === e.type ? e.checked && t.append(e.name, e.value) : (i = \"textarea\" === e.type ? v(e.value) : e.value, t.append(e.name, i));\n          });\n        };\n      if ((e = P.prototype).append = function (e, t, i) {\n        I(arguments, 2), this.i.push(R(e, t, i));\n      }, e.delete = function (e) {\n        I(arguments, 1);\n        var t = [];\n        e = String(e), T(this.i, function (i) {\n          i[0] !== e && t.push(i);\n        }), this.i = t;\n      }, e.entries = function e() {\n        var t,\n          i = this;\n        return S(e, function (e) {\n          if (1 == e.h && (t = 0), 3 != e.h) return t < i.i.length ? e = _(e, i.i[t]) : (e.h = 0, e = void 0), e;\n          t++, e.h = 2;\n        });\n      }, e.forEach = function (e, t) {\n        I(arguments, 1);\n        for (var i = c(this), r = i.next(); !r.done; r = i.next()) {\n          var n = c(r.value);\n          r = n.next().value, n = n.next().value, e.call(t, n, r, this);\n        }\n      }, e.get = function (e) {\n        I(arguments, 1);\n        var t = this.i;\n        e = String(e);\n        for (var i = 0; i < t.length; i++) if (t[i][0] === e) return t[i][1];\n        return null;\n      }, e.getAll = function (e) {\n        I(arguments, 1);\n        var t = [];\n        return e = String(e), T(this.i, function (i) {\n          i[0] === e && t.push(i[1]);\n        }), t;\n      }, e.has = function (e) {\n        I(arguments, 1), e = String(e);\n        for (var t = 0; t < this.i.length; t++) if (this.i[t][0] === e) return !0;\n        return !1;\n      }, e.keys = function e() {\n        var t,\n          i,\n          r,\n          n,\n          o = this;\n        return S(e, function (e) {\n          if (1 == e.h && (t = c(o), i = t.next()), 3 != e.h) return i.done ? void (e.h = 0) : (r = i.value, n = c(r), _(e, n.next().value));\n          i = t.next(), e.h = 2;\n        });\n      }, e.set = function (e, t, i) {\n        I(arguments, 2), e = String(e);\n        var r = [],\n          n = R(e, t, i),\n          o = !0;\n        T(this.i, function (t) {\n          t[0] === e ? o && (o = !r.push(n)) : r.push(t);\n        }), o && r.push(n), this.i = r;\n      }, e.values = function e() {\n        var t,\n          i,\n          r,\n          n,\n          o = this;\n        return S(e, function (e) {\n          if (1 == e.h && (t = c(o), i = t.next()), 3 != e.h) return i.done ? void (e.h = 0) : (r = i.value, (n = c(r)).next(), _(e, n.next().value));\n          i = t.next(), e.h = 2;\n        });\n      }, P.prototype._asNative = function () {\n        for (var e = new C(), t = c(this), i = t.next(); !i.done; i = t.next()) {\n          var r = c(i.value);\n          i = r.next().value, r = r.next().value, e.append(i, r);\n        }\n        return e;\n      }, P.prototype._blob = function () {\n        var e = \"----formdata-polyfill-\" + Math.random(),\n          t = [],\n          i = \"--\" + e + '\\r\\nContent-Disposition: form-data; name=\"';\n        return this.forEach(function (e, r) {\n          return \"string\" == typeof e ? t.push(i + D(v(r)) + '\"\\r\\n\\r\\n' + v(e) + \"\\r\\n\") : t.push(i + D(v(r)) + '\"; filename=\"' + D(e.name) + '\"\\r\\nContent-Type: ' + (e.type || \"application/octet-stream\") + \"\\r\\n\\r\\n\", e, \"\\r\\n\");\n        }), t.push(\"--\" + e + \"--\"), new Blob(t, {\n          type: \"multipart/form-data; boundary=\" + e\n        });\n      }, P.prototype[Symbol.iterator] = function () {\n        return this.entries();\n      }, P.prototype.toString = function () {\n        return \"[object FormData]\";\n      }, w && !w.matches && (w.matches = w.matchesSelector || w.mozMatchesSelector || w.msMatchesSelector || w.oMatchesSelector || w.webkitMatchesSelector || function (e) {\n        for (var t = (e = (this.document || this.ownerDocument).querySelectorAll(e)).length; 0 <= --t && e.item(t) !== this;);\n        return -1 < t;\n      }), N && (P.prototype[N] = \"FormData\"), A) {\n        var L = y.XMLHttpRequest.prototype.setRequestHeader;\n        y.XMLHttpRequest.prototype.setRequestHeader = function (e, t) {\n          L.call(this, e, t), \"content-type\" === e.toLowerCase() && (this.B = !0);\n        }, y.XMLHttpRequest.prototype.send = function (e) {\n          e instanceof P ? (e = e._blob(), this.B || this.setRequestHeader(\"Content-Type\", e.type), A.call(this, e)) : A.call(this, e);\n        };\n      }\n      O && (y.fetch = function (e, t) {\n        return t && t.body && t.body instanceof P && (t.body = t.body._blob()), O.call(this, e, t);\n      }), b && (y.navigator.sendBeacon = function (e, t) {\n        return t instanceof P && (t = t._asNative()), b.call(this, e, t);\n      }), y.FormData = P;\n    }\n  }();\n  let mO = 1;\n  function gO(e, t, i, r, n) {\n    mO += 1;\n    const o = {\n        sid: i.sid,\n        command: \"convergeAllocateEdge\",\n        uid: \"666\",\n        appId: i.appId,\n        ts: Math.floor(Date.now() / 1e3),\n        seq: mO,\n        requestId: mO,\n        version: PE,\n        cname: i.cname\n      },\n      s = {\n        service_name: t,\n        json_body: JSON.stringify(o)\n      };\n    let a,\n      c,\n      d = e[0];\n    return yE(async () => {\n      a = Date.now();\n      const e = await lT(d, {\n        data: s,\n        cancelToken: r,\n        headers: {\n          \"X-Packet-Service-Type\": \"0\",\n          \"X-Packet-URI\": \"61\"\n        }\n      });\n      if (c = Date.now() - a, 0 !== e.code) {\n        const t = new vE(TE.UNEXPECTED_RESPONSE, \"live streaming ap error, code\" + e.code, {\n          retry: !0,\n          responseTime: c\n        });\n        throw NE.error(t.toString()), t;\n      }\n      const i = JSON.parse(e.json_body);\n      if (200 !== i.code) {\n        const e = new vE(TE.UNEXPECTED_RESPONSE, \"live streaming app center error, code: \".concat(i.code, \", reason: \").concat(i.reason), {\n          code: i.code,\n          responseTime: c\n        });\n        throw NE.error(e.toString()), e;\n      }\n      if (!i.servers || 0 === i.servers.length) {\n        const e = new vE(TE.UNEXPECTED_RESPONSE, \"live streaming app center empty server\", {\n          code: i.code,\n          responseTime: c\n        });\n        throw NE.error(e.toString()), e;\n      }\n      const n = function (e, t) {\n        return {\n          addressList: e.servers.map(e => \"wss://\".concat(e.address.replace(/\\./g, \"-\"), \".\").concat(HE(\"WORKER_DOMAIN\"), \":\").concat(e.wss, \"?serviceName=\").concat(encodeURIComponent(t))),\n          workerToken: e.workerToken,\n          vid: e.vid\n        };\n      }(i, t);\n      return HE(\"LIVE_STREAMING_ADDRESS\") && (n.addressList = HE(\"LIVE_STREAMING_ADDRESS\") instanceof Array ? HE(\"LIVE_STREAMING_ADDRESS\") : [HE(\"LIVE_STREAMING_ADDRESS\")]), fO(fO({}, n), {}, {\n        responseTime: c\n      });\n    }, (r, n) => (IT.apworkerEvent(i.sid, {\n      success: !0,\n      sc: 200,\n      serviceName: t,\n      responseDetail: JSON.stringify(r.addressList),\n      firstSuccess: 0 === n,\n      responseTime: c,\n      serverIp: e[n % e.length]\n    }), !1), (r, n) => (IT.apworkerEvent(i.sid, {\n      success: !1,\n      sc: r.data && r.data.code || 200,\n      serviceName: t,\n      responseTime: c,\n      serverIp: e[n % e.length]\n    }), !!(r.code !== TE.OPERATION_ABORTED && r.code !== TE.UNEXPECTED_RESPONSE || r.data && r.data.retry) && (d = e[(n + 1) % e.length], !0)), n);\n  }\n  let SO = 1;\n  function TO(e, t, i, r) {\n    let {\n      url: n,\n      areaCode: o\n    } = e;\n    const s = Date.now();\n    let a;\n    const [c, d] = CO(t, o, [Fg.CHOOSE_SERVER]);\n    let u = pT.networkState;\n    return yE(async () => {\n      u && pT.networkState === bg.OFFLINE && pT.onlineWaiter && (await Cl.race([pT.onlineWaiter, LR(r && r.maxRetryTimeout || RE.maxRetryTimeout)])), u = pT.networkState;\n      const {\n        data: e,\n        headers: o\n      } = await lT(n, {\n        data: c,\n        cancelToken: i,\n        headers: {\n          \"Content-Type\": \"multipart/form-data;\"\n        }\n      }, !0, !0);\n      a = \"1\" === o.http3 ? 1 : -1, IT.reportResourceTiming(n, t.sid), RO(e, n, t, s, [Fg.CHOOSE_SERVER], a);\n      const d = AR(e, Fg.CHOOSE_SERVER);\n      return IO(d), vR(d, n);\n    }, e => (e && IT.joinChooseServer(t.sid, {\n      lts: s,\n      succ: !0,\n      csAddr: n,\n      opid: d,\n      serverList: e.gatewayAddrs.map(e => e.address),\n      ec: null,\n      cid: e.cid.toString(),\n      uid: e.uid.toString(),\n      csIp: e.csIp,\n      unilbsServerIds: [Fg.CHOOSE_SERVER].toString(),\n      isHttp3: a\n    }), !1), e => e.code !== TE.OPERATION_ABORTED && (e.code === TE.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (IT.joinChooseServer(t.sid, {\n      lts: s,\n      succ: !1,\n      csAddr: n,\n      serverList: null,\n      opid: d,\n      ec: e.code,\n      csIp: e.data && e.data.csIp,\n      unilbsServerIds: [Fg.CHOOSE_SERVER].toString(),\n      extend: JSON.stringify({\n        networkState: u\n      }),\n      isHttp3: a\n    }), NE.warning(\"[\".concat(t.clientId, \"] Choose server network error, retry\"), e), !0)), r);\n  }\n  function vO(e, t, i, r) {\n    let n,\n      {\n        url: o,\n        areaCode: s,\n        serviceIds: a\n      } = e;\n    const c = Date.now(),\n      [d, u] = CO(t, s, a);\n    let l = void 0;\n    return yE(async () => {\n      l && pT.networkState === bg.OFFLINE && pT.onlineWaiter && (await Cl.race([pT.onlineWaiter, LR(r && r.maxRetryTimeout || RE.maxRetryTimeout)])), l = pT.networkState;\n      const {\n        data: e,\n        headers: s\n      } = await lT(o, {\n        data: d,\n        cancelToken: i,\n        headers: {\n          \"Content-Type\": \"multipart/form-data;\"\n        }\n      }, !0, !0);\n      n = \"1\" === s.http3 ? 1 : -1, IT.reportResourceTiming(o, t.sid), RO(e, o, t, c, a, n);\n      const u = AR(e, Fg.CHOOSE_SERVER),\n        h = AR(e, \"proxy5\" === t.cloudProxyServer ? Fg.CLOUD_PROXY_5 : \"proxy3\" === t.cloudProxyServer || \"proxy4\" === t.cloudProxyServer ? Fg.CLOUD_PROXY : Fg.CLOUD_PROXY_FALLBACK);\n      return IO(u), {\n        gatewayInfo: vR(u, o),\n        proxyInfo: h,\n        url: o\n      };\n    }, e => (e.gatewayInfo && IT.joinChooseServer(t.sid, {\n      lts: c,\n      succ: !0,\n      csAddr: o,\n      serverList: e.gatewayInfo.gatewayAddrs.map(e => e.address),\n      ec: null,\n      opid: u,\n      cid: e.gatewayInfo.cid.toString(),\n      uid: e.gatewayInfo.uid.toString(),\n      csIp: e.gatewayInfo.csIp,\n      unilbsServerIds: a.toString(),\n      isHttp3: n\n    }), e.proxyInfo && IT.joinWebProxyAP(t.sid, {\n      lts: c,\n      sucess: 1,\n      apServerAddr: o,\n      turnServerAddrList: e.proxyInfo.addresses.map(e => e.ip).join(\",\"),\n      errorCode: null,\n      eventType: t.cloudProxyServer,\n      unilbsServerIds: a.toString()\n    }), !1), e => e.code !== TE.OPERATION_ABORTED && (e.code === TE.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (IT.joinWebProxyAP(t.sid, {\n      lts: c,\n      sucess: 0,\n      apServerAddr: o,\n      turnServerAddrList: null,\n      errorCode: e.code,\n      eventType: t.cloudProxyServer,\n      unilbsServerIds: a.toString(),\n      extend: JSON.stringify({\n        networkState: l\n      })\n    }), NE.warning(\"[\".concat(t.clientId, \"] multi unilbs network error, retry\"), e), !0)), r);\n  }\n  const RO = (e, t, i, r, n, o) => {\n      const s = [],\n        a = s => {\n          4096 === s.flag ? IT.joinChooseServer(i.sid, {\n            lts: r,\n            succ: !1,\n            csAddr: t,\n            opid: e.opid,\n            serverList: null,\n            ec: s.error.message,\n            csIp: s.error.data && s.error.data.csIp,\n            unilbsServerIds: n.toString(),\n            isHttp3: o\n          }) : 1048576 !== s.flag && 4194304 !== s.flag && 4194310 !== s.flag || IT.joinWebProxyAP(i.sid, {\n            lts: r,\n            sucess: 0,\n            apServerAddr: t,\n            turnServerAddrList: null,\n            errorCode: s.error.code,\n            eventType: i.cloudProxyServer,\n            unilbsServerIds: n.toString()\n          });\n        };\n      if (e.response_body.forEach(t => {\n        const i = t.buffer.code;\n        if (23 === t.uri && 0 === i && !t.buffer.edges_services) if (4194310 === t.buffer.flag) NE.warning(\"no edge services in ap response of proxy fallback, will not set proxy in iceServers\"), t.buffer.edges_services = [];else {\n          const i = {\n            error: new vE(TE.CAN_NOT_GET_GATEWAY_SERVER, \"no edge services in ap response\", {\n              retry: !0,\n              csIp: e.detail[502]\n            }),\n            flag: t.buffer.flag\n          };\n          s.push(i), a(i);\n        }\n        if (0 !== i) {\n          const r = JA(i),\n            n = {\n              error: new vE(TE.CAN_NOT_GET_GATEWAY_SERVER, r.desc, {\n                desc: r.desc,\n                retry: r.retry,\n                csIp: e.detail[502]\n              }),\n              flag: t.buffer.flag\n            };\n          4194310 === t.buffer.flag ? NE.warning(n.error.toString()) : s.push(n), a(n);\n        }\n      }), s.length) throw NE.warning(\"[\".concat(i.clientId, \"] multi unilbs \").concat(t, \" failed, \").concat(s.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message, \", retry: \").concat(e.error.data.retry)).join(\" | \"))), new vE(TE.CAN_NOT_GET_GATEWAY_SERVER, s.map(e => \"flag: \".concat(e.flag, \", message: \").concat(e.error.message)).join(\" | \"), {\n        retry: !!s.find(e => e.error.data.retry),\n        csIp: e.detail[502],\n        desc: [...new Set(s.map(e => {\n          var t, i;\n          return null == e || null === (t = e.error) || void 0 === t || null === (i = t.data) || void 0 === i ? void 0 : i.desc;\n        }).filter(e => !!e))]\n      });\n    },\n    IO = e => {\n      var t, i;\n      if (e.addresses && 0 === e.addresses.length && 0 === e.code) throw new vE(TE.CAN_NOT_GET_GATEWAY_SERVER, \"void gateway address\", {\n        retry: !0,\n        csIp: e.detail && e.detail[502]\n      });\n      if (null !== (t = e.detail) && void 0 !== t && t[19] && \"string\" == typeof (null === (i = e.detail) || void 0 === i ? void 0 : i[19])) {\n        const t = e.detail[19],\n          i = null == t ? void 0 : t.split(\";\");\n        for (let t = 0; t < i.length; t++) {\n          var r;\n          const n = Ih(r = i[t]).call(r);\n          e.addresses[t] && i && (e.addresses[t].fingerprint = n);\n        }\n      }\n      if (HE(\"GATEWAY_ADDRESS\") && HE(\"GATEWAY_ADDRESS\").length > 0) {\n        NE.debug(\"assign gateway address to\", HE(\"GATEWAY_ADDRESS\"));\n        const t = HE(\"GATEWAY_ADDRESS\").map(t => {\n          var i, r;\n          const n = null !== (i = null === (r = e.addresses.find(e => e.ip === t.ip && e.port === t.port)) || void 0 === r ? void 0 : r.fingerprint) && void 0 !== i ? i : \"\";\n          return {\n            ip: t.ip,\n            port: t.port,\n            ticket: e.addresses[0] && e.addresses[0].ticket,\n            fingerprint: n\n          };\n        });\n        e.addresses = t;\n      }\n    },\n    yO = (e, t) => {\n      if (e.response_body && e.response_body.length) {\n        const t = e.response_body[0];\n        if (0 !== t.buffer.code) {\n          const e = JA(t.buffer.code);\n          throw new vE(TE.UPDATE_TICKET_FAILED, \"[\".concat(t.buffer.code, \"]: \").concat(e.desc), {\n            retry: e.retry\n          });\n        }\n        return t.buffer.ticket;\n      }\n      throw NE.debug(\"update ticket request received ap response without response body:\", t), new vE(TE.UPDATE_TICKET_FAILED, \"cannot find response body from ap response\", {\n        retry: !1\n      });\n    },\n    CO = (e, t, i) => {\n      const r = Math.floor(Math.random() * 10 ** 12),\n        n = {\n          appid: e.appId,\n          client_ts: Date.now(),\n          opid: r,\n          sid: e.sid,\n          request_bodies: [{\n            uri: 22,\n            buffer: {\n              cname: e.cname,\n              detail: {\n                6: e.stringUid,\n                11: t,\n                12: HE(\"USE_NEW_TOKEN\") ? \"1\" : void 0\n              },\n              key: e.token,\n              service_ids: i,\n              uid: e.uid || 0\n            }\n          }]\n        };\n      n.request_bodies.forEach(t => {\n        e.multiIP && e.multiIP.gateway_ip && (t.buffer.detail[5] = JSON.stringify({\n          vocs_ip: [e.multiIP.uni_lbs_ip],\n          vos_ip: [e.multiIP.gateway_ip]\n        }));\n      });\n      const o = new FormData();\n      return o.append(\"request\", JSON.stringify(n)), [o, r];\n    },\n    AO = (e, t) => {\n      const i = Math.floor(Math.random() * 10 ** 12),\n        r = {\n          appid: e.appId,\n          client_ts: Date.now(),\n          opid: i,\n          sid: e.sid,\n          request_bodies: [{\n            uri: 28,\n            buffer: {\n              cname: e.cname,\n              detail: {\n                1: \"\",\n                6: e.stringUid,\n                12: \"1\"\n              },\n              token: e.token,\n              service_ids: t,\n              uid: e.uid || 0,\n              edges_services: e.apResponse.addresses.map(e => ({\n                ip: e.ip,\n                port: e.port\n              }))\n            }\n          }]\n        },\n        n = new FormData();\n      return n.append(\"request\", JSON.stringify(r)), [n, i];\n    };\n  let OO = 0;\n  const bO = () => {\n      const e = HE(\"AREAS\");\n      0 === e.length && e.push(fg.GLOBAL);\n      return zi(e).call(e, (e, t, i) => {\n        const r = wO(t);\n        return r ? 0 === i ? r : \"\".concat(e, \",\").concat(r) : e;\n      }, \"\");\n    },\n    wO = e => e === fg.OVERSEA ? \"\".concat(Tg.ASIA, \",\").concat(Tg.EUROPE, \",\").concat(Tg.AFRICA, \",\").concat(Tg.NORTH_AMERICA, \",\").concat(Tg.SOUTH_AMERICA, \",\").concat(Tg.OCEANIA) : Tg[e],\n    NO = {\n      GLOBAL: {\n        ASIA: [fg.CHINA, fg.JAPAN, fg.INDIA, fg.KOREA, fg.HKMC],\n        EUROPE: [],\n        NORTH_AMERICA: [fg.US],\n        SOUTH_AMERICA: [],\n        OCEANIA: [],\n        AFRICA: []\n      }\n    },\n    DO = Object.keys(NO[fg.GLOBAL]),\n    PO = [fg.CHINA, fg.NORTH_AMERICA, fg.EUROPE, fg.ASIA, fg.JAPAN, fg.INDIA, fg.OCEANIA, fg.SOUTH_AMERICA, fg.AFRICA, fg.KOREA, fg.HKMC, fg.US],\n    LO = function (e, t) {\n      let i = [];\n      if (e.includes(fg.GLOBAL)) {\n        const o = [fg.GLOBAL, fg.OVERSEA],\n          s = Object.keys(vg);\n        if (t === fg.GLOBAL) throw new vE(TE.INVALID_PARAMS, \"GLOBAL is an invalid excludedArea value\");\n        if (t === fg.CHINA) i = [fg.OVERSEA];else if (n = t, DO.includes(n)) {\n          const e = (r = t, NO[fg.GLOBAL][r] || []),\n            n = [...o, t, ...e];\n          i = s.filter(e => !n.includes(e));\n        } else if (function (e) {\n          let t = !1;\n          return DO.forEach(i => {\n            NO[fg.GLOBAL][i].includes(e) && (t = !0);\n          }), t;\n        }(t)) {\n          const e = function (e) {\n              let t;\n              return DO.forEach(i => {\n                NO[fg.GLOBAL][i].includes(e) && (t = i);\n              }), t;\n            }(t),\n            r = [...o, e, t];\n          i = s.filter(e => !r.includes(e));\n        } else i = e;\n        i = function (e) {\n          const t = [];\n          return PO.forEach(i => {\n            e.includes(i) && t.push(i);\n          }), t.concat(e.filter(e => !PO.includes(e)));\n        }(i);\n      } else i = e;\n      var r, n;\n      return i;\n    };\n  async function kO(e, t, i, r) {\n    const n = async function (e, t, i, r) {\n      let n = null;\n      const o = [],\n        s = async () => {\n          const n = HE(\"WEBCS_DOMAIN\").slice(0, HE(\"AJAX_REQUEST_CONCURRENT\")).map(t => ({\n              url: e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"),\n              areaCode: bO()\n            })),\n            s = r.recordJoinChannelService({\n              startTs: Date.now(),\n              status: \"pending\",\n              service: \"chooseServer\",\n              urls: n.map(e => e.url)\n            }),\n            a = await eI({\n              fragementLength: HE(\"FRAGEMENT_LENGTH\"),\n              referenceList: n,\n              asyncMapHandler: r => (NE.debug(\"[\".concat(e.clientId, \"] Connect to choose_server:\"), r.url), TO(r, e, t, i)),\n              allFailedhandler: e => {\n                throw r.recordJoinChannelService({\n                  endTs: Date.now(),\n                  status: \"error\",\n                  errors: e\n                }, s), e[0];\n              },\n              promisesCollector: o\n            });\n          return r.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, s), a;\n        },\n        a = async () => {\n          if (await LR(1e3), null !== n) return n;\n          const s = HE(\"WEBCS_DOMAIN_BACKUP_LIST\").map(t => ({\n              url: e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"),\n              areaCode: bO()\n            })),\n            a = r.recordJoinChannelService({\n              endTs: void 0,\n              startTs: Date.now(),\n              status: \"pending\",\n              service: \"chooseServer\",\n              urls: s.map(e => e.url)\n            }),\n            c = await eI({\n              fragementLength: HE(\"FRAGEMENT_LENGTH\"),\n              referenceList: s,\n              asyncMapHandler: r => (NE.debug(\"[\".concat(e.clientId, \"] Connect to backup choose_server:\"), r.url), TO(r, e, t, i)),\n              allFailedhandler: e => {\n                throw r.recordJoinChannelService({\n                  endTs: Date.now(),\n                  status: \"error\",\n                  errors: e\n                }, a), e[0];\n              },\n              promisesCollector: o\n            });\n          return r.recordJoinChannelService({\n            endTs: Date.now(),\n            status: \"success\"\n          }, a), c;\n        };\n      try {\n        return n = await jR([s(), a()]), o.length && o.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), n;\n      } catch (e) {\n        throw e[0];\n      }\n    }(e, t, i, r);\n    return {\n      gatewayInfo: await n\n    };\n  }\n  async function MO(e, t, i, r, n) {\n    const o = e.cloudProxyServer;\n    if (\"disabled\" === o) {\n      if (!r) return;\n      if (e.useLocalAccessPoint) return await kO(e, t, i, n);\n      if (HE(\"JOIN_WITH_FALLBACK_MEDIA_PROXY\")) {\n        const {\n          gatewayInfo: r,\n          proxyInfo: o\n        } = await VO(e, t, i, n);\n        return e.turnServer && \"auto\" !== e.turnServer.mode || (e.turnServer = {\n          mode: \"manual\",\n          servers: o.map(e => ({\n            turnServerURL: e.address,\n            tcpport: e.tcpport || kE.tcpport,\n            udpport: e.udpport || kE.udpport,\n            username: e.username || kE.username,\n            password: e.password || kE.password,\n            forceturn: HE(\"JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE\"),\n            security: !0\n          }))\n        }), {\n          gatewayInfo: r\n        };\n      }\n      return await kO(e, t, i, n);\n    }\n    const {\n        proxyInfo: s,\n        gatewayInfo: a\n      } = await VO(e, t, i, n),\n      c = {\n        gatewayInfo: a\n      };\n    return e.turnServer = {\n      mode: \"manual\",\n      servers: s.map(e => ({\n        turnServerURL: e.address,\n        tcpport: \"proxy3\" === o ? void 0 : e.tcpport ? e.tcpport : kE.tcpport,\n        udpport: \"proxy4\" === o ? void 0 : e.udpport ? e.udpport : kE.udpport,\n        username: e.username || kE.username,\n        password: e.password || kE.password,\n        forceturn: \"proxy4\" !== o,\n        security: \"proxy5\" === o\n      }))\n    }, NE.debug(\"[\".concat(e.clientId, \"] set proxy server: \").concat(e.proxyServer, \", mode: \").concat(o)), c;\n  }\n  async function UO(e, t, i, r, n) {\n    const o = HE(\"ACCOUNT_REGISTER\").slice(0, HE(\"AJAX_REQUEST_CONCURRENT\"));\n    let s = [];\n    s = t.proxyServer ? o.map(e => \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1\")) : o.map(e => \"https://\".concat(e, \"/api/v1\"));\n    const a = null == n ? void 0 : n.recordJoinChannelService({\n      startTs: Date.now(),\n      status: \"pending\",\n      service: \"stringUID\",\n      urls: s\n    });\n    try {\n      const o = await async function (e, t, i, r, n) {\n        const o = Date.now(),\n          s = {\n            sid: i.sid,\n            opid: 10,\n            appid: i.appId,\n            string_uid: t\n          };\n        let a = e[0];\n        const c = await yE(() => lT(a + \"\".concat(-1 === a.indexOf(\"?\") ? \"?\" : \"&\", \"action=stringuid\"), {\n          data: s,\n          cancelToken: r,\n          headers: {\n            \"X-Packet-Service-Type\": 0,\n            \"X-Packet-URI\": 72\n          }\n        }), (i, r) => {\n          if (0 === i.code) {\n            if (i.uid <= 0 || i.uid >= Math.pow(2, 32)) throw NE.error(\"Invalid Uint Uid \".concat(t, \" => \").concat(i.uid), i), IT.reqUserAccount(s.sid, {\n              lts: o,\n              success: !1,\n              serverAddr: a,\n              stringUid: s.string_uid,\n              uid: i.uid,\n              errorCode: TE.INVALID_UINT_UID_FROM_STRING_UID,\n              extend: s\n            }), new vE(TE.INVALID_UINT_UID_FROM_STRING_UID);\n            return IT.reqUserAccount(s.sid, {\n              lts: o,\n              success: !0,\n              serverAddr: a,\n              stringUid: s.string_uid,\n              uid: i.uid,\n              errorCode: null,\n              extend: s\n            }), !1;\n          }\n          const n = JA(i.code);\n          return n.retry && (a = e[(r + 1) % e.length]), IT.reqUserAccount(s.sid, {\n            lts: o,\n            success: !1,\n            serverAddr: a,\n            stringUid: s.string_uid,\n            uid: i.uid,\n            errorCode: n.desc,\n            extend: s\n          }), n.retry;\n        }, (t, i) => t.code !== TE.OPERATION_ABORTED && (IT.reqUserAccount(s.sid, {\n          lts: o,\n          success: !1,\n          serverAddr: a,\n          stringUid: s.string_uid,\n          uid: null,\n          errorCode: t.code,\n          extend: s\n        }), a = e[(i + 1) % e.length], !0), n);\n        if (0 !== c.code) {\n          const e = JA(c.code);\n          throw new vE(TE.UNEXPECTED_RESPONSE, e.desc);\n        }\n        return c;\n      }(s, e, t, i, r);\n      return null == n || n.recordJoinChannelService({\n        status: \"success\",\n        endTs: Date.now()\n      }, a), o.uid;\n    } catch (e) {\n      throw null == n || n.recordJoinChannelService({\n        status: \"error\",\n        endTs: Date.now(),\n        errors: [e]\n      }, a), e;\n    }\n  }\n  async function xO(e, t, i) {\n    const r = HE(\"CDS_AP\").slice(0, HE(\"AJAX_REQUEST_CONCURRENT\")).map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v1\") : \"https://\".concat(t, \"/api/v1?action=config\")).map(r => function (e, t, i, r) {\n      const n = Bh(),\n        o = {\n          flag: 64,\n          cipher_method: 0,\n          features: {\n            device: n.name,\n            system: n.os,\n            system_general: navigator.userAgent,\n            vendor: t.appId,\n            version: PE,\n            cname: t.cname,\n            sid: t.sid,\n            session_id: t.sid,\n            detail: \"\",\n            proxyServer: t.proxyServer\n          }\n        };\n      return yE(() => lT(e, {\n        data: o,\n        timeout: 1e3,\n        cancelToken: i,\n        headers: {\n          \"X-Packet-Service-Type\": 0,\n          \"X-Packet-URI\": 54\n        }\n      }), void 0, e => e.code !== TE.OPERATION_ABORTED, r);\n    }(r, e, t, i));\n    let n = null,\n      o = null,\n      s = {};\n    try {\n      n = await jR(r);\n    } catch (e) {\n      if (e.code === TE.OPERATION_ABORTED) throw e;\n      o = e;\n    }\n    r.forEach(e => e.cancel());\n    if (IT.reportApiInvoke(e.sid, {\n      name: Em.REQUEST_CONFIG_DISTRIBUTE,\n      options: {\n        error: o,\n        res: n\n      }\n    }).onSuccess(), n && n.test_tags) try {\n      s = function (e) {\n        if (!e.test_tags) return {};\n        const t = e.test_tags,\n          i = Object.keys(t),\n          r = {};\n        return i.forEach(e => {\n          var i;\n          const n = Ih(i = e.slice(4)).call(i),\n            o = JSON.parse(t[e])[1];\n          r[n] = o;\n        }), r;\n      }(n);\n    } catch (e) {}\n    return s;\n  }\n  async function VO(e, t, i, r) {\n    const n = HE(\"PROXY_SERVER_TYPE3\"),\n      o = (e, t, i) => {\n        let r = i || n;\n        return Array.isArray(r) && (r = t % 2 == 0 ? n[1] : n[0]), \"https://\".concat(r, \"/ap/?url=\").concat(e);\n      };\n    let s = null;\n    const a = [],\n      c = async () => {\n        const n = HE(\"WEBCS_DOMAIN\").slice(0, HE(\"AJAX_REQUEST_CONCURRENT\")).map((t, i) => {\n            let r;\n            return r = \"disabled\" === e.cloudProxyServer && e.proxyServer ? o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i, e.proxyServer) : \"disabled\" === e.cloudProxyServer || \"fallback\" === e.cloudProxyServer ? \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\") : o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i), {\n              url: r,\n              areaCode: bO(),\n              serviceIds: [Fg.CHOOSE_SERVER, \"proxy5\" === e.cloudProxyServer ? Fg.CLOUD_PROXY_5 : \"proxy3\" === e.cloudProxyServer || \"proxy4\" === e.cloudProxyServer ? Fg.CLOUD_PROXY : Fg.CLOUD_PROXY_FALLBACK]\n            };\n          }),\n          s = r.recordJoinChannelService({\n            startTs: Date.now(),\n            status: \"pending\",\n            service: \"chooseServer\",\n            urls: n.map(e => e.url)\n          }),\n          c = await eI({\n            fragementLength: HE(\"FRAGEMENT_LENGTH\"),\n            referenceList: n,\n            asyncMapHandler: r => (NE.debug(\"[\".concat(e.clientId, \"] Connect to choose_server:\"), r.url), vO(r, e, t, i)),\n            allFailedhandler: e => {\n              throw r.recordJoinChannelService({\n                endTs: Date.now(),\n                status: \"error\",\n                errors: e\n              }, s), e[0];\n            },\n            promisesCollector: a\n          });\n        return r.recordJoinChannelService({\n          endTs: Date.now(),\n          status: \"success\"\n        }, s), c;\n      },\n      d = async () => {\n        if (await LR(1e3), null !== s) return s;\n        const n = HE(\"WEBCS_DOMAIN_BACKUP_LIST\").map((t, i) => {\n            let r;\n            return r = \"disabled\" === e.cloudProxyServer && e.proxyServer ? o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i, e.proxyServer) : \"disabled\" === e.cloudProxyServer || \"fallback\" === e.cloudProxyServer ? \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\") : o(\"\".concat(t, \"/api/v2/transpond/webrtc?v=2\"), i), {\n              url: r,\n              areaCode: bO(),\n              serviceIds: [Fg.CHOOSE_SERVER, \"proxy5\" === e.cloudProxyServer ? Fg.CLOUD_PROXY_5 : \"proxy3\" === e.cloudProxyServer || \"proxy4\" === e.cloudProxyServer ? Fg.CLOUD_PROXY : Fg.CLOUD_PROXY_FALLBACK]\n            };\n          }),\n          c = r.recordJoinChannelService({\n            startTs: Date.now(),\n            status: \"pending\",\n            service: \"chooseServer\",\n            urls: n.map(e => e.url)\n          }),\n          d = await eI({\n            fragementLength: HE(\"FRAGEMENT_LENGTH\"),\n            referenceList: n,\n            asyncMapHandler: r => (NE.debug(\"[\".concat(e.clientId, \"] Connect to backup choose_server:\"), r.url), vO(r, e, t, i)),\n            allFailedhandler: e => {\n              throw r.recordJoinChannelService({\n                endTs: Date.now(),\n                status: \"error\",\n                errors: e\n              }, c), e[0];\n            },\n            promisesCollector: a\n          });\n        return r.recordJoinChannelService({\n          endTs: Date.now(),\n          status: \"success\"\n        }, c), d;\n      };\n    let u, l, h;\n    try {\n      ({\n        gatewayInfo: u,\n        proxyInfo: l,\n        url: h\n      } = await jR([c(), d()]));\n    } catch (e) {\n      throw e[0];\n    }\n    if (a.length && a.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), !u || !l) throw new vE(TE.UNEXPECTED_ERROR, \"missing gateway or proxy response\").print();\n    if (e.apUrl = h, \"disabled\" !== e.cloudProxyServer && Array.isArray(n) && h) {\n      const t = new YA(h).host;\n      n.includes(t) && (e.proxyServer = t, NE.setProxyServer(t), IT.setProxyServer(t));\n    }\n    return s = {\n      gatewayInfo: u,\n      proxyInfo: await OR(l, u.uid)\n    }, s;\n  }\n  async function jO(e, t, i, r) {\n    const n = HE(\"UAP_AP\").slice(0, HE(\"AJAX_REQUEST_CONCURRENT\")).map(e => t.proxyServer ? \"https://\".concat(t.proxyServer, \"/ap/?url=\").concat(e + \"/api/v1?action=uap\") : \"https://\".concat(e, \"/api/v1?action=uap\"));\n    return await gO(n, e, t, i, r);\n  }\n  async function FO(e, t, i) {\n    const r = HE(\"UAP_AP\").slice(0, HE(\"AJAX_REQUEST_CONCURRENT\")).map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v1?action=uap\") : \"https://\".concat(t, \"/api/v1?action=uap\")).map(r => function (e, t, i, r) {\n      const n = {\n        command: \"convergeAllocateEdge\",\n        sid: t.sid,\n        appId: t.appId,\n        token: t.token,\n        ts: Date.now(),\n        version: PE,\n        cname: t.cname,\n        uid: t.uid.toString(),\n        requestId: SO,\n        seq: SO\n      };\n      SO += 1;\n      const o = {\n        service_name: \"tele_channel\",\n        json_body: JSON.stringify(n)\n      };\n      return yE(async () => {\n        const t = await lT(e, {\n          data: o,\n          cancelToken: i,\n          headers: {\n            \"X-Packet-Service-Type\": 0,\n            \"X-Packet-URI\": 61\n          }\n        });\n        if (0 !== t.code) {\n          const e = new vE(TE.UNEXPECTED_RESPONSE, \"cross channel ap error, code\" + t.code, {\n            retry: !0\n          });\n          throw NE.error(e.toString()), e;\n        }\n        const r = JSON.parse(t.json_body);\n        if (200 !== r.code) {\n          const e = new vE(TE.UNEXPECTED_RESPONSE, \"cross channel app center error, code: \".concat(r.code, \", reason: \").concat(r.reason));\n          throw NE.error(e.toString()), e;\n        }\n        if (!r.servers || 0 === r.servers.length) {\n          const e = new vE(TE.UNEXPECTED_RESPONSE, \"cross channel app center empty server\");\n          throw NE.error(e.toString()), e;\n        }\n        return {\n          vid: r.vid,\n          workerToken: r.workerToken,\n          addressList: (HE(\"CHANNEL_MEDIA_RELAY_SERVERS\") || r.servers).map(e => \"wss://\".concat(e.address.replace(/\\./g, \"-\"), \".\").concat(HE(\"WORKER_DOMAIN\"), \":\").concat(e.wss))\n        };\n      }, void 0, e => !!(e.code !== TE.OPERATION_ABORTED && e.code !== TE.UNEXPECTED_RESPONSE || e.data && e.data.retry), r);\n    }(r, e, t, i));\n    try {\n      const e = await jR(r);\n      return r.forEach(e => e.cancel()), e;\n    } catch (e) {\n      throw e[0];\n    }\n  }\n  async function BO(e, t, i) {\n    let r = null;\n    const n = [],\n      o = async o => {\n        const s = HE(o ? \"WEBCS_DOMAIN_BACKUP_LIST\" : \"WEBCS_DOMAIN\").map(t => e.proxyServer ? \"https://\".concat(e.proxyServer, \"/ap/?url=\").concat(t + \"/api/v2/transpond/webrtc?v=2\") : \"https://\".concat(t, \"/api/v2/transpond/webrtc?v=2\"));\n        return o && (await LR(1e3), null !== r) ? r : await eI({\n          fragementLength: HE(\"FRAGEMENT_LENGTH\"),\n          referenceList: s,\n          asyncMapHandler: r => (NE.debug(\"[\".concat(e.clientId, \"] update ticket, Connect to \").concat(o ? \"backup\" : \"\", \" choose_server:\"), r), function (e, t, i, r) {\n            const [n] = AO(t, [Fg.CHOOSE_SERVER]);\n            let o = pT.networkState;\n            return yE(async () => {\n              o && pT.networkState === bg.OFFLINE && pT.onlineWaiter && (await Cl.race([pT.onlineWaiter, LR(r && r.maxRetryTimeout || RE.maxRetryTimeout)])), o = pT.networkState;\n              const t = await lT(e, {\n                data: n,\n                cancelToken: i,\n                headers: {\n                  \"Content-Type\": \"multipart/form-data;\"\n                }\n              }, !0);\n              return yO(t, e);\n            }, () => !1, e => e.code !== TE.OPERATION_ABORTED && (e.code === TE.UPDATE_TICKET_FAILED ? e.data.retry : (NE.warning(\"[\".concat(t.clientId, \"] update ticket network error, retry\"), e), !0)), r);\n          }(r, e, t, i)),\n          allFailedhandler: e => {\n            throw e[0];\n          },\n          promisesCollector: n\n        });\n      };\n    try {\n      return r = await jR([o(!1), o(!0)]), n.length && n.forEach(e => e.cancel && \"function\" == typeof e.cancel && e.cancel()), r;\n    } catch (e) {\n      throw e[0];\n    }\n  }\n  function GO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function WO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? GO(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : GO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class HO extends gE {\n    constructor() {\n      super(), mp(this, \"configs\", void 0), mp(this, \"joinInfo\", void 0), mp(this, \"cancelToken\", void 0), mp(this, \"retryConfig\", {\n        timeout: 3e3,\n        timeoutFactor: 1.5,\n        maxRetryCount: 1,\n        maxRetryTimeout: 1e4\n      }), mp(this, \"interval\", void 0), mp(this, \"mutex\", new OT(\"config-distribute\")), mp(this, \"mutableParamsRead\", !1);\n    }\n    startGetConfigDistribute(e, t) {\n      this.joinInfo = e, this.cancelToken = t, this.interval && this.stopGetConfigDistribute(), HE(\"ENABLE_CONFIG_DISTRIBUTE\") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {\n        this.updateConfigDistribute();\n      }, HE(\"CONFIG_DISTRIBUTE_INTERVAL\")));\n    }\n    stopGetConfigDistribute() {\n      this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0;\n    }\n    async awaitConfigDistributeComplete() {\n      if (!this.mutex.isLocked) return;\n      (await this.mutex.lock())();\n    }\n    async updateConfigDistribute() {\n      if (!this.mutableParamsRead) {\n        this.mutableParamsRead = !0;\n        IT.reportApiInvoke(null, {\n          options: void 0,\n          name: Em.LOAD_CONFIG_FROM_LOCALSTORAGE,\n          tag: fm.TRACER\n        }).onSuccess(JSON.stringify(YE));\n      }\n      if (!this.joinInfo || !this.cancelToken || !this.retryConfig) return void NE.debug(\"[config-distribute] get config distribute interrupted have no joininfo\");\n      let e;\n      const t = await this.mutex.lock();\n      try {\n        e = await xO(this.joinInfo, this.cancelToken, this.retryConfig), NE.debug(\"[config-distribute] get config distribute\", JSON.stringify(e)), e.limit_bitrate && this.handleBitrateLimit(e.limit_bitrate), this.cacheGlobalParameterConfig(e), this.configs = e;\n      } catch (e) {\n        const t = new vE(TE.NETWORK_RESPONSE_ERROR, e);\n        NE.warning(\"[config-distribute] \".concat(t.toString()));\n      } finally {\n        t();\n      }\n    }\n    getBitrateLimit() {\n      return this.configs ? this.configs.limit_bitrate : void 0;\n    }\n    handleBitrateLimit(e) {\n      var t;\n      (t = e) && t.uplink && t.id && void 0 !== t.uplink.max_bitrate && void 0 !== t.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e.id && this.emit(Rg.UPDATE_BITRATE_LIMIT, e) : this.emit(Rg.UPDATE_BITRATE_LIMIT, e));\n    }\n    getLowStreamConfigDistribute() {\n      return this.configs && this.configs.limit_bitrate && WO({}, this.configs.limit_bitrate.low_stream_uplink);\n    }\n    cacheGlobalParameterConfig(e) {\n      var t;\n      const i = Yf(t = Object.keys(e).filter(e => /^webrtc_ng_global_parameter/.test(e))).call(t);\n      for (let t = 0; t < i.length; t++) for (let r = i.length - 1; r > t; r--) {\n        const t = i[r];\n        if (\"number\" == typeof e[t].__priority) {\n          const n = e[t].__priority,\n            o = i[r - 1];\n          if (\"number\" == typeof e[o].__priority) {\n            if (!(n > e[o].__priority)) continue;\n            {\n              const e = t;\n              i[r] = i[r - 1], i[r - 1] = e;\n            }\n          } else {\n            const e = t;\n            i[r] = i[r - 1], i[r - 1] = e;\n          }\n        }\n      }\n      const r = {};\n      i.forEach(t => {\n        const i = e[t],\n          n = i.__expires;\n        Object.keys(i).forEach(e => {\n          \"__priority\" === e || \"__expires\" === e || Object.prototype.hasOwnProperty.call(r, e) || (r[e] = WO({\n            value: i[e]\n          }, n && {\n            expires: n\n          }));\n        });\n      });\n      try {\n        const e = JSON.stringify(r),\n          t = window.btoa(e);\n        window.localStorage.setItem(\"websdk_ng_global_parameter\", t), NE.debug(\"Caching global parameters \".concat(e));\n      } catch (e) {\n        NE.error(\"Error caching global parameters:\", e.message);\n      }\n    }\n  }\n  function KO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function YO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? KO(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : KO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class qO extends gE {\n    constructor(e, t, i, r) {\n      super(), mp(this, \"spec\", void 0), mp(this, \"token\", void 0), mp(this, \"websocket\", void 0), mp(this, \"pingpongTimer\", void 0), mp(this, \"reconnectMode\", \"retry\"), mp(this, \"serviceMode\", void 0), mp(this, \"reqId\", 0), mp(this, \"commandReqId\", 0), mp(this, \"handleWebSocketOpen\", () => {\n        this.reconnectMode = \"retry\", this.startPingPong();\n      }), mp(this, \"handleWebSocketMessage\", e => {\n        if (!e.data) return;\n        const t = JSON.parse(e.data);\n        t.requestId ? this.emit(\"@\".concat(t.requestId, \"-\").concat(t.sid), t) : this.serviceMode === Ym.INJECT ? this.emit($m.INJECT_STREAM_STATUS, t) : (IT.workerEvent(this.spec.sid, {\n          actionType: \"status\",\n          serverCode: t.code,\n          workerType: this.serviceMode === Ym.TRANSCODE ? 1 : 2\n        }), this.emit($m.PUBLISH_STREAM_STATUS, t));\n      }), this.spec = t, this.token = e, this.serviceMode = r, this.websocket = new $A(\"live-streaming\", i), this.websocket.on(Km.CONNECTED, this.handleWebSocketOpen), this.websocket.on(Km.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(Km.REQUEST_NEW_URLS, (e, t) => {\n        FR(this, $m.REQUEST_NEW_ADDRESS).then(e).catch(t);\n      }), this.websocket.on(Km.RECONNECTING, () => {\n        this.websocket.reconnectMode = this.reconnectMode;\n      });\n    }\n    init(e) {\n      return this.websocket.init(e);\n    }\n    async request(e, t, i, r) {\n      this.reqId += 1, \"request\" === e && (this.commandReqId += 1);\n      const n = this.commandReqId,\n        o = this.reqId;\n      if (!o || !this.websocket) throw new vE(TE.UNEXPECTED_ERROR);\n      const s = YO({\n        command: e,\n        sdkVersion: \"4.16.1\" === PE ? \"0.0.1\" : PE,\n        seq: o,\n        requestId: o,\n        allocate: i,\n        cname: this.spec.cname,\n        appId: this.spec.appId,\n        sid: this.spec.sid,\n        uid: this.spec.uid.toString(),\n        ts: Math.floor(Date.now() / 1e3)\n      }, t);\n      if (\"closed\" === this.websocket.state) throw new vE(TE.WS_DISCONNECT);\n      const a = () => new Cl((e, t) => {\n        this.websocket.once(Km.CLOSED, () => t(new vE(TE.WS_ABORT))), this.websocket.once(Km.CONNECTED, e);\n      });\n      \"connected\" !== this.websocket.state && (await a()), s.clientRequest && (s.clientRequest.workerToken = this.token);\n      const c = new Cl((e, t) => {\n        const i = () => {\n          t(new vE(TE.WS_ABORT));\n        };\n        this.websocket.once(Km.RECONNECTING, i), this.websocket.once(Km.CLOSED, i), this.once(\"@\".concat(o, \"-\").concat(this.spec.sid), t => {\n          e(t);\n        });\n      });\n      r && IT.workerEvent(this.spec.sid, YO(YO({}, r), {}, {\n        requestId: n,\n        actionType: \"request\",\n        payload: JSON.stringify(t.clientRequest),\n        serverCode: 0,\n        code: 0\n      }));\n      const d = Date.now();\n      this.websocket.sendMessage(s);\n      let u = null;\n      try {\n        u = await c;\n      } catch (r) {\n        if (\"closed\" === this.websocket.state) throw r;\n        return await a(), await this.request(e, t, i);\n      }\n      return r && IT.workerEvent(this.spec.sid, YO(YO({}, r), {}, {\n        requestId: n,\n        actionType: \"response\",\n        payload: JSON.stringify(u.serverResponse),\n        serverCode: u.code,\n        success: 200 === u.code,\n        responseTime: Date.now() - d\n      })), 200 !== u.code && this.handleResponseError(u), u;\n    }\n    tryNextAddress() {\n      this.reconnectMode = \"tryNext\", this.websocket.reconnect(\"tryNext\");\n    }\n    close() {\n      const e = \"4.16.1\" === PE ? \"0.0.1\" : PE;\n      this.reqId += 1, \"connected\" === this.websocket.state ? (this.websocket.sendMessage({\n        command: \"request\",\n        appId: this.spec.appId,\n        cname: this.spec.cname,\n        uid: this.spec.uid.toString(),\n        sdkVersion: e,\n        sid: this.spec.sid,\n        seq: this.reqId,\n        ts: Math.floor(Date.now() / 1e3),\n        requestId: this.reqId,\n        clientRequest: {\n          command: \"DestroyWorker\"\n        }\n      }), this.websocket.close(!1, !0)) : this.websocket.close(!1), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0);\n    }\n    handleResponseError(e) {\n      switch (e.code) {\n        case tg.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:\n          return void NE.warning(\"live stream response already exists stream\");\n        case tg.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:\n        case tg.LIVE_STREAM_RESPONSE_BAD_STREAM:\n        case tg.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:\n          return new vE(TE.LIVE_STREAMING_INVALID_ARGUMENT, \"\", {\n            code: e.code\n          }).throw();\n        case tg.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:\n          if (\"UnpublishStream\" === e.serverResponse.command || \"UninjectStream\" === e.serverResponse.command) return;\n          throw new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream response wm worker not exist\", {\n            retry: !0\n          });\n        case tg.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:\n          return new vE(TE.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, \"\", {\n            code: e.code\n          }).throw();\n        case tg.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:\n          {\n            const t = new vE(TE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);\n            return this.emit($m.WARNING, t, e.serverResponse.url);\n          }\n        case tg.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN:\n          {\n            const t = new vE(TE.LIVE_STREAMING_WARN_FREQUENT_REQUEST);\n            return this.emit($m.WARNING, t, e.serverResponse.url);\n          }\n        case tg.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:\n          throw new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream response wm worker not exist\", {\n            retry: !0\n          });\n        case tg.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:\n          return new vE(TE.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, \"\", {\n            code: e.code\n          }).throw();\n        case tg.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM:\n          {\n            const t = new vE(TE.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);\n            return this.emit($m.WARNING, t, e.serverResponse.url);\n          }\n        case tg.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:\n          return new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"\", {\n            code: e.code\n          }).throw();\n        case tg.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:\n          throw new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"live stream resource limit\", {\n            retry: !0,\n            changeAddress: !0\n          });\n        case tg.LIVE_STREAM_RESPONSE_WORKER_LOST:\n        case tg.LIVE_STREAM_RESPONSE_WORKER_QUIT:\n          if (\"UnpublishStream\" === e.serverResponse.command || \"UninjectStream\" === e.serverResponse.command) return;\n          throw new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            retry: !0,\n            changeAddress: !0\n          });\n        case tg.ERROR_FAIL_SEND_MESSAGE:\n          if (\"UnpublishStream\" === e.serverResponse.command || \"UninjectStream\" === e.serverResponse.command) return;\n          if (\"UpdateTranscoding\" === e.serverResponse.command || \"ControlStream\" === e.serverResponse.command) return new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            code: e.code\n          }).throw();\n          throw new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"error fail send message\", {\n            retry: !0,\n            changeAddress: !0\n          });\n        case tg.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:\n        case tg.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:\n        case tg.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:\n        case tg.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:\n          return new vE(TE.LIVE_STREAMING_CDN_ERROR, \"\", {\n            code: e.code\n          }).throw();\n      }\n    }\n    startPingPong() {\n      this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {\n        \"connected\" === this.websocket.state && this.request(\"ping\", {}).catch(xR);\n      }, 6e3);\n    }\n  }\n  function JO(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function XO(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? JO(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : JO(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class zO extends gE {\n    constructor(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : RE,\n        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : RE;\n      super(), mp(this, \"onLiveStreamWarning\", void 0), mp(this, \"onLiveStreamError\", void 0), mp(this, \"onInjectStatusChange\", void 0), mp(this, \"spec\", void 0), mp(this, \"retryTimeout\", 1e4), mp(this, \"connection\", void 0), mp(this, \"httpRetryConfig\", void 0), mp(this, \"wsRetryConfig\", void 0), mp(this, \"streamingTasks\", new Map()), mp(this, \"isStartingStreamingTask\", !1), mp(this, \"taskMutex\", new OT(\"live-streaming\")), mp(this, \"cancelToken\", fE.CancelToken.source()), mp(this, \"transcodingConfig\", void 0), mp(this, \"injectConfig\", XO({}, Zm)), mp(this, \"injectLoopTimes\", 0), mp(this, \"uapResponse\", void 0), mp(this, \"lastTaskId\", 1), mp(this, \"statusError\", new Map()), this.spec = e, this.httpRetryConfig = i, this.wsRetryConfig = t;\n    }\n    async setTranscodingConfig(e) {\n      const t = XO(XO({}, Qm), e);\n      66 !== t.videoCodecProfile && 77 !== t.videoCodecProfile && 100 !== t.videoCodecProfile && (NE.debug(\"[\".concat(this.spec.clientId, \"] set transcoding config, fix video codec profile: \").concat(t.videoCodecProfile, \" -> 100\")), t.videoCodecProfile = 100), t.transcodingUsers || (t.transcodingUsers = t.userConfigs), t.transcodingUsers && (t.transcodingUsers = t.transcodingUsers.map(e => XO(XO(XO({}, Jm), e), {}, {\n        zOrder: e.zOrder ? e.zOrder + 1 : 1\n      }))), function (e) {\n        tm(e.width) || Xf(e.width, \"config.width\", 0, 1e4), tm(e.height) || Xf(e.height, \"config.height\", 0, 1e4), tm(e.videoBitrate) || Xf(e.videoBitrate, \"config.videoBitrate\", 1, 1e6), tm(e.videoFrameRate) || Xf(e.videoFrameRate, \"config.videoFrameRate\"), tm(e.lowLatency) || qf(e.lowLatency, \"config.lowLatency\"), tm(e.audioSampleRate) || Jf(e.audioSampleRate, \"config.audioSampleRate\", [32e3, 44100, 48e3]), tm(e.audioBitrate) || Xf(e.audioBitrate, \"config.audioBitrate\", 1, 128), tm(e.audioChannels) || Jf(e.audioChannels, \"config.audioChannels\", [1, 2, 3, 4, 5]), tm(e.videoGop) || Xf(e.videoGop, \"config.videoGop\"), tm(e.videoCodecProfile) || Jf(e.videoCodecProfile, \"config.videoCodecProfile\", [66, 77, 100]), tm(e.userCount) || Xf(e.userCount, \"config.userCount\", 0, 17), tm(e.backgroundColor) || Xf(e.backgroundColor, \"config.backgroundColor\", 0, 16777215), tm(e.userConfigExtraInfo) || Qf(e.userConfigExtraInfo, \"config.userConfigExtraInfo\", 0, 4096, !1), e.transcodingUsers && !tm(e.transcodingUsers) && (Zf(e.transcodingUsers, \"config.transcodingUsers\"), e.transcodingUsers.forEach((e, t) => {\n          em(e.uid), tm(e.x) || Xf(e.x, \"transcodingUser[\".concat(t, \"].x\"), 0, 1e4), tm(e.y) || Xf(e.y, \"transcodingUser[\".concat(t, \"].y\"), 0, 1e4), tm(e.width) || Xf(e.width, \"transcodingUser[\".concat(t, \"].width\"), 0, 1e4), tm(e.height) || Xf(e.height, \"transcodingUser[\".concat(t, \"].height\"), 0, 1e4), tm(e.zOrder) || Xf(e.zOrder - 1, \"transcodingUser[\".concat(t, \"].zOrder\"), 0, 100), tm(e.alpha) || Xf(e.alpha, \"transcodingUser[\".concat(t, \"].alpha\"), 0, 1, !1);\n        })), tm(e.watermark) || zm(e.watermark, \"watermark\"), tm(e.backgroundImage) || zm(e.backgroundImage, \"backgroundImage\"), e.images && !tm(e.images) && (Zf(e.images, \"config.images\"), e.images.forEach((e, t) => {\n          zm(e, \"images[\".concat(t, \"]\"));\n        }));\n      }(t);\n      const i = [];\n      t.images && i.push(...t.images.map(e => XO(XO(XO({}, Xm), e), {}, {\n        zOrder: 255\n      }))), t.backgroundImage && (i.push(XO(XO(XO({}, Xm), t.backgroundImage), {}, {\n        zOrder: 0\n      })), delete t.backgroundImage), t.watermark && (i.push(XO(XO(XO({}, Xm), t.watermark), {}, {\n        zOrder: 255\n      })), delete t.watermark), t.images = i, t.transcodingUsers && (t.userConfigs = t.transcodingUsers.map(e => XO({}, e)), t.userCount = t.transcodingUsers.length, delete t.transcodingUsers);\n      const r = (t.userConfigs || []).map(e => \"number\" == typeof e.uid ? Cl.resolve(e.uid) : UO(e.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));\n      if ((await Cl.all(r)).forEach((e, i) => {\n        t.userConfigs && t.userConfigs[i] && (t.userConfigs[i].uid = e);\n      }), this.transcodingConfig = t, this.connection) try {\n        var n;\n        const e = await this.connection.request(\"request\", {\n          clientRequest: {\n            command: \"UpdateTranscoding\",\n            transcodingConfig: this.transcodingConfig\n          }\n        }, !1, {\n          command: \"UpdateTranscoding\",\n          workerType: 1,\n          requestByUser: !0,\n          tid: Array.from(zv(n = this.streamingTasks).call(n)).map(e => e.taskId).join(\"#\")\n        });\n        NE.debug(\"[\".concat(this.spec.clientId, \"] update live transcoding config success, code: \").concat(e.code, \", config:\"), JSON.stringify(this.transcodingConfig));\n      } catch (e) {\n        if (!e.data || !e.data.retry) throw e;\n        e.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach(t => {\n          NE.warning(\"[\".concat(this.spec.clientId, \"] live streaming receive error\"), e.toString(), \"try to republish\", t.url), this.startLiveStreamingTask(t.url, t.mode, e).then(() => {\n            NE.debug(\"[\".concat(this.spec.clientId, \"] live streaming republish \").concat(t.url, \" success\"));\n          }).catch(e => {\n            NE.error(\"[\".concat(this.spec.clientId, \"] live streaming republish failed\"), t.url, e.toString()), this.onLiveStreamError && this.onLiveStreamError(t.url, e);\n          });\n        });\n      }\n    }\n    setInjectStreamConfig(e, t) {\n      this.injectConfig = Object.assign({}, this.injectConfig, e), this.injectLoopTimes = t;\n    }\n    async startLiveStreamingTask(e, t, i) {\n      var r;\n      if (Array.from(zv(r = this.streamingTasks).call(r)).find(e => e.mode === Ym.INJECT) && t === Ym.INJECT) return new vE(TE.LIVE_STREAMING_TASK_CONFLICT, \"inject stream over limit\").throw();\n      if (!this.transcodingConfig && t === Ym.TRANSCODE) throw new vE(TE.INVALID_OPERATION, \"[LiveStreaming] no transcoding config found, can not start transcoding streaming task\");\n      let n = {\n        command: \"PublishStream\",\n        ts: Date.now(),\n        url: e,\n        uid: this.spec.uid.toString(),\n        autoDestroyTime: 100,\n        acceptImageTimeout: !0\n      };\n      NE.debug(\"[\".concat(this.spec.clientId, \"] start live streaming \").concat(e, \", mode: \").concat(t));\n      const o = await this.taskMutex.lock();\n      if (!this.connection && i) return void o();\n      if (this.streamingTasks.get(e) && !i) return o(), new vE(TE.LIVE_STREAMING_TASK_CONFLICT).throw();\n      try {\n        this.connection || (this.connection = await this.connect(t));\n      } catch (e) {\n        throw o(), e;\n      }\n      switch (t) {\n        case Ym.TRANSCODE:\n          n.transcodingConfig = XO({}, this.transcodingConfig);\n          break;\n        case Ym.RAW:\n          break;\n        case Ym.INJECT:\n          n = {\n            cname: this.spec.cname,\n            command: \"InjectStream\",\n            sid: this.spec.sid,\n            transcodingConfig: this.injectConfig,\n            ts: Date.now(),\n            url: e,\n            loopTimes: this.injectLoopTimes\n          };\n      }\n      this.uapResponse && this.uapResponse.vid && (n.vid = this.uapResponse.vid), this.isStartingStreamingTask = !0;\n      const s = this.lastTaskId++;\n      try {\n        const r = new Cl((t, r) => {\n            LR(this.retryTimeout).then(() => {\n              if (i) return r(i);\n              const t = this.statusError.get(e);\n              return t ? (this.statusError.delete(e), r(t)) : void 0;\n            });\n          }),\n          a = await Cl.race([this.connection.request(\"request\", {\n            clientRequest: n\n          }, !0, {\n            url: e,\n            command: \"PublishStream\",\n            workerType: t === Ym.TRANSCODE ? 1 : 2,\n            requestByUser: !i,\n            tid: s.toString()\n          }), r]);\n        this.isStartingStreamingTask = !1, NE.debug(\"[\".concat(this.spec.clientId, \"] live streaming started, code: \").concat(a.code)), this.streamingTasks.set(e, {\n          clientRequest: n,\n          mode: t,\n          url: e,\n          taskId: s\n        }), o();\n      } catch (r) {\n        if (o(), this.isStartingStreamingTask = !1, !r.data || !r.data.retry || i) throw r;\n        return r.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e, t, r)) : await this.startLiveStreamingTask(e, t, r);\n      }\n    }\n    stopLiveStreamingTask(e) {\n      return new Cl((t, i) => {\n        const r = this.streamingTasks.get(e);\n        if (!r || !this.connection) return new vE(TE.UNEXPECTED_ERROR, \"can not find streaming task to stop\").throw();\n        const n = r.mode;\n        r.abortTask = () => {\n          NE.debug(\"[\".concat(this.spec.clientId, \"] stop live streaming success(worker exception)\")), this.streamingTasks.delete(e), t();\n        }, this.connection.request(\"request\", {\n          clientRequest: {\n            command: n === Ym.INJECT ? \"UninjectStream\" : \"UnpublishStream\",\n            url: r.url\n          }\n        }, !1, {\n          url: e,\n          command: \"UnPublishStream\",\n          workerType: n === Ym.TRANSCODE ? 1 : 2,\n          requestByUser: !0,\n          tid: (this.lastTaskId++).toString()\n        }).then(i => {\n          NE.debug(\"[\".concat(this.spec.clientId, \"] stop live streaming success, code: \").concat(i.code)), this.streamingTasks.delete(e), 0 === this.streamingTasks.size && n !== Ym.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t(), n === Ym.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(qm.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e);\n        }).catch(i);\n      });\n    }\n    async controlInjectStream(e, t, i, r) {\n      const n = this.streamingTasks.get(e);\n      if (!n || !this.connection || n.mode !== Ym.INJECT) throw new vE(TE.INVALID_OPERATION, \"can not find inject stream task to control\");\n      return (await this.connection.request(\"request\", {\n        clientRequest: {\n          command: \"ControlStream\",\n          url: e,\n          control: t,\n          audioVolume: i,\n          position: r\n        }\n      })).serverResponse;\n    }\n    resetAllTask() {\n      var e;\n      const t = Array.from(zv(e = this.streamingTasks).call(e));\n      this.terminate();\n      for (const e of t) this.startLiveStreamingTask(e.url, e.mode).catch(t => {\n        this.onLiveStreamError && this.onLiveStreamError(e.url, t);\n      });\n    }\n    terminate() {\n      this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = new Map(), this.isStartingStreamingTask = !1, this.statusError = new Map(), this.cancelToken = fE.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0;\n    }\n    async connect(e) {\n      if (this.connection) throw new vE(TE.UNEXPECTED_ERROR, \"live streaming connection has already connected\");\n      const t = await FR(this, eg.REQUEST_WORKER_MANAGER_LIST, e);\n      return this.uapResponse = t, this.connection = new qO(t.workerToken, this.spec, this.wsRetryConfig, e), this.connection.on($m.WARNING, (e, t) => this.onLiveStreamWarning && this.onLiveStreamWarning(t, e)), this.connection.on($m.PUBLISH_STREAM_STATUS, e => this.handlePublishStreamServer(e)), this.connection.on($m.INJECT_STREAM_STATUS, e => this.handleInjectStreamServerStatus(e)), this.connection.on($m.REQUEST_NEW_ADDRESS, (t, i) => {\n        if (!this.connection) return i(new vE(TE.UNEXPECTED_ERROR, \"can not get new live streaming address list\"));\n        FR(this, eg.REQUEST_WORKER_MANAGER_LIST, e).then(e => {\n          this.uapResponse = e, t(e.addressList);\n        }).catch(i);\n      }), await this.connection.init(t.addressList), this.connection;\n    }\n    handlePublishStreamServer(e) {\n      const t = e.serverStatus && e.serverStatus.url || \"empty_url\",\n        i = this.streamingTasks.get(t),\n        r = e.reason;\n      switch (e.code) {\n        case tg.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:\n        case tg.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:\n        case tg.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:\n        case tg.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:\n          {\n            const r = new vE(TE.LIVE_STREAMING_CDN_ERROR, \"\", {\n              code: e.code\n            });\n            if (i) return NE.error(r.toString()), this.onLiveStreamError && this.onLiveStreamError(t, r);\n            if (!this.isStartingStreamingTask) return;\n            this.statusError.set(t, r);\n          }\n        case tg.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:\n          {\n            const e = new vE(TE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, r);\n            return this.onLiveStreamWarning && this.onLiveStreamWarning(t, e);\n          }\n        case tg.LIVE_STREAM_RESPONSE_WORKER_LOST:\n        case tg.LIVE_STREAM_RESPONSE_WORKER_QUIT:\n          {\n            var n;\n            if (!this.connection) return;\n            this.connection.tryNextAddress();\n            const t = Array.from(zv(n = this.streamingTasks).call(n));\n            for (const i of t) i.abortTask ? i.abortTask() : (NE.warning(\"[\".concat(this.spec.clientId, \"] publish stream status code\"), e.code, \"try to republish\", i.url), this.startLiveStreamingTask(i.url, i.mode, new vE(TE.LIVE_STREAMING_INTERNAL_SERVER_ERROR, \"\", {\n              code: e.code\n            })).then(() => {\n              NE.debug(\"[\".concat(this.spec.clientId, \"] republish live stream success\"), i.url);\n            }).catch(e => {\n              NE.error(e.toString()), this.onLiveStreamError && this.onLiveStreamError(i.url, e);\n            }));\n            return;\n          }\n      }\n    }\n    handleInjectStreamServerStatus(e) {\n      const t = Number(e.uid),\n        i = e.serverStatus && e.serverStatus.url;\n      switch (e.code) {\n        case 200:\n          return void (this.onInjectStatusChange && this.onInjectStatusChange(qm.INJECT_STREAM_STATUS_START_SUCCESS, t, i));\n        case 451:\n          return this.onInjectStatusChange && this.onInjectStatusChange(qm.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t, i), void this.streamingTasks.delete(i);\n        case 453:\n          return this.onInjectStatusChange && this.onInjectStatusChange(qm.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t, i), void this.streamingTasks.delete(i);\n        case 470:\n          return this.onInjectStatusChange && this.onInjectStatusChange(qm.INJECT_STREAM_STATUS_BROKEN, t, i), void this.streamingTasks.delete(i);\n        case 499:\n          return this.onInjectStatusChange && this.onInjectStatusChange(qm.INJECT_STREAM_STATUS_START_TIMEOUT, t, i), void this.streamingTasks.delete(i);\n        default:\n          return void NE.debug(\"inject stream server status\", e);\n      }\n    }\n    hasUrl(e) {\n      return this.streamingTasks.has(e);\n    }\n  }\n  class QO {\n    constructor() {\n      mp(this, \"destChannelMediaInfos\", new Map()), mp(this, \"srcChannelMediaInfo\", void 0);\n    }\n    setSrcChannelInfo(e) {\n      mg(e), this.srcChannelMediaInfo = e;\n    }\n    addDestChannelInfo(e) {\n      mg(e), this.destChannelMediaInfos.set(e.channelName, e);\n    }\n    removeDestChannelInfo(e) {\n      $f(e), this.destChannelMediaInfos.delete(e);\n    }\n    getSrcChannelMediaInfo() {\n      return this.srcChannelMediaInfo;\n    }\n    getDestChannelMediaInfo() {\n      return this.destChannelMediaInfos;\n    }\n  }\n  function ZO(e) {\n    if (!(e instanceof QO)) {\n      return new vE(TE.INVALID_PARAMS, \"Config should be instance of [ChannelMediaRelayConfiguration]\").throw();\n    }\n    const t = e.getSrcChannelMediaInfo(),\n      i = e.getDestChannelMediaInfo();\n    if (!t) {\n      return new vE(TE.INVALID_PARAMS, \"srcChannelMediaInfo should not be empty\").throw();\n    }\n    if (0 === i.size) {\n      return new vE(TE.INVALID_PARAMS, \"destChannelMediaInfo should not be empty\").throw();\n    }\n  }\n  class $O extends gE {\n    constructor(e, t, i) {\n      super(), mp(this, \"ws\", void 0), mp(this, \"requestId\", 1), mp(this, \"heartBeatTimer\", void 0), mp(this, \"joinInfo\", void 0), mp(this, \"clientId\", void 0), mp(this, \"onOpen\", () => {\n        this.emit(\"open\"), this.startHeartBeatCheck();\n      }), mp(this, \"onClose\", e => {\n        this.emit(\"close\"), this.dispose();\n      }), mp(this, \"onMessage\", e => {\n        const t = JSON.parse(e.data);\n        if (!t || \"serverResponse\" !== t.command || !t.requestId) return t && \"serverStatus\" === t.command && t.serverStatus && t.serverStatus.command ? (this.emit(\"status\", t.serverStatus), void this.emit(t.serverStatus.command, t.serverStatus)) : void 0;\n        this.emit(\"req_\".concat(t.requestId), t);\n      }), this.joinInfo = e, this.clientId = t, this.ws = new $A(\"cross-channel-\".concat(this.clientId), i), this.ws.on(Km.RECONNECTING, () => {\n        this.ws.reconnectMode = \"retry\", this.emit(\"reconnecting\");\n      }), this.ws.on(Km.CONNECTED, this.onOpen), this.ws.on(Km.ON_MESSAGE, this.onMessage), this.ws.on(Km.CLOSED, this.onClose);\n    }\n    isConnect() {\n      return \"connected\" === this.ws.state;\n    }\n    sendMessage(e) {\n      const t = this.requestId++;\n      return e.requestId = t, e.seq = t, this.ws.sendMessage(e), t;\n    }\n    waitStatus(e) {\n      return new Cl((t, i) => {\n        const r = window.setTimeout(() => {\n          i(new vE(TE.TIMEOUT, \"wait status timeout, status: \".concat(e)));\n        }, 5e3);\n        this.once(e, n => {\n          window.clearTimeout(r), n.state && 0 !== n.state ? i(new vE(TE.CROSS_CHANNEL_WAIT_STATUS_ERROR, \"wait status error, status: \".concat(e))) : t(void 0);\n        }), this.once(\"dispose\", () => {\n          window.clearTimeout(r), i(new vE(TE.WS_ABORT));\n        });\n      });\n    }\n    async request(e) {\n      if (\"closed\" === this.ws.state) throw new vE(TE.WS_DISCONNECT);\n      const t = () => new Cl((e, t) => {\n        this.ws.once(Km.CLOSED, () => t(new vE(TE.WS_ABORT))), this.ws.once(Km.CONNECTED, e);\n      });\n      \"connected\" !== this.ws.state && (await t());\n      const i = this.sendMessage(e),\n        r = new Cl((e, t) => {\n          const r = () => {\n            t(new vE(TE.WS_ABORT));\n          };\n          this.ws.once(Km.RECONNECTING, r), this.ws.once(Km.CLOSED, r), this.once(\"req_\".concat(i), e), LR(3e3).then(() => {\n            this.removeAllListeners(\"req_\".concat(i)), this.ws.off(Km.RECONNECTING, r), this.ws.off(Km.CLOSED, r), t(new vE(TE.TIMEOUT, \"cross channel ws request timeout\"));\n          });\n        }),\n        n = await r;\n      if (!n || 200 !== n.code) throw new vE(TE.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, \"response: \".concat(JSON.stringify(n)));\n      return n;\n    }\n    async connect(e) {\n      this.ws.removeAllListeners(Km.REQUEST_NEW_URLS), this.ws.on(Km.REQUEST_NEW_URLS, t => {\n        t(e);\n      }), await this.ws.init(e);\n    }\n    dispose() {\n      this.clearHeartBeatCheck(), this.emit(\"dispose\"), this.removeAllListeners(), this.ws.close();\n    }\n    sendPing(e) {\n      const t = this.requestId++;\n      return e.requestId = t, this.ws.sendMessage(e), t;\n    }\n    startHeartBeatCheck() {\n      this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {\n        this.sendPing({\n          command: \"ping\",\n          appId: this.joinInfo.appId,\n          cname: this.joinInfo.cname,\n          uid: this.joinInfo.uid.toString(),\n          sid: this.joinInfo.sid,\n          ts: +new Date(),\n          requestId: 0\n        });\n      }, 3e3);\n    }\n    clearHeartBeatCheck() {\n      window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0;\n    }\n  }\n  class eb extends gE {\n    set state(e) {\n      e !== this._state && (e !== og.RELAY_STATE_FAILURE && (this.errorCode = sg.RELAY_OK), this.emit(\"state\", e, this.errorCode), this._state = e);\n    }\n    get state() {\n      return this._state;\n    }\n    constructor(e, t, i, r) {\n      super(), mp(this, \"joinInfo\", void 0), mp(this, \"sid\", void 0), mp(this, \"clientId\", void 0), mp(this, \"cancelToken\", fE.CancelToken.source()), mp(this, \"workerToken\", void 0), mp(this, \"requestId\", 0), mp(this, \"signal\", void 0), mp(this, \"prevChannelMediaConfig\", void 0), mp(this, \"httpRetryConfig\", void 0), mp(this, \"_state\", og.RELAY_STATE_IDLE), mp(this, \"errorCode\", sg.RELAY_OK), mp(this, \"onStatus\", e => {\n        NE.debug(\"[\".concat(this.clientId, \"] ChannelMediaStatus: \").concat(JSON.stringify(e))), e && e.command && (\"onAudioPacketReceived\" === e.command && this.emit(\"event\", ng.PACKET_RECEIVED_AUDIO_FROM_SRC), \"onVideoPacketReceived\" === e.command && this.emit(\"event\", ng.PACKET_RECEIVED_VIDEO_FROM_SRC), \"onSrcTokenPrivilegeDidExpire\" === e.command && (this.errorCode = sg.SRC_TOKEN_EXPIRED, this.state = og.RELAY_STATE_FAILURE), \"onDestTokenPrivilegeDidExpire\" === e.command && (this.errorCode = sg.DEST_TOKEN_EXPIRED, this.state = og.RELAY_STATE_FAILURE));\n      }), mp(this, \"onReconnect\", async () => {\n        NE.debug(\"[\".concat(this.clientId, \"] ChannelMediaSocket disconnect, reconnecting\")), this.emit(\"event\", ng.NETWORK_DISCONNECTED), this.state = og.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch(e => {\n          this.state !== og.RELAY_STATE_IDLE && (NE.error(\"auto restart channel media relay failed\", e.toString()), this.errorCode = sg.SERVER_CONNECTION_LOST, this.state = og.RELAY_STATE_FAILURE);\n        });\n      }), this.joinInfo = e, this.clientId = t, this.sid = UR(), this.signal = new $O(this.joinInfo, this.clientId, i), this.httpRetryConfig = r;\n    }\n    async startChannelMediaRelay(e) {\n      if (this.state !== og.RELAY_STATE_IDLE) throw new vE(TE.INVALID_OPERATION);\n      this.state = og.RELAY_STATE_CONNECTING, await this.connect(), NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: connect success\"));\n      try {\n        await this.sendStartRelayMessage(e);\n      } catch (e) {\n        if (e.data && e.data.serverResponse && \"SetSourceChannel\" === e.data.serverResponse.command) throw new vE(TE.CROSS_CHANNEL_FAILED_JOIN_SRC);\n        if (e.data && e.data.serverResponse && \"SetDestChannelStatus\" === e.serverResponse.command) throw new vE(TE.CROSS_CHANNEL_FAILED_JOIN_DEST);\n        if (e.data && e.data.serverResponse && \"StartPacketTransfer\" === e.serverResponse.command) throw new vE(TE.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);\n        throw e;\n      }\n      this.prevChannelMediaConfig = e;\n    }\n    async updateChannelMediaRelay(e) {\n      if (this.state !== og.RELAY_STATE_RUNNING) throw new vE(TE.INVALID_OPERATION);\n      await this.sendUpdateMessage(e), this.prevChannelMediaConfig = e;\n    }\n    async stopChannelMediaRelay() {\n      await this.sendStopRelayMessage(), NE.debug(\"[\".concat(this.clientId, \"] stopChannelMediaRelay: send stop message success\")), this.state = og.RELAY_STATE_IDLE, this.dispose();\n    }\n    dispose() {\n      NE.debug(\"[\".concat(this.clientId, \"] disposeChannelMediaRelay\")), this.cancelToken.cancel(), this.cancelToken = fE.CancelToken.source(), this.state = og.RELAY_STATE_IDLE, this.emit(\"dispose\"), this.signal.dispose(), this.prevChannelMediaConfig = void 0;\n    }\n    async connect() {\n      const e = await FO(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);\n      this.workerToken = e.workerToken, await this.signal.connect(e.addressList), this.emit(\"event\", ng.NETWORK_CONNECTED), this.signal.on(\"status\", this.onStatus), this.signal.on(\"reconnecting\", this.onReconnect);\n    }\n    async sendStartRelayMessage(e) {\n      const t = this.genMessage(rg.StopPacketTransfer);\n      await this.signal.request(t), await this.signal.waitStatus(\"Normal Quit\"), NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: StopPacketTransfer success\"));\n      const i = this.genMessage(rg.SetSdkProfile, e);\n      await this.signal.request(i), NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetSdkProfile success\"));\n      const r = this.genMessage(rg.SetSourceChannel, e);\n      await this.signal.request(r), await this.signal.waitStatus(\"SetSourceChannelStatus\"), this.emit(\"event\", ng.PACKET_JOINED_SRC_CHANNEL), NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetSourceChannel success\"));\n      const n = this.genMessage(rg.SetSourceUserId, e);\n      await this.signal.request(n), NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetSourceUserId success\"));\n      const o = this.genMessage(rg.SetDestChannel, e);\n      await this.signal.request(o), await this.signal.waitStatus(\"SetDestChannelStatus\"), this.emit(\"event\", ng.PACKET_JOINED_DEST_CHANNEL), NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: SetDestChannel success\"));\n      const s = this.genMessage(rg.StartPacketTransfer, e);\n      await this.signal.request(s), this.emit(\"event\", ng.PACKET_SENT_TO_DEST_CHANNEL), this.state = og.RELAY_STATE_RUNNING, NE.debug(\"[\".concat(this.clientId, \"] startChannelMediaRelay: StartPacketTransfer success\"));\n    }\n    async sendUpdateMessage(e) {\n      const t = this.genMessage(rg.UpdateDestChannel, e);\n      await this.signal.request(t), this.emit(\"event\", ng.PACKET_UPDATE_DEST_CHANNEL), NE.debug(\"[\".concat(this.clientId, \"] sendUpdateMessage: UpdateDestChannel success\"));\n    }\n    async sendStopRelayMessage() {\n      const e = this.genMessage(rg.StopPacketTransfer);\n      await this.signal.request(e), NE.debug(\"[\".concat(this.clientId, \"] sendStopRelayMessage: StopPacketTransfer success\"));\n    }\n    genMessage(e, t) {\n      const i = [],\n        r = [],\n        n = [];\n      this.requestId += 1;\n      const o = {\n        appId: this.joinInfo.appId,\n        cname: this.joinInfo.cname,\n        uid: this.joinInfo.uid.toString(),\n        sdkVersion: PE,\n        sid: this.sid,\n        ts: Date.now(),\n        requestId: this.requestId,\n        seq: this.requestId,\n        allocate: !0,\n        clientRequest: {}\n      };\n      \"4.16.1\" === o.sdkVersion && (o.sdkVersion = \"0.0.1\");\n      let s = null,\n        a = null;\n      switch (e) {\n        case rg.SetSdkProfile:\n          return o.clientRequest = {\n            command: \"SetSdkProfile\",\n            type: \"multi_channel\"\n          }, o;\n        case rg.SetSourceChannel:\n          if (a = t && t.getSrcChannelMediaInfo(), !a) throw new vE(TE.UNEXPECTED_ERROR, \"can not find source config\");\n          return o.clientRequest = {\n            command: \"SetSourceChannel\",\n            uid: \"0\",\n            channelName: a.channelName,\n            token: a.token || this.joinInfo.appId\n          }, o;\n        case rg.SetSourceUserId:\n          if (a = t && t.getSrcChannelMediaInfo(), !a) throw new vE(TE.UNEXPECTED_ERROR, \"can not find source config\");\n          return o.clientRequest = {\n            command: \"SetSourceUserId\",\n            uid: a.uid + \"\"\n          }, o;\n        case rg.SetDestChannel:\n          if (s = t && t.getDestChannelMediaInfo(), !s) throw new vE(TE.UNEXPECTED_ERROR, \"can not find dest config\");\n          return s.forEach(e => {\n            i.push(e.channelName), r.push(e.uid + \"\"), n.push(e.token || this.joinInfo.appId);\n          }), o.clientRequest = {\n            command: \"SetDestChannel\",\n            channelName: i,\n            uid: r,\n            token: n\n          }, o;\n        case rg.StartPacketTransfer:\n          return o.clientRequest = {\n            command: \"StartPacketTransfer\"\n          }, o;\n        case rg.Reconnect:\n          return o.clientRequest = {\n            command: \"Reconnect\"\n          }, o;\n        case rg.StopPacketTransfer:\n          return o.clientRequest = {\n            command: \"StopPacketTransfer\"\n          }, o;\n        case rg.UpdateDestChannel:\n          if (s = t && t.getDestChannelMediaInfo(), !s) throw new vE(TE.UNEXPECTED_ERROR, \"can not find dest config\");\n          return s.forEach(e => {\n            i.push(e.channelName), r.push(e.uid + \"\"), n.push(e.token || this.joinInfo.appId);\n          }), o.clientRequest = {\n            command: \"UpdateDestChannel\",\n            channelName: i,\n            uid: r,\n            token: n\n          }, o;\n      }\n      return o;\n    }\n  }\n  const tb = e => {\n      const t = document.createElement(\"canvas\");\n      return t.width = 2, t.height = 2, new Cl((i, r) => {\n        t.toBlob(async e => {\n          if (t.remove(), e) {\n            const r = await ib(e);\n            i({\n              buffer: r,\n              width: t.width,\n              height: t.height\n            });\n          } else r(new vE(TE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));\n        }, e, 1);\n      });\n    },\n    ib = async e => {\n      const t = await e.arrayBuffer();\n      return new Uint8Array(t);\n    };\n  function rb(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function nb(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? rb(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : rb(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class ob {\n    get videoElementStatus() {\n      return this._videoElementStatus;\n    }\n    set videoElementStatus(e) {\n      e !== this._videoElementStatus && (NE.debug(\"[\".concat(this.trackId, \"] video-element-status change \").concat(this._videoElementStatus, \" => \").concat(e)), this._videoElementStatus = e);\n    }\n    constructor(e) {\n      mp(this, \"trackId\", void 0), mp(this, \"config\", void 0), mp(this, \"onFirstVideoFrameDecoded\", void 0), mp(this, \"freezeTimeCounterList\", []), mp(this, \"renderFreezeAccTime\", 0), mp(this, \"timeUpdatedCount\", 0), mp(this, \"freezeTime\", 0), mp(this, \"playbackTime\", 0), mp(this, \"lastTimeUpdatedTime\", 0), mp(this, \"autoplayFailed\", !1), mp(this, \"videoTrack\", void 0), mp(this, \"container\", void 0), mp(this, \"videoElement\", void 0), mp(this, \"videoElementCheckInterval\", void 0), mp(this, \"_videoElementStatus\", am.NONE), mp(this, \"slot\", void 0), mp(this, \"isGettingVideoDimensions\", !1), mp(this, \"handleVideoEvents\", e => {\n        switch (e.type) {\n          case \"play\":\n          case \"playing\":\n            this.startGetVideoDimensions(), this.videoElementStatus = am.PLAYING;\n            break;\n          case \"loadeddata\":\n            this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded();\n            break;\n          case \"canplay\":\n            this.videoElementStatus = am.CANPLAY;\n            break;\n          case \"stalled\":\n            this.videoElementStatus = am.STALLED;\n            break;\n          case \"suspend\":\n            this.videoElementStatus = am.SUSPEND;\n            break;\n          case \"pause\":\n            this.videoElementStatus = am.PAUSED, Zh() || np() || zh() && this.autoplayFailed || !this.videoElement || !this.videoTrack || \"live\" !== this.videoTrack.readyState || (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume\")), this.videoElement.play());\n            break;\n          case \"waiting\":\n            this.videoElementStatus = am.WAITING;\n            break;\n          case \"abort\":\n            this.videoElementStatus = am.ABORT;\n            break;\n          case \"ended\":\n            this.videoElementStatus = am.ENDED;\n            break;\n          case \"emptied\":\n            this.videoElementStatus = am.EMPTIED;\n            break;\n          case \"error\":\n            {\n              var t;\n              this.videoElementStatus = am.ERROR;\n              const e = null === (t = this.videoElement) || void 0 === t ? void 0 : t.error;\n              e && NE.error(\"[\".concat(this.trackId, \"] media error, code: \").concat(e.code, \", message: \").concat(e.message));\n              break;\n            }\n          case \"timeupdate\":\n            {\n              const e = performance.now();\n              if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e);\n              const t = e - this.lastTimeUpdatedTime,\n                i = this.lastTimeUpdatedTime;\n              if (this.lastTimeUpdatedTime = e, mR.lastVisibleTime < mR.lastHiddenTime || i < mR.lastHiddenTime || i < mR.lastVisibleTime) return;\n              for (t > HE(\"VIDEO_FREEZE_DURATION\") && (this.freezeTime += t), this.playbackTime += t; this.playbackTime >= 6e3;) {\n                this.playbackTime -= 6e3;\n                const e = Math.min(6e3, this.freezeTime);\n                this.freezeTimeCounterList.push(e), this.freezeTime = Math.max(0, this.freezeTime - 6e3);\n              }\n              break;\n            }\n        }\n      }), mp(this, \"startGetVideoDimensions\", () => {\n        const e = () => {\n          if (this.isGettingVideoDimensions = !0, this.videoElement && this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return NE.debug(\"[\".concat(this.trackId, \"] current video dimensions:\"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = !1);\n          setTimeout(e, 500);\n        };\n        !this.isGettingVideoDimensions && e();\n      }), mp(this, \"autoResumeAfterInterruption\", () => {\n        this.videoElement && this.videoTrack && \"live\" === this.videoTrack.readyState && \"running\" === LT.curState && (rp() ? (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for iOS 15.2\")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : ip() ? (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for iOS 15.1\")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : tp() && (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for iOS 15.0\")), this.videoElement.pause(), this.videoElement.play()));\n      }), mp(this, \"autoResumeAfterInterruptionOnIOS15\", () => {\n        this.videoElement && this.videoTrack && \"live\" === this.videoTrack.readyState && (rp() ? (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for iOS 15.2\")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : ip() ? (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for iOS 15.1\")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : tp() && (NE.debug(\"[track-\".concat(this.trackId, \"] video element paused, auto resume for iOS 15.0\")), this.videoElement.pause(), this.videoElement.play()));\n      }), this.slot = e.element, this.trackId = e.trackId, this.updateConfig(e), LT.on(CT.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), LT.on(CT.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15);\n    }\n    updateConfig(e) {\n      this.config = e, this.trackId = e.trackId;\n      const t = e.element;\n      t !== this.slot && (this.destroy(), this.slot = t), this.createElements();\n    }\n    updateVideoTrack(e) {\n      this.videoTrack !== e && (this.videoTrack = e, this.createElements());\n    }\n    play(e) {\n      if (this.videoElement) {\n        const t = this.videoElement.play();\n        t && t.catch && t.catch(t => {\n          e && IT.autoplayFailed(e, \"video\", t.message, this.trackId), \"NotAllowedError\" === t.name ? (NE.warning(\"detected video element autoplay failed\", t), this.autoplayFailed = !0, this.handleAutoPlayFailed()) : NE.warning(\"[\".concat(this.trackId, \"] play warning: \"), t);\n        });\n        const i = Bh();\n        if ((\"Safari\" === i.name && 15 === Number(i.version) || ep()) && t && t.then && t.catch) {\n          const e = () => {\n            this.config.mirror && this.videoElement && (this.videoElement.style.transform = \"rotateY(180deg)\");\n          };\n          t.then(e).catch(e);\n        }\n      }\n    }\n    getCurrentFrame() {\n      if (!this.videoElement) return new ImageData(2, 2);\n      const e = document.createElement(\"canvas\");\n      e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight;\n      const t = e.getContext(\"2d\");\n      if (!t) return NE.error(\"create canvas context failed!\"), new ImageData(2, 2);\n      t.drawImage(this.videoElement, 0, 0, e.width, e.height);\n      const i = t.getImageData(0, 0, e.width, e.height);\n      return e.remove(), i;\n    }\n    async getCurrentFrameToUint8Array(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n      if (!this.videoElement) return await tb(e);\n      const i = document.createElement(\"canvas\");\n      i.width = this.videoElement.videoWidth, i.height = this.videoElement.videoHeight;\n      const r = i.getContext(\"2d\");\n      return r ? (r.drawImage(this.videoElement, 0, 0, i.width, i.height), new Cl((r, n) => {\n        i.toBlob(async e => {\n          if (i.remove(), e) {\n            const t = await ib(e);\n            r({\n              buffer: t,\n              width: i.width,\n              height: i.height\n            });\n          } else n(new vE(TE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));\n        }, e, t < 0 ? .1 : t > 1 ? 1 : t);\n      })) : await tb(e);\n    }\n    destroy() {\n      if (LT.off(CT.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), LT.off(CT.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), this.videoElement && (this.videoElement.srcObject = null, this.videoElement.remove(), this.videoElement = void 0), this.container) {\n        try {\n          this.container.remove(), this.slot.removeChild(this.container);\n        } catch (e) {}\n        this.container = void 0;\n      }\n      this.freezeTimeCounterList = [];\n    }\n    createElements() {\n      this.container || (this.container = document.createElement(\"div\")), this.container.id = \"agora-video-player-\".concat(this.trackId), this.container.style.width = \"100%\", this.container.style.height = \"100%\", this.container.style.position = \"relative\", this.container.style.overflow = \"hidden\", this.videoTrack ? (this.container.style.backgroundColor = \"black\", this.createVideoElement(), this.container.appendChild(this.videoElement)) : this.removeVideoElement(), this.slot.appendChild(this.container);\n    }\n    createVideoElement() {\n      if (!this.videoElement && (this.videoElementStatus = am.INIT, this.videoElement = document.createElement(\"video\"), this.container && this.container.appendChild(this.videoElement), sb.forEach(e => {\n        this.videoElement && this.videoElement.addEventListener(e, this.handleVideoEvents);\n      }), this.videoElementCheckInterval = window.setInterval(() => {\n        !document.getElementById(\"video_\".concat(this.trackId)) && this.videoElement && (this.videoElementStatus = am.DESTROYED);\n      }, 1e3), HE(\"ENABLE_VIDEO_FRAME_CALLBACK\"))) {\n        var e, t;\n        let i;\n        const r = (e, t) => {\n          if (this.videoElementStatus === am.PLAYING) {\n            if (i) {\n              const e = t.presentationTime - i.presentationTime;\n              e > HE(\"VIDEO_FREEZE_DURATION\") && mR.lastVisibleTime >= mR.lastHiddenTime && i.timestamp > mR.lastVisibleTime && i.timestamp > mR.lastHiddenTime && (this.renderFreezeAccTime += e);\n            }\n            i = nb(nb({}, t), {}, {\n              timestamp: e\n            });\n          }\n          var n, o;\n          HE(\"ENABLE_VIDEO_FRAME_CALLBACK\") && (null === (n = this.videoElement) || void 0 === n || null === (o = n.requestVideoFrameCallback) || void 0 === o || o.call(n, r));\n        };\n        null === (e = (t = this.videoElement).requestVideoFrameCallback) || void 0 === e || e.call(t, r);\n      }\n      this.videoElement.id = \"video_\".concat(this.trackId), this.videoElement.className = \"agora_video_player\", this.videoElement.style.width = \"100%\", this.videoElement.style.height = \"100%\", this.videoElement.style.position = \"absolute\", this.videoElement.controls = !1, this.videoElement.setAttribute(\"playsinline\", \"\"), this.videoElement.style.left = \"0\", this.videoElement.style.top = \"0\", cp() && (this.videoElement.poster = \"noposter\");\n      const i = Bh();\n      if (\"Safari\" === i.name && 15 === Number(i.version) || ep() || !this.config.mirror || (this.videoElement.style.transform = \"rotateY(180deg)\"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = \"cover\", this.videoElement.setAttribute(\"muted\", \"\"), this.videoElement.muted = !0, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream) {\n        this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Qh() && this.videoElement.load());\n      } else this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, Qh() && this.videoElement.load();\n      const r = this.videoElement.play();\n      void 0 !== r && r.catch(e => {\n        NE.debug(\"[\".concat(this.trackId, \"] playback interrupted\"), e.toString());\n      });\n    }\n    removeVideoElement() {\n      if (this.videoElement) {\n        sb.forEach(e => {\n          this.videoElement && this.videoElement.removeEventListener(e, this.handleVideoEvents);\n        }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0);\n        try {\n          this.container && this.container.removeChild(this.videoElement);\n        } catch (e) {}\n        this.videoElement = void 0, this.videoElementStatus = am.NONE;\n      }\n    }\n    handleAutoPlayFailed() {\n      if (this.videoElement) {\n        const e = t => {\n          t.preventDefault(), this.videoElement && (this.videoElement.play().then(() => {\n            NE.debug(\"[\".concat(this.trackId, \"] Video element for trackId:\").concat(this.trackId, \" autoplay resumed.\"));\n          }).catch(e => {\n            NE.error(e);\n          }), this.autoplayFailed = !1, dp() ? document.body.removeEventListener(\"click\", e, !0) : (document.body.removeEventListener(\"touchstart\", e, !0), document.body.removeEventListener(\"mousedown\", e, !0)));\n        };\n        dp() ? document.body.addEventListener(\"click\", e, !0) : (document.body.addEventListener(\"touchstart\", e, !0), document.body.addEventListener(\"mousedown\", e, !0)), fT();\n      }\n    }\n    getVideoElement() {\n      return this.videoElement;\n    }\n    getContainerElement() {\n      return this.container;\n    }\n  }\n  const sb = [\"play\", \"playing\", \"loadeddata\", \"canplay\", \"pause\", \"stalled\", \"suspend\", \"waiting\", \"abort\", \"emptied\", \"ended\", \"timeupdate\", \"error\"];\n  var ab = {\n    exports: {}\n  };\n  function cb(e, t, i) {\n    const r = e.createShader(i);\n    if (!r) {\n      return new vE(TE.WEBGL_INTERNAL_ERROR, \"can not create shader\").throw();\n    }\n    e.shaderSource(r, t), e.compileShader(r);\n    if (!e.getShaderParameter(r, e.COMPILE_STATUS)) {\n      const t = e.getShaderInfoLog(r);\n      e.deleteShader(r);\n      return new vE(TE.WEBGL_INTERNAL_ERROR, \"error compiling shader:\" + t).throw();\n    }\n    return r;\n  }\n  function db(e, t, i, r) {\n    const n = [];\n    for (let i = 0; i < t.length; ++i) {\n      const r = 0 === i ? e.VERTEX_SHADER : e.FRAGMENT_SHADER;\n      n.push(cb(e, t[i], r));\n    }\n    return function (e, t, i, r) {\n      const n = e.createProgram();\n      if (!n) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"can not create webgl program\");\n      if (t.forEach(t => {\n        e.attachShader(n, t);\n      }), i && i.forEach((t, i) => {\n        e.bindAttribLocation(n, r ? r[i] : i, t);\n      }), e.linkProgram(n), !e.getProgramParameter(n, e.LINK_STATUS)) {\n        const t = e.getProgramInfoLog(n);\n        throw e.deleteProgram(n), new vE(TE.WEBGL_INTERNAL_ERROR, \"error in program linking:\" + t);\n      }\n      return n;\n    }(e, n, i, r);\n  }\n  !function (e, t) {\n    var i;\n    self, i = () => (() => {\n      var e = {\n          3536: (e, t, i) => {\n            var r = i(1910);\n            e.exports = r;\n          },\n          8171: (e, t, i) => {\n            i(6450);\n            var r = i(4058).Object,\n              n = e.exports = function (e, t, i) {\n                return r.defineProperty(e, t, i);\n              };\n            r.defineProperty.sham && (n.sham = !0);\n          },\n          2956: (e, t, i) => {\n            i(7627), i(6274), i(5967), i(8881), i(4560), i(7206), i(4349), i(7971);\n            var r = i(4058);\n            e.exports = r.Promise;\n          },\n          3685: (e, t, i) => {\n            e.exports = i(621);\n          },\n          621: (e, t, i) => {\n            var r = i(3536);\n            e.exports = r;\n          },\n          4883: (e, t, i) => {\n            var r = i(7475),\n              n = i(9826),\n              o = TypeError;\n            e.exports = function (e) {\n              if (r(e)) return e;\n              throw o(n(e) + \" is not a function\");\n            };\n          },\n          174: (e, t, i) => {\n            var r = i(4284),\n              n = i(9826),\n              o = TypeError;\n            e.exports = function (e) {\n              if (r(e)) return e;\n              throw o(n(e) + \" is not a constructor\");\n            };\n          },\n          1851: (e, t, i) => {\n            var r = i(7475),\n              n = String,\n              o = TypeError;\n            e.exports = function (e) {\n              if (\"object\" == typeof e || r(e)) return e;\n              throw o(\"Can't set \" + n(e) + \" as a prototype\");\n            };\n          },\n          8479: e => {\n            e.exports = function () {};\n          },\n          5743: (e, t, i) => {\n            var r = i(7046),\n              n = TypeError;\n            e.exports = function (e, t) {\n              if (r(t, e)) return e;\n              throw n(\"Incorrect invocation\");\n            };\n          },\n          6059: (e, t, i) => {\n            var r = i(941),\n              n = String,\n              o = TypeError;\n            e.exports = function (e) {\n              if (r(e)) return e;\n              throw o(n(e) + \" is not an object\");\n            };\n          },\n          1692: (e, t, i) => {\n            var r = i(4529),\n              n = i(9413),\n              o = i(623),\n              s = function (e) {\n                return function (t, i, s) {\n                  var a,\n                    c = r(t),\n                    d = o(c),\n                    u = n(s, d);\n                  if (e && i != i) {\n                    for (; d > u;) if ((a = c[u++]) != a) return !0;\n                  } else for (; d > u; u++) if ((e || u in c) && c[u] === i) return e || u || 0;\n                  return !e && -1;\n                };\n              };\n            e.exports = {\n              includes: s(!0),\n              indexOf: s(!1)\n            };\n          },\n          3765: (e, t, i) => {\n            var r = i(5329);\n            e.exports = r([].slice);\n          },\n          1385: (e, t, i) => {\n            var r = i(9813)(\"iterator\"),\n              n = !1;\n            try {\n              var o = 0,\n                s = {\n                  next: function () {\n                    return {\n                      done: !!o++\n                    };\n                  },\n                  return: function () {\n                    n = !0;\n                  }\n                };\n              s[r] = function () {\n                return this;\n              }, Array.from(s, function () {\n                throw 2;\n              });\n            } catch (e) {}\n            e.exports = function (e, t) {\n              if (!t && !n) return !1;\n              var i = !1;\n              try {\n                var o = {};\n                o[r] = function () {\n                  return {\n                    next: function () {\n                      return {\n                        done: i = !0\n                      };\n                    }\n                  };\n                }, e(o);\n              } catch (e) {}\n              return i;\n            };\n          },\n          2532: (e, t, i) => {\n            var r = i(4163),\n              n = r({}.toString),\n              o = r(\"\".slice);\n            e.exports = function (e) {\n              return o(n(e), 8, -1);\n            };\n          },\n          9697: (e, t, i) => {\n            var r = i(2885),\n              n = i(7475),\n              o = i(2532),\n              s = i(9813)(\"toStringTag\"),\n              a = Object,\n              c = \"Arguments\" == o(function () {\n                return arguments;\n              }());\n            e.exports = r ? o : function (e) {\n              var t, i, r;\n              return void 0 === e ? \"Undefined\" : null === e ? \"Null\" : \"string\" == typeof (i = function (e, t) {\n                try {\n                  return e[t];\n                } catch (e) {}\n              }(t = a(e), s)) ? i : c ? o(t) : \"Object\" == (r = o(t)) && n(t.callee) ? \"Arguments\" : r;\n            };\n          },\n          3489: (e, t, i) => {\n            var r = i(953),\n              n = i(1136),\n              o = i(9677),\n              s = i(5988);\n            e.exports = function (e, t, i) {\n              for (var a = n(t), c = s.f, d = o.f, u = 0; u < a.length; u++) {\n                var l = a[u];\n                r(e, l) || i && r(i, l) || c(e, l, d(t, l));\n              }\n            };\n          },\n          4160: (e, t, i) => {\n            var r = i(5981);\n            e.exports = !r(function () {\n              function e() {}\n              return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;\n            });\n          },\n          3538: e => {\n            e.exports = function (e, t) {\n              return {\n                value: e,\n                done: t\n              };\n            };\n          },\n          2029: (e, t, i) => {\n            var r = i(5746),\n              n = i(5988),\n              o = i(1887);\n            e.exports = r ? function (e, t, i) {\n              return n.f(e, t, o(1, i));\n            } : function (e, t, i) {\n              return e[t] = i, e;\n            };\n          },\n          1887: e => {\n            e.exports = function (e, t) {\n              return {\n                enumerable: !(1 & e),\n                configurable: !(2 & e),\n                writable: !(4 & e),\n                value: t\n              };\n            };\n          },\n          5929: (e, t, i) => {\n            var r = i(2029);\n            e.exports = function (e, t, i, n) {\n              return n && n.enumerable ? e[t] = i : r(e, t, i), e;\n            };\n          },\n          5609: (e, t, i) => {\n            var r = i(1899),\n              n = Object.defineProperty;\n            e.exports = function (e, t) {\n              try {\n                n(r, e, {\n                  value: t,\n                  configurable: !0,\n                  writable: !0\n                });\n              } catch (i) {\n                r[e] = t;\n              }\n              return t;\n            };\n          },\n          5746: (e, t, i) => {\n            var r = i(5981);\n            e.exports = !r(function () {\n              return 7 != Object.defineProperty({}, 1, {\n                get: function () {\n                  return 7;\n                }\n              })[1];\n            });\n          },\n          6616: e => {\n            var t = \"object\" == typeof document && document.all,\n              i = void 0 === t && void 0 !== t;\n            e.exports = {\n              all: t,\n              IS_HTMLDDA: i\n            };\n          },\n          1333: (e, t, i) => {\n            var r = i(1899),\n              n = i(941),\n              o = r.document,\n              s = n(o) && n(o.createElement);\n            e.exports = function (e) {\n              return s ? o.createElement(e) : {};\n            };\n          },\n          3281: e => {\n            e.exports = {\n              CSSRuleList: 0,\n              CSSStyleDeclaration: 0,\n              CSSValueList: 0,\n              ClientRectList: 0,\n              DOMRectList: 0,\n              DOMStringList: 0,\n              DOMTokenList: 1,\n              DataTransferItemList: 0,\n              FileList: 0,\n              HTMLAllCollection: 0,\n              HTMLCollection: 0,\n              HTMLFormElement: 0,\n              HTMLSelectElement: 0,\n              MediaList: 0,\n              MimeTypeArray: 0,\n              NamedNodeMap: 0,\n              NodeList: 1,\n              PaintRequestList: 0,\n              Plugin: 0,\n              PluginArray: 0,\n              SVGLengthList: 0,\n              SVGNumberList: 0,\n              SVGPathSegList: 0,\n              SVGPointList: 0,\n              SVGStringList: 0,\n              SVGTransformList: 0,\n              SourceBufferList: 0,\n              StyleSheetList: 0,\n              TextTrackCueList: 0,\n              TextTrackList: 0,\n              TouchList: 0\n            };\n          },\n          3321: (e, t, i) => {\n            var r = i(8501),\n              n = i(6049);\n            e.exports = !r && !n && \"object\" == typeof window && \"object\" == typeof document;\n          },\n          8501: e => {\n            e.exports = \"object\" == typeof Deno && Deno && \"object\" == typeof Deno.version;\n          },\n          4470: (e, t, i) => {\n            var r = i(2861),\n              n = i(1899);\n            e.exports = /ipad|iphone|ipod/i.test(r) && void 0 !== n.Pebble;\n          },\n          2749: (e, t, i) => {\n            var r = i(2861);\n            e.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(r);\n          },\n          6049: (e, t, i) => {\n            var r = i(2532),\n              n = i(1899);\n            e.exports = \"process\" == r(n.process);\n          },\n          8045: (e, t, i) => {\n            var r = i(2861);\n            e.exports = /web0s(?!.*chrome)/i.test(r);\n          },\n          2861: (e, t, i) => {\n            var r = i(626);\n            e.exports = r(\"navigator\", \"userAgent\") || \"\";\n          },\n          3385: (e, t, i) => {\n            var r,\n              n,\n              o = i(1899),\n              s = i(2861),\n              a = o.process,\n              c = o.Deno,\n              d = a && a.versions || c && c.version,\n              u = d && d.v8;\n            u && (n = (r = u.split(\".\"))[0] > 0 && r[0] < 4 ? 1 : +(r[0] + r[1])), !n && s && (!(r = s.match(/Edge\\/(\\d+)/)) || r[1] >= 74) && (r = s.match(/Chrome\\/(\\d+)/)) && (n = +r[1]), e.exports = n;\n          },\n          6759: e => {\n            e.exports = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\n          },\n          3995: (e, t, i) => {\n            var r = i(5329),\n              n = Error,\n              o = r(\"\".replace),\n              s = String(n(\"zxcasd\").stack),\n              a = /\\n\\s*at [^:]*:[^\\n]*/,\n              c = a.test(s);\n            e.exports = function (e, t) {\n              if (c && \"string\" == typeof e && !n.prepareStackTrace) for (; t--;) e = o(e, a, \"\");\n              return e;\n            };\n          },\n          8780: (e, t, i) => {\n            var r = i(5981),\n              n = i(1887);\n            e.exports = !r(function () {\n              var e = Error(\"a\");\n              return !(\"stack\" in e) || (Object.defineProperty(e, \"stack\", n(1, 7)), 7 !== e.stack);\n            });\n          },\n          6887: (e, t, i) => {\n            var r = i(1899),\n              n = i(9730),\n              o = i(5329),\n              s = i(7475),\n              a = i(9677).f,\n              c = i(7252),\n              d = i(4058),\n              u = i(6843),\n              l = i(2029),\n              h = i(953),\n              p = function (e) {\n                var t = function (i, r, o) {\n                  if (this instanceof t) {\n                    switch (arguments.length) {\n                      case 0:\n                        return new e();\n                      case 1:\n                        return new e(i);\n                      case 2:\n                        return new e(i, r);\n                    }\n                    return new e(i, r, o);\n                  }\n                  return n(e, this, arguments);\n                };\n                return t.prototype = e.prototype, t;\n              };\n            e.exports = function (e, t) {\n              var i,\n                n,\n                _,\n                E,\n                f,\n                m,\n                g,\n                S,\n                T = e.target,\n                v = e.global,\n                R = e.stat,\n                I = e.proto,\n                y = v ? r : R ? r[T] : (r[T] || {}).prototype,\n                C = v ? d : d[T] || l(d, T, {})[T],\n                A = C.prototype;\n              for (_ in t) i = !c(v ? _ : T + (R ? \".\" : \"#\") + _, e.forced) && y && h(y, _), f = C[_], i && (m = e.dontCallGetSet ? (S = a(y, _)) && S.value : y[_]), E = i && m ? m : t[_], i && typeof f == typeof E || (g = e.bind && i ? u(E, r) : e.wrap && i ? p(E) : I && s(E) ? o(E) : E, (e.sham || E && E.sham || f && f.sham) && l(g, \"sham\", !0), l(C, _, g), I && (h(d, n = T + \"Prototype\") || l(d, n, {}), l(d[n], _, E), e.real && A && !A[_] && l(A, _, E)));\n            };\n          },\n          5981: e => {\n            e.exports = function (e) {\n              try {\n                return !!e();\n              } catch (e) {\n                return !0;\n              }\n            };\n          },\n          9730: (e, t, i) => {\n            var r = i(8285),\n              n = Function.prototype,\n              o = n.apply,\n              s = n.call;\n            e.exports = \"object\" == typeof Reflect && Reflect.apply || (r ? s.bind(o) : function () {\n              return s.apply(o, arguments);\n            });\n          },\n          6843: (e, t, i) => {\n            var r = i(5329),\n              n = i(4883),\n              o = i(8285),\n              s = r(r.bind);\n            e.exports = function (e, t) {\n              return n(e), void 0 === t ? e : o ? s(e, t) : function () {\n                return e.apply(t, arguments);\n              };\n            };\n          },\n          8285: (e, t, i) => {\n            var r = i(5981);\n            e.exports = !r(function () {\n              var e = function () {}.bind();\n              return \"function\" != typeof e || e.hasOwnProperty(\"prototype\");\n            });\n          },\n          8834: (e, t, i) => {\n            var r = i(8285),\n              n = Function.prototype.call;\n            e.exports = r ? n.bind(n) : function () {\n              return n.apply(n, arguments);\n            };\n          },\n          9417: (e, t, i) => {\n            var r = i(5746),\n              n = i(953),\n              o = Function.prototype,\n              s = r && Object.getOwnPropertyDescriptor,\n              a = n(o, \"name\"),\n              c = a && \"something\" === function () {}.name,\n              d = a && (!r || r && s(o, \"name\").configurable);\n            e.exports = {\n              EXISTS: a,\n              PROPER: c,\n              CONFIGURABLE: d\n            };\n          },\n          4163: (e, t, i) => {\n            var r = i(8285),\n              n = Function.prototype,\n              o = n.call,\n              s = r && n.bind.bind(o, o);\n            e.exports = r ? s : function (e) {\n              return function () {\n                return o.apply(e, arguments);\n              };\n            };\n          },\n          5329: (e, t, i) => {\n            var r = i(2532),\n              n = i(4163);\n            e.exports = function (e) {\n              if (\"Function\" === r(e)) return n(e);\n            };\n          },\n          626: (e, t, i) => {\n            var r = i(4058),\n              n = i(1899),\n              o = i(7475),\n              s = function (e) {\n                return o(e) ? e : void 0;\n              };\n            e.exports = function (e, t) {\n              return arguments.length < 2 ? s(r[e]) || s(n[e]) : r[e] && r[e][t] || n[e] && n[e][t];\n            };\n          },\n          2902: (e, t, i) => {\n            var r = i(9697),\n              n = i(4229),\n              o = i(2119),\n              s = i(2077),\n              a = i(9813)(\"iterator\");\n            e.exports = function (e) {\n              if (!o(e)) return n(e, a) || n(e, \"@@iterator\") || s[r(e)];\n            };\n          },\n          3476: (e, t, i) => {\n            var r = i(8834),\n              n = i(4883),\n              o = i(6059),\n              s = i(9826),\n              a = i(2902),\n              c = TypeError;\n            e.exports = function (e, t) {\n              var i = arguments.length < 2 ? a(e) : t;\n              if (n(i)) return o(r(i, e));\n              throw c(s(e) + \" is not iterable\");\n            };\n          },\n          4229: (e, t, i) => {\n            var r = i(4883),\n              n = i(2119);\n            e.exports = function (e, t) {\n              var i = e[t];\n              return n(i) ? void 0 : r(i);\n            };\n          },\n          1899: (e, t, i) => {\n            var r = function (e) {\n              return e && e.Math == Math && e;\n            };\n            e.exports = r(\"object\" == typeof globalThis && globalThis) || r(\"object\" == typeof window && window) || r(\"object\" == typeof self && self) || r(\"object\" == typeof i.g && i.g) || function () {\n              return this;\n            }() || Function(\"return this\")();\n          },\n          953: (e, t, i) => {\n            var r = i(5329),\n              n = i(9678),\n              o = r({}.hasOwnProperty);\n            e.exports = Object.hasOwn || function (e, t) {\n              return o(n(e), t);\n            };\n          },\n          7748: e => {\n            e.exports = {};\n          },\n          4845: (e, t, i) => {\n            var r = i(1899);\n            e.exports = function (e, t) {\n              var i = r.console;\n              i && i.error && (1 == arguments.length ? i.error(e) : i.error(e, t));\n            };\n          },\n          5463: (e, t, i) => {\n            var r = i(626);\n            e.exports = r(\"document\", \"documentElement\");\n          },\n          2840: (e, t, i) => {\n            var r = i(5746),\n              n = i(5981),\n              o = i(1333);\n            e.exports = !r && !n(function () {\n              return 7 != Object.defineProperty(o(\"div\"), \"a\", {\n                get: function () {\n                  return 7;\n                }\n              }).a;\n            });\n          },\n          7026: (e, t, i) => {\n            var r = i(5329),\n              n = i(5981),\n              o = i(2532),\n              s = Object,\n              a = r(\"\".split);\n            e.exports = n(function () {\n              return !s(\"z\").propertyIsEnumerable(0);\n            }) ? function (e) {\n              return \"String\" == o(e) ? a(e, \"\") : s(e);\n            } : s;\n          },\n          1302: (e, t, i) => {\n            var r = i(5329),\n              n = i(7475),\n              o = i(3030),\n              s = r(Function.toString);\n            n(o.inspectSource) || (o.inspectSource = function (e) {\n              return s(e);\n            }), e.exports = o.inspectSource;\n          },\n          3794: (e, t, i) => {\n            var r = i(941),\n              n = i(2029);\n            e.exports = function (e, t) {\n              r(t) && \"cause\" in t && n(e, \"cause\", t.cause);\n            };\n          },\n          5402: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s = i(7093),\n              a = i(1899),\n              c = i(941),\n              d = i(2029),\n              u = i(953),\n              l = i(3030),\n              h = i(4262),\n              p = i(7748),\n              _ = \"Object already initialized\",\n              E = a.TypeError,\n              f = a.WeakMap;\n            if (s || l.state) {\n              var m = l.state || (l.state = new f());\n              m.get = m.get, m.has = m.has, m.set = m.set, r = function (e, t) {\n                if (m.has(e)) throw E(_);\n                return t.facade = e, m.set(e, t), t;\n              }, n = function (e) {\n                return m.get(e) || {};\n              }, o = function (e) {\n                return m.has(e);\n              };\n            } else {\n              var g = h(\"state\");\n              p[g] = !0, r = function (e, t) {\n                if (u(e, g)) throw E(_);\n                return t.facade = e, d(e, g, t), t;\n              }, n = function (e) {\n                return u(e, g) ? e[g] : {};\n              }, o = function (e) {\n                return u(e, g);\n              };\n            }\n            e.exports = {\n              set: r,\n              get: n,\n              has: o,\n              enforce: function (e) {\n                return o(e) ? n(e) : r(e, {});\n              },\n              getterFor: function (e) {\n                return function (t) {\n                  var i;\n                  if (!c(t) || (i = n(t)).type !== e) throw E(\"Incompatible receiver, \" + e + \" required\");\n                  return i;\n                };\n              }\n            };\n          },\n          6782: (e, t, i) => {\n            var r = i(9813),\n              n = i(2077),\n              o = r(\"iterator\"),\n              s = Array.prototype;\n            e.exports = function (e) {\n              return void 0 !== e && (n.Array === e || s[o] === e);\n            };\n          },\n          7475: (e, t, i) => {\n            var r = i(6616),\n              n = r.all;\n            e.exports = r.IS_HTMLDDA ? function (e) {\n              return \"function\" == typeof e || e === n;\n            } : function (e) {\n              return \"function\" == typeof e;\n            };\n          },\n          4284: (e, t, i) => {\n            var r = i(5329),\n              n = i(5981),\n              o = i(7475),\n              s = i(9697),\n              a = i(626),\n              c = i(1302),\n              d = function () {},\n              u = [],\n              l = a(\"Reflect\", \"construct\"),\n              h = /^\\s*(?:class|function)\\b/,\n              p = r(h.exec),\n              _ = !h.exec(d),\n              E = function (e) {\n                if (!o(e)) return !1;\n                try {\n                  return l(d, u, e), !0;\n                } catch (e) {\n                  return !1;\n                }\n              },\n              f = function (e) {\n                if (!o(e)) return !1;\n                switch (s(e)) {\n                  case \"AsyncFunction\":\n                  case \"GeneratorFunction\":\n                  case \"AsyncGeneratorFunction\":\n                    return !1;\n                }\n                try {\n                  return _ || !!p(h, c(e));\n                } catch (e) {\n                  return !0;\n                }\n              };\n            f.sham = !0, e.exports = !l || n(function () {\n              var e;\n              return E(E.call) || !E(Object) || !E(function () {\n                e = !0;\n              }) || e;\n            }) ? f : E;\n          },\n          7252: (e, t, i) => {\n            var r = i(5981),\n              n = i(7475),\n              o = /#|\\.prototype\\./,\n              s = function (e, t) {\n                var i = c[a(e)];\n                return i == u || i != d && (n(t) ? r(t) : !!t);\n              },\n              a = s.normalize = function (e) {\n                return String(e).replace(o, \".\").toLowerCase();\n              },\n              c = s.data = {},\n              d = s.NATIVE = \"N\",\n              u = s.POLYFILL = \"P\";\n            e.exports = s;\n          },\n          2119: e => {\n            e.exports = function (e) {\n              return null == e;\n            };\n          },\n          941: (e, t, i) => {\n            var r = i(7475),\n              n = i(6616),\n              o = n.all;\n            e.exports = n.IS_HTMLDDA ? function (e) {\n              return \"object\" == typeof e ? null !== e : r(e) || e === o;\n            } : function (e) {\n              return \"object\" == typeof e ? null !== e : r(e);\n            };\n          },\n          2529: e => {\n            e.exports = !0;\n          },\n          6664: (e, t, i) => {\n            var r = i(626),\n              n = i(7475),\n              o = i(7046),\n              s = i(2302),\n              a = Object;\n            e.exports = s ? function (e) {\n              return \"symbol\" == typeof e;\n            } : function (e) {\n              var t = r(\"Symbol\");\n              return n(t) && o(t.prototype, a(e));\n            };\n          },\n          3091: (e, t, i) => {\n            var r = i(6843),\n              n = i(8834),\n              o = i(6059),\n              s = i(9826),\n              a = i(6782),\n              c = i(623),\n              d = i(7046),\n              u = i(3476),\n              l = i(2902),\n              h = i(7609),\n              p = TypeError,\n              _ = function (e, t) {\n                this.stopped = e, this.result = t;\n              },\n              E = _.prototype;\n            e.exports = function (e, t, i) {\n              var f,\n                m,\n                g,\n                S,\n                T,\n                v,\n                R,\n                I = i && i.that,\n                y = !(!i || !i.AS_ENTRIES),\n                C = !(!i || !i.IS_RECORD),\n                A = !(!i || !i.IS_ITERATOR),\n                O = !(!i || !i.INTERRUPTED),\n                b = r(t, I),\n                w = function (e) {\n                  return f && h(f, \"normal\", e), new _(!0, e);\n                },\n                N = function (e) {\n                  return y ? (o(e), O ? b(e[0], e[1], w) : b(e[0], e[1])) : O ? b(e, w) : b(e);\n                };\n              if (C) f = e.iterator;else if (A) f = e;else {\n                if (!(m = l(e))) throw p(s(e) + \" is not iterable\");\n                if (a(m)) {\n                  for (g = 0, S = c(e); S > g; g++) if ((T = N(e[g])) && d(E, T)) return T;\n                  return new _(!1);\n                }\n                f = u(e, m);\n              }\n              for (v = C ? e.next : f.next; !(R = n(v, f)).done;) {\n                try {\n                  T = N(R.value);\n                } catch (e) {\n                  h(f, \"throw\", e);\n                }\n                if (\"object\" == typeof T && T && d(E, T)) return T;\n              }\n              return new _(!1);\n            };\n          },\n          7609: (e, t, i) => {\n            var r = i(8834),\n              n = i(6059),\n              o = i(4229);\n            e.exports = function (e, t, i) {\n              var s, a;\n              n(e);\n              try {\n                if (!(s = o(e, \"return\"))) {\n                  if (\"throw\" === t) throw i;\n                  return i;\n                }\n                s = r(s, e);\n              } catch (e) {\n                a = !0, s = e;\n              }\n              if (\"throw\" === t) throw i;\n              if (a) throw s;\n              return n(s), i;\n            };\n          },\n          3847: (e, t, i) => {\n            var r = i(5143).IteratorPrototype,\n              n = i(9290),\n              o = i(1887),\n              s = i(904),\n              a = i(2077),\n              c = function () {\n                return this;\n              };\n            e.exports = function (e, t, i, d) {\n              var u = t + \" Iterator\";\n              return e.prototype = n(r, {\n                next: o(+!d, i)\n              }), s(e, u, !1, !0), a[u] = c, e;\n            };\n          },\n          5105: (e, t, i) => {\n            var r = i(6887),\n              n = i(8834),\n              o = i(2529),\n              s = i(9417),\n              a = i(7475),\n              c = i(3847),\n              d = i(249),\n              u = i(8929),\n              l = i(904),\n              h = i(2029),\n              p = i(5929),\n              _ = i(9813),\n              E = i(2077),\n              f = i(5143),\n              m = s.PROPER,\n              g = s.CONFIGURABLE,\n              S = f.IteratorPrototype,\n              T = f.BUGGY_SAFARI_ITERATORS,\n              v = _(\"iterator\"),\n              R = \"keys\",\n              I = \"values\",\n              y = \"entries\",\n              C = function () {\n                return this;\n              };\n            e.exports = function (e, t, i, s, _, f, A) {\n              c(i, t, s);\n              var O,\n                b,\n                w,\n                N = function (e) {\n                  if (e === _ && M) return M;\n                  if (!T && e in L) return L[e];\n                  switch (e) {\n                    case R:\n                    case I:\n                    case y:\n                      return function () {\n                        return new i(this, e);\n                      };\n                  }\n                  return function () {\n                    return new i(this);\n                  };\n                },\n                D = t + \" Iterator\",\n                P = !1,\n                L = e.prototype,\n                k = L[v] || L[\"@@iterator\"] || _ && L[_],\n                M = !T && k || N(_),\n                U = \"Array\" == t && L.entries || k;\n              if (U && (O = d(U.call(new e()))) !== Object.prototype && O.next && (o || d(O) === S || (u ? u(O, S) : a(O[v]) || p(O, v, C)), l(O, D, !0, !0), o && (E[D] = C)), m && _ == I && k && k.name !== I && (!o && g ? h(L, \"name\", I) : (P = !0, M = function () {\n                return n(k, this);\n              })), _) if (b = {\n                values: N(I),\n                keys: f ? M : N(R),\n                entries: N(y)\n              }, A) for (w in b) (T || P || !(w in L)) && p(L, w, b[w]);else r({\n                target: t,\n                proto: !0,\n                forced: T || P\n              }, b);\n              return o && !A || L[v] === M || p(L, v, M, {\n                name: _\n              }), E[t] = M, b;\n            };\n          },\n          5143: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s = i(5981),\n              a = i(7475),\n              c = i(941),\n              d = i(9290),\n              u = i(249),\n              l = i(5929),\n              h = i(9813),\n              p = i(2529),\n              _ = h(\"iterator\"),\n              E = !1;\n            [].keys && (\"next\" in (o = [].keys()) ? (n = u(u(o))) !== Object.prototype && (r = n) : E = !0), !c(r) || s(function () {\n              var e = {};\n              return r[_].call(e) !== e;\n            }) ? r = {} : p && (r = d(r)), a(r[_]) || l(r, _, function () {\n              return this;\n            }), e.exports = {\n              IteratorPrototype: r,\n              BUGGY_SAFARI_ITERATORS: E\n            };\n          },\n          2077: e => {\n            e.exports = {};\n          },\n          623: (e, t, i) => {\n            var r = i(3057);\n            e.exports = function (e) {\n              return r(e.length);\n            };\n          },\n          5331: e => {\n            var t = Math.ceil,\n              i = Math.floor;\n            e.exports = Math.trunc || function (e) {\n              var r = +e;\n              return (r > 0 ? i : t)(r);\n            };\n          },\n          6132: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s,\n              a,\n              c,\n              d,\n              u,\n              l = i(1899),\n              h = i(6843),\n              p = i(9677).f,\n              _ = i(2941).set,\n              E = i(2749),\n              f = i(4470),\n              m = i(8045),\n              g = i(6049),\n              S = l.MutationObserver || l.WebKitMutationObserver,\n              T = l.document,\n              v = l.process,\n              R = l.Promise,\n              I = p(l, \"queueMicrotask\"),\n              y = I && I.value;\n            y || (r = function () {\n              var e, t;\n              for (g && (e = v.domain) && e.exit(); n;) {\n                t = n.fn, n = n.next;\n                try {\n                  t();\n                } catch (e) {\n                  throw n ? s() : o = void 0, e;\n                }\n              }\n              o = void 0, e && e.enter();\n            }, E || g || m || !S || !T ? !f && R && R.resolve ? ((d = R.resolve(void 0)).constructor = R, u = h(d.then, d), s = function () {\n              u(r);\n            }) : g ? s = function () {\n              v.nextTick(r);\n            } : (_ = h(_, l), s = function () {\n              _(r);\n            }) : (a = !0, c = T.createTextNode(\"\"), new S(r).observe(c, {\n              characterData: !0\n            }), s = function () {\n              c.data = a = !a;\n            })), e.exports = y || function (e) {\n              var t = {\n                fn: e,\n                next: void 0\n              };\n              o && (o.next = t), n || (n = t, s()), o = t;\n            };\n          },\n          9520: (e, t, i) => {\n            var r = i(4883),\n              n = TypeError,\n              o = function (e) {\n                var t, i;\n                this.promise = new e(function (e, r) {\n                  if (void 0 !== t || void 0 !== i) throw n(\"Bad Promise constructor\");\n                  t = e, i = r;\n                }), this.resolve = r(t), this.reject = r(i);\n              };\n            e.exports.f = function (e) {\n              return new o(e);\n            };\n          },\n          4649: (e, t, i) => {\n            var r = i(5803);\n            e.exports = function (e, t) {\n              return void 0 === e ? arguments.length < 2 ? \"\" : t : r(e);\n            };\n          },\n          9290: (e, t, i) => {\n            var r,\n              n = i(6059),\n              o = i(9938),\n              s = i(6759),\n              a = i(7748),\n              c = i(5463),\n              d = i(1333),\n              u = i(4262)(\"IE_PROTO\"),\n              l = function () {},\n              h = function (e) {\n                return \"<script>\" + e + \"<\\/script>\";\n              },\n              p = function (e) {\n                e.write(h(\"\")), e.close();\n                var t = e.parentWindow.Object;\n                return e = null, t;\n              },\n              _ = function () {\n                try {\n                  r = new ActiveXObject(\"htmlfile\");\n                } catch (e) {}\n                var e, t;\n                _ = \"undefined\" != typeof document ? document.domain && r ? p(r) : ((t = d(\"iframe\")).style.display = \"none\", c.appendChild(t), t.src = String(\"javascript:\"), (e = t.contentWindow.document).open(), e.write(h(\"document.F=Object\")), e.close(), e.F) : p(r);\n                for (var i = s.length; i--;) delete _.prototype[s[i]];\n                return _();\n              };\n            a[u] = !0, e.exports = Object.create || function (e, t) {\n              var i;\n              return null !== e ? (l.prototype = n(e), i = new l(), l.prototype = null, i[u] = e) : i = _(), void 0 === t ? i : o.f(i, t);\n            };\n          },\n          9938: (e, t, i) => {\n            var r = i(5746),\n              n = i(3937),\n              o = i(5988),\n              s = i(6059),\n              a = i(4529),\n              c = i(4771);\n            t.f = r && !n ? Object.defineProperties : function (e, t) {\n              s(e);\n              for (var i, r = a(t), n = c(t), d = n.length, u = 0; d > u;) o.f(e, i = n[u++], r[i]);\n              return e;\n            };\n          },\n          5988: (e, t, i) => {\n            var r = i(5746),\n              n = i(2840),\n              o = i(3937),\n              s = i(6059),\n              a = i(3894),\n              c = TypeError,\n              d = Object.defineProperty,\n              u = Object.getOwnPropertyDescriptor;\n            t.f = r ? o ? function (e, t, i) {\n              if (s(e), t = a(t), s(i), \"function\" == typeof e && \"prototype\" === t && \"value\" in i && \"writable\" in i && !i.writable) {\n                var r = u(e, t);\n                r && r.writable && (e[t] = i.value, i = {\n                  configurable: \"configurable\" in i ? i.configurable : r.configurable,\n                  enumerable: \"enumerable\" in i ? i.enumerable : r.enumerable,\n                  writable: !1\n                });\n              }\n              return d(e, t, i);\n            } : d : function (e, t, i) {\n              if (s(e), t = a(t), s(i), n) try {\n                return d(e, t, i);\n              } catch (e) {}\n              if (\"get\" in i || \"set\" in i) throw c(\"Accessors not supported\");\n              return \"value\" in i && (e[t] = i.value), e;\n            };\n          },\n          9677: (e, t, i) => {\n            var r = i(5746),\n              n = i(8834),\n              o = i(6760),\n              s = i(1887),\n              a = i(4529),\n              c = i(3894),\n              d = i(953),\n              u = i(2840),\n              l = Object.getOwnPropertyDescriptor;\n            t.f = r ? l : function (e, t) {\n              if (e = a(e), t = c(t), u) try {\n                return l(e, t);\n              } catch (e) {}\n              if (d(e, t)) return s(!n(o.f, e, t), e[t]);\n            };\n          },\n          946: (e, t, i) => {\n            var r = i(5629),\n              n = i(6759).concat(\"length\", \"prototype\");\n            t.f = Object.getOwnPropertyNames || function (e) {\n              return r(e, n);\n            };\n          },\n          7857: (e, t) => {\n            t.f = Object.getOwnPropertySymbols;\n          },\n          249: (e, t, i) => {\n            var r = i(953),\n              n = i(7475),\n              o = i(9678),\n              s = i(4262),\n              a = i(4160),\n              c = s(\"IE_PROTO\"),\n              d = Object,\n              u = d.prototype;\n            e.exports = a ? d.getPrototypeOf : function (e) {\n              var t = o(e);\n              if (r(t, c)) return t[c];\n              var i = t.constructor;\n              return n(i) && t instanceof i ? i.prototype : t instanceof d ? u : null;\n            };\n          },\n          7046: (e, t, i) => {\n            var r = i(5329);\n            e.exports = r({}.isPrototypeOf);\n          },\n          5629: (e, t, i) => {\n            var r = i(5329),\n              n = i(953),\n              o = i(4529),\n              s = i(1692).indexOf,\n              a = i(7748),\n              c = r([].push);\n            e.exports = function (e, t) {\n              var i,\n                r = o(e),\n                d = 0,\n                u = [];\n              for (i in r) !n(a, i) && n(r, i) && c(u, i);\n              for (; t.length > d;) n(r, i = t[d++]) && (~s(u, i) || c(u, i));\n              return u;\n            };\n          },\n          4771: (e, t, i) => {\n            var r = i(5629),\n              n = i(6759);\n            e.exports = Object.keys || function (e) {\n              return r(e, n);\n            };\n          },\n          6760: (e, t) => {\n            var i = {}.propertyIsEnumerable,\n              r = Object.getOwnPropertyDescriptor,\n              n = r && !i.call({\n                1: 2\n              }, 1);\n            t.f = n ? function (e) {\n              var t = r(this, e);\n              return !!t && t.enumerable;\n            } : i;\n          },\n          8929: (e, t, i) => {\n            var r = i(5329),\n              n = i(6059),\n              o = i(1851);\n            e.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n              var e,\n                t = !1,\n                i = {};\n              try {\n                (e = r(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set))(i, []), t = i instanceof Array;\n              } catch (e) {}\n              return function (i, r) {\n                return n(i), o(r), t ? e(i, r) : i.__proto__ = r, i;\n              };\n            }() : void 0);\n          },\n          5623: (e, t, i) => {\n            var r = i(2885),\n              n = i(9697);\n            e.exports = r ? {}.toString : function () {\n              return \"[object \" + n(this) + \"]\";\n            };\n          },\n          9811: (e, t, i) => {\n            var r = i(8834),\n              n = i(7475),\n              o = i(941),\n              s = TypeError;\n            e.exports = function (e, t) {\n              var i, a;\n              if (\"string\" === t && n(i = e.toString) && !o(a = r(i, e))) return a;\n              if (n(i = e.valueOf) && !o(a = r(i, e))) return a;\n              if (\"string\" !== t && n(i = e.toString) && !o(a = r(i, e))) return a;\n              throw s(\"Can't convert object to primitive value\");\n            };\n          },\n          1136: (e, t, i) => {\n            var r = i(626),\n              n = i(5329),\n              o = i(946),\n              s = i(7857),\n              a = i(6059),\n              c = n([].concat);\n            e.exports = r(\"Reflect\", \"ownKeys\") || function (e) {\n              var t = o.f(a(e)),\n                i = s.f;\n              return i ? c(t, i(e)) : t;\n            };\n          },\n          4058: e => {\n            e.exports = {};\n          },\n          2: e => {\n            e.exports = function (e) {\n              try {\n                return {\n                  error: !1,\n                  value: e()\n                };\n              } catch (e) {\n                return {\n                  error: !0,\n                  value: e\n                };\n              }\n            };\n          },\n          7742: (e, t, i) => {\n            var r = i(1899),\n              n = i(6991),\n              o = i(7475),\n              s = i(7252),\n              a = i(1302),\n              c = i(9813),\n              d = i(3321),\n              u = i(8501),\n              l = i(2529),\n              h = i(3385),\n              p = n && n.prototype,\n              _ = c(\"species\"),\n              E = !1,\n              f = o(r.PromiseRejectionEvent),\n              m = s(\"Promise\", function () {\n                var e = a(n),\n                  t = e !== String(n);\n                if (!t && 66 === h) return !0;\n                if (l && (!p.catch || !p.finally)) return !0;\n                if (!h || h < 51 || !/native code/.test(e)) {\n                  var i = new n(function (e) {\n                      e(1);\n                    }),\n                    r = function (e) {\n                      e(function () {}, function () {});\n                    };\n                  if ((i.constructor = {})[_] = r, !(E = i.then(function () {}) instanceof r)) return !0;\n                }\n                return !t && (d || u) && !f;\n              });\n            e.exports = {\n              CONSTRUCTOR: m,\n              REJECTION_EVENT: f,\n              SUBCLASSING: E\n            };\n          },\n          6991: (e, t, i) => {\n            var r = i(1899);\n            e.exports = r.Promise;\n          },\n          6584: (e, t, i) => {\n            var r = i(6059),\n              n = i(941),\n              o = i(9520);\n            e.exports = function (e, t) {\n              if (r(e), n(t) && t.constructor === e) return t;\n              var i = o.f(e);\n              return (0, i.resolve)(t), i.promise;\n            };\n          },\n          1542: (e, t, i) => {\n            var r = i(6991),\n              n = i(1385),\n              o = i(7742).CONSTRUCTOR;\n            e.exports = o || !n(function (e) {\n              r.all(e).then(void 0, function () {});\n            });\n          },\n          8397: e => {\n            var t = function () {\n              this.head = null, this.tail = null;\n            };\n            t.prototype = {\n              add: function (e) {\n                var t = {\n                  item: e,\n                  next: null\n                };\n                this.head ? this.tail.next = t : this.head = t, this.tail = t;\n              },\n              get: function () {\n                var e = this.head;\n                if (e) return this.head = e.next, this.tail === e && (this.tail = null), e.item;\n              }\n            }, e.exports = t;\n          },\n          8219: (e, t, i) => {\n            var r = i(2119),\n              n = TypeError;\n            e.exports = function (e) {\n              if (r(e)) throw n(\"Can't call method on \" + e);\n              return e;\n            };\n          },\n          4431: (e, t, i) => {\n            var r = i(626),\n              n = i(5988),\n              o = i(9813),\n              s = i(5746),\n              a = o(\"species\");\n            e.exports = function (e) {\n              var t = r(e),\n                i = n.f;\n              s && t && !t[a] && i(t, a, {\n                configurable: !0,\n                get: function () {\n                  return this;\n                }\n              });\n            };\n          },\n          904: (e, t, i) => {\n            var r = i(2885),\n              n = i(5988).f,\n              o = i(2029),\n              s = i(953),\n              a = i(5623),\n              c = i(9813)(\"toStringTag\");\n            e.exports = function (e, t, i, d) {\n              if (e) {\n                var u = i ? e : e.prototype;\n                s(u, c) || n(u, c, {\n                  configurable: !0,\n                  value: t\n                }), d && !r && o(u, \"toString\", a);\n              }\n            };\n          },\n          4262: (e, t, i) => {\n            var r = i(8726),\n              n = i(9418),\n              o = r(\"keys\");\n            e.exports = function (e) {\n              return o[e] || (o[e] = n(e));\n            };\n          },\n          3030: (e, t, i) => {\n            var r = i(1899),\n              n = i(5609),\n              o = \"__core-js_shared__\",\n              s = r[o] || n(o, {});\n            e.exports = s;\n          },\n          8726: (e, t, i) => {\n            var r = i(2529),\n              n = i(3030);\n            (e.exports = function (e, t) {\n              return n[e] || (n[e] = void 0 !== t ? t : {});\n            })(\"versions\", []).push({\n              version: \"3.26.0\",\n              mode: r ? \"pure\" : \"global\",\n              copyright: \"Â© 2014-2022 Denis Pushkarev (zloirock.ru)\",\n              license: \"https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE\",\n              source: \"https://github.com/zloirock/core-js\"\n            });\n          },\n          487: (e, t, i) => {\n            var r = i(6059),\n              n = i(174),\n              o = i(2119),\n              s = i(9813)(\"species\");\n            e.exports = function (e, t) {\n              var i,\n                a = r(e).constructor;\n              return void 0 === a || o(i = r(a)[s]) ? t : n(i);\n            };\n          },\n          4620: (e, t, i) => {\n            var r = i(5329),\n              n = i(2435),\n              o = i(5803),\n              s = i(8219),\n              a = r(\"\".charAt),\n              c = r(\"\".charCodeAt),\n              d = r(\"\".slice),\n              u = function (e) {\n                return function (t, i) {\n                  var r,\n                    u,\n                    l = o(s(t)),\n                    h = n(i),\n                    p = l.length;\n                  return h < 0 || h >= p ? e ? \"\" : void 0 : (r = c(l, h)) < 55296 || r > 56319 || h + 1 === p || (u = c(l, h + 1)) < 56320 || u > 57343 ? e ? a(l, h) : r : e ? d(l, h, h + 2) : u - 56320 + (r - 55296 << 10) + 65536;\n                };\n              };\n            e.exports = {\n              codeAt: u(!1),\n              charAt: u(!0)\n            };\n          },\n          3405: (e, t, i) => {\n            var r = i(3385),\n              n = i(5981);\n            e.exports = !!Object.getOwnPropertySymbols && !n(function () {\n              var e = Symbol();\n              return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && r && r < 41;\n            });\n          },\n          2941: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s,\n              a = i(1899),\n              c = i(9730),\n              d = i(6843),\n              u = i(7475),\n              l = i(953),\n              h = i(5981),\n              p = i(5463),\n              _ = i(3765),\n              E = i(1333),\n              f = i(8348),\n              m = i(2749),\n              g = i(6049),\n              S = a.setImmediate,\n              T = a.clearImmediate,\n              v = a.process,\n              R = a.Dispatch,\n              I = a.Function,\n              y = a.MessageChannel,\n              C = a.String,\n              A = 0,\n              O = {};\n            try {\n              r = a.location;\n            } catch (e) {}\n            var b = function (e) {\n                if (l(O, e)) {\n                  var t = O[e];\n                  delete O[e], t();\n                }\n              },\n              w = function (e) {\n                return function () {\n                  b(e);\n                };\n              },\n              N = function (e) {\n                b(e.data);\n              },\n              D = function (e) {\n                a.postMessage(C(e), r.protocol + \"//\" + r.host);\n              };\n            S && T || (S = function (e) {\n              f(arguments.length, 1);\n              var t = u(e) ? e : I(e),\n                i = _(arguments, 1);\n              return O[++A] = function () {\n                c(t, void 0, i);\n              }, n(A), A;\n            }, T = function (e) {\n              delete O[e];\n            }, g ? n = function (e) {\n              v.nextTick(w(e));\n            } : R && R.now ? n = function (e) {\n              R.now(w(e));\n            } : y && !m ? (s = (o = new y()).port2, o.port1.onmessage = N, n = d(s.postMessage, s)) : a.addEventListener && u(a.postMessage) && !a.importScripts && r && \"file:\" !== r.protocol && !h(D) ? (n = D, a.addEventListener(\"message\", N, !1)) : n = \"onreadystatechange\" in E(\"script\") ? function (e) {\n              p.appendChild(E(\"script\")).onreadystatechange = function () {\n                p.removeChild(this), b(e);\n              };\n            } : function (e) {\n              setTimeout(w(e), 0);\n            }), e.exports = {\n              set: S,\n              clear: T\n            };\n          },\n          9413: (e, t, i) => {\n            var r = i(2435),\n              n = Math.max,\n              o = Math.min;\n            e.exports = function (e, t) {\n              var i = r(e);\n              return i < 0 ? n(i + t, 0) : o(i, t);\n            };\n          },\n          4529: (e, t, i) => {\n            var r = i(7026),\n              n = i(8219);\n            e.exports = function (e) {\n              return r(n(e));\n            };\n          },\n          2435: (e, t, i) => {\n            var r = i(5331);\n            e.exports = function (e) {\n              var t = +e;\n              return t != t || 0 === t ? 0 : r(t);\n            };\n          },\n          3057: (e, t, i) => {\n            var r = i(2435),\n              n = Math.min;\n            e.exports = function (e) {\n              return e > 0 ? n(r(e), 9007199254740991) : 0;\n            };\n          },\n          9678: (e, t, i) => {\n            var r = i(8219),\n              n = Object;\n            e.exports = function (e) {\n              return n(r(e));\n            };\n          },\n          6935: (e, t, i) => {\n            var r = i(8834),\n              n = i(941),\n              o = i(6664),\n              s = i(4229),\n              a = i(9811),\n              c = i(9813),\n              d = TypeError,\n              u = c(\"toPrimitive\");\n            e.exports = function (e, t) {\n              if (!n(e) || o(e)) return e;\n              var i,\n                c = s(e, u);\n              if (c) {\n                if (void 0 === t && (t = \"default\"), i = r(c, e, t), !n(i) || o(i)) return i;\n                throw d(\"Can't convert object to primitive value\");\n              }\n              return void 0 === t && (t = \"number\"), a(e, t);\n            };\n          },\n          3894: (e, t, i) => {\n            var r = i(6935),\n              n = i(6664);\n            e.exports = function (e) {\n              var t = r(e, \"string\");\n              return n(t) ? t : t + \"\";\n            };\n          },\n          2885: (e, t, i) => {\n            var r = {};\n            r[i(9813)(\"toStringTag\")] = \"z\", e.exports = \"[object z]\" === String(r);\n          },\n          5803: (e, t, i) => {\n            var r = i(9697),\n              n = String;\n            e.exports = function (e) {\n              if (\"Symbol\" === r(e)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n              return n(e);\n            };\n          },\n          9826: e => {\n            var t = String;\n            e.exports = function (e) {\n              try {\n                return t(e);\n              } catch (e) {\n                return \"Object\";\n              }\n            };\n          },\n          9418: (e, t, i) => {\n            var r = i(5329),\n              n = 0,\n              o = Math.random(),\n              s = r(1..toString);\n            e.exports = function (e) {\n              return \"Symbol(\" + (void 0 === e ? \"\" : e) + \")_\" + s(++n + o, 36);\n            };\n          },\n          2302: (e, t, i) => {\n            var r = i(3405);\n            e.exports = r && !Symbol.sham && \"symbol\" == typeof Symbol.iterator;\n          },\n          3937: (e, t, i) => {\n            var r = i(5746),\n              n = i(5981);\n            e.exports = r && n(function () {\n              return 42 != Object.defineProperty(function () {}, \"prototype\", {\n                value: 42,\n                writable: !1\n              }).prototype;\n            });\n          },\n          8348: e => {\n            var t = TypeError;\n            e.exports = function (e, i) {\n              if (e < i) throw t(\"Not enough arguments\");\n              return e;\n            };\n          },\n          7093: (e, t, i) => {\n            var r = i(1899),\n              n = i(7475),\n              o = r.WeakMap;\n            e.exports = n(o) && /native code/.test(String(o));\n          },\n          9813: (e, t, i) => {\n            var r = i(1899),\n              n = i(8726),\n              o = i(953),\n              s = i(9418),\n              a = i(3405),\n              c = i(2302),\n              d = n(\"wks\"),\n              u = r.Symbol,\n              l = u && u.for,\n              h = c ? u : u && u.withoutSetter || s;\n            e.exports = function (e) {\n              if (!o(d, e) || !a && \"string\" != typeof d[e]) {\n                var t = \"Symbol.\" + e;\n                a && o(u, e) ? d[e] = u[e] : d[e] = c && l ? l(t) : h(t);\n              }\n              return d[e];\n            };\n          },\n          9812: (e, t, i) => {\n            var r = i(6887),\n              n = i(7046),\n              o = i(249),\n              s = i(8929),\n              a = i(3489),\n              c = i(9290),\n              d = i(2029),\n              u = i(1887),\n              l = i(3995),\n              h = i(3794),\n              p = i(3091),\n              _ = i(4649),\n              E = i(9813),\n              f = i(8780),\n              m = E(\"toStringTag\"),\n              g = Error,\n              S = [].push,\n              T = function (e, t) {\n                var i,\n                  r = arguments.length > 2 ? arguments[2] : void 0,\n                  a = n(v, this);\n                s ? i = s(g(), a ? o(this) : v) : (i = a ? this : c(v), d(i, m, \"Error\")), void 0 !== t && d(i, \"message\", _(t)), f && d(i, \"stack\", l(i.stack, 1)), h(i, r);\n                var u = [];\n                return p(e, S, {\n                  that: u\n                }), d(i, \"errors\", u), i;\n              };\n            s ? s(T, g) : a(T, g, {\n              name: !0\n            });\n            var v = T.prototype = c(g.prototype, {\n              constructor: u(1, T),\n              message: u(1, \"\"),\n              name: u(1, \"AggregateError\")\n            });\n            r({\n              global: !0,\n              constructor: !0,\n              arity: 2\n            }, {\n              AggregateError: T\n            });\n          },\n          7627: (e, t, i) => {\n            i(9812);\n          },\n          6274: (e, t, i) => {\n            var r = i(4529),\n              n = i(8479),\n              o = i(2077),\n              s = i(5402),\n              a = i(5988).f,\n              c = i(5105),\n              d = i(3538),\n              u = i(2529),\n              l = i(5746),\n              h = \"Array Iterator\",\n              p = s.set,\n              _ = s.getterFor(h);\n            e.exports = c(Array, \"Array\", function (e, t) {\n              p(this, {\n                type: h,\n                target: r(e),\n                index: 0,\n                kind: t\n              });\n            }, function () {\n              var e = _(this),\n                t = e.target,\n                i = e.kind,\n                r = e.index++;\n              return !t || r >= t.length ? (e.target = void 0, d(void 0, !0)) : d(\"keys\" == i ? r : \"values\" == i ? t[r] : [r, t[r]], !1);\n            }, \"values\");\n            var E = o.Arguments = o.Array;\n            if (n(\"keys\"), n(\"values\"), n(\"entries\"), !u && l && \"values\" !== E.name) try {\n              a(E, \"name\", {\n                value: \"values\"\n              });\n            } catch (e) {}\n          },\n          6450: (e, t, i) => {\n            var r = i(6887),\n              n = i(5746),\n              o = i(5988).f;\n            r({\n              target: \"Object\",\n              stat: !0,\n              forced: Object.defineProperty !== o,\n              sham: !n\n            }, {\n              defineProperty: o\n            });\n          },\n          5967: () => {},\n          4560: (e, t, i) => {\n            var r = i(6887),\n              n = i(8834),\n              o = i(4883),\n              s = i(9520),\n              a = i(2),\n              c = i(3091);\n            r({\n              target: \"Promise\",\n              stat: !0\n            }, {\n              allSettled: function (e) {\n                var t = this,\n                  i = s.f(t),\n                  r = i.resolve,\n                  d = i.reject,\n                  u = a(function () {\n                    var i = o(t.resolve),\n                      s = [],\n                      a = 0,\n                      d = 1;\n                    c(e, function (e) {\n                      var o = a++,\n                        c = !1;\n                      d++, n(i, t, e).then(function (e) {\n                        c || (c = !0, s[o] = {\n                          status: \"fulfilled\",\n                          value: e\n                        }, --d || r(s));\n                      }, function (e) {\n                        c || (c = !0, s[o] = {\n                          status: \"rejected\",\n                          reason: e\n                        }, --d || r(s));\n                      });\n                    }), --d || r(s);\n                  });\n                return u.error && d(u.value), i.promise;\n              }\n            });\n          },\n          6890: (e, t, i) => {\n            var r = i(6887),\n              n = i(8834),\n              o = i(4883),\n              s = i(9520),\n              a = i(2),\n              c = i(3091);\n            r({\n              target: \"Promise\",\n              stat: !0,\n              forced: i(1542)\n            }, {\n              all: function (e) {\n                var t = this,\n                  i = s.f(t),\n                  r = i.resolve,\n                  d = i.reject,\n                  u = a(function () {\n                    var i = o(t.resolve),\n                      s = [],\n                      a = 0,\n                      u = 1;\n                    c(e, function (e) {\n                      var o = a++,\n                        c = !1;\n                      u++, n(i, t, e).then(function (e) {\n                        c || (c = !0, s[o] = e, --u || r(s));\n                      }, d);\n                    }), --u || r(s);\n                  });\n                return u.error && d(u.value), i.promise;\n              }\n            });\n          },\n          7206: (e, t, i) => {\n            var r = i(6887),\n              n = i(8834),\n              o = i(4883),\n              s = i(626),\n              a = i(9520),\n              c = i(2),\n              d = i(3091),\n              u = \"No one promise resolved\";\n            r({\n              target: \"Promise\",\n              stat: !0\n            }, {\n              any: function (e) {\n                var t = this,\n                  i = s(\"AggregateError\"),\n                  r = a.f(t),\n                  l = r.resolve,\n                  h = r.reject,\n                  p = c(function () {\n                    var r = o(t.resolve),\n                      s = [],\n                      a = 0,\n                      c = 1,\n                      p = !1;\n                    d(e, function (e) {\n                      var o = a++,\n                        d = !1;\n                      c++, n(r, t, e).then(function (e) {\n                        d || p || (p = !0, l(e));\n                      }, function (e) {\n                        d || p || (d = !0, s[o] = e, --c || h(new i(s, u)));\n                      });\n                    }), --c || h(new i(s, u));\n                  });\n                return p.error && h(p.value), r.promise;\n              }\n            });\n          },\n          3376: (e, t, i) => {\n            var r = i(6887),\n              n = i(2529),\n              o = i(7742).CONSTRUCTOR,\n              s = i(6991),\n              a = i(626),\n              c = i(7475),\n              d = i(5929),\n              u = s && s.prototype;\n            if (r({\n              target: \"Promise\",\n              proto: !0,\n              forced: o,\n              real: !0\n            }, {\n              catch: function (e) {\n                return this.then(void 0, e);\n              }\n            }), !n && c(s)) {\n              var l = a(\"Promise\").prototype.catch;\n              u.catch !== l && d(u, \"catch\", l, {\n                unsafe: !0\n              });\n            }\n          },\n          6934: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s = i(6887),\n              a = i(2529),\n              c = i(6049),\n              d = i(1899),\n              u = i(8834),\n              l = i(5929),\n              h = i(8929),\n              p = i(904),\n              _ = i(4431),\n              E = i(4883),\n              f = i(7475),\n              m = i(941),\n              g = i(5743),\n              S = i(487),\n              T = i(2941).set,\n              v = i(6132),\n              R = i(4845),\n              I = i(2),\n              y = i(8397),\n              C = i(5402),\n              A = i(6991),\n              O = i(7742),\n              b = i(9520),\n              w = \"Promise\",\n              N = O.CONSTRUCTOR,\n              D = O.REJECTION_EVENT,\n              P = O.SUBCLASSING,\n              L = C.getterFor(w),\n              k = C.set,\n              M = A && A.prototype,\n              U = A,\n              x = M,\n              V = d.TypeError,\n              j = d.document,\n              F = d.process,\n              B = b.f,\n              G = B,\n              W = !!(j && j.createEvent && d.dispatchEvent),\n              H = \"unhandledrejection\",\n              K = function (e) {\n                var t;\n                return !(!m(e) || !f(t = e.then)) && t;\n              },\n              Y = function (e, t) {\n                var i,\n                  r,\n                  n,\n                  o = t.value,\n                  s = 1 == t.state,\n                  a = s ? e.ok : e.fail,\n                  c = e.resolve,\n                  d = e.reject,\n                  l = e.domain;\n                try {\n                  a ? (s || (2 === t.rejection && Q(t), t.rejection = 1), !0 === a ? i = o : (l && l.enter(), i = a(o), l && (l.exit(), n = !0)), i === e.promise ? d(V(\"Promise-chain cycle\")) : (r = K(i)) ? u(r, i, c, d) : c(i)) : d(o);\n                } catch (e) {\n                  l && !n && l.exit(), d(e);\n                }\n              },\n              q = function (e, t) {\n                e.notified || (e.notified = !0, v(function () {\n                  for (var i, r = e.reactions; i = r.get();) Y(i, e);\n                  e.notified = !1, t && !e.rejection && X(e);\n                }));\n              },\n              J = function (e, t, i) {\n                var r, n;\n                W ? ((r = j.createEvent(\"Event\")).promise = t, r.reason = i, r.initEvent(e, !1, !0), d.dispatchEvent(r)) : r = {\n                  promise: t,\n                  reason: i\n                }, !D && (n = d[\"on\" + e]) ? n(r) : e === H && R(\"Unhandled promise rejection\", i);\n              },\n              X = function (e) {\n                u(T, d, function () {\n                  var t,\n                    i = e.facade,\n                    r = e.value;\n                  if (z(e) && (t = I(function () {\n                    c ? F.emit(\"unhandledRejection\", r, i) : J(H, i, r);\n                  }), e.rejection = c || z(e) ? 2 : 1, t.error)) throw t.value;\n                });\n              },\n              z = function (e) {\n                return 1 !== e.rejection && !e.parent;\n              },\n              Q = function (e) {\n                u(T, d, function () {\n                  var t = e.facade;\n                  c ? F.emit(\"rejectionHandled\", t) : J(\"rejectionhandled\", t, e.value);\n                });\n              },\n              Z = function (e, t, i) {\n                return function (r) {\n                  e(t, r, i);\n                };\n              },\n              $ = function (e, t, i) {\n                e.done || (e.done = !0, i && (e = i), e.value = t, e.state = 2, q(e, !0));\n              },\n              ee = function (e, t, i) {\n                if (!e.done) {\n                  e.done = !0, i && (e = i);\n                  try {\n                    if (e.facade === t) throw V(\"Promise can't be resolved itself\");\n                    var r = K(t);\n                    r ? v(function () {\n                      var i = {\n                        done: !1\n                      };\n                      try {\n                        u(r, t, Z(ee, i, e), Z($, i, e));\n                      } catch (t) {\n                        $(i, t, e);\n                      }\n                    }) : (e.value = t, e.state = 1, q(e, !1));\n                  } catch (t) {\n                    $({\n                      done: !1\n                    }, t, e);\n                  }\n                }\n              };\n            if (N && (x = (U = function (e) {\n              g(this, x), E(e), u(r, this);\n              var t = L(this);\n              try {\n                e(Z(ee, t), Z($, t));\n              } catch (e) {\n                $(t, e);\n              }\n            }).prototype, (r = function (e) {\n              k(this, {\n                type: w,\n                done: !1,\n                notified: !1,\n                parent: !1,\n                reactions: new y(),\n                rejection: !1,\n                state: 0,\n                value: void 0\n              });\n            }).prototype = l(x, \"then\", function (e, t) {\n              var i = L(this),\n                r = B(S(this, U));\n              return i.parent = !0, r.ok = !f(e) || e, r.fail = f(t) && t, r.domain = c ? F.domain : void 0, 0 == i.state ? i.reactions.add(r) : v(function () {\n                Y(r, i);\n              }), r.promise;\n            }), n = function () {\n              var e = new r(),\n                t = L(e);\n              this.promise = e, this.resolve = Z(ee, t), this.reject = Z($, t);\n            }, b.f = B = function (e) {\n              return e === U || void 0 === e ? new n(e) : G(e);\n            }, !a && f(A) && M !== Object.prototype)) {\n              o = M.then, P || l(M, \"then\", function (e, t) {\n                var i = this;\n                return new U(function (e, t) {\n                  u(o, i, e, t);\n                }).then(e, t);\n              }, {\n                unsafe: !0\n              });\n              try {\n                delete M.constructor;\n              } catch (e) {}\n              h && h(M, x);\n            }\n            s({\n              global: !0,\n              constructor: !0,\n              wrap: !0,\n              forced: N\n            }, {\n              Promise: U\n            }), p(U, w, !1, !0), _(w);\n          },\n          4349: (e, t, i) => {\n            var r = i(6887),\n              n = i(2529),\n              o = i(6991),\n              s = i(5981),\n              a = i(626),\n              c = i(7475),\n              d = i(487),\n              u = i(6584),\n              l = i(5929),\n              h = o && o.prototype;\n            if (r({\n              target: \"Promise\",\n              proto: !0,\n              real: !0,\n              forced: !!o && s(function () {\n                h.finally.call({\n                  then: function () {}\n                }, function () {});\n              })\n            }, {\n              finally: function (e) {\n                var t = d(this, a(\"Promise\")),\n                  i = c(e);\n                return this.then(i ? function (i) {\n                  return u(t, e()).then(function () {\n                    return i;\n                  });\n                } : e, i ? function (i) {\n                  return u(t, e()).then(function () {\n                    throw i;\n                  });\n                } : e);\n              }\n            }), !n && c(o)) {\n              var p = a(\"Promise\").prototype.finally;\n              h.finally !== p && l(h, \"finally\", p, {\n                unsafe: !0\n              });\n            }\n          },\n          8881: (e, t, i) => {\n            i(6934), i(6890), i(3376), i(5921), i(4069), i(4482);\n          },\n          5921: (e, t, i) => {\n            var r = i(6887),\n              n = i(8834),\n              o = i(4883),\n              s = i(9520),\n              a = i(2),\n              c = i(3091);\n            r({\n              target: \"Promise\",\n              stat: !0,\n              forced: i(1542)\n            }, {\n              race: function (e) {\n                var t = this,\n                  i = s.f(t),\n                  r = i.reject,\n                  d = a(function () {\n                    var s = o(t.resolve);\n                    c(e, function (e) {\n                      n(s, t, e).then(i.resolve, r);\n                    });\n                  });\n                return d.error && r(d.value), i.promise;\n              }\n            });\n          },\n          4069: (e, t, i) => {\n            var r = i(6887),\n              n = i(8834),\n              o = i(9520);\n            r({\n              target: \"Promise\",\n              stat: !0,\n              forced: i(7742).CONSTRUCTOR\n            }, {\n              reject: function (e) {\n                var t = o.f(this);\n                return n(t.reject, void 0, e), t.promise;\n              }\n            });\n          },\n          4482: (e, t, i) => {\n            var r = i(6887),\n              n = i(626),\n              o = i(2529),\n              s = i(6991),\n              a = i(7742).CONSTRUCTOR,\n              c = i(6584),\n              d = n(\"Promise\"),\n              u = o && !a;\n            r({\n              target: \"Promise\",\n              stat: !0,\n              forced: o || a\n            }, {\n              resolve: function (e) {\n                return c(u && this === d ? s : this, e);\n              }\n            });\n          },\n          7971: (e, t, i) => {\n            var r = i(4620).charAt,\n              n = i(5803),\n              o = i(5402),\n              s = i(5105),\n              a = i(3538),\n              c = \"String Iterator\",\n              d = o.set,\n              u = o.getterFor(c);\n            s(String, \"String\", function (e) {\n              d(this, {\n                type: c,\n                string: n(e),\n                index: 0\n              });\n            }, function () {\n              var e,\n                t = u(this),\n                i = t.string,\n                n = t.index;\n              return n >= i.length ? a(void 0, !0) : (e = r(i, n), t.index += e.length, a(e, !1));\n            });\n          },\n          7634: (e, t, i) => {\n            i(6274);\n            var r = i(3281),\n              n = i(1899),\n              o = i(9697),\n              s = i(2029),\n              a = i(2077),\n              c = i(9813)(\"toStringTag\");\n            for (var d in r) {\n              var u = n[d],\n                l = u && u.prototype;\n              l && o(l) !== c && s(l, c, d), a[d] = a.Array;\n            }\n          },\n          1910: (e, t, i) => {\n            var r = i(8171);\n            e.exports = r;\n          },\n          7460: (e, t, i) => {\n            var r = i(2956);\n            i(7634), e.exports = r;\n          },\n          9662: (e, t, i) => {\n            var r = i(614),\n              n = i(6330),\n              o = TypeError;\n            e.exports = function (e) {\n              if (r(e)) return e;\n              throw o(n(e) + \" is not a function\");\n            };\n          },\n          6077: (e, t, i) => {\n            var r = i(614),\n              n = String,\n              o = TypeError;\n            e.exports = function (e) {\n              if (\"object\" == typeof e || r(e)) return e;\n              throw o(\"Can't set \" + n(e) + \" as a prototype\");\n            };\n          },\n          1223: (e, t, i) => {\n            var r = i(5112),\n              n = i(30),\n              o = i(3070).f,\n              s = r(\"unscopables\"),\n              a = Array.prototype;\n            null == a[s] && o(a, s, {\n              configurable: !0,\n              value: n(null)\n            }), e.exports = function (e) {\n              a[s][e] = !0;\n            };\n          },\n          9670: (e, t, i) => {\n            var r = i(111),\n              n = String,\n              o = TypeError;\n            e.exports = function (e) {\n              if (r(e)) return e;\n              throw o(n(e) + \" is not an object\");\n            };\n          },\n          1318: (e, t, i) => {\n            var r = i(5656),\n              n = i(1400),\n              o = i(6244),\n              s = function (e) {\n                return function (t, i, s) {\n                  var a,\n                    c = r(t),\n                    d = o(c),\n                    u = n(s, d);\n                  if (e && i != i) {\n                    for (; d > u;) if ((a = c[u++]) != a) return !0;\n                  } else for (; d > u; u++) if ((e || u in c) && c[u] === i) return e || u || 0;\n                  return !e && -1;\n                };\n              };\n            e.exports = {\n              includes: s(!0),\n              indexOf: s(!1)\n            };\n          },\n          4326: (e, t, i) => {\n            var r = i(84),\n              n = r({}.toString),\n              o = r(\"\".slice);\n            e.exports = function (e) {\n              return o(n(e), 8, -1);\n            };\n          },\n          648: (e, t, i) => {\n            var r = i(1694),\n              n = i(614),\n              o = i(4326),\n              s = i(5112)(\"toStringTag\"),\n              a = Object,\n              c = \"Arguments\" == o(function () {\n                return arguments;\n              }());\n            e.exports = r ? o : function (e) {\n              var t, i, r;\n              return void 0 === e ? \"Undefined\" : null === e ? \"Null\" : \"string\" == typeof (i = function (e, t) {\n                try {\n                  return e[t];\n                } catch (e) {}\n              }(t = a(e), s)) ? i : c ? o(t) : \"Object\" == (r = o(t)) && n(t.callee) ? \"Arguments\" : r;\n            };\n          },\n          9920: (e, t, i) => {\n            var r = i(2597),\n              n = i(3887),\n              o = i(1236),\n              s = i(3070);\n            e.exports = function (e, t, i) {\n              for (var a = n(t), c = s.f, d = o.f, u = 0; u < a.length; u++) {\n                var l = a[u];\n                r(e, l) || i && r(i, l) || c(e, l, d(t, l));\n              }\n            };\n          },\n          8544: (e, t, i) => {\n            var r = i(7293);\n            e.exports = !r(function () {\n              function e() {}\n              return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;\n            });\n          },\n          6178: e => {\n            e.exports = function (e, t) {\n              return {\n                value: e,\n                done: t\n              };\n            };\n          },\n          8880: (e, t, i) => {\n            var r = i(9781),\n              n = i(3070),\n              o = i(9114);\n            e.exports = r ? function (e, t, i) {\n              return n.f(e, t, o(1, i));\n            } : function (e, t, i) {\n              return e[t] = i, e;\n            };\n          },\n          9114: e => {\n            e.exports = function (e, t) {\n              return {\n                enumerable: !(1 & e),\n                configurable: !(2 & e),\n                writable: !(4 & e),\n                value: t\n              };\n            };\n          },\n          8052: (e, t, i) => {\n            var r = i(614),\n              n = i(3070),\n              o = i(6339),\n              s = i(3072);\n            e.exports = function (e, t, i, a) {\n              a || (a = {});\n              var c = a.enumerable,\n                d = void 0 !== a.name ? a.name : t;\n              if (r(i) && o(i, d, a), a.global) c ? e[t] = i : s(t, i);else {\n                try {\n                  a.unsafe ? e[t] && (c = !0) : delete e[t];\n                } catch (e) {}\n                c ? e[t] = i : n.f(e, t, {\n                  value: i,\n                  enumerable: !1,\n                  configurable: !a.nonConfigurable,\n                  writable: !a.nonWritable\n                });\n              }\n              return e;\n            };\n          },\n          3072: (e, t, i) => {\n            var r = i(7854),\n              n = Object.defineProperty;\n            e.exports = function (e, t) {\n              try {\n                n(r, e, {\n                  value: t,\n                  configurable: !0,\n                  writable: !0\n                });\n              } catch (i) {\n                r[e] = t;\n              }\n              return t;\n            };\n          },\n          9781: (e, t, i) => {\n            var r = i(7293);\n            e.exports = !r(function () {\n              return 7 != Object.defineProperty({}, 1, {\n                get: function () {\n                  return 7;\n                }\n              })[1];\n            });\n          },\n          4154: e => {\n            var t = \"object\" == typeof document && document.all,\n              i = void 0 === t && void 0 !== t;\n            e.exports = {\n              all: t,\n              IS_HTMLDDA: i\n            };\n          },\n          317: (e, t, i) => {\n            var r = i(7854),\n              n = i(111),\n              o = r.document,\n              s = n(o) && n(o.createElement);\n            e.exports = function (e) {\n              return s ? o.createElement(e) : {};\n            };\n          },\n          8324: e => {\n            e.exports = {\n              CSSRuleList: 0,\n              CSSStyleDeclaration: 0,\n              CSSValueList: 0,\n              ClientRectList: 0,\n              DOMRectList: 0,\n              DOMStringList: 0,\n              DOMTokenList: 1,\n              DataTransferItemList: 0,\n              FileList: 0,\n              HTMLAllCollection: 0,\n              HTMLCollection: 0,\n              HTMLFormElement: 0,\n              HTMLSelectElement: 0,\n              MediaList: 0,\n              MimeTypeArray: 0,\n              NamedNodeMap: 0,\n              NodeList: 1,\n              PaintRequestList: 0,\n              Plugin: 0,\n              PluginArray: 0,\n              SVGLengthList: 0,\n              SVGNumberList: 0,\n              SVGPathSegList: 0,\n              SVGPointList: 0,\n              SVGStringList: 0,\n              SVGTransformList: 0,\n              SourceBufferList: 0,\n              StyleSheetList: 0,\n              TextTrackCueList: 0,\n              TextTrackList: 0,\n              TouchList: 0\n            };\n          },\n          8509: (e, t, i) => {\n            var r = i(317)(\"span\").classList,\n              n = r && r.constructor && r.constructor.prototype;\n            e.exports = n === Object.prototype ? void 0 : n;\n          },\n          8113: (e, t, i) => {\n            var r = i(5005);\n            e.exports = r(\"navigator\", \"userAgent\") || \"\";\n          },\n          7392: (e, t, i) => {\n            var r,\n              n,\n              o = i(7854),\n              s = i(8113),\n              a = o.process,\n              c = o.Deno,\n              d = a && a.versions || c && c.version,\n              u = d && d.v8;\n            u && (n = (r = u.split(\".\"))[0] > 0 && r[0] < 4 ? 1 : +(r[0] + r[1])), !n && s && (!(r = s.match(/Edge\\/(\\d+)/)) || r[1] >= 74) && (r = s.match(/Chrome\\/(\\d+)/)) && (n = +r[1]), e.exports = n;\n          },\n          748: e => {\n            e.exports = [\"constructor\", \"hasOwnProperty\", \"isPrototypeOf\", \"propertyIsEnumerable\", \"toLocaleString\", \"toString\", \"valueOf\"];\n          },\n          1060: (e, t, i) => {\n            var r = i(1702),\n              n = Error,\n              o = r(\"\".replace),\n              s = String(n(\"zxcasd\").stack),\n              a = /\\n\\s*at [^:]*:[^\\n]*/,\n              c = a.test(s);\n            e.exports = function (e, t) {\n              if (c && \"string\" == typeof e && !n.prepareStackTrace) for (; t--;) e = o(e, a, \"\");\n              return e;\n            };\n          },\n          2914: (e, t, i) => {\n            var r = i(7293),\n              n = i(9114);\n            e.exports = !r(function () {\n              var e = Error(\"a\");\n              return !(\"stack\" in e) || (Object.defineProperty(e, \"stack\", n(1, 7)), 7 !== e.stack);\n            });\n          },\n          2109: (e, t, i) => {\n            var r = i(7854),\n              n = i(1236).f,\n              o = i(8880),\n              s = i(8052),\n              a = i(3072),\n              c = i(9920),\n              d = i(4705);\n            e.exports = function (e, t) {\n              var i,\n                u,\n                l,\n                h,\n                p,\n                _ = e.target,\n                E = e.global,\n                f = e.stat;\n              if (i = E ? r : f ? r[_] || a(_, {}) : (r[_] || {}).prototype) for (u in t) {\n                if (h = t[u], l = e.dontCallGetSet ? (p = n(i, u)) && p.value : i[u], !d(E ? u : _ + (f ? \".\" : \"#\") + u, e.forced) && void 0 !== l) {\n                  if (typeof h == typeof l) continue;\n                  c(h, l);\n                }\n                (e.sham || l && l.sham) && o(h, \"sham\", !0), s(i, u, h, e);\n              }\n            };\n          },\n          7293: e => {\n            e.exports = function (e) {\n              try {\n                return !!e();\n              } catch (e) {\n                return !0;\n              }\n            };\n          },\n          2104: (e, t, i) => {\n            var r = i(4374),\n              n = Function.prototype,\n              o = n.apply,\n              s = n.call;\n            e.exports = \"object\" == typeof Reflect && Reflect.apply || (r ? s.bind(o) : function () {\n              return s.apply(o, arguments);\n            });\n          },\n          4374: (e, t, i) => {\n            var r = i(7293);\n            e.exports = !r(function () {\n              var e = function () {}.bind();\n              return \"function\" != typeof e || e.hasOwnProperty(\"prototype\");\n            });\n          },\n          6916: (e, t, i) => {\n            var r = i(4374),\n              n = Function.prototype.call;\n            e.exports = r ? n.bind(n) : function () {\n              return n.apply(n, arguments);\n            };\n          },\n          6530: (e, t, i) => {\n            var r = i(9781),\n              n = i(2597),\n              o = Function.prototype,\n              s = r && Object.getOwnPropertyDescriptor,\n              a = n(o, \"name\"),\n              c = a && \"something\" === function () {}.name,\n              d = a && (!r || r && s(o, \"name\").configurable);\n            e.exports = {\n              EXISTS: a,\n              PROPER: c,\n              CONFIGURABLE: d\n            };\n          },\n          84: (e, t, i) => {\n            var r = i(4374),\n              n = Function.prototype,\n              o = n.call,\n              s = r && n.bind.bind(o, o);\n            e.exports = r ? s : function (e) {\n              return function () {\n                return o.apply(e, arguments);\n              };\n            };\n          },\n          1702: (e, t, i) => {\n            var r = i(4326),\n              n = i(84);\n            e.exports = function (e) {\n              if (\"Function\" === r(e)) return n(e);\n            };\n          },\n          5005: (e, t, i) => {\n            var r = i(7854),\n              n = i(614),\n              o = function (e) {\n                return n(e) ? e : void 0;\n              };\n            e.exports = function (e, t) {\n              return arguments.length < 2 ? o(r[e]) : r[e] && r[e][t];\n            };\n          },\n          8173: (e, t, i) => {\n            var r = i(9662),\n              n = i(8554);\n            e.exports = function (e, t) {\n              var i = e[t];\n              return n(i) ? void 0 : r(i);\n            };\n          },\n          7854: (e, t, i) => {\n            var r = function (e) {\n              return e && e.Math == Math && e;\n            };\n            e.exports = r(\"object\" == typeof globalThis && globalThis) || r(\"object\" == typeof window && window) || r(\"object\" == typeof self && self) || r(\"object\" == typeof i.g && i.g) || function () {\n              return this;\n            }() || Function(\"return this\")();\n          },\n          2597: (e, t, i) => {\n            var r = i(1702),\n              n = i(7908),\n              o = r({}.hasOwnProperty);\n            e.exports = Object.hasOwn || function (e, t) {\n              return o(n(e), t);\n            };\n          },\n          3501: e => {\n            e.exports = {};\n          },\n          490: (e, t, i) => {\n            var r = i(5005);\n            e.exports = r(\"document\", \"documentElement\");\n          },\n          4664: (e, t, i) => {\n            var r = i(9781),\n              n = i(7293),\n              o = i(317);\n            e.exports = !r && !n(function () {\n              return 7 != Object.defineProperty(o(\"div\"), \"a\", {\n                get: function () {\n                  return 7;\n                }\n              }).a;\n            });\n          },\n          8361: (e, t, i) => {\n            var r = i(1702),\n              n = i(7293),\n              o = i(4326),\n              s = Object,\n              a = r(\"\".split);\n            e.exports = n(function () {\n              return !s(\"z\").propertyIsEnumerable(0);\n            }) ? function (e) {\n              return \"String\" == o(e) ? a(e, \"\") : s(e);\n            } : s;\n          },\n          9587: (e, t, i) => {\n            var r = i(614),\n              n = i(111),\n              o = i(7674);\n            e.exports = function (e, t, i) {\n              var s, a;\n              return o && r(s = t.constructor) && s !== i && n(a = s.prototype) && a !== i.prototype && o(e, a), e;\n            };\n          },\n          2788: (e, t, i) => {\n            var r = i(1702),\n              n = i(614),\n              o = i(5465),\n              s = r(Function.toString);\n            n(o.inspectSource) || (o.inspectSource = function (e) {\n              return s(e);\n            }), e.exports = o.inspectSource;\n          },\n          8340: (e, t, i) => {\n            var r = i(111),\n              n = i(8880);\n            e.exports = function (e, t) {\n              r(t) && \"cause\" in t && n(e, \"cause\", t.cause);\n            };\n          },\n          9909: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s = i(4811),\n              a = i(7854),\n              c = i(111),\n              d = i(8880),\n              u = i(2597),\n              l = i(5465),\n              h = i(6200),\n              p = i(3501),\n              _ = \"Object already initialized\",\n              E = a.TypeError,\n              f = a.WeakMap;\n            if (s || l.state) {\n              var m = l.state || (l.state = new f());\n              m.get = m.get, m.has = m.has, m.set = m.set, r = function (e, t) {\n                if (m.has(e)) throw E(_);\n                return t.facade = e, m.set(e, t), t;\n              }, n = function (e) {\n                return m.get(e) || {};\n              }, o = function (e) {\n                return m.has(e);\n              };\n            } else {\n              var g = h(\"state\");\n              p[g] = !0, r = function (e, t) {\n                if (u(e, g)) throw E(_);\n                return t.facade = e, d(e, g, t), t;\n              }, n = function (e) {\n                return u(e, g) ? e[g] : {};\n              }, o = function (e) {\n                return u(e, g);\n              };\n            }\n            e.exports = {\n              set: r,\n              get: n,\n              has: o,\n              enforce: function (e) {\n                return o(e) ? n(e) : r(e, {});\n              },\n              getterFor: function (e) {\n                return function (t) {\n                  var i;\n                  if (!c(t) || (i = n(t)).type !== e) throw E(\"Incompatible receiver, \" + e + \" required\");\n                  return i;\n                };\n              }\n            };\n          },\n          614: (e, t, i) => {\n            var r = i(4154),\n              n = r.all;\n            e.exports = r.IS_HTMLDDA ? function (e) {\n              return \"function\" == typeof e || e === n;\n            } : function (e) {\n              return \"function\" == typeof e;\n            };\n          },\n          4705: (e, t, i) => {\n            var r = i(7293),\n              n = i(614),\n              o = /#|\\.prototype\\./,\n              s = function (e, t) {\n                var i = c[a(e)];\n                return i == u || i != d && (n(t) ? r(t) : !!t);\n              },\n              a = s.normalize = function (e) {\n                return String(e).replace(o, \".\").toLowerCase();\n              },\n              c = s.data = {},\n              d = s.NATIVE = \"N\",\n              u = s.POLYFILL = \"P\";\n            e.exports = s;\n          },\n          8554: e => {\n            e.exports = function (e) {\n              return null == e;\n            };\n          },\n          111: (e, t, i) => {\n            var r = i(614),\n              n = i(4154),\n              o = n.all;\n            e.exports = n.IS_HTMLDDA ? function (e) {\n              return \"object\" == typeof e ? null !== e : r(e) || e === o;\n            } : function (e) {\n              return \"object\" == typeof e ? null !== e : r(e);\n            };\n          },\n          1913: e => {\n            e.exports = !1;\n          },\n          2190: (e, t, i) => {\n            var r = i(5005),\n              n = i(614),\n              o = i(7976),\n              s = i(3307),\n              a = Object;\n            e.exports = s ? function (e) {\n              return \"symbol\" == typeof e;\n            } : function (e) {\n              var t = r(\"Symbol\");\n              return n(t) && o(t.prototype, a(e));\n            };\n          },\n          3061: (e, t, i) => {\n            var r = i(3383).IteratorPrototype,\n              n = i(30),\n              o = i(9114),\n              s = i(8003),\n              a = i(7497),\n              c = function () {\n                return this;\n              };\n            e.exports = function (e, t, i, d) {\n              var u = t + \" Iterator\";\n              return e.prototype = n(r, {\n                next: o(+!d, i)\n              }), s(e, u, !1, !0), a[u] = c, e;\n            };\n          },\n          1656: (e, t, i) => {\n            var r = i(2109),\n              n = i(6916),\n              o = i(1913),\n              s = i(6530),\n              a = i(614),\n              c = i(3061),\n              d = i(9518),\n              u = i(7674),\n              l = i(8003),\n              h = i(8880),\n              p = i(8052),\n              _ = i(5112),\n              E = i(7497),\n              f = i(3383),\n              m = s.PROPER,\n              g = s.CONFIGURABLE,\n              S = f.IteratorPrototype,\n              T = f.BUGGY_SAFARI_ITERATORS,\n              v = _(\"iterator\"),\n              R = \"keys\",\n              I = \"values\",\n              y = \"entries\",\n              C = function () {\n                return this;\n              };\n            e.exports = function (e, t, i, s, _, f, A) {\n              c(i, t, s);\n              var O,\n                b,\n                w,\n                N = function (e) {\n                  if (e === _ && M) return M;\n                  if (!T && e in L) return L[e];\n                  switch (e) {\n                    case R:\n                    case I:\n                    case y:\n                      return function () {\n                        return new i(this, e);\n                      };\n                  }\n                  return function () {\n                    return new i(this);\n                  };\n                },\n                D = t + \" Iterator\",\n                P = !1,\n                L = e.prototype,\n                k = L[v] || L[\"@@iterator\"] || _ && L[_],\n                M = !T && k || N(_),\n                U = \"Array\" == t && L.entries || k;\n              if (U && (O = d(U.call(new e()))) !== Object.prototype && O.next && (o || d(O) === S || (u ? u(O, S) : a(O[v]) || p(O, v, C)), l(O, D, !0, !0), o && (E[D] = C)), m && _ == I && k && k.name !== I && (!o && g ? h(L, \"name\", I) : (P = !0, M = function () {\n                return n(k, this);\n              })), _) if (b = {\n                values: N(I),\n                keys: f ? M : N(R),\n                entries: N(y)\n              }, A) for (w in b) (T || P || !(w in L)) && p(L, w, b[w]);else r({\n                target: t,\n                proto: !0,\n                forced: T || P\n              }, b);\n              return o && !A || L[v] === M || p(L, v, M, {\n                name: _\n              }), E[t] = M, b;\n            };\n          },\n          3383: (e, t, i) => {\n            var r,\n              n,\n              o,\n              s = i(7293),\n              a = i(614),\n              c = i(111),\n              d = i(30),\n              u = i(9518),\n              l = i(8052),\n              h = i(5112),\n              p = i(1913),\n              _ = h(\"iterator\"),\n              E = !1;\n            [].keys && (\"next\" in (o = [].keys()) ? (n = u(u(o))) !== Object.prototype && (r = n) : E = !0), !c(r) || s(function () {\n              var e = {};\n              return r[_].call(e) !== e;\n            }) ? r = {} : p && (r = d(r)), a(r[_]) || l(r, _, function () {\n              return this;\n            }), e.exports = {\n              IteratorPrototype: r,\n              BUGGY_SAFARI_ITERATORS: E\n            };\n          },\n          7497: e => {\n            e.exports = {};\n          },\n          6244: (e, t, i) => {\n            var r = i(7466);\n            e.exports = function (e) {\n              return r(e.length);\n            };\n          },\n          6339: (e, t, i) => {\n            var r = i(7293),\n              n = i(614),\n              o = i(2597),\n              s = i(9781),\n              a = i(6530).CONFIGURABLE,\n              c = i(2788),\n              d = i(9909),\n              u = d.enforce,\n              l = d.get,\n              h = Object.defineProperty,\n              p = s && !r(function () {\n                return 8 !== h(function () {}, \"length\", {\n                  value: 8\n                }).length;\n              }),\n              _ = String(String).split(\"String\"),\n              E = e.exports = function (e, t, i) {\n                \"Symbol(\" === String(t).slice(0, 7) && (t = \"[\" + String(t).replace(/^Symbol\\(([^)]*)\\)/, \"$1\") + \"]\"), i && i.getter && (t = \"get \" + t), i && i.setter && (t = \"set \" + t), (!o(e, \"name\") || a && e.name !== t) && (s ? h(e, \"name\", {\n                  value: t,\n                  configurable: !0\n                }) : e.name = t), p && i && o(i, \"arity\") && e.length !== i.arity && h(e, \"length\", {\n                  value: i.arity\n                });\n                try {\n                  i && o(i, \"constructor\") && i.constructor ? s && h(e, \"prototype\", {\n                    writable: !1\n                  }) : e.prototype && (e.prototype = void 0);\n                } catch (e) {}\n                var r = u(e);\n                return o(r, \"source\") || (r.source = _.join(\"string\" == typeof t ? t : \"\")), e;\n              };\n            Function.prototype.toString = E(function () {\n              return n(this) && l(this).source || c(this);\n            }, \"toString\");\n          },\n          4758: e => {\n            var t = Math.ceil,\n              i = Math.floor;\n            e.exports = Math.trunc || function (e) {\n              var r = +e;\n              return (r > 0 ? i : t)(r);\n            };\n          },\n          6277: (e, t, i) => {\n            var r = i(1340);\n            e.exports = function (e, t) {\n              return void 0 === e ? arguments.length < 2 ? \"\" : t : r(e);\n            };\n          },\n          30: (e, t, i) => {\n            var r,\n              n = i(9670),\n              o = i(6048),\n              s = i(748),\n              a = i(3501),\n              c = i(490),\n              d = i(317),\n              u = i(6200)(\"IE_PROTO\"),\n              l = function () {},\n              h = function (e) {\n                return \"<script>\" + e + \"<\\/script>\";\n              },\n              p = function (e) {\n                e.write(h(\"\")), e.close();\n                var t = e.parentWindow.Object;\n                return e = null, t;\n              },\n              _ = function () {\n                try {\n                  r = new ActiveXObject(\"htmlfile\");\n                } catch (e) {}\n                var e, t;\n                _ = \"undefined\" != typeof document ? document.domain && r ? p(r) : ((t = d(\"iframe\")).style.display = \"none\", c.appendChild(t), t.src = String(\"javascript:\"), (e = t.contentWindow.document).open(), e.write(h(\"document.F=Object\")), e.close(), e.F) : p(r);\n                for (var i = s.length; i--;) delete _.prototype[s[i]];\n                return _();\n              };\n            a[u] = !0, e.exports = Object.create || function (e, t) {\n              var i;\n              return null !== e ? (l.prototype = n(e), i = new l(), l.prototype = null, i[u] = e) : i = _(), void 0 === t ? i : o.f(i, t);\n            };\n          },\n          6048: (e, t, i) => {\n            var r = i(9781),\n              n = i(3353),\n              o = i(3070),\n              s = i(9670),\n              a = i(5656),\n              c = i(1956);\n            t.f = r && !n ? Object.defineProperties : function (e, t) {\n              s(e);\n              for (var i, r = a(t), n = c(t), d = n.length, u = 0; d > u;) o.f(e, i = n[u++], r[i]);\n              return e;\n            };\n          },\n          3070: (e, t, i) => {\n            var r = i(9781),\n              n = i(4664),\n              o = i(3353),\n              s = i(9670),\n              a = i(4948),\n              c = TypeError,\n              d = Object.defineProperty,\n              u = Object.getOwnPropertyDescriptor;\n            t.f = r ? o ? function (e, t, i) {\n              if (s(e), t = a(t), s(i), \"function\" == typeof e && \"prototype\" === t && \"value\" in i && \"writable\" in i && !i.writable) {\n                var r = u(e, t);\n                r && r.writable && (e[t] = i.value, i = {\n                  configurable: \"configurable\" in i ? i.configurable : r.configurable,\n                  enumerable: \"enumerable\" in i ? i.enumerable : r.enumerable,\n                  writable: !1\n                });\n              }\n              return d(e, t, i);\n            } : d : function (e, t, i) {\n              if (s(e), t = a(t), s(i), n) try {\n                return d(e, t, i);\n              } catch (e) {}\n              if (\"get\" in i || \"set\" in i) throw c(\"Accessors not supported\");\n              return \"value\" in i && (e[t] = i.value), e;\n            };\n          },\n          1236: (e, t, i) => {\n            var r = i(9781),\n              n = i(6916),\n              o = i(5296),\n              s = i(9114),\n              a = i(5656),\n              c = i(4948),\n              d = i(2597),\n              u = i(4664),\n              l = Object.getOwnPropertyDescriptor;\n            t.f = r ? l : function (e, t) {\n              if (e = a(e), t = c(t), u) try {\n                return l(e, t);\n              } catch (e) {}\n              if (d(e, t)) return s(!n(o.f, e, t), e[t]);\n            };\n          },\n          8006: (e, t, i) => {\n            var r = i(6324),\n              n = i(748).concat(\"length\", \"prototype\");\n            t.f = Object.getOwnPropertyNames || function (e) {\n              return r(e, n);\n            };\n          },\n          5181: (e, t) => {\n            t.f = Object.getOwnPropertySymbols;\n          },\n          9518: (e, t, i) => {\n            var r = i(2597),\n              n = i(614),\n              o = i(7908),\n              s = i(6200),\n              a = i(8544),\n              c = s(\"IE_PROTO\"),\n              d = Object,\n              u = d.prototype;\n            e.exports = a ? d.getPrototypeOf : function (e) {\n              var t = o(e);\n              if (r(t, c)) return t[c];\n              var i = t.constructor;\n              return n(i) && t instanceof i ? i.prototype : t instanceof d ? u : null;\n            };\n          },\n          7976: (e, t, i) => {\n            var r = i(1702);\n            e.exports = r({}.isPrototypeOf);\n          },\n          6324: (e, t, i) => {\n            var r = i(1702),\n              n = i(2597),\n              o = i(5656),\n              s = i(1318).indexOf,\n              a = i(3501),\n              c = r([].push);\n            e.exports = function (e, t) {\n              var i,\n                r = o(e),\n                d = 0,\n                u = [];\n              for (i in r) !n(a, i) && n(r, i) && c(u, i);\n              for (; t.length > d;) n(r, i = t[d++]) && (~s(u, i) || c(u, i));\n              return u;\n            };\n          },\n          1956: (e, t, i) => {\n            var r = i(6324),\n              n = i(748);\n            e.exports = Object.keys || function (e) {\n              return r(e, n);\n            };\n          },\n          5296: (e, t) => {\n            var i = {}.propertyIsEnumerable,\n              r = Object.getOwnPropertyDescriptor,\n              n = r && !i.call({\n                1: 2\n              }, 1);\n            t.f = n ? function (e) {\n              var t = r(this, e);\n              return !!t && t.enumerable;\n            } : i;\n          },\n          7674: (e, t, i) => {\n            var r = i(1702),\n              n = i(9670),\n              o = i(6077);\n            e.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function () {\n              var e,\n                t = !1,\n                i = {};\n              try {\n                (e = r(Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set))(i, []), t = i instanceof Array;\n              } catch (e) {}\n              return function (i, r) {\n                return n(i), o(r), t ? e(i, r) : i.__proto__ = r, i;\n              };\n            }() : void 0);\n          },\n          2140: (e, t, i) => {\n            var r = i(6916),\n              n = i(614),\n              o = i(111),\n              s = TypeError;\n            e.exports = function (e, t) {\n              var i, a;\n              if (\"string\" === t && n(i = e.toString) && !o(a = r(i, e))) return a;\n              if (n(i = e.valueOf) && !o(a = r(i, e))) return a;\n              if (\"string\" !== t && n(i = e.toString) && !o(a = r(i, e))) return a;\n              throw s(\"Can't convert object to primitive value\");\n            };\n          },\n          3887: (e, t, i) => {\n            var r = i(5005),\n              n = i(1702),\n              o = i(8006),\n              s = i(5181),\n              a = i(9670),\n              c = n([].concat);\n            e.exports = r(\"Reflect\", \"ownKeys\") || function (e) {\n              var t = o.f(a(e)),\n                i = s.f;\n              return i ? c(t, i(e)) : t;\n            };\n          },\n          2626: (e, t, i) => {\n            var r = i(3070).f;\n            e.exports = function (e, t, i) {\n              i in e || r(e, i, {\n                configurable: !0,\n                get: function () {\n                  return t[i];\n                },\n                set: function (e) {\n                  t[i] = e;\n                }\n              });\n            };\n          },\n          4488: (e, t, i) => {\n            var r = i(8554),\n              n = TypeError;\n            e.exports = function (e) {\n              if (r(e)) throw n(\"Can't call method on \" + e);\n              return e;\n            };\n          },\n          8003: (e, t, i) => {\n            var r = i(3070).f,\n              n = i(2597),\n              o = i(5112)(\"toStringTag\");\n            e.exports = function (e, t, i) {\n              e && !i && (e = e.prototype), e && !n(e, o) && r(e, o, {\n                configurable: !0,\n                value: t\n              });\n            };\n          },\n          6200: (e, t, i) => {\n            var r = i(2309),\n              n = i(9711),\n              o = r(\"keys\");\n            e.exports = function (e) {\n              return o[e] || (o[e] = n(e));\n            };\n          },\n          5465: (e, t, i) => {\n            var r = i(7854),\n              n = i(3072),\n              o = \"__core-js_shared__\",\n              s = r[o] || n(o, {});\n            e.exports = s;\n          },\n          2309: (e, t, i) => {\n            var r = i(1913),\n              n = i(5465);\n            (e.exports = function (e, t) {\n              return n[e] || (n[e] = void 0 !== t ? t : {});\n            })(\"versions\", []).push({\n              version: \"3.26.0\",\n              mode: r ? \"pure\" : \"global\",\n              copyright: \"Â© 2014-2022 Denis Pushkarev (zloirock.ru)\",\n              license: \"https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE\",\n              source: \"https://github.com/zloirock/core-js\"\n            });\n          },\n          6293: (e, t, i) => {\n            var r = i(7392),\n              n = i(7293);\n            e.exports = !!Object.getOwnPropertySymbols && !n(function () {\n              var e = Symbol();\n              return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && r && r < 41;\n            });\n          },\n          1400: (e, t, i) => {\n            var r = i(9303),\n              n = Math.max,\n              o = Math.min;\n            e.exports = function (e, t) {\n              var i = r(e);\n              return i < 0 ? n(i + t, 0) : o(i, t);\n            };\n          },\n          5656: (e, t, i) => {\n            var r = i(8361),\n              n = i(4488);\n            e.exports = function (e) {\n              return r(n(e));\n            };\n          },\n          9303: (e, t, i) => {\n            var r = i(4758);\n            e.exports = function (e) {\n              var t = +e;\n              return t != t || 0 === t ? 0 : r(t);\n            };\n          },\n          7466: (e, t, i) => {\n            var r = i(9303),\n              n = Math.min;\n            e.exports = function (e) {\n              return e > 0 ? n(r(e), 9007199254740991) : 0;\n            };\n          },\n          7908: (e, t, i) => {\n            var r = i(4488),\n              n = Object;\n            e.exports = function (e) {\n              return n(r(e));\n            };\n          },\n          7593: (e, t, i) => {\n            var r = i(6916),\n              n = i(111),\n              o = i(2190),\n              s = i(8173),\n              a = i(2140),\n              c = i(5112),\n              d = TypeError,\n              u = c(\"toPrimitive\");\n            e.exports = function (e, t) {\n              if (!n(e) || o(e)) return e;\n              var i,\n                c = s(e, u);\n              if (c) {\n                if (void 0 === t && (t = \"default\"), i = r(c, e, t), !n(i) || o(i)) return i;\n                throw d(\"Can't convert object to primitive value\");\n              }\n              return void 0 === t && (t = \"number\"), a(e, t);\n            };\n          },\n          4948: (e, t, i) => {\n            var r = i(7593),\n              n = i(2190);\n            e.exports = function (e) {\n              var t = r(e, \"string\");\n              return n(t) ? t : t + \"\";\n            };\n          },\n          1694: (e, t, i) => {\n            var r = {};\n            r[i(5112)(\"toStringTag\")] = \"z\", e.exports = \"[object z]\" === String(r);\n          },\n          1340: (e, t, i) => {\n            var r = i(648),\n              n = String;\n            e.exports = function (e) {\n              if (\"Symbol\" === r(e)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n              return n(e);\n            };\n          },\n          6330: e => {\n            var t = String;\n            e.exports = function (e) {\n              try {\n                return t(e);\n              } catch (e) {\n                return \"Object\";\n              }\n            };\n          },\n          9711: (e, t, i) => {\n            var r = i(1702),\n              n = 0,\n              o = Math.random(),\n              s = r(1..toString);\n            e.exports = function (e) {\n              return \"Symbol(\" + (void 0 === e ? \"\" : e) + \")_\" + s(++n + o, 36);\n            };\n          },\n          3307: (e, t, i) => {\n            var r = i(6293);\n            e.exports = r && !Symbol.sham && \"symbol\" == typeof Symbol.iterator;\n          },\n          3353: (e, t, i) => {\n            var r = i(9781),\n              n = i(7293);\n            e.exports = r && n(function () {\n              return 42 != Object.defineProperty(function () {}, \"prototype\", {\n                value: 42,\n                writable: !1\n              }).prototype;\n            });\n          },\n          4811: (e, t, i) => {\n            var r = i(7854),\n              n = i(614),\n              o = r.WeakMap;\n            e.exports = n(o) && /native code/.test(String(o));\n          },\n          5112: (e, t, i) => {\n            var r = i(7854),\n              n = i(2309),\n              o = i(2597),\n              s = i(9711),\n              a = i(6293),\n              c = i(3307),\n              d = n(\"wks\"),\n              u = r.Symbol,\n              l = u && u.for,\n              h = c ? u : u && u.withoutSetter || s;\n            e.exports = function (e) {\n              if (!o(d, e) || !a && \"string\" != typeof d[e]) {\n                var t = \"Symbol.\" + e;\n                a && o(u, e) ? d[e] = u[e] : d[e] = c && l ? l(t) : h(t);\n              }\n              return d[e];\n            };\n          },\n          9191: (e, t, i) => {\n            var r = i(5005),\n              n = i(2597),\n              o = i(8880),\n              s = i(7976),\n              a = i(7674),\n              c = i(9920),\n              d = i(2626),\n              u = i(9587),\n              l = i(6277),\n              h = i(8340),\n              p = i(1060),\n              _ = i(2914),\n              E = i(9781),\n              f = i(1913);\n            e.exports = function (e, t, i, m) {\n              var g = \"stackTraceLimit\",\n                S = m ? 2 : 1,\n                T = e.split(\".\"),\n                v = T[T.length - 1],\n                R = r.apply(null, T);\n              if (R) {\n                var I = R.prototype;\n                if (!f && n(I, \"cause\") && delete I.cause, !i) return R;\n                var y = r(\"Error\"),\n                  C = t(function (e, t) {\n                    var i = l(m ? t : e, void 0),\n                      r = m ? new R(e) : new R();\n                    return void 0 !== i && o(r, \"message\", i), _ && o(r, \"stack\", p(r.stack, 2)), this && s(I, this) && u(r, this, C), arguments.length > S && h(r, arguments[S]), r;\n                  });\n                if (C.prototype = I, \"Error\" !== v ? a ? a(C, y) : c(C, y, {\n                  name: !0\n                }) : E && g in R && (d(C, R, g), d(C, R, \"prepareStackTrace\")), c(C, R), !f) try {\n                  I.name !== v && o(I, \"name\", v), I.constructor = C;\n                } catch (e) {}\n                return C;\n              }\n            };\n          },\n          6992: (e, t, i) => {\n            var r = i(5656),\n              n = i(1223),\n              o = i(7497),\n              s = i(9909),\n              a = i(3070).f,\n              c = i(1656),\n              d = i(6178),\n              u = i(1913),\n              l = i(9781),\n              h = \"Array Iterator\",\n              p = s.set,\n              _ = s.getterFor(h);\n            e.exports = c(Array, \"Array\", function (e, t) {\n              p(this, {\n                type: h,\n                target: r(e),\n                index: 0,\n                kind: t\n              });\n            }, function () {\n              var e = _(this),\n                t = e.target,\n                i = e.kind,\n                r = e.index++;\n              return !t || r >= t.length ? (e.target = void 0, d(void 0, !0)) : d(\"keys\" == i ? r : \"values\" == i ? t[r] : [r, t[r]], !1);\n            }, \"values\");\n            var E = o.Arguments = o.Array;\n            if (n(\"keys\"), n(\"values\"), n(\"entries\"), !u && l && \"values\" !== E.name) try {\n              a(E, \"name\", {\n                value: \"values\"\n              });\n            } catch (e) {}\n          },\n          1703: (e, t, i) => {\n            var r = i(2109),\n              n = i(7854),\n              o = i(2104),\n              s = i(9191),\n              a = n.WebAssembly,\n              c = 7 !== Error(\"e\", {\n                cause: 7\n              }).cause,\n              d = function (e, t) {\n                var i = {};\n                i[e] = s(e, t, c), r({\n                  global: !0,\n                  constructor: !0,\n                  arity: 1,\n                  forced: c\n                }, i);\n              },\n              u = function (e, t) {\n                if (a && a[e]) {\n                  var i = {};\n                  i[e] = s(\"WebAssembly.\" + e, t, c), r({\n                    target: \"WebAssembly\",\n                    stat: !0,\n                    constructor: !0,\n                    arity: 1,\n                    forced: c\n                  }, i);\n                }\n              };\n            d(\"Error\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), d(\"EvalError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), d(\"RangeError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), d(\"ReferenceError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), d(\"SyntaxError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), d(\"TypeError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), d(\"URIError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), u(\"CompileError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), u(\"LinkError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            }), u(\"RuntimeError\", function (e) {\n              return function (t) {\n                return o(e, this, arguments);\n              };\n            });\n          },\n          3948: (e, t, i) => {\n            var r = i(7854),\n              n = i(8324),\n              o = i(8509),\n              s = i(6992),\n              a = i(8880),\n              c = i(5112),\n              d = c(\"iterator\"),\n              u = c(\"toStringTag\"),\n              l = s.values,\n              h = function (e, t) {\n                if (e) {\n                  if (e[d] !== l) try {\n                    a(e, d, l);\n                  } catch (t) {\n                    e[d] = l;\n                  }\n                  if (e[u] || a(e, u, t), n[t]) for (var i in s) if (e[i] !== s[i]) try {\n                    a(e, i, s[i]);\n                  } catch (t) {\n                    e[i] = s[i];\n                  }\n                }\n              };\n            for (var p in n) h(r[p] && r[p].prototype, p);\n            h(o, \"DOMTokenList\");\n          },\n          6226: (e, t, i) => {\n            e.exports = i(7460);\n          },\n          7445: (e, t, i) => {\n            e.exports = i(3685);\n          }\n        },\n        t = {};\n      function i(r) {\n        var n = t[r];\n        if (void 0 !== n) return n.exports;\n        var o = t[r] = {\n          exports: {}\n        };\n        return e[r](o, o.exports, i), o.exports;\n      }\n      i.n = e => {\n        var t = e && e.__esModule ? () => e.default : () => e;\n        return i.d(t, {\n          a: t\n        }), t;\n      }, i.d = (e, t) => {\n        for (var r in t) i.o(t, r) && !i.o(e, r) && Object.defineProperty(e, r, {\n          enumerable: !0,\n          get: t[r]\n        });\n      }, i.g = function () {\n        if (\"object\" == typeof globalThis) return globalThis;\n        try {\n          return this || new Function(\"return this\")();\n        } catch (e) {\n          if (\"object\" == typeof window) return window;\n        }\n      }(), i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n      };\n      var r = {};\n      return (() => {\n        i.r(r), i.d(r, {\n          AudioExtension: () => T,\n          AudioProcessor: () => g,\n          Extension: () => S,\n          PromiseMutex: () => y,\n          Ticker: () => R,\n          VideoProcessor: () => m,\n          logger: () => u,\n          reporter: () => p\n        });\n        var e = i(7445);\n        function t(t, i, r) {\n          return i in t ? e(t, i, {\n            value: r,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n          }) : t[i] = r, t;\n        }\n        i(1703), i(6992), i(3948);\n        var n = i(6226),\n          o = i.n(n);\n        const s = Date.now(),\n          a = {\n            DEBUG: 0,\n            INFO: 1,\n            WARNING: 2,\n            ERROR: 3,\n            NONE: 4\n          };\n        function c() {\n          const e = new Date();\n          return e.toTimeString().split(\" \")[0] + \":\" + e.getMilliseconds();\n        }\n        const d = e => {\n            for (const t in a) if (Object.prototype.hasOwnProperty.call(a, t) && a[t] === e) return t;\n            return \"DEFAULT\";\n          },\n          u = new class {\n            constructor() {\n              t(this, \"logLevel\", a.DEBUG), t(this, \"hookLog\", void 0);\n            }\n            debug() {\n              for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n              const r = [a.DEBUG].concat(t);\n              this.log.apply(this, r);\n            }\n            info() {\n              for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n              const r = [a.INFO].concat(t);\n              this.log.apply(this, r);\n            }\n            warning() {\n              for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n              const r = [a.WARNING].concat(t);\n              this.log.apply(this, r);\n            }\n            error() {\n              for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];\n              const r = [a.ERROR].concat(t);\n              this.log.apply(this, r);\n            }\n            log() {\n              for (var e, t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];\n              if (Date.now() - s < 100) return void setTimeout(() => {\n                this.log(...i);\n              }, Date.now() - s);\n              const n = Math.max(0, Math.min(4, i[0]));\n              if (i[0] = c() + \" Agora-Extension [\".concat(d(n), \"]:\"), n < this.logLevel) return;\n              const o = c() + \" %cAgora-Extension [\".concat(d(n), \"]:\");\n              let u = [];\n              switch (n) {\n                case a.DEBUG:\n                  u = [o, \"color: #64B5F6;\"].concat(i.slice(1)), console.log.apply(console, u);\n                  break;\n                case a.INFO:\n                  u = [o, \"color: #1E88E5; font-weight: bold;\"].concat(i.slice(1)), console.log.apply(console, u);\n                  break;\n                case a.WARNING:\n                  u = [o, \"color: #FB8C00; font-weight: bold;\"].concat(i.slice(1)), console.warn.apply(console, u);\n                  break;\n                case a.ERROR:\n                  u = [o, \"color: #B00020; font-weight: bold;\"].concat(i.slice(1)), console.error.apply(console, u);\n              }\n              null === (e = this.hookLog) || void 0 === e || e.call(this, n, u);\n            }\n          }();\n        function l(e, t) {\n          var i = Object.keys(e);\n          if (Object.getOwnPropertySymbols) {\n            var r = Object.getOwnPropertySymbols(e);\n            t && (r = r.filter(function (t) {\n              return Object.getOwnPropertyDescriptor(e, t).enumerable;\n            })), i.push.apply(i, r);\n          }\n          return i;\n        }\n        function h(e) {\n          for (var i = 1; i < arguments.length; i++) {\n            var r = null != arguments[i] ? arguments[i] : {};\n            i % 2 ? l(Object(r), !0).forEach(function (i) {\n              t(e, i, r[i]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : l(Object(r)).forEach(function (t) {\n              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));\n            });\n          }\n          return e;\n        }\n        const p = new class {\n          constructor() {\n            t(this, \"apiInvokeMsgQueue\", []), t(this, \"hookApiInvoke\", void 0);\n          }\n          reportApiInvoke(e) {\n            e.timeout = e.timeout || 6e4, e.reportResult = void 0 === e.reportResult || e.reportResult;\n            const t = Date.now(),\n              i = () => ({\n                name: e.name,\n                apiInvokeTime: t,\n                options: e.options\n              });\n            let r = !1;\n            var n;\n            (n = e.timeout, new (o())(e => {\n              window.setTimeout(e, n);\n            })).then(() => {\n              r || (this.sendApiInvoke(h(h({}, i()), {}, {\n                error: \"API_INVOKE_TIMEOUT\",\n                success: !1\n              })), u.debug(\"\".concat(e.name, \" timeout\")));\n            });\n            const s = new Error(\"\".concat(e.name, \": this api invoke is end\"));\n            return {\n              onSuccess: t => {\n                if (r) throw s;\n                r = !0, this.sendApiInvoke(h(h({}, i()), {}, {\n                  success: !0\n                }, e.reportResult && {\n                  result: t\n                }));\n              },\n              onError: e => {\n                if (r) throw e;\n                r = !0, this.sendApiInvoke(h(h({}, i()), {}, {\n                  success: !1,\n                  error: e.toString()\n                }));\n              }\n            };\n          }\n          sendApiInvoke(e) {\n            this.hookApiInvoke ? (this.hookApiInvoke([...this.apiInvokeMsgQueue, e]), this.apiInvokeMsgQueue = []) : this.apiInvokeMsgQueue.push(e);\n          }\n        }();\n        function _(e, t) {\n          var i = Object.keys(e);\n          if (Object.getOwnPropertySymbols) {\n            var r = Object.getOwnPropertySymbols(e);\n            t && (r = r.filter(function (t) {\n              return Object.getOwnPropertyDescriptor(e, t).enumerable;\n            })), i.push.apply(i, r);\n          }\n          return i;\n        }\n        function E(e) {\n          for (var i = 1; i < arguments.length; i++) {\n            var r = null != arguments[i] ? arguments[i] : {};\n            i % 2 ? _(Object(r), !0).forEach(function (i) {\n              t(e, i, r[i]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : _(Object(r)).forEach(function (t) {\n              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));\n            });\n          }\n          return e;\n        }\n        class f extends class {\n          constructor() {\n            t(this, \"_events\", {}), t(this, \"addListener\", this.on);\n          }\n          getListeners(e) {\n            return this._events[e] ? this._events[e].map(e => e.listener) : [];\n          }\n          on(e, t) {\n            this._events[e] || (this._events[e] = []);\n            const i = this._events[e];\n            -1 === this._indexOfListener(i, t) && i.push({\n              listener: t,\n              once: !1\n            });\n          }\n          once(e, t) {\n            this._events[e] || (this._events[e] = []);\n            const i = this._events[e];\n            -1 === this._indexOfListener(i, t) && i.push({\n              listener: t,\n              once: !0\n            });\n          }\n          off(e, t) {\n            if (!this._events[e]) return;\n            const i = this._events[e],\n              r = this._indexOfListener(i, t);\n            -1 !== r && i.splice(r, 1), 0 === this._events[e].length && delete this._events[e];\n          }\n          removeAllListeners(e) {\n            e ? delete this._events[e] : this._events = {};\n          }\n          emit(e) {\n            this._events[e] || (this._events[e] = []);\n            const t = this._events[e].map(e => e);\n            for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) r[n - 1] = arguments[n];\n            for (let i = 0; i < t.length; i += 1) {\n              const n = t[i];\n              n.once && this.off(e, n.listener), n.listener.apply(this, r || []);\n            }\n          }\n          _indexOfListener(e, t) {\n            let i = e.length;\n            for (; i--;) if (e[i].listener === t) return i;\n            return -1;\n          }\n          emitAsPromise(e) {\n            for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];\n            return 0 === this.getListeners(e).length ? o().reject(new Error(\"No promise event handler.\")) : new (o())((t, r) => {\n              this.emit(e, ...i, t, r);\n            });\n          }\n          emitAsPromiseNoResponse(e) {\n            for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) i[r - 1] = arguments[r];\n            return 0 === this.getListeners(e).length ? o().resolve() : new (o())((t, r) => {\n              this.emit(e, ...i, t, r);\n            });\n          }\n        } {\n          get enabled() {\n            return this._enabled;\n          }\n          output(e, t) {\n            if (this.outputTrack === e) return;\n            const i = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".output\"),\n              options: {\n                track: null == e ? void 0 : e.toString()\n              }\n            });\n            this.outputTrack = e, this.destination && this.destination.updateInput({\n              track: e,\n              context: t\n            }), i.onSuccess();\n          }\n          constructor() {\n            super(), t(this, \"inputTrack\", void 0), t(this, \"outputTrack\", void 0), t(this, \"_enabled\", !0), t(this, \"_source\", void 0), t(this, \"ID\", function e() {\n              let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,\n                i = arguments.length > 1 ? arguments[1] : void 0;\n              const r = Math.random().toString(16).substr(2, t).toLowerCase();\n              return r.length === t ? \"\".concat(i).concat(r) : \"\".concat(i).concat(r) + e(t - r.length, \"\");\n            }(6, \"\")), t(this, \"destination\", void 0), t(this, \"context\", void 0), t(this, \"name\", void 0);\n          }\n          enable() {\n            if (this._enabled) return;\n            const e = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".enable\"),\n              options: !0\n            });\n            u.info(\"\".concat(this.name, \"-\").concat(this.ID, \" enabled\")), this._enabled = !0;\n            try {\n              var t;\n              const i = null === (t = this.onEnableChange) || void 0 === t ? void 0 : t.call(this, this._enabled);\n              if (i instanceof o()) return i.then(() => {\n                e.onSuccess();\n              }).catch(t => {\n                throw e.onError(t), t;\n              });\n              e.onSuccess();\n            } catch (t) {\n              throw e.onError(t), t;\n            }\n          }\n          disable() {\n            if (!this._enabled) return;\n            const e = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".enable\"),\n              options: !1\n            });\n            u.info(\"\".concat(this.name, \"-\").concat(this.ID, \" disabled\")), this._enabled = !1;\n            try {\n              var t;\n              const i = null === (t = this.onEnableChange) || void 0 === t ? void 0 : t.call(this, this._enabled);\n              if (i instanceof o()) return i.then(() => {\n                e.onSuccess();\n              }).catch(t => {\n                throw e.onError(t), t;\n              });\n              e.onSuccess();\n            } catch (t) {\n              throw e.onError(t), t;\n            }\n          }\n        }\n        class m extends f {\n          get kind() {\n            return \"video\";\n          }\n          pipe(e) {\n            const t = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".pipe\"),\n              options: {\n                processor: e.name\n              }\n            });\n            if (this.destination === e) return t.onSuccess(), e;\n            if (e._source) {\n              const i = new Error(\"Processor \".concat(e.name, \" already being piped, please call \").concat(e._source.name, \".unpipe() beforehand.\"));\n              throw t.onError(i), i;\n            }\n            return this.destination && this.unpipe(), this.destination = e, e._source = this, this.context && this.destination.updateInput({\n              track: this.outputTrack,\n              context: this.context\n            }), t.onSuccess(), e;\n          }\n          unpipe() {\n            if (!this.destination) return;\n            const e = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".unpipe\"),\n              options: {\n                processor: this.destination.name\n              }\n            });\n            u.info(\"unpiping processor \".concat(this.destination.name, \"-\").concat(this.destination.ID));\n            try {\n              const t = this.destination;\n              this.destination._source = void 0, this.destination = void 0, t.reset();\n            } finally {\n              e.onSuccess();\n            }\n          }\n          updateInput(e) {\n            var t, i;\n            e.context !== this.context && (this.context = e.context, null === (t = this.onPiped) || void 0 === t || t.call(this, this.context), this.destination && this.destination.updateInput({\n              track: this.outputTrack,\n              context: e.context\n            })), e.track && this.inputTrack !== e.track && (this.inputTrack = e.track, null === (i = this.onTrack) || void 0 === i || i.call(this, e.track, this.context));\n          }\n          reset() {\n            var e;\n            this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.context = void 0, null === (e = this.onUnpiped) || void 0 === e || e.call(this), this.destination && this.destination.reset();\n          }\n        }\n        class g extends f {\n          constructor() {\n            super(...arguments), t(this, \"inputNode\", void 0), t(this, \"outputNode\", void 0), t(this, \"destination\", void 0), t(this, \"context\", void 0);\n          }\n          get kind() {\n            return \"audio\";\n          }\n          pipe(e) {\n            const t = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".pipe\"),\n              options: {\n                processor: e.name\n              }\n            });\n            if (this.destination === e) return t.onSuccess(), e;\n            if (e._source) {\n              const i = new Error(\"Processor \".concat(e.name, \" already being piped, please call \").concat(e._source.name, \".unpipe() beforehand.\"));\n              throw t.onError(i), i;\n            }\n            return this.destination && this.unpipe(), this.destination = e, e._source = this, this.context && this.destination.updateInput({\n              track: this.outputTrack,\n              node: this.outputNode,\n              context: this.context\n            }), t.onSuccess(), e;\n          }\n          unpipe() {\n            if (!this.destination) return;\n            u.info(\"unpiping processor \".concat(this.destination.name, \"-\").concat(this.destination.ID));\n            const e = p.reportApiInvoke({\n              name: \"\".concat(this.name, \".unpipe\"),\n              options: {\n                processor: this.destination.name\n              }\n            });\n            try {\n              var t;\n              let i = this.destination;\n              null === (t = this.outputNode) || void 0 === t || t.disconnect(), this.destination._source = void 0, this.destination = void 0, i.reset();\n            } finally {\n              e.onSuccess();\n            }\n          }\n          output(e, t) {\n            if (e instanceof MediaStreamTrack) super.output(e, t);else if (e instanceof AudioNode) {\n              if (this.outputNode === e) return;\n              const i = p.reportApiInvoke({\n                name: \"\".concat(this.name, \".output\"),\n                options: E(E({}, e instanceof MediaStreamTrack && {\n                  track: e.toString()\n                }), e instanceof AudioNode && {\n                  audioNode: e.toString()\n                })\n              });\n              this.outputNode = e, this.destination && this.destination.updateInput({\n                node: e,\n                context: t\n              }), i.onSuccess();\n            }\n          }\n          updateInput(e) {\n            var t, i, r;\n            e.context !== this.context && (this.context = e.context, null === (t = this.onPiped) || void 0 === t || t.call(this, this.context), this.destination && this.destination.updateInput({\n              track: this.outputTrack,\n              node: this.outputNode,\n              context: e.context\n            })), e.track && this.inputTrack !== e.track && (this.inputTrack = e.track, null === (i = this.onTrack) || void 0 === i || i.call(this, e.track, this.context)), e.node && this.inputNode !== e.node && (this.inputNode = e.node, null === (r = this.onNode) || void 0 === r || r.call(this, e.node, this.context));\n          }\n          reset() {\n            var e;\n            this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.inputNode = void 0, null === (e = this.onUnpiped) || void 0 === e || e.call(this, this.context), this.context = void 0, this.destination && this.destination.reset();\n          }\n        }\n        class S {\n          constructor() {\n            t(this, \"__registered__\", !1), t(this, \"logger\", u), t(this, \"reporter\", p), t(this, \"parameters\", {});\n          }\n          createProcessor() {\n            if (!this.__registered__) throw new Error(\"Extension not registered yet!\");\n            return this._createProcessor();\n          }\n        }\n        class T extends S {}\n        let v;\n        class R {\n          get running() {\n            return this._running;\n          }\n          constructor(e, i) {\n            if (t(this, \"type\", void 0), t(this, \"interval\", void 0), t(this, \"fn\", void 0), t(this, \"_running\", !1), t(this, \"_osc\", void 0), !e) throw new Error();\n            if (i <= 0) throw new Error();\n            this.type = e, this.interval = i;\n          }\n          add(e) {\n            this.fn = e;\n          }\n          remove() {\n            this.fn = void 0;\n          }\n          start() {\n            if (!this._running) switch (this._running = !0, this.type) {\n              case \"Timer\":\n                {\n                  const e = () => {\n                    setTimeout(() => {\n                      this.fn && this.fn(), this._running && e();\n                    }, this.interval);\n                  };\n                  e();\n                  break;\n                }\n              case \"RAF\":\n                {\n                  const e = t => {\n                    requestAnimationFrame(i => {\n                      i - t < this.interval ? this._running && e(t) : (this.fn && this.fn(), this._running && e(i));\n                    });\n                  };\n                  e(performance.now());\n                  break;\n                }\n              case \"Oscillator\":\n                {\n                  v || (v = new AudioContext());\n                  const e = v.createGain();\n                  let t;\n                  e.gain.value = 0, e.connect(v.destination);\n                  const i = () => {\n                    this.fn && this.fn(), t && t.disconnect(), t = v.createOscillator(), this._osc = t, t.connect(e), this._running && (t.onended = i, t.start(0), t.stop(v.currentTime + this.interval / 1e3));\n                  };\n                  i();\n                  break;\n                }\n            }\n          }\n          stop() {\n            this._running = !1, this._osc && (this._osc.onended = null, this._osc = void 0);\n          }\n        }\n        let I = 1;\n        class y {\n          constructor(e) {\n            t(this, \"lockingPromise\", o().resolve()), t(this, \"locks\", 0), t(this, \"name\", \"\"), t(this, \"lockId\", void 0), this.lockId = I++, e && (this.name = e);\n          }\n          get isLocked() {\n            return this.locks > 0;\n          }\n          lock(e) {\n            let t;\n            this.locks += 1;\n            const i = new (o())(e => {\n                t = () => {\n                  this.locks -= 1, e();\n                };\n              }),\n              r = this.lockingPromise.then(() => t);\n            return this.lockingPromise = this.lockingPromise.then(() => i), r;\n          }\n        }\n      })(), r;\n    })(), e.exports = i();\n  }(ab);\n  var ub;\n  ! /*@cc_on!@*/\n  !!document.documentMode && !!window.StyleMedia && (HTMLCanvasElement.prototype.getContext = (ub = HTMLCanvasElement.prototype.getContext, function () {\n    let e = arguments;\n    const t = e[0];\n    return \"webgl\" === t && (e = [].slice.call(arguments), e[0] = \"experimental-webgl\"), ub.apply(null, e);\n  }));\n  const lb = [31, 222, 239, 159, 192, 236, 164, 81, 54, 227, 176, 149, 2, 247, 75, 141, 183, 54, 213, 216, 158, 92, 111, 49, 228, 111, 150, 6, 135, 79, 35, 212, 4, 155, 200, 168, 37, 107, 243, 110, 144, 179, 51, 81, 55, 78, 223, 242, 191, 211, 74, 119, 203, 151, 142, 62, 31, 41, 132, 22, 35, 155, 87, 123, 119, 117, 216, 57, 201, 53, 228, 67, 201, 40, 106, 24, 80, 176, 187, 253, 60, 63, 136, 100, 20, 12, 177, 99, 64, 38, 101, 143, 111, 176, 251, 211, 145, 136, 34, 23, 79, 136, 202, 95, 105, 199, 125, 67, 180, 44, 210, 179, 228, 4, 85, 160, 188, 64, 26, 46, 6, 61, 201, 103, 248, 18, 97, 254, 140, 36, 115, 106, 48, 124, 102, 216, 155, 120, 36, 227, 165, 217, 7, 227, 191, 128, 212, 157, 80, 37, 117, 175, 24, 214, 47, 221, 183, 211, 51, 174, 251, 223, 159, 167, 152, 53, 36, 107, 199, 223, 91, 62, 46, 194, 11, 80, 121, 188, 219, 2, 99, 99, 232, 229, 173, 234, 21, 30, 236, 177, 243, 142, 97, 48, 108, 56, 62, 172, 56, 216, 3, 42, 79, 138, 23, 88, 182, 39, 5, 118, 68, 135, 178, 56, 9, 94, 189, 44, 104, 9, 238, 231, 174, 122, 85, 247, 231, 86, 74, 8, 189, 147, 218, 180, 58, 76, 227, 17, 46, 90, 194, 100, 51, 178, 72, 163, 151, 243, 166, 130, 85, 1, 223, 130, 152, 242, 85, 255, 28, 173, 97, 252, 119, 215, 177, 119, 86, 104, 136, 82, 40, 72, 53, 11, 18, 26, 240, 188, 76, 110, 39, 31, 189];\n  function hb(e) {\n    const t = new Uint8Array([99, 114, 121, 112, 116, 105, 105]),\n      i = t.length,\n      r = e,\n      n = r.length,\n      o = new Uint8Array(n),\n      s = new Uint8Array(256);\n    for (let e = 0; e < 256; e++) s[e] = e;\n    let a = 0;\n    for (let e = 0; e < 256; e++) a = (a + s[e] + t[e % i]) % 256, [s[e], s[a]] = [s[a], s[e]];\n    let c,\n      d = 0;\n    a = 0;\n    for (let e = 0; e < 0 + n; e++) d = (d + 1) % 256, a = (a + s[d]) % 256, [s[d], s[a]] = [s[a], s[d]], c = s[(s[d] + s[a]) % 256], e >= 0 && (o[e - 0] = r[e - 0] ^ c);\n    const u = String.fromCharCode.apply(null, Array.from(o));\n    return Function(\"var winSize = 5; return `\" + u + \"`\")();\n  }\n  const pb = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 152, 221, 191, 124, 116, 248, 106, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 134, 194, 240, 46, 9, 3, 141, 22, 35, 146, 76, 23, 109, 117, 208, 41, 201, 45, 218, 76, 203, 105, 51, 58, 97, 154, 145, 236, 49, 18, 183, 127, 27, 12, 210, 122, 73, 42, 37, 143, 36, 207, 251, 211, 145, 191, 56, 10, 88, 222, 181, 125, 22, 238, 123, 71, 177, 107, 218, 254, 173, 28, 34, 253, 249, 67, 83, 97, 73, 111, 219, 43, 181, 82, 38, 230, 136, 109, 22, 67];\n  class _b {\n    constructor(e, t) {\n      mp(this, \"program\", void 0), mp(this, \"gl\", void 0), mp(this, \"kernel\", void 0), this.gl = e, this.kernel = t || pb, this.program = function (e, t) {\n        const i = hb(t),\n          r = db(e, [hb(lb), i]);\n        {\n          const t = e.getAttribLocation(r, \"a_position\"),\n            i = e.createBuffer();\n          e.bindBuffer(e.ARRAY_BUFFER, i), e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW), e.enableVertexAttribArray(t);\n          const n = 2,\n            o = e.FLOAT,\n            s = !1,\n            a = 0,\n            c = 0;\n          e.vertexAttribPointer(t, n, o, s, a, c);\n        }\n        {\n          const t = e.getAttribLocation(r, \"a_texCoord\"),\n            i = e.createBuffer();\n          e.bindBuffer(e.ARRAY_BUFFER, i), e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW), e.enableVertexAttribArray(t);\n          const n = 2,\n            o = e.FLOAT,\n            s = !1,\n            a = 0,\n            c = 0;\n          e.vertexAttribPointer(t, n, o, s, a, c);\n        }\n        return r;\n      }(this.gl, this.kernel);\n    }\n    setUniforms() {\n      const e = this.gl.getUniformLocation(this.program, \"u_flipY\");\n      this.gl.uniform1f(e, 1);\n    }\n  }\n  class Eb extends _b {\n    constructor(e, t, i, r) {\n      super(e, t), mp(this, \"xOffset\", void 0), mp(this, \"yOffset\", void 0), mp(this, \"denoiseLevel\", 5), this.xOffset = 1 / i, this.yOffset = 1 / r;\n    }\n    setUniforms() {\n      const e = this.gl.getUniformLocation(this.program, \"u_flipY\"),\n        t = this.gl.getUniformLocation(this.program, \"u_singleStepOffset\"),\n        i = this.gl.getUniformLocation(this.program, \"u_denoiseLevel\");\n      this.gl.uniform2f(t, this.xOffset, this.yOffset), this.gl.uniform1f(i, this.denoiseLevel), this.gl.uniform1f(e, 1);\n    }\n    setParameters(e) {\n      void 0 !== e.denoiseLevel && (this.denoiseLevel = e.denoiseLevel);\n    }\n    setSize(e, t) {\n      this.xOffset = 1 / e, this.yOffset = 1 / t;\n    }\n  }\n  const fb = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 155, 210, 164, 99, 114, 228, 96, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 133, 194, 247, 34, 31, 39, 142, 28, 2, 130, 18, 109, 84, 124, 223, 62, 140, 52, 128, 47, 208, 47, 115, 39, 4, 200, 220, 171, 53, 36, 150, 101, 10, 75, 247, 121, 74, 36, 35, 143, 108, 176, 235, 211, 135, 164, 36, 11, 88, 160, 148, 35, 6, 221, 41, 32, 166, 109, 205, 171, 228, 4, 26, 169, 244, 82, 119, 102, 86, 61, 201, 103, 248, 18, 97, 242, 182, 34, 121, 70, 28, 71, 126, 197, 223, 126, 14, 244, 149, 192, 12, 176, 187, 149, 212, 156, 22, 44, 36, 133, 10, 216, 63, 198, 213, 154, 116, 230, 253, 154, 154, 249, 215, 55, 60, 34, 196, 229, 76, 50, 44, 135, 22, 77, 113, 247, 142, 94, 60, 23, 172, 145, 175, 218, 81, 86, 162, 239, 180, 205, 63, 118, 3, 110, 123, 224, 127, 158, 124, 15, 127, 157, 27, 66, 176, 33, 24, 51, 53, 194, 178, 56, 6, 74, 191, 111, 51, 78, 174, 157, 229, 17, 22, 178, 231, 92, 25, 23, 191, 157, 137, 188, 54, 64, 176, 13, 22, 81, 207, 45, 108, 203, 83, 186, 130, 237, 186, 153, 110, 8, 196, 168, 152, 161, 28, 238, 46, 184, 36, 185, 20, 203, 183, 98, 95, 41, 149, 93, 105, 37, 116, 91, 68, 105, 164, 217, 30, 42, 60, 53, 173, 213, 177, 216, 195, 53, 204, 173, 128, 243, 42, 122, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 220, 161, 39, 214, 146, 183, 193, 225, 23, 177, 201, 243, 128, 160, 33, 75, 86, 126, 139, 254, 232, 14, 13, 85, 2, 112, 17, 150, 36, 180, 86, 226, 225, 126, 197, 17, 228, 225, 142, 245, 37, 170, 39, 96, 187, 190, 2, 35, 85, 237, 11, 189, 1, 79, 237, 2, 1, 114, 246, 109, 190, 66, 54, 153, 43, 218, 204, 70, 6, 204, 162, 247, 18, 130, 123, 30, 60, 165, 130, 142, 210, 133, 91, 127, 117, 71, 38, 145, 172, 7, 5, 16, 220, 222, 111, 98, 141, 239, 208, 125, 26, 238, 28, 0, 216, 89, 13, 7, 119, 134, 194, 75, 41, 67, 174, 1, 217, 80, 101, 40, 26, 59, 28, 59, 46, 108, 138, 38, 157, 167, 28, 234, 73, 177, 42, 42, 102, 108, 26, 181, 27, 178, 42, 43, 52, 28, 110, 117, 198, 173, 176, 178, 101, 225, 150, 36, 139, 108, 105, 10, 237, 222, 3, 143, 126, 18, 144, 115, 74, 56, 114, 134, 231, 159, 212, 62, 126, 80, 173, 216, 167, 4, 81, 18, 52, 17, 144, 218, 32, 139, 207, 104, 128, 229, 99, 84, 120, 31, 87, 227, 154, 91, 196, 63, 123, 111, 125, 36, 52, 57, 168, 113, 150, 189, 204, 24, 104, 196, 237, 86, 163, 68, 197, 202, 170, 212, 191, 81, 193, 111, 255, 162, 181, 202, 156, 146, 196, 96, 16, 118, 117, 55, 71, 156, 31, 163, 242, 204, 239, 11, 150, 27, 126, 115, 154, 107, 247, 134, 158, 125, 255, 146, 35, 183, 209, 36, 116, 87, 215, 172, 5, 251, 133, 114, 254, 141, 195, 6, 145, 4, 111, 182, 167, 74, 154, 152, 68, 18, 146, 88, 106, 200, 154, 15, 176, 94, 86, 66, 178, 101, 219, 35, 188, 129, 66, 28, 41, 110, 174, 53, 88, 174, 64, 191, 206, 127, 48, 126, 214, 216, 93, 119, 2, 166, 99, 181, 222, 29, 218, 28, 195, 219, 125, 44, 50, 16, 99, 174, 225, 51, 133, 120, 184, 159, 168, 75, 242, 162, 124, 255, 81, 25, 153, 109, 69, 220, 176, 4, 237, 196, 233, 19, 8, 240, 160, 39, 122, 81, 29, 188, 144, 249, 170, 174, 137, 30, 10, 93, 133, 151, 199, 248, 175, 38, 41, 144, 229, 245, 149, 25, 240, 138, 179, 114, 182, 84, 50, 103, 95, 31, 199, 31, 87, 208, 203, 199, 135, 49, 211, 43, 52, 36, 74, 59, 37, 22, 136, 171, 244, 126, 18, 251, 39, 159, 241, 66, 206, 127, 149, 159, 182, 143, 232, 199, 136, 46, 150, 32, 51, 221, 74, 22, 102, 93, 22, 44, 132, 140, 199, 43, 69, 249, 77, 75, 140, 70, 4, 252, 98, 235, 77, 190, 125, 18, 56, 21, 10, 244, 42, 2, 246, 62, 127, 241, 123, 137, 22, 247, 219, 177, 160, 84, 18, 10, 84, 97, 251, 127, 102, 16, 209, 181, 100, 94, 56, 238, 209, 207, 76, 189, 95, 15, 165, 139, 143, 189, 96, 225, 55, 112, 178, 27, 218, 198, 223, 251, 52, 123, 94, 130, 220, 142, 216, 116, 237, 18, 254, 49, 59, 128, 41, 29, 15, 179, 164, 85, 76, 167, 166, 151, 39, 221, 2, 190, 68, 167, 26, 177, 114, 141, 4, 67, 25, 69, 182, 38, 166, 160, 27, 151, 148, 108, 48, 227, 60, 112, 48, 22, 159, 76, 127, 251, 63, 254, 177, 113, 217, 197, 95, 179, 109, 128, 138, 99, 27, 249, 10, 174, 155, 129, 80, 39, 165, 252, 85, 60, 131, 183, 98, 107, 68, 207, 19, 233, 231, 55, 225, 126, 77, 49, 53, 145, 203, 113, 29, 208, 64, 237, 182, 229, 165, 7, 11, 169, 106, 253, 116, 141, 200, 62, 16, 38, 121, 55, 148, 91, 83, 160, 140, 126, 121, 12, 79, 189, 72, 172, 31, 243, 240, 209, 229, 32, 220, 91, 229, 81, 94, 247, 121, 153, 151, 232, 182, 171, 198, 50, 31, 152, 245, 172, 151, 130, 55, 62, 125, 38, 155, 229, 78, 207, 148, 201, 2, 78, 63, 119, 107, 168, 78, 139, 141, 163, 177, 191, 239, 141, 39, 182, 174, 40, 76, 226, 62, 125, 209, 6, 6, 34, 37, 147, 85, 204, 103, 51, 191, 36, 248, 17, 175, 20, 1, 53, 16, 35, 143, 237, 177, 125, 86, 29, 219, 235, 20, 121, 205, 59, 5, 250, 107, 109, 32, 224, 30, 152, 143, 113, 151, 95, 85, 19, 254, 164, 135, 124, 68, 136, 199, 29, 31, 244, 91, 10, 84, 127, 101, 210, 70, 226, 195, 140, 70, 166, 54, 217, 165, 84, 42, 165, 175, 100, 234, 124, 121, 105, 53, 101, 118, 174, 101, 220, 147, 68, 161, 37, 0, 182, 220, 142, 221, 155, 230, 115, 164, 10, 214, 208, 120, 91, 152, 66, 27, 81, 184, 48, 84, 70, 7, 128, 153, 217, 218, 249, 226, 70, 130, 200, 156, 61, 227, 21, 164, 137, 193, 221, 119, 10, 134, 204, 23, 20, 17, 90, 94, 105, 204, 39, 99, 1, 64, 153, 45, 213, 19, 247, 97, 194, 49, 35, 125, 255, 195, 139, 63, 209, 175, 208, 147, 189, 244, 204, 24, 211, 99, 142, 18, 92, 130, 254, 182, 231, 235, 93, 10, 127, 175, 87, 35, 62, 110, 137, 184, 39, 114, 200, 150, 11, 190, 40, 162, 168, 223, 203, 110, 242, 192, 234, 26, 11, 54, 155, 38, 48, 79, 109, 101, 119, 165, 187, 223, 5, 20, 168, 171, 241, 20, 243, 108, 199, 3, 155, 69, 244, 149, 0, 187, 110, 12, 233, 42, 151, 189, 139, 133, 104, 3, 30, 16, 200, 69, 4, 123, 103, 144, 12, 106, 182, 1, 127, 91, 125, 158, 12, 144, 238, 232, 209, 101, 159, 56, 163, 240, 179, 50, 169, 120, 219, 176, 87, 77, 45, 247, 153, 190, 82, 132, 50, 137, 209, 97, 19, 35, 247, 161, 62, 77, 16, 71, 152, 72, 61, 50, 99, 157, 154, 56, 58, 175, 27, 73, 121, 229, 195, 228, 132, 69, 233, 169, 100, 21, 123, 17, 3, 164, 6, 146, 106, 196, 29, 3, 250, 217, 164, 23, 171, 203, 14, 242, 239, 249, 169, 116, 138, 209, 98, 113, 181, 122, 35, 162, 216, 46, 230, 4, 155, 142, 118, 216, 232, 229, 28, 12, 158, 153, 126, 149, 171, 172, 231, 99, 211, 57, 114, 136, 183, 114, 74, 35, 233, 115, 127, 253, 157, 38, 49, 136, 141, 25, 161, 255, 232, 110, 101, 208, 166, 186, 226, 12, 185, 19, 155, 53, 93, 155, 39, 161, 7, 124, 213, 52, 223, 125, 211, 242, 253, 22, 13, 131, 115, 167, 198, 188, 90, 209, 63, 224, 92, 112, 118, 220, 165, 31, 164, 43, 58, 197, 77, 17, 247, 77, 164, 74, 77, 218, 18, 187, 41, 76, 189, 127, 98, 18, 226, 231, 71, 115, 236, 68, 183, 111, 50, 168, 88, 247, 9, 123, 65, 180, 88, 74, 44, 101, 101, 173, 11];\n  class mb extends Eb {\n    constructor(e, t, i) {\n      super(e, fb, t, i);\n    }\n  }\n  const gb = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 165, 108, 122, 254, 125, 130, 229, 55, 109, 113, 11, 210, 238, 163, 213, 86, 116, 156, 248, 215, 63, 20, 48, 173, 31, 55, 133, 18, 105, 32, 16, 204, 35, 128, 38, 212, 87, 200, 97, 114, 40, 12, 210, 193, 171, 59, 33, 158, 108, 14, 75, 228, 74, 65, 32, 57, 192, 112, 156, 234, 250, 140, 189, 40, 20, 6, 230, 135, 52, 17, 200, 123, 68, 183, 44, 215, 187, 234, 2, 13, 169, 234, 94, 115, 60, 6, 107, 224, 118, 254, 88, 2, 235, 134, 36, 120, 5, 85, 94, 126, 222, 223, 101, 105, 227, 147, 199, 64, 185, 246, 143, 183, 210, 30, 37, 127, 226, 79, 156, 118, 147, 208, 131, 51, 248, 232, 217, 206, 181, 218, 58, 61, 112, 244, 227, 68, 45, 41, 206, 69, 12, 45, 163, 205, 75, 6, 23, 167, 145, 250, 237, 92, 84, 164, 240, 253, 216, 54, 85, 7, 108, 62, 255, 42, 217, 3, 27, 0, 196, 94, 28, 241, 120, 80, 92, 89, 135, 228, 125, 2, 3, 242, 39, 116, 64, 248, 216, 177, 122, 66, 178, 180, 9, 7, 33, 186, 208, 213, 188, 59, 78, 243, 95, 123, 28, 142, 45, 99, 130, 7, 167, 194, 156, 238, 199, 10, 71, 141, 251, 221, 158, 16, 255, 38, 181, 36, 184, 20, 136, 240, 55, 27, 51, 191, 82, 105, 55, 97, 78, 74, 121, 191, 161, 91, 126, 105, 103, 174, 139, 223, 145, 150, 120, 156, 240, 252, 182, 105, 104, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 201, 211, 39, 203, 146, 225, 246, 252, 21, 161, 250, 188, 137, 190, 42, 4, 90, 126, 211, 171, 240, 113, 67, 28, 92, 57, 77, 200, 125, 224, 19, 178, 142, 112, 202, 5, 233, 229, 128, 235, 105, 239, 102, 52, 179, 224, 87, 45, 68, 211, 10, 187, 9, 38, 190, 86, 25, 43, 175, 56, 231, 11, 108, 220, 36, 129, 131, 19, 93, 163, 239, 169, 118, 205, 50, 77, 121, 139, 139, 141, 197, 170, 20, 44, 39, 19, 97, 205, 228, 8, 106, 67, 210, 135, 111, 127, 141, 185, 175, 123, 26, 226, 42, 29, 217, 16, 99, 9, 46, 157, 232, 22, 3, 105, 174, 73, 144, 23, 110, 55, 84, 46, 4, 116, 39, 113, 205, 58, 158, 242, 7, 208, 75, 162, 55, 115, 35, 52, 124, 235, 114, 178, 55, 43, 98, 17, 100, 33, 134, 237, 190, 230, 60, 184, 192, 104, 146, 52, 58, 79, 174, 180, 81, 155, 114, 0, 153, 113, 90, 51, 86, 150, 254, 136, 205, 104, 39, 11, 190, 187, 233, 80, 81, 81, 56, 18, 222, 148, 116, 155, 156, 33, 132, 226, 127, 84, 34, 83, 28, 249, 153, 18, 197, 10, 116, 102, 125, 45, 47, 36, 235, 46, 212, 166, 209, 3, 125, 132, 237, 124, 163, 68, 197, 202, 232, 152, 234, 75, 235, 103, 248, 160, 241, 213, 151, 144, 130, 37, 23, 51, 48, 55, 12, 227, 31, 163, 242, 251, 245, 22, 129, 77, 20, 35, 150, 20, 181, 203, 138, 69, 233, 215, 109, 178, 209, 52, 85, 96, 221, 179, 56, 249, 138, 111, 250, 141, 134, 95, 152, 92, 109, 183, 174, 104, 151, 156, 31, 66, 211, 10, 57, 141, 167, 18, 177, 27, 126, 74, 252, 29, 143, 121, 173, 203, 8, 27, 44, 123, 148, 57, 88, 163, 68, 228, 158, 62, 98, 121, 192, 228, 94, 92, 72, 241, 33, 230, 173, 0, 197, 1, 194, 144, 111, 91, 60, 0, 106, 181, 203, 51, 133, 120, 250, 158, 184, 93, 216, 184, 126, 253, 21, 22, 155, 99, 80, 205, 227, 69, 231, 141, 165, 71, 70, 252, 223, 105, 51, 93, 22, 165, 135, 233, 177, 164, 139, 53, 5, 85, 151, 134, 214, 165, 249, 100, 24, 186, 207, 245, 149, 68, 218, 204, 252, 32, 190, 90, 48, 76, 57, 31, 201, 15, 52, 130, 135, 152, 206, 63, 198, 100, 126, 36, 2, 104, 116, 0, 160, 163, 186, 2, 91, 165, 57, 149, 163, 12, 239, 121, 152, 209, 224, 136, 248, 135, 136, 46, 150, 32, 51, 154, 6, 105, 0, 71, 30, 44, 175, 147, 139, 34, 91, 184, 78, 31, 145, 18, 3, 250, 122, 166, 47, 252, 109, 19, 40, 10, 123, 163, 99, 76, 133, 119, 37, 180, 38, 207, 79, 171, 185, 188];\n  class Sb extends Eb {\n    constructor(e, t, i) {\n      super(e, gb, t, i);\n    }\n  }\n  const Tb = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 160, 96, 121, 255, 120, 207, 227, 114, 120, 38, 72, 149, 145, 165, 227, 75, 122, 158, 250, 232, 46, 34, 52, 135, 9, 30, 144, 17, 110, 126, 110, 130, 71, 156, 46, 210, 67, 202, 51, 119, 97, 3, 211, 214, 227, 45, 109, 151, 97, 21, 10, 229, 53, 80, 26, 51, 202, 119, 128, 230, 197, 140, 135, 40, 14, 88, 128, 202, 95, 21, 208, 96, 83, 185, 98, 216, 242, 224, 15, 25, 224, 233, 86, 96, 46, 80, 120, 220, 48, 187, 86, 30, 240, 140, 46, 95, 81, 48, 90, 117, 140, 177, 51, 107, 235, 158, 137, 5, 241, 191, 154, 149, 219, 30, 126, 85, 175, 10, 216, 63, 139, 216, 151, 122, 251, 224, 202, 220, 227, 221, 53, 122, 34, 213, 224, 94, 45, 14, 200, 68, 31, 61, 175, 208, 17, 120, 82, 244, 138, 208, 165, 21, 19, 236, 232, 180, 217, 50, 74, 70, 126, 114, 227, 62, 192, 124, 9, 85, 148, 33, 77, 255, 117, 75, 102, 87, 151, 255, 87, 74, 74, 181, 111, 108, 9, 249, 220, 174, 59, 80, 254, 168, 29, 30, 94, 171, 133, 133, 195, 105, 64, 254, 68, 65, 18, 158, 54, 73, 203, 65, 175, 151, 170, 236, 138, 17, 119, 128, 237, 214, 189, 28, 250, 38, 149, 97, 242, 81, 212, 254, 57, 18, 120, 155, 64, 96, 108, 75, 78, 74, 121, 191, 243, 30, 42, 60, 103, 165, 196, 160, 195, 216, 99, 182, 173, 214, 182, 105, 53, 231, 3, 45, 212, 144, 101, 217, 65, 141, 44, 230, 125, 151, 154, 123, 57, 134, 223, 98, 133, 156, 238, 137, 181, 80, 175, 230, 167, 131, 180, 13, 69, 77, 44, 156, 165, 252, 14, 27, 85, 71, 1, 82, 196, 64, 243, 26, 167, 146, 98, 201, 6, 195, 247, 200, 224, 44, 177, 104, 109, 187, 231, 83, 118, 28, 159, 92, 179, 28, 14, 162, 81, 84, 21, 168, 34, 156, 21, 127, 215, 88, 218, 208, 11, 92, 161, 239, 239, 82, 221, 59, 86, 83, 201, 199, 216, 151, 139, 23, 54, 39, 52, 103, 204, 247, 24, 102, 94, 157, 138, 42, 49, 131, 183, 208, 50, 95, 236, 54, 6, 211, 26, 68, 72, 56, 212, 134, 24, 91, 114, 132, 1, 217, 80, 38, 47, 29, 47, 0, 107, 102, 99, 129, 33, 140, 243, 74, 251, 89, 247, 103, 12, 114, 58, 113, 240, 72, 188, 39, 48, 72, 89, 45, 102, 206, 245, 247, 231, 56, 167, 129, 122, 222, 47, 40, 78, 227, 159, 64, 206, 34, 127, 203, 127, 87, 40, 108, 152, 238, 147, 231, 46, 104, 89, 182, 180, 232, 86, 89, 91, 57, 10, 222, 202, 59, 199, 135, 60, 199, 189, 40, 84, 125, 28, 84, 162, 210, 91, 143, 34, 106, 117, 118, 3, 125, 126, 237, 60, 131, 173, 153, 69, 49, 212, 204, 117, 163, 31, 239, 202, 232, 152, 234, 3, 162, 32, 176, 184, 184, 196, 154, 131, 144, 115, 6, 53, 122, 55, 69, 166, 19, 230, 183, 175, 244, 1, 156, 11, 37, 121, 134, 121, 152, 142, 158, 125, 229, 150, 44, 183, 216, 109, 7, 65, 222, 169, 56, 222, 140, 110, 233, 157, 138, 66, 208, 6, 111, 166, 188, 76, 208, 222, 4, 104, 211, 10, 57, 141, 243, 65, 228, 86, 85, 88, 169, 91, 237, 56, 249, 133, 77, 21, 32, 37, 230, 55, 0, 184, 110, 228, 158, 62, 98, 45, 147, 177, 19, 119, 89, 164, 103, 132, 239, 84, 139, 68, 204, 157, 49, 41, 50, 89, 113, 159, 203, 51, 133, 120, 184, 210, 237, 15, 249, 187, 100, 253, 50, 16, 154, 112, 64, 193, 254, 10, 235, 200, 253, 84, 31, 169, 171, 39, 122, 70, 46, 186, 139, 212, 162, 173, 158, 41, 23, 86, 148, 172, 196, 237, 242, 58, 102, 180, 150, 238, 191, 25, 240, 204, 252, 125, 148, 29, 124, 51, 95, 10, 196, 55, 49, 159, 138, 144, 255, 126, 205, 43, 49, 42, 17, 59, 60, 77, 139, 177, 239, 64, 36, 224, 98, 205, 234, 70, 199, 103, 139, 218, 206, 207, 178, 217, 255, 32, 134, 59, 25, 221, 74, 22, 102, 82, 19, 20, 170, 142, 134, 42, 106, 249, 64, 80, 222, 28, 21, 169, 50, 235, 4, 237, 56, 81, 87, 76, 32, 251, 42, 6, 173, 105, 54, 191, 8, 136, 5, 245, 206, 239, 176, 9, 116, 24];\n  class vb extends Eb {\n    constructor(e, t, i) {\n      super(e, Tb, t, i);\n    }\n  }\n  const Rb = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 190, 100, 112, 230, 97, 199, 225, 96, 74, 99, 94, 248, 222, 162, 213, 95, 122, 158, 212, 233, 42, 22, 37, 217, 115, 36, 152, 30, 123, 116, 104, 212, 109, 129, 41, 220, 77, 213, 97, 124, 45, 4, 219, 197, 171, 40, 18, 149, 104, 20, 4, 248, 102, 64, 9, 50, 217, 124, 131, 180, 188, 159, 170, 63, 1, 84, 130, 150, 117, 14, 212, 118, 67, 165, 97, 207, 242, 251, 15, 30, 187, 188, 77, 79, 122, 67, 101, 252, 109, 244, 82, 37, 191, 227, 35, 114, 87, 57, 71, 99, 218, 155, 54, 101, 239, 138, 197, 13, 226, 228, 176, 157, 158, 87, 98, 55, 251, 79, 150, 64, 138, 200, 135, 40, 132, 135, 207, 146, 252, 222, 57, 58, 111, 151, 225, 78, 59, 36, 210, 70, 29, 121, 160, 210, 31, 109, 67, 167, 194, 177, 236, 91, 108, 164, 229, 130, 211, 59, 66, 93, 18, 107, 226, 54, 210, 51, 8, 77, 217, 19, 73, 187, 33, 30, 59, 9, 135, 162, 49, 5, 11, 225, 111, 119, 11, 247, 218, 129, 115, 83, 205, 170, 21, 4, 69, 210, 133, 134, 245, 109, 15, 177, 9, 81, 81, 203, 105, 42, 158, 12, 255, 151, 165, 230, 205, 5, 92, 196, 251, 211, 187, 27, 214, 43, 186, 91, 233, 85, 192, 229, 15, 71, 38, 220, 20, 38, 101, 44, 78, 7, 60, 251, 186, 75, 103, 108, 53, 166, 220, 186, 208, 194, 120, 207, 230, 159, 248, 22, 32, 142, 124, 96, 157, 222, 60, 191, 65, 145, 6, 239, 125, 151, 147, 50, 58, 130, 207, 110, 131, 223, 231, 137, 238, 28, 182, 216, 167, 198, 191, 37, 67, 76, 1, 144, 232, 218, 79, 72, 28, 65, 101, 43, 216, 64, 253, 16, 173, 179, 123, 140, 27, 233, 245, 199, 230, 36, 181, 102, 114, 247, 162, 18, 34, 20, 212, 25, 171, 24, 28, 143, 80, 94, 40, 167, 34, 209, 61, 117, 130, 1, 198, 196, 7, 21, 252, 180, 255, 92, 128, 119, 9, 48, 156, 138, 136, 151, 143, 23, 44, 52, 3, 40, 197, 228, 31, 123, 67, 163, 140, 32, 54, 204, 187, 149, 80, 19, 255, 82, 120, 195, 12, 110, 65, 56, 212, 143, 22, 78, 44, 234, 72, 140, 29, 118, 103, 18, 36, 7, 122, 50, 37, 139, 47, 142, 243, 25, 208, 88, 237, 126, 50, 103, 127, 19, 183, 29, 169, 29, 1, 55, 23, 100, 32, 129, 239, 243, 160, 61, 178, 197, 117, 199, 45, 57, 26, 165, 135, 92, 218, 59, 0, 197, 54, 13, 96, 40, 141, 212, 221, 131, 103, 46, 22, 228, 191, 167, 73, 20, 86, 62, 11, 147, 217, 116, 205, 203, 110, 134, 249, 51, 6, 123, 23, 86, 231, 157, 8, 144, 83, 126, 115, 118, 35, 96, 36, 229, 36, 220, 228, 143, 71, 45, 223, 129, 48, 236, 5, 145, 202, 188, 208, 184, 70, 241, 104, 255, 188, 181, 146, 210, 206, 144, 53, 77, 101, 120, 38, 8, 245, 80, 230, 165, 160, 183, 83, 202, 79, 127, 57, 214, 126, 242, 150, 208, 40, 239, 148, 35, 163, 201, 97, 74, 70, 214, 181, 63, 240, 147, 33, 253, 149, 140, 77, 197, 82, 126, 189, 231, 7, 196, 212, 80, 14, 151, 24, 57, 144, 243, 81, 234, 66, 24, 19, 236, 2, 137, 121, 246, 129, 65, 7, 99, 110, 174, 54, 74, 182, 81, 234, 142, 37, 72, 110, 220, 255, 64, 119, 10, 188, 111, 191, 228, 1, 205, 9, 204, 143, 56, 62, 125, 84, 106, 225, 131, 97, 192, 43, 240, 157, 161, 75, 168, 247, 44, 175, 65, 81, 192, 48, 21, 157, 167, 80, 191, 130, 161, 75, 85, 186, 174, 42, 117, 1, 68, 252, 204, 138, 254, 203, 152, 21, 13, 64, 144, 195, 207, 238, 229, 54, 103, 247, 159, 245, 211, 85, 191, 141, 168, 32, 234, 85, 46, 118, 12, 5, 199, 4, 19, 217, 203, 202, 156, 33, 143, 114, 116, 60, 66, 40, 58, 77, 208, 237, 171, 26, 72, 175, 114, 205, 248, 87, 137, 62, 210, 143, 151, 197, 167, 210, 241, 122, 150, 104, 122, 154, 2, 70, 102, 83, 19, 36, 141, 136, 199, 42, 79, 229, 71, 86, 194, 109, 31, 236, 80, 166, 17, 230, 109, 1, 40, 28, 46, 224, 56, 20, 230, 47, 100, 254, 116, 208, 76, 169, 157, 241, 175, 3, 70, 85, 31, 38, 245, 58, 33, 80, 145, 237, 8, 22, 71, 224, 158, 156, 31, 249, 81, 87, 247, 230, 199, 237, 96, 167, 123, 63, 243, 79, 156, 206, 203, 160, 54, 124, 68, 253, 215, 132, 235, 57, 185, 92, 238, 55, 59, 210, 104, 71, 26, 183, 180, 71, 12, 255, 224, 192, 65, 154, 72, 244, 8, 164, 10, 248, 46, 207, 30, 92, 1, 80, 244, 31, 189, 138, 88, 216, 218, 63, 100, 227, 116, 57, 119, 94, 135, 5, 126, 255, 32, 191, 163, 61, 209, 194, 88, 248, 112, 139, 173, 43, 69, 134, 3, 160, 151, 137, 25, 98, 239, 166, 19, 123, 208, 180, 31, 120, 30, 191, 75, 183, 179, 126, 180, 125, 92, 107, 105, 206, 138, 28, 67, 139, 3, 188, 230, 184, 255, 121, 13, 181, 45, 160, 114, 202, 194, 123, 87, 55, 124, 97, 164, 82, 95, 232, 216, 117, 62, 5, 90, 176, 82, 167, 52, 160, 153, 174, 168, 105, 146, 91, 248, 81, 79, 249, 97, 138, 133, 170, 245, 229, 132, 61, 5, 149, 224, 246, 194, 213, 61, 12, 109, 44, 136, 235, 95, 219, 133, 220, 27, 93, 36, 93, 124, 180, 81, 141, 152, 220, 170, 163, 229, 197, 124, 171, 232, 48, 70, 251, 106, 119, 150, 20, 16, 49, 119, 247, 42, 132, 36, 76, 254, 124, 177, 66, 175, 9, 1, 39, 92, 127, 195, 171, 198, 34, 2, 64, 144, 179, 72, 40, 151, 110, 89, 229, 42, 125, 33, 238, 16, 220, 228, 51, 203, 8, 1, 68, 145, 253, 133, 118, 93, 163, 129, 22, 13, 248, 65, 12, 4, 63, 101, 210, 70, 170, 138, 203, 14, 246, 54, 194, 195, 27, 107, 241, 175, 35, 171, 49, 52, 106, 121, 45, 36, 152, 85, 215, 132, 78, 167, 34, 18, 167, 245, 152, 133, 134, 170, 120, 182, 10, 146, 191, 37, 2, 205, 47, 125, 20, 203, 44, 88, 81, 32, 150, 223, 220, 218, 238, 254, 30, 212, 167, 221, 115, 156, 82, 226, 137, 220, 221, 97, 3, 139, 202, 33, 9, 27, 26, 126, 40, 215, 25, 126, 9, 82, 208, 49, 217, 14, 161, 81, 196, 61, 60, 87, 254, 213, 194, 81, 216, 161, 151, 209, 166, 222, 230, 24, 128, 117, 140, 92, 4, 203, 254, 170, 253, 249, 88, 90, 112, 226, 18, 44, 122, 39, 158, 158, 56, 69, 204, 159, 5, 179, 51, 197, 233, 139, 216, 102, 226, 206, 248, 15, 78, 112, 214, 126, 67, 28, 40, 38, 98, 190, 178, 206, 67, 94, 245, 254, 160, 101, 176, 32, 157, 26, 132, 83, 252, 228, 87, 242, 32, 127, 160, 112, 210, 224, 133, 149, 115, 41, 30, 16, 200, 69, 89, 81, 77, 144, 12, 106, 182, 73, 54, 28, 53, 195, 28, 216, 179, 179, 136, 35, 141, 102, 234, 177, 240, 34, 186, 106, 145, 245, 3, 84, 48, 251, 157, 245, 11, 217, 111, 227, 138, 42, 67, 114, 211, 177, 37, 103, 16, 71, 152, 72, 117, 123, 36, 213, 202, 56, 124, 227, 84, 8, 45, 229, 149, 165, 214, 69, 244, 169, 55, 68, 62, 94, 104, 228, 74, 205, 123, 222, 17, 7, 172, 158, 227, 74, 206, 149, 67, 175, 171, 251, 185, 121, 151, 223, 63, 35, 229, 32, 49, 190, 209, 120, 137, 69, 213, 214, 19, 150, 187, 177, 28, 12, 158, 153, 126, 149, 171, 167, 234, 120, 129, 109, 32, 157, 180, 75, 66, 56, 233, 115, 127, 230, 157, 32, 34, 143, 156, 31, 230, 168, 174, 125, 118, 195, 249, 243, 165, 81, 246, 10, 144, 15, 103, 139, 55, 173, 7, 59, 136, 69, 172, 54, 132, 165, 140, 78, 77, 230, 33, 169, 129, 188, 71, 209, 109, 161, 8, 57, 57, 199, 143, 31, 164, 43, 58, 130, 1, 110, 145, 31, 229, 13, 46, 149, 94, 244, 106, 76, 238, 105, 107, 1, 183, 177, 10, 61, 225, 94, 185, 116, 58, 183, 95, 225, 22, 119, 19, 248, 28, 13, 123, 125, 108, 158, 64, 184, 77, 245, 153, 162, 217, 227, 208, 41, 185, 211, 235, 41, 153, 181, 54, 166, 165, 11, 154, 55, 21, 184, 209, 192, 249, 44, 164, 160, 29, 229, 159, 82, 156, 198, 241, 183, 114, 83, 137, 186, 151, 148, 31, 21, 197, 216, 145, 32, 13, 50, 22, 241, 137, 39, 71, 28, 142, 160, 215, 107, 221, 45, 202, 104, 227, 110, 186, 12, 150, 145, 240, 51, 49, 44, 196, 115, 224, 238, 149, 189, 134, 99, 67, 241, 62, 157, 240, 114, 247, 195, 26, 200, 141, 97, 147, 249, 23, 150, 174, 10, 13, 219, 81, 73, 58, 242, 96, 250, 243, 15, 49, 218, 58, 230, 104, 252, 175, 150, 123, 86, 185, 84, 90, 198, 6, 36, 0, 99, 72, 28, 166, 238, 115, 231, 171, 249, 179, 71, 174, 68, 156, 227, 17, 198, 79, 73, 142, 99, 144, 20, 80, 62, 80, 191, 142, 46, 71, 9, 243, 6, 8, 214, 116, 72, 190, 106, 161, 19, 185, 100, 9, 187, 64, 94, 86, 203, 174, 156, 245, 222, 95, 54, 30, 148, 19, 11, 50, 112, 96, 61, 237, 159, 173, 7, 154, 127, 175, 79, 48, 97, 89, 78, 126, 66, 171, 204, 158, 195, 27, 226, 205, 222, 157, 89, 251, 90, 125, 37, 212, 27, 97, 3, 141, 247, 175, 50, 121, 7, 187, 68, 196, 181, 202, 167, 189, 57, 84, 81, 222, 23, 27, 84, 130, 176, 98, 66, 240, 207, 18, 23, 28, 163, 163, 194, 45, 37, 129, 202, 170, 97, 189, 0, 81, 238, 0, 39, 199, 163, 35, 211, 206, 247, 65, 29, 116, 242, 67, 102, 235, 13, 136, 232, 230, 114, 146, 187, 7, 254, 142, 26, 121, 16, 237, 5, 160, 201, 114, 94, 178, 199, 95, 212, 241, 45, 112, 180, 188, 72, 86, 114, 189, 155, 149, 149, 163, 210, 112, 101, 12, 69, 225, 75, 202, 223, 28, 242, 90, 215, 156, 169, 224, 245, 135, 128, 92, 148, 217, 131, 208, 255, 25, 135, 117, 136, 5, 104, 185, 249, 161, 228, 214, 16, 105, 204, 9, 182, 135, 153, 220, 101, 244, 160, 207, 58, 182, 118, 185, 240, 57, 245, 123, 13, 112, 182, 106, 229, 220, 90, 29, 86, 215, 96, 147, 232, 2, 55, 131, 225, 137, 68, 245, 89, 141, 252, 97, 3, 129, 155, 216, 223, 98, 116, 45, 78, 85, 141, 161, 74, 215, 7, 150, 171, 225, 59, 78, 221, 152, 236, 14, 117, 100, 208, 158, 86, 13, 185, 124, 87, 157, 111, 40, 187, 182, 124, 173, 71, 173, 23, 199, 52, 155, 190, 134, 11, 23, 64, 25, 215, 39, 115, 231, 173, 77, 72, 114, 54, 252, 116, 178, 59, 221, 106, 241, 119, 254, 30, 226, 241, 204, 233, 113, 197, 96, 146, 0, 41, 67, 3, 231, 126, 12, 218, 202, 22, 171, 114, 249, 176, 134, 160, 19, 216, 31, 229, 118, 226, 62, 242, 126, 126, 42, 127, 130, 68, 218, 218, 81, 202, 106, 217, 191, 25, 177, 82, 97, 81, 36, 232, 137, 58, 90, 216, 190, 117, 235, 20, 194, 144, 76, 178, 27, 213, 13, 208, 18, 29, 118, 126, 49, 98, 203, 179, 128, 237, 100, 32, 242, 189, 212, 6, 210, 210, 188, 161, 205, 13, 124, 119, 13, 215, 112, 41, 183, 176, 215, 168, 210, 182, 111, 1, 115, 2, 239, 141, 8, 177, 124, 112, 48, 197, 2, 239, 11, 99, 4, 36, 77, 69, 47, 244, 19, 153, 61, 19, 2, 96, 176, 7, 112, 122, 131, 169, 25, 189, 116, 171, 49, 12, 121, 162, 79, 154, 74, 251, 50, 233, 182, 63, 180, 224, 118, 49, 253, 21, 20, 16, 31, 144, 184, 93, 174, 231, 244, 183, 13, 49, 225, 189, 211, 73, 185, 49, 110, 142, 25, 226, 45, 176, 233, 204, 74, 33, 16, 205, 88, 131, 92, 157, 170, 175, 68, 170, 61, 53, 116, 165, 16, 27, 182, 160, 181, 87, 241, 15, 151, 85, 107, 76, 167, 129, 25, 172, 127, 184, 138, 153, 222, 228, 125, 64, 44, 45, 32, 12, 227, 148, 106, 152, 83, 240, 166, 54, 235, 32, 190, 12, 242, 164, 123, 189, 53, 194, 141, 104, 43, 202, 110, 4, 168, 119, 245, 232, 179, 178, 198, 1, 224, 87, 86, 160, 31, 19, 140, 233, 102, 191, 204, 4, 98, 138, 163, 191, 106, 24, 213, 47, 208, 82, 137, 132, 131, 16, 253, 84, 25, 144, 90, 159, 148, 16, 196, 84, 166, 61, 160, 101, 229, 227, 93, 118, 59, 87, 66, 16, 128, 59, 96, 131, 250, 20, 184, 150, 205, 91, 227, 201, 62, 35, 79, 180, 172, 173, 85, 197, 106, 153, 238, 229, 60, 204, 65, 193, 230, 94, 101, 177, 134, 6, 165, 53, 171, 142, 208, 155, 2, 11, 4, 202, 127, 54, 17, 142, 117, 227, 121, 128, 204, 192, 147, 147, 92, 189, 5, 224, 148, 72, 18, 83, 101, 126, 124, 228, 153, 242, 123, 229, 247, 92, 221, 6, 73, 227, 250, 87, 167, 194, 129, 187, 73, 38, 185, 109, 217, 240, 193, 88, 50, 178, 180, 151, 54, 197, 187, 137, 190, 166, 233, 1, 103, 204, 88, 31, 127, 185, 29, 65, 1, 29, 254, 223, 14, 83, 167, 215, 114, 248, 30, 173, 89, 173, 187, 69, 5, 105, 117, 15, 106, 94, 173, 63, 227, 25, 230, 190, 136, 168, 177, 175, 107, 91, 126, 254, 34, 188, 25, 118, 48, 12, 226, 130, 153, 162, 57, 47, 181, 212, 79, 160, 97, 64, 157, 246, 90, 53, 43, 149, 76, 102, 15, 195, 107, 58, 242, 84, 172, 29, 81, 198, 113, 81, 251, 138, 182, 154, 111, 30, 171, 129, 56, 17, 45, 214, 153, 112, 117, 203, 174, 40, 38, 234, 236, 32, 4, 112, 225, 26, 187, 195, 246, 252, 9, 218, 69, 160, 223, 178, 54, 148, 81, 8, 134, 151, 75, 248, 63, 224, 240, 48, 75, 250, 221, 85, 46, 100, 50, 3, 70, 64, 102, 111, 160, 155, 233, 59, 147, 184, 57, 61, 6, 126, 79, 176, 16, 185, 94, 166, 33, 135, 78, 42, 75, 140, 208, 140, 44, 153, 187, 64, 103, 119, 160, 236, 16, 239, 74, 218, 219, 212, 207, 110, 53, 30, 76, 248, 40, 111, 98, 44, 20, 113, 204, 233, 109, 135, 96, 107, 39, 163, 203, 125, 45, 157, 152, 71, 239, 175, 174, 159, 147, 80, 111, 93, 38, 253, 228, 154, 225, 181, 101, 12, 241, 127, 65, 49, 189, 5, 85, 151, 237, 213, 143, 14, 104, 138, 54, 52, 27, 4, 132, 67, 35, 156, 86, 157, 73, 16, 229, 222, 245, 110, 79, 165, 179, 56, 179, 53, 218, 229, 100, 58, 87, 149, 48, 231, 64, 63, 115, 67, 3, 172, 6, 186, 115, 154, 60, 53, 214, 152, 149, 89, 234, 37, 143, 82, 255, 64, 28, 183, 93, 112, 39, 70, 185, 57, 0, 199, 9, 61, 175, 219, 41, 76, 37, 176, 82, 125, 65, 53, 160, 214, 105, 62, 153, 244, 222, 96, 205, 6, 178, 85, 41, 240, 113, 0, 96, 149, 38, 3, 195, 18, 152, 41, 246, 3, 103, 29, 110, 134, 30, 101, 75, 46, 103, 199, 184, 20, 230, 8, 55, 120, 4, 229, 168, 35, 43, 7, 28, 161, 143, 87, 27, 87, 79, 255, 186, 44, 195, 158, 155, 181, 119, 81, 172, 217, 107, 95, 98, 55, 243, 186, 66, 105, 48, 224, 123, 232, 84, 156, 20, 10, 156, 208, 204, 52, 34, 228, 136, 97, 242, 200, 246, 211, 67, 202, 40, 241, 91, 92, 253, 9, 54, 72, 131, 221, 106, 178, 32, 44, 182, 4, 225, 193, 37, 20, 249, 249, 231, 10, 206, 18, 71, 254, 221, 187, 172, 88, 204, 6, 127, 138, 102, 7, 208, 75, 147, 219, 199, 177, 79, 36, 170, 101, 207, 177, 109, 95, 143, 217, 41, 199, 80, 183, 201, 2, 254, 12, 55, 23, 198, 14, 255, 69, 245, 138, 155, 129, 227, 167, 168, 130, 156, 135, 14, 96, 93, 48, 99, 143, 107, 126, 92, 117, 143, 112, 108, 193, 228, 84, 13, 41, 186, 27, 172, 92, 201, 149, 116, 19, 112, 197, 116, 209, 128, 102, 1, 55, 152, 177, 28, 37, 34, 50, 83, 41, 199, 74, 178, 59, 111, 67, 118, 35, 252, 36, 33, 87, 28, 170, 17, 215, 47, 90, 154, 124, 137, 15, 14, 211, 59, 75, 59, 30, 77, 0, 49, 37, 225, 191, 87, 101, 127, 214, 227, 160, 99, 174, 234, 82, 148, 235, 16, 241, 219, 147, 170, 127, 221, 250, 116, 39, 218, 156, 72, 227, 172, 55, 0, 79, 188, 76, 51, 222, 232, 24, 36, 62, 94, 154, 3, 61, 230, 146, 114, 253, 0, 128, 58, 253, 90, 72, 211, 242, 38, 39, 133, 153, 161, 119, 105, 195, 152, 225, 208, 105, 140, 80, 217, 186, 196, 157, 21, 116, 230, 116, 139, 25, 159, 143, 118, 128, 77, 201, 238, 247, 228, 15, 168, 4, 133, 148, 21, 148, 12, 44, 241, 7, 115, 17, 129, 176, 202, 46, 130, 122, 129, 235, 141, 223, 85, 21, 199, 65, 181, 169, 52, 174, 161, 153, 62, 25, 164, 115, 213, 89, 138, 199, 103, 79, 200, 165, 135, 249, 244, 27, 209, 178, 240, 129, 211, 61, 9, 111, 157, 147, 119, 36, 119, 255, 110, 130, 84, 49, 210, 225, 247, 100, 26, 121, 127, 163, 160, 26, 79, 99, 24, 77, 65, 32, 178, 109, 36, 27, 253, 173, 110, 183, 11, 14, 211, 57, 130, 254, 124, 104, 165, 219, 31, 70, 97, 14, 194, 39, 61, 26, 141, 125, 228, 126, 194, 184, 101, 160, 204, 106, 128, 144, 106, 103, 171, 18, 246, 129, 220, 85, 172, 151, 123, 5, 73, 155, 192, 175, 91, 157, 239, 61, 237, 116, 170, 65, 233, 56, 19, 49, 114, 168, 190, 3, 214, 53, 250, 90, 213, 244, 88, 101, 30, 229, 248, 124, 15, 71, 141, 27, 172, 235, 21, 129, 211, 72, 61, 172, 112, 170, 128, 135, 96, 196, 221, 255, 27, 176, 105, 188, 183, 121, 33, 37, 149, 53, 131, 226, 233, 29, 167, 234, 218, 109, 53, 185, 152, 36, 248, 53, 61, 235, 78, 21, 201, 214, 210, 163, 12, 251, 187, 45, 188, 137, 126, 127, 237, 92, 234, 91, 240, 225, 38, 194, 57, 213, 251, 237, 171, 30, 99, 52, 14, 49, 84, 101, 252, 237, 7, 166, 122, 114, 32, 107, 32, 207, 239, 136, 168, 178, 12, 11, 241, 233, 230, 146, 132, 18, 83, 233, 41, 172, 17, 6, 161, 42, 113, 87, 40, 255, 185, 1, 146, 128, 5, 240, 126, 131, 71, 42, 54, 124, 205, 2, 122, 71, 30, 222, 229, 40, 134, 142, 102, 97, 239, 151, 177, 1, 230, 231, 49, 123, 219, 28, 129, 91, 152, 112, 13, 154, 81, 197, 226, 255, 112, 158, 178, 177, 55, 181, 108, 138, 185, 245, 29, 186, 21, 73, 188, 209, 154, 200, 89, 116, 235, 198, 144, 36, 87, 248, 22, 7, 200, 122, 7, 148, 44, 42, 87, 140, 238, 204, 95, 231, 252, 0, 136, 0, 22, 39, 70, 123, 125, 165, 113, 227, 172, 146, 163, 128, 158, 36, 52, 91, 19, 36, 245, 27, 150, 138, 141, 11, 67, 239, 224, 65, 24, 116, 101, 7, 39, 46, 142, 172, 164, 243, 148, 0, 33, 226, 59, 47, 203, 137, 156, 241, 66, 250, 157, 30, 204, 101, 143, 134, 98, 238, 155, 226, 25, 184, 136, 219, 89, 100, 193, 11, 143, 71, 139, 243, 230, 151, 0, 249, 1, 78, 26, 32, 93, 104, 157, 67, 97, 164, 248, 86, 124, 146, 93, 74, 222, 228, 167, 55, 53, 100, 135, 216, 109, 13, 64, 37, 106, 177, 200, 200, 182, 92, 251, 69, 31, 243, 89, 80, 198, 14, 132, 203, 72, 103, 28, 104, 217, 24, 97, 223, 113, 11, 29, 178, 191, 210, 46, 162, 255, 68, 99, 8, 237, 213, 162, 152, 193, 183, 121, 203, 19, 108, 182, 29, 86, 26, 192, 103, 220, 103, 205, 154, 179, 197, 9, 22, 73, 127, 175, 146, 38, 119, 210, 0, 24, 180, 21, 245, 215, 204, 91, 186, 119, 138, 183, 239, 15, 155, 231, 248, 133, 39, 24, 101, 144, 236, 10, 230, 54, 174, 227, 73, 21, 110, 10, 160, 241, 232, 131, 14, 212, 127, 232, 59, 122, 65, 146, 54, 163, 9, 189, 190, 121, 88, 170, 62, 194, 14, 204, 152, 245, 38, 131, 37, 91, 81, 72, 114, 29, 115, 239, 182, 56, 44, 156, 159, 177, 180, 82, 160, 93, 97, 86, 183, 236, 50, 95, 85, 39, 71, 181, 225, 152, 143, 63, 123, 117, 34, 44, 109, 160, 166, 229, 240, 91, 138, 102, 54, 180, 173, 44, 50, 80, 42, 124, 7, 50, 124, 211, 239, 21, 94, 197, 185, 239, 213, 107, 142, 64, 95, 124, 125, 17, 180, 97, 189, 101, 52, 48, 19, 112, 12, 70, 9, 212, 177, 54, 118, 66, 84, 147, 236, 248, 26, 124, 95, 103, 135, 254, 124, 49, 112, 186, 99, 120, 90, 8, 194, 191, 88, 57, 242, 65, 61, 10, 104, 246, 197, 252, 19, 159, 58, 194, 75, 173, 242, 103, 8, 115, 84, 69, 238, 149, 26, 15, 159, 182, 141, 132, 119, 70, 29, 53, 20, 143, 46, 163, 204, 6, 236, 59, 45, 185, 172, 89, 119, 83, 38, 144, 36, 222, 96, 151, 26, 99, 195, 163, 170, 133, 92, 159, 214, 53, 150, 116, 90, 176, 69, 145, 130, 15, 172, 140, 217, 215, 101, 163, 115, 161, 65, 101, 8, 7, 183, 113, 213, 134, 58, 175, 130, 251, 143, 173, 248, 168, 135, 60, 159, 30, 194, 68, 208, 119, 120, 2, 40, 178, 227, 247, 161, 77, 47, 136, 46, 244, 163, 72, 65, 158, 25, 225, 195, 61, 132, 182, 204, 177, 186, 200, 81, 2, 65, 105, 212, 72, 94, 203, 232, 217, 182, 123, 251, 228, 160, 1, 161, 204, 123, 20, 37, 1, 77, 208, 179, 45, 149, 181, 122, 102, 190, 123, 213, 164, 231, 41, 216, 130, 234, 248, 208, 251, 252, 220, 84, 209, 67, 47, 61, 220, 5, 142, 162, 26, 236, 121, 142, 248, 132, 255, 65, 122, 203, 196, 102, 191, 187, 2, 195, 127, 255, 193, 92, 49, 91, 186, 154, 39, 156, 29, 211, 172, 49, 104, 245, 114, 153, 223, 211, 199, 249, 35, 130, 160, 128, 0, 152, 176, 183, 20, 236, 113, 193, 108, 26, 255, 11, 237, 102, 133, 245, 94, 115, 114, 10, 89, 229, 214, 221, 99, 149, 30, 99, 37, 246, 10, 26, 26, 39, 92, 123, 170, 73, 211, 127, 227, 54, 30, 86, 133, 159, 112, 225, 91, 148, 100, 174, 149, 75, 143, 14, 140, 20, 44, 64, 212, 5, 243, 8, 116, 63, 30, 97, 42, 123, 20, 73, 212, 85, 207, 83, 122, 27, 251, 233, 84, 10, 17, 236, 232, 83, 200, 127, 119, 143, 163, 204, 220, 167, 59, 231, 20, 106, 186, 222, 191, 8, 40, 234, 21, 25, 180, 13, 116, 250, 152, 224, 174, 75, 3, 205, 38, 173, 215, 236, 151, 185, 121, 254, 244, 154, 239, 17, 53, 106, 164, 61, 49, 116, 216, 118, 94, 150, 35, 181, 26, 238, 66, 49, 211, 221, 132, 146, 166, 115, 39, 136, 36, 205, 230, 179, 31, 197, 51, 148, 165, 109, 38, 70, 37, 148, 52, 44, 209, 250, 98, 58, 246, 225, 103, 198, 101, 26, 25, 196, 207, 8, 166, 21, 88, 252, 175, 253, 10, 88, 107, 157, 19, 225, 61, 12, 246, 221, 37, 239, 186, 167, 137, 142, 135, 222, 128, 174, 62, 95, 216, 38, 141, 157, 45, 232, 97, 217, 173, 203, 234, 116, 129, 69, 206, 189, 94, 221, 12, 54, 139, 186, 247, 184, 16, 200, 121, 244, 104, 8, 7, 35, 111, 47, 188, 10, 140, 92, 73, 143, 206, 203, 72, 122, 184, 20, 102, 197, 130, 64, 150, 63, 96, 239, 8, 132, 111, 217, 84, 91, 198, 32, 43, 100, 138, 241, 15, 160, 42, 190, 253, 193, 184, 164, 124, 29, 210, 96, 67, 224, 221, 182, 29, 218, 129, 149, 29, 128, 174, 98, 88, 88, 125, 56, 40, 255, 120, 5, 0, 87, 174, 42, 150, 90, 112, 201, 183, 169, 19, 57, 195, 191, 12, 58, 244, 235, 132, 25, 145, 72, 146, 214, 8, 125, 100, 135, 12, 5, 102, 97, 248, 174, 24, 159, 90, 33, 43, 187, 6, 61, 212, 241, 225, 190, 219, 252, 197, 123, 129, 164, 108, 123, 55, 230, 4, 153, 166, 105, 234, 15, 85, 216, 23, 56, 32, 3, 41, 110, 68, 146, 172, 133, 202, 98, 41, 7, 47, 152, 35, 255, 168, 106, 241, 226, 222, 77, 244, 52, 185, 65, 252, 227, 32, 66, 38, 11, 172, 60, 28, 28, 103, 84, 1, 1, 205, 182, 190, 28, 189, 102, 253, 43, 1, 191, 148, 116, 10, 227, 18, 81, 93, 80, 239, 157, 232, 215, 180, 163, 165, 161, 109, 177, 71, 150, 244, 144, 208, 160, 110, 22, 174, 60, 206, 43, 103, 121, 55, 103, 114, 115, 173, 238, 13, 10, 227, 251, 41, 176, 216, 158, 229, 216, 55, 234, 128, 128, 20, 167, 106, 181, 86, 163, 130, 215, 110, 149, 191, 10, 227, 215, 8, 214, 154, 178, 181, 15, 19, 0, 247, 250, 97, 74, 43, 157, 55, 94, 174, 41, 41, 9, 199, 97, 20, 91, 32, 18, 10, 43, 98, 240, 247, 203, 20, 250, 117, 160, 44, 229, 202, 187, 64, 54, 124, 15, 184, 169, 129, 27, 160, 240, 26, 61, 255, 60, 166, 60, 144, 209, 84, 55, 187, 186, 168, 13, 124, 125, 29, 17, 100, 249, 227, 62, 205, 78, 179, 163, 168, 139, 168, 21, 38, 83, 239, 151, 74, 43, 66, 2, 92, 72, 71, 94, 216, 134, 238, 20, 45, 158, 213, 164, 73, 57, 80, 47, 198, 184, 130, 223, 227, 71, 132, 133, 235, 177, 85, 174, 142, 124, 172, 200, 54, 229, 40, 126, 60, 76, 92, 216, 153, 56, 241, 174, 66, 141, 90, 226, 3, 30, 68, 234, 71, 187, 163, 112, 146, 255, 22, 143, 170, 204, 3, 127, 179, 81, 139, 160, 37, 77, 246, 128, 220, 196, 158, 153, 73, 177, 65, 199, 119, 29, 197, 144, 130, 248, 206, 155, 253, 108, 213, 124, 7, 223, 221, 162, 146, 134, 242, 65, 99, 162, 107, 120, 247, 214, 207, 96, 150, 169, 131, 208, 218, 221, 28, 24, 112, 208, 23, 1, 130, 142, 232, 56, 104, 45, 33, 158, 95, 255, 123, 31, 74, 76, 120, 178, 155, 213, 6, 195, 164, 8, 8, 69, 241, 197, 127, 83, 169, 21, 167, 19, 94, 143, 252, 33, 159, 248, 241, 170, 153, 147, 1, 149, 199, 201, 131, 170, 79, 236, 212, 209, 143, 107, 98, 24, 123, 56, 33, 193, 85, 247, 64, 225, 135, 210, 78, 145, 57, 16, 145, 71, 170, 20, 133, 87, 235, 4, 166, 239, 100, 82, 235, 81, 50, 223, 9, 193, 52, 49, 86, 129, 190, 196, 82, 165, 107, 63, 115, 161, 98, 33, 20, 193, 29, 42, 151, 205, 252, 124, 72, 245, 48, 181, 67, 7, 13, 21, 127, 59, 226, 188, 144, 129, 112, 244, 192, 121, 213, 80, 42, 196, 1, 13, 107, 108, 78, 0, 40, 121, 225, 148, 237, 234, 209, 216, 238, 9, 147, 226, 254, 96, 89, 212, 72, 193, 106, 75, 135, 74, 227, 67, 255, 92, 191, 81, 188, 124, 226, 149, 152, 142, 15, 159, 195, 238, 114, 55, 255, 166, 157, 230, 59, 148, 170, 166, 151, 65, 213, 104, 253, 253, 112, 150, 82, 147, 137, 27, 214, 100, 247, 65, 81, 92, 47, 86, 217, 7, 45, 120, 81, 130, 31, 236, 243, 76, 78, 3, 45, 105, 172, 220, 71, 48, 220, 94, 196, 249, 163, 193, 133, 50, 236, 205, 20, 55, 2, 63, 14, 127, 69, 113, 212, 204, 12, 58, 79, 89, 86, 29, 61, 199, 201, 64, 149, 6, 144, 182, 150, 129, 31, 18, 167, 120, 248, 82, 107, 25, 143, 128, 27, 161, 28, 25, 153, 183, 217, 238, 78, 186, 106, 92, 27, 202, 219, 165, 96, 0, 216, 234, 169, 73, 101, 39, 182, 113, 217, 240, 170, 116, 172, 221, 250, 233, 48, 49, 242, 83, 227, 92, 181, 184, 72, 230, 180, 21, 15, 108, 135, 25, 38, 153, 25, 124, 227, 26, 149, 73, 236, 39, 211, 244, 149, 58, 183, 132, 26, 223, 219, 174, 144, 117, 233, 219, 165, 205, 157, 159, 222, 184, 52, 47, 241, 201, 123, 65, 24, 44, 55, 215, 177, 168, 250, 179, 115, 190, 227, 123, 158, 163, 179, 224, 69, 196, 66, 207, 254, 243, 101, 221, 193, 140, 250, 4, 28, 222, 52, 96, 138, 160, 33, 218, 64, 118, 214, 234, 201, 152, 148, 91, 178, 111, 107, 144, 142, 6, 182, 102, 72, 188, 34, 213, 181, 26, 223, 58, 255, 103, 81, 17, 47, 169, 11, 245, 224, 123, 148, 215, 237, 186, 107, 75, 152, 90, 202, 166, 22, 149, 197, 5, 246, 238, 78, 76, 229, 106, 199, 94, 127, 195, 0, 45, 82, 6, 159, 103, 96, 138, 231, 71, 46, 107, 59, 216, 39, 43, 12, 221, 27, 214, 56, 155, 145, 66, 187, 169, 250, 235, 78, 211, 179, 239, 183, 198, 163, 93, 5, 196, 24, 174, 143, 225, 106, 139, 89, 98, 13, 127, 207, 184, 194, 30, 1, 165, 198, 169, 8, 197, 118, 86, 163, 221, 138, 23, 209, 61, 116, 79, 99, 233, 43, 130, 60, 244, 85, 229, 243, 172, 123, 148, 200, 120, 192, 127, 211, 52, 11, 159, 41, 95, 212, 230, 188, 169, 156, 137, 29, 212, 12, 148, 168, 148, 133, 243, 44, 241, 139, 127, 24, 246, 220, 227, 125, 209, 97, 60, 52, 162, 192, 146, 49, 161, 92, 138, 112, 189, 128, 59, 126, 125, 46, 207, 60, 79, 231, 174, 152, 209, 68, 223, 205, 2, 38, 14, 91, 116, 159, 255, 28, 27, 178, 248, 164, 104, 158, 79, 69, 214, 234, 157, 12, 75, 163, 83, 253, 245, 202, 61, 213, 176, 6, 197, 230, 29, 208, 166, 253, 194, 254, 235, 29, 141, 241, 70, 249, 15, 62, 0, 148, 163, 135, 52, 122, 40, 96, 87, 31, 179, 152, 51, 216, 133, 184, 122, 198, 203, 60, 115, 218, 191, 193, 16, 178, 25, 148, 252, 112, 104, 103, 252, 36, 92, 221, 28, 179, 43, 199, 198, 151, 128, 100, 252, 217, 161, 249, 34, 201, 172, 118, 52, 180, 252, 104, 7, 223, 44, 116, 102, 212, 21, 40, 224, 184, 55, 163, 210, 21, 207, 161, 239, 51, 54, 155, 41, 133, 18, 67, 48, 3, 165, 130, 251, 4, 79, 214, 57, 72, 130, 157, 212, 144],\n    Ib = [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 26, 29, 31, 34, 36, 39, 41, 44, 46, 49, 51, 54, 56, 59, 61, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 212, 213, 214, 215, 216, 217, 219, 220, 221, 222, 223, 224, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255],\n    yb = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 76, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 90, 91, 92, 93, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 115, 116, 117, 118, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132, 134, 135, 136, 137, 139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 173, 174, 175, 176, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 195, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 219, 220, 222, 223, 224, 226, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255],\n    Cb = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 133, 135, 136, 138, 139, 140, 142, 143, 144, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 205, 205, 206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 219, 219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 239, 239, 240, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 254, 255];\n  class Ab extends Eb {\n    constructor(e, t, i, r) {\n      super(e, Rb, i, r), mp(this, \"inputTexture\", void 0), mp(this, \"lightLevel\", .1), mp(this, \"rednessLevel\", .5), mp(this, \"mskin_he_max\", 175 / 180 * 3.141593), mp(this, \"mskin_he_min\", 115 / 180 * 3.141593), mp(this, \"mskin_hc_max\", 173 / 180 * 3.141593), mp(this, \"mskin_hc_min\", 116 / 180 * 3.141593), mp(this, \"mskin_hc_axis\", 2.04203545), mp(this, \"mfacts_rotate_c\", 0), mp(this, \"mfacts_rotate_le\", 0), mp(this, \"mfacts_rotate_ge\", 0), mp(this, \"tab_addr\", null), mp(this, \"lutTextures\", []), this.inputTexture = t, this.init();\n    }\n    setUniforms() {\n      const e = this.gl.getUniformLocation(this.program, \"u_flipY\"),\n        t = this.gl.getUniformLocation(this.program, \"u_denoiseLevel\");\n      this.gl.uniform1f(t, this.denoiseLevel), this.gl.uniform1f(e, 1);\n      const i = this.gl.getUniformLocation(this.program, \"light\");\n      this.gl.uniform1f(i, this.lightLevel);\n      const r = this.gl.getUniformLocation(this.program, \"redness\");\n      this.gl.uniform1f(r, this.rednessLevel);\n      const n = this.gl.getUniformLocation(this.program, \"skin_he_max\"),\n        o = this.gl.getUniformLocation(this.program, \"skin_he_min\"),\n        s = this.gl.getUniformLocation(this.program, \"skin_hc_max\"),\n        a = this.gl.getUniformLocation(this.program, \"skin_hc_min\"),\n        c = this.gl.getUniformLocation(this.program, \"skin_hc_axis\"),\n        d = this.gl.getUniformLocation(this.program, \"facts_rotate_c\"),\n        u = this.gl.getUniformLocation(this.program, \"facts_rotate_le\"),\n        l = this.gl.getUniformLocation(this.program, \"facts_rotate_ge\");\n      this.gl.uniform1f(n, this.mskin_he_max), this.gl.uniform1f(o, this.mskin_he_min), this.gl.uniform1f(s, this.mskin_hc_max), this.gl.uniform1f(a, this.mskin_hc_min), this.gl.uniform1f(c, this.mskin_hc_axis), this.gl.uniform1f(d, this.mfacts_rotate_c), this.gl.uniform1f(u, this.mfacts_rotate_le), this.gl.uniform1f(l, this.mfacts_rotate_ge);\n      const h = this.gl.getUniformLocation(this.program, \"u_originImage\");\n      this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.uniform1i(h, 2);\n      const p = [\"lighten_lut\"],\n        _ = [this.gl.TEXTURE3];\n      for (let e = 0; e < p.length; e++) {\n        const t = this.gl.getUniformLocation(this.program, p[e]);\n        this.gl.activeTexture(_[e]), this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e]), this.gl.uniform1i(t, e + 3);\n      }\n    }\n    setParameters(e) {\n      void 0 !== e.denoiseLevel && (this.denoiseLevel = e.denoiseLevel), void 0 !== e.lightLevel && (this.lightLevel = e.lightLevel), void 0 !== e.rednessLevel && (this.rednessLevel = e.rednessLevel, this.updateRedness(this.rednessLevel)), e.lighteningContrastLevel && this.updateLut(e.lighteningContrastLevel);\n    }\n    init() {\n      this.tab_addr = new Uint8Array(yb);\n      const e = [this.tab_addr],\n        t = [256],\n        i = [1];\n      for (let r = 0; r < e.length; r++) {\n        const n = this.gl.createTexture();\n        if (!n) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"create lut texture failed\");\n        this.gl.bindTexture(this.gl.TEXTURE_2D, n), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, t[r], i[r], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, e[r]), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.lutTextures.push(n);\n      }\n    }\n    updateRedness(e) {\n      const t = 3.141593;\n      let i,\n        r,\n        n = e,\n        o = n;\n      n > 1 && (n = 1), n < 0 && (n = 0), o > 1 && (o = 1), o < 0 && (o = 0), this.mfacts_rotate_c = .8 * n, o < .8 && (o = 0), this.mskin_he_max = 175 / 180 * t, this.mskin_hc_max = 173 / 180 * t, this.mskin_he_min = (115 - 4 * o) / 180 * t, this.mskin_hc_min = (116 - 4 * o) / 180 * t, this.mskin_hc_axis = (117 - 4 * o) / 180 * t, this.mskin_hc_axis < this.mskin_hc_min && (this.mskin_hc_axis = this.mskin_hc_min), this.mskin_hc_min < t / 2 && (this.mskin_hc_min = t / 2), this.mskin_hc_axis < t / 2 && (this.mskin_hc_axis = t / 2), this.mskin_he_min < t / 2 && (this.mskin_he_min = t / 2), this.mskin_hc_max > t && (this.mskin_hc_max = t), this.mskin_hc_axis > t && (this.mskin_hc_axis = t), this.mskin_he_max > t && (this.mskin_he_max = t), i = this.mskin_he_max - this.mskin_hc_max, r = this.mskin_hc_max - this.mskin_hc_axis, this.mfacts_rotate_ge = i > .01 ? this.mfacts_rotate_c * r / i : this.mfacts_rotate_c, i = this.mskin_hc_min - this.mskin_he_min, r = this.mskin_hc_axis - this.mskin_hc_min, this.mfacts_rotate_le = i > .01 ? this.mfacts_rotate_c * r / i : this.mfacts_rotate_c;\n    }\n    updateLut(e) {\n      let t = null;\n      if (0 === e && (t = yb), 1 === e && (t = Cb), 2 === e && (t = Ib), !t) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"invalid ylut_table value:\" + e);\n      this.tab_addr = new Uint8Array(t);\n      const i = [this.tab_addr],\n        r = [256],\n        n = [1];\n      for (let e = 0; e < i.length; e++) this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e]), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, r[e], n[e], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, i[e]);\n    }\n  }\n  class Ob {\n    constructor() {\n      mp(this, \"gl\", null), mp(this, \"canvas\", null), mp(this, \"programs\", []), mp(this, \"commonProgram\", null), mp(this, \"inputTexture\", null), mp(this, \"outputTextures\", []), mp(this, \"fbos\", []), mp(this, \"originalFrameWidth\", 0), mp(this, \"originalFrameHeight\", 0), mp(this, \"enableBeauty\", !1), mp(this, \"denoiseLevel\", 5), mp(this, \"lightLevel\", .35), mp(this, \"rednessLevel\", .5), mp(this, \"lighteningContrastLevel\", 1);\n    }\n    setEnableBeauty(e) {\n      this.enableBeauty = !!e;\n    }\n    init(e, t, i) {\n      if (!jg().supportWebGL) throw new vE(TE.NOT_SUPPORTED, \"your browser is not support webGL\");\n      if (this.gl = i.getContext(\"webgl\"), !this.gl) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"can not get webgl context\");\n      if (this.initGL(e, t), !this.inputTexture) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"can not find input texture\");\n      this.canvas = i, this.programs.push(new _b(this.gl)), this.programs.push(new mb(this.gl, e, t)), this.programs.push(new Sb(this.gl, e, t)), this.programs.push(new vb(this.gl, e, t)), this.programs.push(new Ab(this.gl, this.inputTexture, e, t)), this.commonProgram = this.programs[0].program, this.setDenoiseLevel(this.denoiseLevel), this.setLightLevel(this.lightLevel), this.setRednessLevel(this.rednessLevel), this.setContrastLevel(this.lighteningContrastLevel);\n    }\n    render(e) {\n      if (!this.gl || !this.commonProgram || !this.canvas) return void NE.warning(\"video effect manager is not init!\");\n      let t = 0;\n      if (this.originalFrameHeight === e.videoWidth && this.originalFrameWidth === e.videoHeight) t = 2;else if (this.originalFrameHeight !== e.videoHeight || this.originalFrameWidth !== e.videoWidth) {\n        if (NE.debug(\"beauty effect: resolution changed \".concat(this.originalFrameWidth, \"x\").concat(this.originalFrameHeight, \" -> \").concat(e.videoWidth, \"x\").concat(e.videoHeight)), 0 === e.videoHeight || 0 === e.videoWidth) return void NE.debug(\"beauty effect: skip 0 resolution frame\");\n        this.canvas.width = e.videoWidth, this.canvas.height = e.videoHeight, e.setAttribute(\"width\", e.videoWidth.toString()), e.setAttribute(\"height\", e.videoHeight.toString()), this.release(), this.init(e.videoWidth, e.videoHeight, this.canvas);\n      }\n      this.gl.viewport(0, 0, e.videoWidth, e.videoHeight), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e);\n      const i = this.enableBeauty ? this.programs.length - 1 : 0;\n      for (let e = 0; e <= i; e++) {\n        const i = this.programs[e].program;\n        this.gl.useProgram(i);\n        const r = this.gl.getUniformLocation(i, \"u_image\");\n        this.programs[e].setUniforms(), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbos[t + e % 2]), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.outputTextures[t + e % 2]), this.gl.uniform1i(r, 0);\n      }\n      this.gl.useProgram(this.commonProgram);\n      const r = this.gl.getUniformLocation(this.commonProgram, \"u_flipY\");\n      this.gl.uniform1f(r, -1), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    }\n    setDenoiseLevel(e) {\n      this.programs.forEach(t => {\n        t instanceof Eb && t.setParameters({\n          denoiseLevel: e\n        });\n      }), this.denoiseLevel = e;\n    }\n    setLightLevel(e) {\n      this.programs.forEach(t => {\n        t instanceof Eb && t.setParameters({\n          lightLevel: e\n        });\n      }), this.lightLevel = e;\n    }\n    setRednessLevel(e) {\n      this.programs.forEach(t => {\n        t instanceof Eb && t.setParameters({\n          rednessLevel: e\n        });\n      }), this.rednessLevel = e;\n    }\n    setContrastLevel(e) {\n      this.programs.forEach(t => {\n        t instanceof Eb && t.setParameters({\n          lighteningContrastLevel: e\n        });\n      }), this.lighteningContrastLevel = e;\n    }\n    setSize(e, t) {\n      this.programs.forEach(i => {\n        i instanceof Eb && i.setSize(e, t);\n      });\n    }\n    release() {\n      this.gl = null, this.commonProgram = null, this.inputTexture = null, this.programs = [], this.outputTextures = [], this.fbos = [];\n    }\n    initGL(e, t) {\n      if (!this.gl) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"can not find webgl context\");\n      this.inputTexture = this.gl.createTexture(), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n      for (let i = 0; i < 4; i++) {\n        const r = this.gl.createTexture();\n        if (!r) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"create texture failed\");\n        this.gl.bindTexture(this.gl.TEXTURE_2D, r), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), i < 2 ? this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, e, t, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null) : this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, t, e, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n        const n = this.gl.createFramebuffer();\n        if (!n) throw new vE(TE.WEBGL_INTERNAL_ERROR, \"create frame buffer failed\");\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, n), this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, r, 0), this.outputTextures.push(r), this.fbos.push(n);\n      }\n      this.gl.viewport(0, 0, e, t), this.originalFrameWidth = e, this.originalFrameHeight = t;\n    }\n  }\n  class bb {\n    constructor() {\n      mp(this, \"targetFrameRate\", 0), mp(this, \"recordedFrameCount\", 0), mp(this, \"recordingTime\", 2), mp(this, \"recordID\", void 0);\n    }\n    async startRecordBeautyEffectOutput(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4;\n      if (this.recordID) throw new vE(TE.UNEXPECTED_ERROR, \"another beauty effect recording is in progress\");\n      const i = MR(6, \"\");\n      return this.recordID = i, this.targetFrameRate = e, this.recordedFrameCount = 0, this.recordingTime = t, await LR(1e3 * this.recordingTime), this.recordID !== i ? (this.recordID = void 0, !0) : (this.recordID = void 0, this.recordedFrameCount < this.targetFrameRate * this.recordingTime / 2 ? (NE.warning(\"detect beauty effect overload, current framerate\", this.recordedFrameCount / 2), !1) : (NE.debug(\"beauty effect current framerate\", this.recordedFrameCount / 2), !0));\n    }\n    stopRecordBeautyEffectOutput() {\n      this.targetFrameRate = 0, this.recordedFrameCount = 0, this.recordID = void 0;\n    }\n    addFrame() {\n      this.recordID && (this.recordedFrameCount += 1);\n    }\n  }\n  class wb extends ab.exports.VideoProcessor {\n    constructor() {\n      super(), mp(this, \"name\", \"BeautyProcessor\"), mp(this, \"fps\", 15), mp(this, \"canvas\", void 0), mp(this, \"video\", void 0), mp(this, \"manager\", void 0), mp(this, \"overloadDetector\", new bb()), mp(this, \"stopChromeBackgroundLoop\", null), mp(this, \"onOverload\", void 0), mp(this, \"stopLoop\", void 0), mp(this, \"lastRenderTime\", 0), this.fps = 30, this.manager = new Ob(), this._enabled = !1;\n    }\n    async onEnableChange(e) {\n      this.manager.setEnableBeauty(e), this.context && this.inputTrack && (e ? await this.startEffect(this.inputTrack, this.context) : await this.stopEffect(this.inputTrack, this.context));\n    }\n    async setBeautyEffectOptions(e) {\n      if (function (e) {\n        void 0 !== e.smoothnessLevel && Xf(e.smoothnessLevel, \"options.smoothnessLevel\", 0, 1, !1), void 0 !== e.lighteningLevel && Xf(e.lighteningLevel, \"options.lighteningLevel\", 0, 1, !1), void 0 !== e.rednessLevel && Xf(e.rednessLevel, \"options.rednessLevel\", 0, 1, !1), void 0 !== e.lighteningContrastLevel && Jf(e.lighteningContrastLevel, \"options.lighteningContrastLevel\", [0, 1, 2]);\n      }(e), void 0 !== e.smoothnessLevel) {\n        const t = Math.max(.1, 10 * e.smoothnessLevel);\n        this.manager.setDenoiseLevel(t);\n      }\n      if (void 0 !== e.lighteningLevel) {\n        const t = Math.max(.1, e.lighteningLevel / 2);\n        this.manager.setLightLevel(t);\n      }\n      if (void 0 !== e.rednessLevel) {\n        const t = Math.max(.01, e.rednessLevel);\n        this.manager.setRednessLevel(t);\n      }\n      if (void 0 !== e.lighteningContrastLevel) {\n        const t = e.lighteningContrastLevel;\n        this.manager.setContrastLevel(t);\n      }\n    }\n    async onTrack(e, t) {\n      var i;\n      this.video && this.enabled && (null === (i = this.stopLoop) || void 0 === i || i.call(this), await this.stopEffect(e, t));\n      await this.startEffect(e, t);\n    }\n    async startEffect(e, t) {\n      if (!this.enabled) return;\n      const i = Bh(),\n        r = await this.renderWithWebGL(e);\n      this.output(r, t), NE.info(\"start video effect, output:\", this.outputTrack), this.overloadDetector.startRecordBeautyEffectOutput(this.fps).then(e => {\n        e || this.onOverload && this.onOverload();\n      });\n      let n = !1;\n      this.stopLoop = () => {\n        n = !0;\n      };\n      const o = () => {\n        this.enabled && !n && requestAnimationFrame(o);\n        const e = Date.now(),\n          t = 1e3 / this.fps,\n          i = this.lastRenderTime ? e - this.lastRenderTime : t;\n        i < t || (this.lastRenderTime = e - (i - t), this.video && this.video.paused && this.video.play(), this.enabled && this.video && (this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame()));\n      };\n      requestAnimationFrame(o), i.name === xh.CHROME && document.addEventListener(\"visibilitychange\", () => {\n        document.hidden ? this.stopChromeBackgroundLoop = VT(() => {\n          this.enabled && this.video && this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame();\n        }, this.fps) : this.stopChromeBackgroundLoop && (this.stopChromeBackgroundLoop(), this.stopChromeBackgroundLoop = null);\n      }, !1);\n    }\n    async renderWithWebGL(e) {\n      this.canvas && (this.canvas.remove(), this.canvas = void 0), this.video && (this.video.remove(), this.video = void 0), this.canvas = document.createElement(\"canvas\"), this.video = document.createElement(\"video\"), this.video.setAttribute(\"autoplay\", \"\"), this.video.setAttribute(\"muted\", \"\"), this.video.muted = !0, this.video.setAttribute(\"playsinline\", \"\"), this.video.setAttribute(\"style\", \"display:none\"), this.video.srcObject = new MediaStream([e]);\n      const t = new Cl(e => {\n        const t = () => {\n          this.video && this.video.removeEventListener(\"playing\", t), e(void 0);\n        };\n        this.video && this.video.addEventListener(\"playing\", t);\n      });\n      this.video.play(), await t;\n      const i = e.getSettings(),\n        r = i.width || this.video.videoWidth,\n        n = i.height || this.video.videoHeight;\n      if (i.frameRate && this.fps !== i.frameRate && (this.fps = i.frameRate, NE.debug(\"beauty video processor: set fps to\", this.fps)), NE.debug(\"beauty video processor: width \".concat(r, \" height \").concat(n)), !r || !n) throw new vE(TE.BEAUTY_PROCESSOR_INTERNAL_ERROR, \"can not get track resolution\");\n      this.canvas.width = r, this.canvas.height = n, this.video.setAttribute(\"width\", r.toString()), this.video.setAttribute(\"height\", n.toString()), this.manager.init(r, n, this.canvas);\n      const o = jg();\n      return this.canvas.captureStream(o.supportRequestFrame ? 0 : this.fps).getVideoTracks()[0];\n    }\n    async stopEffect(e, t) {\n      NE.info(\"stop video effect\"), this.overloadDetector.stopRecordBeautyEffectOutput(), this.manager.release(), this.canvas && this.canvas.remove(), this.video && this.video.remove(), this.canvas = void 0, this.video = void 0, this.output(e, t);\n    }\n  }\n  function Nb(e) {\n    const t = {};\n    if (e.facingMode && (t.facingMode = e.facingMode), e.cameraId && (t.deviceId = {\n      exact: e.cameraId\n    }), !e.encoderConfig) return t;\n    const i = VE(e.encoderConfig);\n    return t.width = i.width, t.height = i.height, !sp() && i.frameRate && (t.frameRate = i.frameRate), Bh().name === xh.EDGE && \"object\" == typeof t.frameRate && (t.frameRate.max = 60), Qh() && (t.frameRate = {\n      ideal: 30,\n      max: 30\n    }), t;\n  }\n  function Db(e) {\n    const t = {};\n    e.screenSourceType && (t.mediaSource = e.screenSourceType), e.extensionId && Xh() && (t.extensionId = e.extensionId), e.electronScreenSourceId && (t.sourceId = e.electronScreenSourceId);\n    const i = e.encoderConfig ? jE(e.encoderConfig) : null;\n    return t.mandatory = {\n      chromeMediaSource: \"desktop\",\n      maxWidth: i ? i.width : void 0,\n      maxHeight: i ? i.height : void 0\n    }, i && i.frameRate && (\"number\" == typeof i.frameRate ? (t.mandatory.maxFrameRate = i.frameRate, t.mandatory.minFrameRate = i.frameRate) : (t.mandatory.maxFrameRate = i.frameRate.max || i.frameRate.ideal || i.frameRate.exact || void 0, t.mandatory.minFrameRate = i.frameRate.min || i.frameRate.ideal || i.frameRate.exact || void 0), t.frameRate = i.frameRate), i && i.width && (t.width = i.width), i && i.height && (t.height = i.height), t;\n  }\n  function Pb(e) {\n    const t = {};\n    if (sp() || (void 0 !== e.AGC && (t.autoGainControl = e.AGC), void 0 !== e.AEC && (t.echoCancellation = e.AEC), void 0 !== e.ANS && (t.noiseSuppression = e.ANS, Xh() && e.ANS && (t.googHighpassFilter = e.ANS))), e.encoderConfig) {\n      const i = GE(e.encoderConfig);\n      t.channelCount = i.stereo ? 2 : 1, t.sampleRate = i.sampleRate, t.sampleSize = i.sampleSize;\n    }\n    return e.microphoneId && (t.deviceId = {\n      exact: e.microphoneId\n    }), cp() && (t.sampleRate = void 0), t;\n  }\n  var Lb, kb;\n  !function (e) {\n    e.COVERED = \"COVERED\", e.POSITION = \"POSITION\", e.SIZE = \"SIZE\", e.STYLE = \"STYLE\";\n  }(Lb || (Lb = {})), function (e) {\n    e.UNMOUNTED = \"UNMOUNTED\", e.INVALID_HTML_ELEMENT = \"INVALID_HTML_ELEMENT\";\n  }(kb || (kb = {}));\n  var Mb,\n    Ub,\n    xb,\n    Vb,\n    jb,\n    Fb,\n    Bb,\n    Gb,\n    Wb,\n    Hb,\n    Kb,\n    Yb,\n    qb,\n    Jb,\n    Xb,\n    zb,\n    Qb,\n    Zb,\n    $b,\n    ew,\n    tw,\n    iw,\n    rw,\n    nw,\n    ow,\n    sw,\n    aw,\n    cw,\n    dw,\n    uw,\n    lw,\n    hw = new class {\n      constructor() {\n        mp(this, \"_clientSize\", null), mp(this, \"getClientWidth\", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), mp(this, \"getClientHeight\", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), mp(this, \"getStyle\", e => window.getComputedStyle(e, null)), mp(this, \"checkCssVisibleProperty\", e => {\n          let t = !0;\n          const i = this.getStyle(e),\n            {\n              display: r,\n              visibility: n,\n              opacity: o,\n              filter: s\n            } = i;\n          if ((\"none\" === r || [\"hidden\", \"collapse\"].includes(n) || Number(o) < .1) && (t = !1), !t) return !1;\n          if (s) {\n            s.split(\" \").filter(e => {\n              const t = e.split(\"(\")[0];\n              return [\"brightness\", \"blur\", \"opacity\"].includes(t);\n            }).map(e => {\n              const [t, i] = e.split(/\\(|\\)/);\n              return [t, Number(i.match(/^[0-9\\.]+/))];\n            }).forEach(e => {\n              const [i, r] = e;\n              switch (i) {\n                case \"brightness\":\n                  (r < .1 || r > 3) && (t = !1);\n                  break;\n                case \"blur\":\n                  r > 3 && (t = !1);\n                  break;\n                case \"opacity\":\n                  r < .1 && (t = !1);\n              }\n            });\n          }\n          return t;\n        }), mp(this, \"checkPropertyUpToAllParentNodes\", (e, t) => {\n          let i = !0,\n            r = !0;\n          const n = e => t(e);\n          let o = e;\n          for (; o && r;) {\n            n(o) || (i = !1, r = !1), o = o.parentElement, o || (r = !1);\n          }\n          return i;\n        }), mp(this, \"checkActualCssVisibleIncludeInherit\", e => this.checkPropertyUpToAllParentNodes(e, this.checkCssVisibleProperty)), mp(this, \"getSizeAboutClient\", e => {\n          const {\n              width: t,\n              height: i,\n              left: r,\n              right: n,\n              top: o,\n              bottom: s\n            } = e.getBoundingClientRect(),\n            a = this.getClientWidth(),\n            c = this.getClientHeight();\n          return {\n            width: t,\n            height: i,\n            left: r,\n            right: n,\n            top: o,\n            bottom: s,\n            clientWidth: a,\n            clientHeight: c,\n            clientMin: Math.min(a, c)\n          };\n        }), mp(this, \"checkActualSize\", () => {\n          const {\n            width: e,\n            height: t,\n            clientMin: i\n          } = this._clientSize;\n          return this.checkSizeIsVisible(e, t, i);\n        }), mp(this, \"elementFromPoint\", (e, t) => document.elementFromPoint ? document.elementFromPoint(e, t) : null), mp(this, \"checkCoverForAPoint\", (e, t, i) => {\n          const r = this.elementFromPoint(e, t);\n          return null !== r && r !== i;\n        }), mp(this, \"getPointPositionList\", () => {\n          const {\n              width: e,\n              height: t,\n              left: i,\n              top: r\n            } = this._clientSize,\n            n = e / 6,\n            o = t / 6,\n            s = [],\n            a = 10 ** 6;\n          for (let e = 0; e < 5; e++) for (let t = 0; t < 5; t++) {\n            const c = (i * a + (0 === e ? .1 : 4 === e ? (n * e * a - 1e5) / a : n * e) * a) / a,\n              d = (r * a + (0 === t ? .1 : 4 === t ? (o * t * a - 1e5) / a : o * t) * a) / a;\n            s.push({\n              x: c,\n              y: d\n            });\n          }\n          return [...s];\n        }), mp(this, \"checkElementCover\", e => this.getPointPositionList().map(t => this.checkCoverForAPoint(t.x, t.y, e)).filter(e => !!e).length > 6), mp(this, \"checkSizeIsVisible\", (e, t, i) => (e > 50 || i / e <= 10) && (t > 50 || i / t <= 10)), mp(this, \"checkSizeOfPartInClient\", () => {\n          const {\n            left: e,\n            right: t,\n            top: i,\n            bottom: r,\n            clientHeight: n,\n            clientWidth: o,\n            clientMin: s\n          } = this._clientSize;\n          let a, c, d, u;\n          if (e < 0) a = 0;else {\n            if (!(e < o)) return !1;\n            a = e;\n          }\n          if (t < 0) return !1;\n          if (c = t < o ? t : o, i < 0) d = 0;else {\n            if (!(i < n)) return !1;\n            d = i;\n          }\n          if (r < 0) return !1;\n          u = r < n ? r : n;\n          const l = c - a,\n            h = u - d;\n          return this.checkSizeIsVisible(l, h, s);\n        }), mp(this, \"returnHiddenResult\", e => (this._clientSize = null, {\n          visible: !1,\n          reason: e\n        })), mp(this, \"checkOneElementVisible\", e => {\n          if (e instanceof HTMLElement) {\n            if (this.checkElementIsMountedOnDom(e)) {\n              if (this.checkActualCssVisibleIncludeInherit(e)) {\n                if (this._clientSize = this.getSizeAboutClient(e), this.checkElementCover(e)) return this.returnHiddenResult(Lb.COVERED);\n                {\n                  const e = this.checkActualSize(),\n                    t = this.checkSizeOfPartInClient();\n                  return e && !t ? this.returnHiddenResult(Lb.POSITION) : e ? (this._clientSize = null, {\n                    visible: !0\n                  }) : this.returnHiddenResult(Lb.SIZE);\n                }\n              }\n              return this.returnHiddenResult(Lb.STYLE);\n            }\n            return this.returnHiddenResult(kb.UNMOUNTED);\n          }\n          return this.returnHiddenResult(kb.INVALID_HTML_ELEMENT);\n        }), mp(this, \"checkElementIsMountedOnDom\", e => this.checkPropertyUpToAllParentNodes(e, e => \"HTML\" !== e.nodeName.toUpperCase() ? null !== e.parentElement : !!document.documentElement));\n      }\n    }();\n  function pw(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function _w(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? pw(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : pw(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let Ew = (Mb = RT({\n      argsMap: (e, t, i) => [e.getTrackId(), \"string\" == typeof t ? t : \"HTMLElement\", i]\n    }), Ub = ov(), xb = RT({\n      argsMap: e => [e.getTrackId()]\n    }), Vb = bT(\"LocalVideoTrack\", \"_enabledMutex\"), jb = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), Fb = ov(), Bb = bT(\"LocalVideoTrack\", \"_enabledMutex\"), Gb = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), Wb = ov(), Hb = ov(), Kb = RT({\n      argsMap: (e, t, i) => [e.getTrackId(), t, i]\n    }), Yb = ov(), qb = ov(), Jb = ov(), Xb = ov(), zb = ov(), Qb = ov(), Zb = ov(), $b = RT({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), ew = RT({\n      argsMap: e => [e.getTrackId()]\n    }), tw = RT({\n      argsMap: e => [e.getTrackId()]\n    }), ZS((iw = class e extends wT {\n      get isPlaying() {\n        return !(!this._player || this._player.videoElementStatus !== am.PLAYING);\n      }\n      get __className__() {\n        return \"LocalVideoTrack\";\n      }\n      constructor(e, t, i, r, n, o) {\n        super(e, n), mp(this, \"trackMediaType\", \"video\"), mp(this, \"_player\", void 0), mp(this, \"_videoBeautyProcessor\", void 0), mp(this, \"_videoVisibleTimer\", null), mp(this, \"_previousVideoVisibleStatus\", void 0), mp(this, \"_clearPreviousVideoVisibleStatus\", () => this._previousVideoVisibleStatus = void 0), mp(this, \"_encoderConfig\", void 0), mp(this, \"_scalabiltyMode\", {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }), mp(this, \"_optimizationMode\", void 0), mp(this, \"_videoHeight\", void 0), mp(this, \"_videoWidth\", void 0), mp(this, \"_forceBitrateLimit\", void 0), mp(this, \"_enabled\", !0), mp(this, \"processorDestination\", void 0), mp(this, \"processorContext\", void 0), this.updateMediaStreamTrackResolution(), this._encoderConfig = t, this._scalabiltyMode = i, this._optimizationMode = r, this._hints = o || [], -1 === this._hints.indexOf(lg.SCREEN_TRACK) && this.updateBitrateFromProfile(), this.processorContext = new eR(this.getTrackId(), \"local\"), this.processorDestination = new $v(this.processorContext), this.bindProcessorDestinationEvents();\n      }\n      play(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (\"string\" == typeof e) {\n          const t = document.getElementById(e);\n          t ? e = t : (NE.warning(\"[\".concat(this.getTrackId(), '] can not find \"#').concat(e, '\" element, use document.body')), e = document.body);\n        }\n        NE.debug(\"[\".concat(this.getTrackId(), \"] start video playback\"), JSON.stringify(t));\n        const i = _w(_w(_w({}, this._getDefaultPlayerConfig()), t), {}, {\n          trackId: this.getTrackId(),\n          element: e\n        });\n        this._player ? this._player.updateConfig(i) : (this._player = new ob(i), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {\n          try {\n            const e = this.getVideoElementVisibleStatus();\n            this.emit(_g.VIDEO_ELEMENT_VISIBLE_STATUS, e);\n          } catch (e) {}\n        }, HE(\"CHECK_VIDEO_VISIBLE_INTERVAL\"));\n      }\n      stop() {\n        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, NE.debug(\"[\".concat(this.getTrackId(), \"] stop video playback\")));\n      }\n      async setEnabled(e, t) {\n        if (!t) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (NE.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), !e) {\n          this._originMediaStreamTrack.enabled = !1;\n          try {\n            await BR(this, ug.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n          }\n          return t || (this._enabled = !1), void NE.info(\"[\".concat(this.getTrackId(), \"] setEnabled to false success\"));\n        }\n        this._originMediaStreamTrack.enabled = !0;\n        try {\n          await BR(this, ug.NEED_ENABLE_TRACK, this);\n        } catch (e) {\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled to true error\"), e.toString()), e;\n        }\n        NE.info(\"[\".concat(this.getTrackId(), \"] setEnabled to true success\")), t || (this._enabled = !0);\n      }\n      async setMuted(e) {\n        e !== this._muted && (this.stateCheck(\"muted\", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, NE.debug(\"[\".concat(this.getTrackId(), \"] start set muted: \").concat(e)), e ? await BR(this, ug.NEED_MUTE_TRACK, this) : await BR(this, ug.NEED_UNMUTE_TRACK, this));\n      }\n      getStats() {\n        XR(() => {\n          NE.warning(\"[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead\");\n        }, \"localVideoTrackGetStatsWarning\");\n        const e = GR(this, ug.GET_STATS);\n        return e || _w({}, Bm);\n      }\n      async setBeautyEffect(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (e || this._videoBeautyProcessor) {\n          if (Kh() === Uh.IOS || Kh() === Uh.ANDROID) throw new vE(TE.INVALID_OPERATION, \"can not enable beauty effect on mobile device\");\n          if (!this._enabled && e) throw new vE(TE.TRACK_IS_DISABLED, \"can not enable beauty effect when track is disabled\");\n          if (NE.info(\"[\".concat(this.getTrackId(), \"] start setBeautyEffect\"), e, JSON.stringify(t)), this._videoBeautyProcessor || e) {\n            try {\n              if (!this._videoBeautyProcessor) if (this._videoBeautyProcessor = new wb(), this.processor) {\n                const e = this.processor;\n                this.pipe(this._videoBeautyProcessor).pipe(e);\n              } else this.pipe(this._videoBeautyProcessor).pipe(this.processorDestination);\n              await this._videoBeautyProcessor.setBeautyEffectOptions(t), e ? await this._videoBeautyProcessor.enable() : await this._videoBeautyProcessor.disable();\n            } catch (e) {\n              throw NE.error(\"[\".concat(this.getTrackId(), \"] setBeautyEffect error\"), e.toString()), e;\n            }\n            NE.info(\"[\".concat(this.getTrackId(), \"] setBeautyEffect success\"));\n          }\n        }\n      }\n      getCurrentFrameData() {\n        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n      }\n      async getCurrentFrameImage(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n        return this._player ? this._player.getCurrentFrameToUint8Array(e, t) : await tb(e);\n      }\n      clone(t, i, r, n) {\n        const o = this._mediaStreamTrack.clone();\n        return new e(o, t, i, r, n);\n      }\n      async setBitrateLimit(e) {\n        if (NE.debug(\"[\".concat(this.getTrackId(), \"] set bitrate limit, \").concat(JSON.stringify(e))), e) {\n          this._forceBitrateLimit = e, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e.max_bitrate ? this._encoderConfig.bitrateMax : e.max_bitrate : this._encoderConfig.bitrateMax = e.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e.min_bitrate);\n          try {\n            await BR(this, ug.NEED_UPDATE_VIDEO_ENCODER, this);\n          } catch (e) {\n            return e.throw();\n          }\n        }\n      }\n      async setOptimizationMode(e) {\n        if (\"motion\" !== e && \"detail\" !== e && \"balanced\" !== e) return void NE.error(TE.INVALID_PARAMS, \"optimization mode must be motion, detail or balanced\");\n        const t = this._optimizationMode;\n        try {\n          this._optimizationMode = e, await BR(this, ug.SET_OPTIMIZATION_MODE, this);\n        } catch (e) {\n          throw this._optimizationMode = t, NE.error(\"[\".concat(this.getTrackId(), \"] set optimization mode failed\"), e.toString()), e;\n        }\n        NE.info(\"[\".concat(this.getTrackId(), \"] set optimization mode success (\").concat(e, \")\"));\n      }\n      setScalabiltyMode(e) {\n        if (1 === e.numSpatialLayers && 1 !== e.numTemporalLayers) return NE.error(TE.INVALID_PARAMS, \"scalability mode currently not supported, no SVC.\"), void (this._scalabiltyMode = {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        });\n        this._scalabiltyMode = e, NE.info(\"[\".concat(this.getTrackId(), \"] set scalability mode success (\").concat(e, \")\"));\n      }\n      updateMediaStreamTrackResolution() {\n        VR(this._originMediaStreamTrack).then(e => {\n          let [t, i] = e;\n          this._videoHeight = i, this._videoWidth = t;\n        }).catch(xR);\n      }\n      _updatePlayerSource() {\n        this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n      }\n      _getDefaultPlayerConfig() {\n        return {\n          fit: \"contain\"\n        };\n      }\n      updateBitrateFromProfile() {\n        if (!this._encoderConfig) return;\n        const {\n          width: e,\n          height: t,\n          frameRate: i\n        } = this.getMediaStreamTrackSettings();\n        if (!e || !t || !i) return;\n        const [r, n] = function (e, t, i) {\n          const r = HE(\"BITRATE_ADAPTER_TYPE\");\n          let n;\n          const o = 200 * Math.pow(i / 15, .6) * Math.pow(e * t / 640 / 360, .75),\n            s = o;\n          if (\"STANDARD_BITRATE\" === r) n = 4 * o;else {\n            if (\"COMPATIABLE_BITRATE\" !== r) return;\n            n = 2 * o;\n          }\n          return [Math.floor(n), Math.floor(s)];\n        }(e, t, i) || [void 0, void 0];\n        this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = n, this._encoderConfig.bitrateMax = r, NE.debug(\"[\".concat(this.getTrackId(), \"] update bitrate from profile, [w: \").concat(e, \", h: \").concat(t, \", fps: \").concat(i, \"] => [brMax: \").concat(r, \", brMin: \").concat(n, \"]\")));\n      }\n      getVideoElementVisibleStatus() {\n        try {\n          var e, t;\n          const i = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),\n            r = {\n              track: this,\n              element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),\n              slot: null == i ? void 0 : i.parentElement\n            },\n            {\n              element: n,\n              slot: o\n            } = r;\n          if (this.isPlaying && n instanceof HTMLVideoElement && o instanceof HTMLElement) {\n            const e = hw.checkOneElementVisible(n),\n              t = Object.assign({}, e);\n            if (t.visible !== this._previousVideoVisibleStatus) {\n              this._previousVideoVisibleStatus = t.visible;\n              const e = IT.reportApiInvoke(null, {\n                tag: fm.TRACER,\n                name: Em.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,\n                options: [this.getTrackId()]\n              });\n              t.visible ? e.onSuccess(\"Video is visible\") : e.onSuccess(\"Invisible because of \".concat(t.reason));\n            }\n            return t;\n          }\n          return;\n        } catch (e) {\n          throw new vE(TE.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);\n        }\n      }\n      async renewMediaStreamTrack(e) {}\n      pipe(e) {\n        if (this._videoBeautyProcessor && e !== this._videoBeautyProcessor) return this._videoBeautyProcessor.pipe(e);\n        if (this.processor === e) return e;\n        if (e._source) throw new vE(TE.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        if (!this.processor) return;\n        if (this._videoBeautyProcessor && this.processor === this._videoBeautyProcessor) return void this._videoBeautyProcessor.unpipe();\n        const e = this.processor;\n        this.processor._source = void 0, this.processor = void 0, e.reset();\n      }\n      close() {\n        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe();\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(Ng.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(), await BR(this, ug.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await BR(this, ug.NEED_REPLACE_TRACK, this));\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(Ng.ON_TRACK);\n      }\n      unbindProcessorContextEvents() {\n        this.processorContext.removeAllListeners(Dg.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(Dg.REQUEST_CONSTRAINTS);\n      }\n    }).prototype, \"play\", [Mb, Ub], Object.getOwnPropertyDescriptor(iw.prototype, \"play\"), iw.prototype), ZS(iw.prototype, \"stop\", [xb], Object.getOwnPropertyDescriptor(iw.prototype, \"stop\"), iw.prototype), ZS(iw.prototype, \"setEnabled\", [Vb, jb, Fb], Object.getOwnPropertyDescriptor(iw.prototype, \"setEnabled\"), iw.prototype), ZS(iw.prototype, \"setMuted\", [Bb, Gb, Wb], Object.getOwnPropertyDescriptor(iw.prototype, \"setMuted\"), iw.prototype), ZS(iw.prototype, \"getStats\", [Hb], Object.getOwnPropertyDescriptor(iw.prototype, \"getStats\"), iw.prototype), ZS(iw.prototype, \"setBeautyEffect\", [Kb, Yb], Object.getOwnPropertyDescriptor(iw.prototype, \"setBeautyEffect\"), iw.prototype), ZS(iw.prototype, \"getCurrentFrameData\", [qb], Object.getOwnPropertyDescriptor(iw.prototype, \"getCurrentFrameData\"), iw.prototype), ZS(iw.prototype, \"getCurrentFrameImage\", [Jb], Object.getOwnPropertyDescriptor(iw.prototype, \"getCurrentFrameImage\"), iw.prototype), ZS(iw.prototype, \"setBitrateLimit\", [Xb], Object.getOwnPropertyDescriptor(iw.prototype, \"setBitrateLimit\"), iw.prototype), ZS(iw.prototype, \"setOptimizationMode\", [zb], Object.getOwnPropertyDescriptor(iw.prototype, \"setOptimizationMode\"), iw.prototype), ZS(iw.prototype, \"setScalabiltyMode\", [Qb], Object.getOwnPropertyDescriptor(iw.prototype, \"setScalabiltyMode\"), iw.prototype), ZS(iw.prototype, \"updateMediaStreamTrackResolution\", [Zb], Object.getOwnPropertyDescriptor(iw.prototype, \"updateMediaStreamTrackResolution\"), iw.prototype), ZS(iw.prototype, \"pipe\", [$b], Object.getOwnPropertyDescriptor(iw.prototype, \"pipe\"), iw.prototype), ZS(iw.prototype, \"unpipe\", [ew], Object.getOwnPropertyDescriptor(iw.prototype, \"unpipe\"), iw.prototype), ZS(iw.prototype, \"close\", [tw], Object.getOwnPropertyDescriptor(iw.prototype, \"close\"), iw.prototype), iw),\n    fw = (rw = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), nw = ov(), ow = bT(\"CameraVideoTrack\", \"_enabledMutex\"), sw = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), aw = ov(), cw = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), dw = ov(), uw = RT({\n      argsMap: e => [e.getTrackId()]\n    }), ZS((lw = class extends Ew {\n      get __className__() {\n        return \"CameraVideoTrack\";\n      }\n      constructor(e, t, i, r, n, o) {\n        super(e, t.encoderConfig ? VE(t.encoderConfig) : {}, r, n, o), mp(this, \"_config\", void 0), mp(this, \"_originalConstraints\", void 0), mp(this, \"_constraints\", void 0), mp(this, \"_enabled\", !0), mp(this, \"_deviceName\", \"default\"), mp(this, \"tryResumeVideoForIOS15WeChat\", async () => {\n          ep() && !rp() && op() && this._enabled && !this._isClosed && (NE.debug(\"[\".concat(this.getTrackId(), \"] try capture camera media device for interrupted iOS 15 device on WeChat.\")), await this.renewMediaStreamTrack());\n        }), this._config = t, this._originalConstraints = i, this._constraints = i, this._deviceName = e.label, this._config.encoderConfig && (this._encoderConfig = VE(this._config.encoderConfig)), LT.on(CT.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), LT.on(CT.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), this.bindProcessorContextEvents();\n      }\n      async setDevice(e) {\n        if (NE.info(\"[\".concat(this.getTrackId(), \"] set device to \").concat(e)), this._enabled) try {\n          const t = await iv.getDeviceById(e),\n            i = {};\n          i.video = _w({}, this._constraints), i.video.deviceId = {\n            exact: e\n          }, i.video.facingMode = void 0, this._originMediaStreamTrack.stop();\n          let r = null;\n          try {\n            r = await ZT(i, this.getTrackId());\n          } catch (e) {\n            throw NE.error(\"[\".concat(this.getTrackId(), \"] setDevice failed\"), e.toString()), r = await ZT({\n              video: this._constraints\n            }, this.getTrackId()), await this._updateOriginMediaStreamTrack(r.getVideoTracks()[0], !1), e;\n          }\n          await this._updateOriginMediaStreamTrack(r.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution(), this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        } else try {\n          const t = await iv.getDeviceById(e);\n          this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {\n            exact: e\n          };\n        } catch (e) {\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] setDevice error\"), e.toString()), e;\n        }\n        NE.info(\"[\".concat(this.getTrackId(), \"] setDevice success\"));\n      }\n      async setEnabled(e, t) {\n        if (!t) {\n          if (e === this._enabled) return;\n          this.stateCheck(\"enabled\", e);\n        }\n        if (NE.info(\"[\".concat(this.getTrackId(), \"] start setEnabled\"), e), !e) {\n          this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), t || (this._enabled = !1);\n          try {\n            await BR(this, ug.NEED_DISABLE_TRACK, this);\n          } catch (e) {\n            throw NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled to false error\"), e.toString()), e;\n          }\n          return void NE.info(\"[\".concat(this.getTrackId(), \"] setEnabled to false success\"));\n        }\n        const i = _w({}, this._constraints),\n          r = iv.searchDeviceIdByName(this._deviceName);\n        r && !i.deviceId && (i.deviceId = {\n          exact: r\n        });\n        try {\n          const e = await ZT({\n            video: this._constraints\n          }, this.getTrackId());\n          await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !1), await BR(this, ug.NEED_ENABLE_TRACK, this);\n        } catch (e) {\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] setEnabled true error\"), e.toString()), e;\n        }\n        this.updateMediaStreamTrackResolution(), NE.info(\"[\".concat(this.getTrackId(), \"] setEnabled to true success\")), t || (this._enabled = !0);\n      }\n      async setEncoderConfiguration(e, t) {\n        if (!this._enabled) throw new vE(TE.TRACK_IS_DISABLED, \"can not set encoder configuration when track is disabled\");\n        e = VE(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin);\n        const i = qR(this._config);\n        i.encoderConfig = e;\n        const r = Nb(i);\n        (zh() || Zh() || np()) && (r.deviceId = void 0), NE.debug(\"[\".concat(this.getTrackId(), \"] setEncoderConfiguration applyConstraints\"), JSON.stringify(e), JSON.stringify(r));\n        try {\n          await this._originMediaStreamTrack.applyConstraints(r), this.updateMediaStreamTrackResolution();\n        } catch (e) {\n          const t = new vE(TE.UNEXPECTED_ERROR, e.toString());\n          throw NE.error(\"[\".concat(this.getTrackId(), \"] applyConstraints error\"), t.toString()), t;\n        }\n        this._config = i, this._constraints = r, this._originalConstraints = r, this._encoderConfig = e, -1 === this._hints.indexOf(lg.SCREEN_TRACK) && this.updateBitrateFromProfile();\n        try {\n          await BR(this, ug.NEED_UPDATE_VIDEO_ENCODER, this);\n        } catch (e) {\n          return e.throw();\n        }\n      }\n      _getDefaultPlayerConfig() {\n        return {\n          mirror: !0,\n          fit: \"cover\"\n        };\n      }\n      onTrackEnded() {\n        if ((Zh() || np()) && this._enabled && !this._isClosed && LT.duringInterruption) {\n          const e = async () => {\n            LT.off(CT.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (NE.debug(\"[\".concat(this.getTrackId(), \"] try capture camera media device for interrupted iOS device.\")), await this.setEnabled(!1), await this.setEnabled(!0));\n          };\n          LT.on(CT.IOS_INTERRUPTION_END, e);\n        } else NE.debug(\"[\".concat(this.getTrackId(), \"] track ended\")), this.emit(_g.TRACK_ENDED);\n      }\n      async renewMediaStreamTrack(e) {\n        const t = e || this._constraints,\n          i = iv.searchDeviceIdByName(this._deviceName);\n        if (i && !t.deviceId && (t.deviceId = {\n          exact: i\n        }), this._enabled) {\n          const e = await ZT({\n            video: t\n          }, this.getTrackId());\n          this._constraints = t, await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !0), this.updateMediaStreamTrackResolution();\n        }\n      }\n      close() {\n        super.close(), LT.off(CT.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), LT.off(CT.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat);\n      }\n      bindProcessorContextEvents() {\n        this.processorContext.on(Dg.REQUEST_UPDATE_CONSTRAINTS, async (e, t, i) => {\n          try {\n            const i = Object.assign({}, this._originalConstraints, ...e);\n            await this.renewMediaStreamTrack(i), t();\n          } catch (e) {\n            i(e);\n          }\n        }), this.processorContext.on(Dg.REQUEST_CONSTRAINTS, async e => {\n          e(this._originMediaStreamTrack.getSettings());\n        });\n      }\n    }).prototype, \"setDevice\", [rw, nw], Object.getOwnPropertyDescriptor(lw.prototype, \"setDevice\"), lw.prototype), ZS(lw.prototype, \"setEnabled\", [ow, sw, aw], Object.getOwnPropertyDescriptor(lw.prototype, \"setEnabled\"), lw.prototype), ZS(lw.prototype, \"setEncoderConfiguration\", [cw, dw], Object.getOwnPropertyDescriptor(lw.prototype, \"setEncoderConfiguration\"), lw.prototype), ZS(lw.prototype, \"close\", [uw], Object.getOwnPropertyDescriptor(lw.prototype, \"close\"), lw.prototype), lw);\n  class mw {\n    get hasVideo() {\n      return this._video_enabled_ && !this._video_muted_ && this._video_added_;\n    }\n    get hasAudio() {\n      return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_;\n    }\n    get audioTrack() {\n      if (this.hasAudio) return this._audioTrack;\n    }\n    get videoTrack() {\n      if (this.hasVideo) return this._videoTrack;\n    }\n    constructor(e, t) {\n      mp(this, \"uid\", void 0), mp(this, \"_uintid\", void 0), mp(this, \"_trust_in_room_\", !0), mp(this, \"_trust_audio_enabled_state_\", !0), mp(this, \"_trust_video_enabled_state_\", !0), mp(this, \"_trust_audio_mute_state_\", !0), mp(this, \"_trust_video_mute_state_\", !0), mp(this, \"_audio_muted_\", !1), mp(this, \"_video_muted_\", !1), mp(this, \"_audio_enabled_\", !0), mp(this, \"_video_enabled_\", !0), mp(this, \"_audio_added_\", !1), mp(this, \"_video_added_\", !1), mp(this, \"_trust_video_stream_added_state_\", !0), mp(this, \"_trust_audio_stream_added_state_\", !0), mp(this, \"_audioTrack\", void 0), mp(this, \"_videoTrack\", void 0), mp(this, \"_audioSSRC\", void 0), mp(this, \"_videoSSRC\", void 0), mp(this, \"_audioOrtc\", void 0), mp(this, \"_videoOrtc\", void 0), mp(this, \"_cname\", void 0), mp(this, \"_rtxSsrcId\", void 0), this.uid = e, this._uintid = t;\n    }\n  }\n  var gw = yl,\n    Sw = Sd,\n    Tw = Od;\n  Ri({\n    target: \"Promise\",\n    stat: !0\n  }, {\n    try: function (e) {\n      var t = Sw.f(this),\n        i = Tw(e);\n      return (i.error ? t.reject : t.resolve)(i.value), t.promise;\n    }\n  });\n  var vw = gw,\n    Rw = Ri,\n    Iw = h,\n    yw = i,\n    Cw = Gg,\n    Aw = q,\n    Ow = je,\n    bw = wi,\n    ww = nf,\n    Nw = zg,\n    Dw = DS,\n    Pw = ae,\n    Lw = nt(\"isConcatSpreadable\"),\n    kw = 9007199254740991,\n    Mw = \"Maximum allowed index exceeded\",\n    Uw = Iw.TypeError,\n    xw = Pw >= 51 || !yw(function () {\n      var e = [];\n      return e[Lw] = !1, e.concat()[0] !== e;\n    }),\n    Vw = Dw(\"concat\"),\n    jw = function (e) {\n      if (!Aw(e)) return !1;\n      var t = e[Lw];\n      return void 0 !== t ? !!t : Cw(e);\n    };\n  Rw({\n    target: \"Array\",\n    proto: !0,\n    forced: !xw || !Vw\n  }, {\n    concat: function (e) {\n      var t,\n        i,\n        r,\n        n,\n        o,\n        s = Ow(this),\n        a = Nw(s, 0),\n        c = 0;\n      for (t = -1, r = arguments.length; t < r; t++) if (jw(o = -1 === t ? s : arguments[t])) {\n        if (c + (n = bw(o)) > kw) throw Uw(Mw);\n        for (i = 0; i < n; i++, c++) i in o && ww(a, c, o[i]);\n      } else {\n        if (c >= kw) throw Uw(Mw);\n        ww(a, c++, o);\n      }\n      return a.length = c, a;\n    }\n  });\n  var Fw = {},\n    Bw = k,\n    Gw = K,\n    Ww = Dr.f,\n    Hw = uf,\n    Kw = \"object\" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\n  Fw.f = function (e) {\n    return Kw && \"Window\" == Bw(e) ? function (e) {\n      try {\n        return Ww(e);\n      } catch (e) {\n        return Hw(Kw);\n      }\n    }(e) : Ww(Gw(e));\n  };\n  var Yw = {},\n    qw = nt;\n  Yw.f = qw;\n  var Jw = J,\n    Xw = Ge,\n    zw = Yw,\n    Qw = Ht.f,\n    Zw = function (e) {\n      var t = Jw.Symbol || (Jw.Symbol = {});\n      Xw(t, e) || Qw(t, e, {\n        value: zw.f(e)\n      });\n    },\n    $w = Ri,\n    eN = h,\n    tN = $,\n    iN = m,\n    rN = I,\n    nN = d,\n    oN = T,\n    sN = ue,\n    aN = i,\n    cN = Ge,\n    dN = Gg,\n    uN = g,\n    lN = q,\n    hN = u,\n    pN = me,\n    _N = zt,\n    EN = je,\n    fN = K,\n    mN = Et,\n    gN = Lo,\n    SN = N,\n    TN = Pn,\n    vN = hn,\n    RN = Dr,\n    IN = Fw,\n    yN = Qr,\n    CN = S,\n    AN = Ht,\n    ON = dn,\n    bN = y,\n    wN = Sc,\n    NN = Fs,\n    DN = Ne.exports,\n    PN = Br,\n    LN = qe,\n    kN = nt,\n    MN = Yw,\n    UN = Zw,\n    xN = na,\n    VN = Ps,\n    jN = nS.forEach,\n    FN = hr(\"hidden\"),\n    BN = \"Symbol\",\n    GN = kN(\"toPrimitive\"),\n    WN = VN.set,\n    HN = VN.getterFor(BN),\n    KN = Object.prototype,\n    YN = eN.Symbol,\n    qN = YN && YN.prototype,\n    JN = eN.TypeError,\n    XN = eN.QObject,\n    zN = tN(\"JSON\", \"stringify\"),\n    QN = CN.f,\n    ZN = AN.f,\n    $N = IN.f,\n    eD = bN.f,\n    tD = nN([].push),\n    iD = DN(\"symbols\"),\n    rD = DN(\"op-symbols\"),\n    nD = DN(\"string-to-symbol-registry\"),\n    oD = DN(\"symbol-to-string-registry\"),\n    sD = DN(\"wks\"),\n    aD = !XN || !XN.prototype || !XN.prototype.findChild,\n    cD = oN && aN(function () {\n      return 7 != TN(ZN({}, \"a\", {\n        get: function () {\n          return ZN(this, \"a\", {\n            value: 7\n          }).a;\n        }\n      })).a;\n    }) ? function (e, t, i) {\n      var r = QN(KN, t);\n      r && delete KN[t], ZN(e, t, i), r && e !== KN && ZN(KN, t, r);\n    } : ZN,\n    dD = function (e, t) {\n      var i = iD[e] = TN(qN);\n      return WN(i, {\n        type: BN,\n        tag: e,\n        description: t\n      }), oN || (i.description = t), i;\n    },\n    uD = function (e, t, i) {\n      e === KN && uD(rD, t, i), _N(e);\n      var r = mN(t);\n      return _N(i), cN(iD, r) ? (i.enumerable ? (cN(e, FN) && e[FN][r] && (e[FN][r] = !1), i = TN(i, {\n        enumerable: SN(0, !1)\n      })) : (cN(e, FN) || ZN(e, FN, SN(1, {})), e[FN][r] = !0), cD(e, r, i)) : ZN(e, r, i);\n    },\n    lD = function (e, t) {\n      _N(e);\n      var i = fN(t),\n        r = vN(i).concat(ED(i));\n      return jN(r, function (t) {\n        oN && !rN(hD, i, t) || uD(e, t, i[t]);\n      }), e;\n    },\n    hD = function (e) {\n      var t = mN(e),\n        i = rN(eD, this, t);\n      return !(this === KN && cN(iD, t) && !cN(rD, t)) && (!(i || !cN(this, t) || !cN(iD, t) || cN(this, FN) && this[FN][t]) || i);\n    },\n    pD = function (e, t) {\n      var i = fN(e),\n        r = mN(t);\n      if (i !== KN || !cN(iD, r) || cN(rD, r)) {\n        var n = QN(i, r);\n        return !n || !cN(iD, r) || cN(i, FN) && i[FN][r] || (n.enumerable = !0), n;\n      }\n    },\n    _D = function (e) {\n      var t = $N(fN(e)),\n        i = [];\n      return jN(t, function (e) {\n        cN(iD, e) || cN(PN, e) || tD(i, e);\n      }), i;\n    },\n    ED = function (e) {\n      var t = e === KN,\n        i = $N(t ? rD : fN(e)),\n        r = [];\n      return jN(i, function (e) {\n        !cN(iD, e) || t && !cN(KN, e) || tD(r, iD[e]);\n      }), r;\n    };\n  (sN || (NN(qN = (YN = function () {\n    if (hN(qN, this)) throw JN(\"Symbol is not a constructor\");\n    var e = arguments.length && void 0 !== arguments[0] ? gN(arguments[0]) : void 0,\n      t = LN(e),\n      i = function (e) {\n        this === KN && rN(i, rD, e), cN(this, FN) && cN(this[FN], t) && (this[FN][t] = !1), cD(this, t, SN(1, e));\n      };\n    return oN && aD && cD(KN, t, {\n      configurable: !0,\n      set: i\n    }), dD(t, e);\n  }).prototype, \"toString\", function () {\n    return HN(this).tag;\n  }), NN(YN, \"withoutSetter\", function (e) {\n    return dD(LN(e), e);\n  }), bN.f = hD, AN.f = uD, ON.f = lD, CN.f = pD, RN.f = IN.f = _D, yN.f = ED, MN.f = function (e) {\n    return dD(kN(e), e);\n  }, oN && ZN(qN, \"description\", {\n    configurable: !0,\n    get: function () {\n      return HN(this).description;\n    }\n  })), $w({\n    global: !0,\n    wrap: !0,\n    forced: !sN,\n    sham: !sN\n  }, {\n    Symbol: YN\n  }), jN(vN(sD), function (e) {\n    UN(e);\n  }), $w({\n    target: BN,\n    stat: !0,\n    forced: !sN\n  }, {\n    for: function (e) {\n      var t = gN(e);\n      if (cN(nD, t)) return nD[t];\n      var i = YN(t);\n      return nD[t] = i, oD[i] = t, i;\n    },\n    keyFor: function (e) {\n      if (!pN(e)) throw JN(e + \" is not a symbol\");\n      if (cN(oD, e)) return oD[e];\n    },\n    useSetter: function () {\n      aD = !0;\n    },\n    useSimple: function () {\n      aD = !1;\n    }\n  }), $w({\n    target: \"Object\",\n    stat: !0,\n    forced: !sN,\n    sham: !oN\n  }, {\n    create: function (e, t) {\n      return void 0 === t ? TN(e) : lD(TN(e), t);\n    },\n    defineProperty: uD,\n    defineProperties: lD,\n    getOwnPropertyDescriptor: pD\n  }), $w({\n    target: \"Object\",\n    stat: !0,\n    forced: !sN\n  }, {\n    getOwnPropertyNames: _D,\n    getOwnPropertySymbols: ED\n  }), $w({\n    target: \"Object\",\n    stat: !0,\n    forced: aN(function () {\n      yN.f(1);\n    })\n  }, {\n    getOwnPropertySymbols: function (e) {\n      return yN.f(EN(e));\n    }\n  }), zN) && $w({\n    target: \"JSON\",\n    stat: !0,\n    forced: !sN || aN(function () {\n      var e = YN();\n      return \"[null]\" != zN([e]) || \"{}\" != zN({\n        a: e\n      }) || \"{}\" != zN(Object(e));\n    })\n  }, {\n    stringify: function (e, t, i) {\n      var r = wN(arguments),\n        n = t;\n      if ((lN(t) || void 0 !== e) && !pN(e)) return dN(t) || (t = function (e, t) {\n        if (uN(n) && (t = rN(n, this, e, t)), !pN(t)) return t;\n      }), r[1] = t, iN(zN, null, r);\n    }\n  });\n  if (!qN[GN]) {\n    var fD = qN.valueOf;\n    NN(qN, GN, function (e) {\n      return rN(fD, this);\n    });\n  }\n  xN(YN, BN), PN[FN] = !0, Zw(\"asyncIterator\"), Zw(\"hasInstance\"), Zw(\"isConcatSpreadable\"), Zw(\"iterator\"), Zw(\"match\"), Zw(\"matchAll\"), Zw(\"replace\"), Zw(\"search\"), Zw(\"species\"), Zw(\"split\"), Zw(\"toPrimitive\"), Zw(\"toStringTag\"), Zw(\"unscopables\"), na(h.JSON, \"JSON\", !0);\n  var mD = J.Symbol;\n  Zw(\"asyncDispose\"), Zw(\"dispose\"), Zw(\"matcher\"), Zw(\"metadata\"), Zw(\"observable\"), Zw(\"patternMatch\"), Zw(\"replaceAll\");\n  var gD = mD,\n    SD = Yw.f(\"asyncIterator\"),\n    TD = SD;\n  function vD(e) {\n    this.wrapped = e;\n  }\n  function RD(e) {\n    var t, i;\n    function r(t, i) {\n      try {\n        var o = e[t](i),\n          s = o.value,\n          a = s instanceof vD;\n        vw.resolve(a ? s.wrapped : s).then(function (e) {\n          a ? r(\"return\" === t ? \"return\" : \"next\", e) : n(o.done ? \"return\" : \"normal\", e);\n        }, function (e) {\n          r(\"throw\", e);\n        });\n      } catch (e) {\n        n(\"throw\", e);\n      }\n    }\n    function n(e, n) {\n      switch (e) {\n        case \"return\":\n          t.resolve({\n            value: n,\n            done: !0\n          });\n          break;\n        case \"throw\":\n          t.reject(n);\n          break;\n        default:\n          t.resolve({\n            value: n,\n            done: !1\n          });\n      }\n      (t = t.next) ? r(t.key, t.arg) : i = null;\n    }\n    this._invoke = function (e, n) {\n      return new vw(function (o, s) {\n        var a = {\n          key: e,\n          arg: n,\n          resolve: o,\n          reject: s,\n          next: null\n        };\n        i ? i = i.next = a : (t = i = a, r(e, n));\n      });\n    }, \"function\" != typeof e.return && (this.return = void 0);\n  }\n  function ID(e) {\n    return function () {\n      return new RD(e.apply(this, arguments));\n    };\n  }\n  function yD(e) {\n    return new vD(e);\n  }\n  RD.prototype[\"function\" == typeof gD && TD || \"@@asyncIterator\"] = function () {\n    return this;\n  }, RD.prototype.next = function (e) {\n    return this._invoke(\"next\", e);\n  }, RD.prototype.throw = function (e) {\n    return this._invoke(\"throw\", e);\n  }, RD.prototype.return = function (e) {\n    return this._invoke(\"return\", e);\n  };\n  var CD = Yw.f(\"iterator\");\n  function AD(e, t) {\n    var i = {},\n      r = !1;\n    function n(i, n) {\n      return r = !0, n = new vw(function (t) {\n        t(e[i](n));\n      }), {\n        done: !1,\n        value: t(n)\n      };\n    }\n    return i[void 0 !== gD && CD || \"@@iterator\"] = function () {\n      return this;\n    }, i.next = function (e) {\n      return r ? (r = !1, e) : n(\"next\", e);\n    }, \"function\" == typeof e.throw && (i.throw = function (e) {\n      if (r) throw r = !1, e;\n      return n(\"throw\", e);\n    }), \"function\" == typeof e.return && (i.return = function (e) {\n      return r ? (r = !1, e) : n(\"return\", e);\n    }), i;\n  }\n  var OD = SD,\n    bD = {\n      exports: {}\n    };\n  function wD(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function ND(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? wD(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : wD(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function DD(e, t, i, r, n, o, s) {\n    let a = [],\n      c = [],\n      d = [],\n      u = [],\n      l = !1,\n      h = !1;\n    if (bD.exports.parse(e).mediaDescriptions.forEach(e => {\n      s && s !== e.attributes.direction || (\"video\" !== e.media.mediaType || l || (c = e.attributes.payloads, u = e.attributes.extmaps, l = !0), \"audio\" !== e.media.mediaType || h || (a = e.attributes.payloads, d = e.attributes.extmaps, h = !0));\n    }), !u || 0 === c.length) throw new Error(\"Cannot get video capabilities from SDP.\");\n    if (!d || 0 === a.length) throw new Error(\"Cannot get audio capabilities from SDP.\");\n    return c.forEach(e => {\n      var t;\n      null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate));\n    }), a.forEach(e => {\n      var t;\n      null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate));\n    }), t && (a = a.filter(e => {\n      var t;\n      return \"rtx\" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n    }), c = c.filter(e => {\n      var t;\n      return \"rtx\" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n    })), i && (c = c.filter(e => {\n      var t;\n      return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || \"\");\n    })), r && (a = a.filter(e => {\n      var t;\n      return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || \"\");\n    })), n && (null == n ? void 0 : n.length) > 0 && (a = a.filter(e => {\n      var t;\n      return n.includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\");\n    })), o && (null == o ? void 0 : o.length) > 0 && (c = c.filter(e => {\n      var t;\n      return o.includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\");\n    })), {\n      audioCodecs: a,\n      videoCodecs: c,\n      audioExtensions: d,\n      videoExtensions: u\n    };\n  }\n  function PD(e) {\n    const t = bD.exports.parse(e);\n    let i, r;\n    for (const e of t.mediaDescriptions) {\n      if (!i) {\n        const t = e.attributes.iceUfrag,\n          r = e.attributes.icePwd;\n        if (!t || !r) throw new Error(\"Cannot get iceUfrag or icePwd from SDP.\");\n        i = {\n          iceUfrag: t,\n          icePwd: r\n        };\n      }\n      if (!r) {\n        const t = e.attributes.fingerprints;\n        t.length > 0 && (r = {\n          fingerprints: t\n        });\n      }\n    }\n    if (!r && t.attributes.fingerprints.length > 0 && (r = {\n      fingerprints: t.attributes.fingerprints\n    }), !r || !i) throw new Error(\"Cannot get iceParameters or dtlsParameters from SDP.\");\n    return {\n      iceParameters: i,\n      dtlsParameters: r\n    };\n  }\n  function LD(e, t) {\n    const i = [],\n      r = e.attributes.ssrcGroups.filter(e => \"FID\" === e.semantic),\n      n = e.attributes.ssrcGroups.find(e => \"SIM\" === e.semantic),\n      o = e.attributes.ssrcs;\n    if (n) n.ssrcIds.forEach(e => {\n      var n;\n      const o = null === (n = r.find(t => t.ssrcIds[0] === e)) || void 0 === n ? void 0 : n.ssrcIds[1];\n      i.push({\n        ssrcId: e,\n        rtx: t ? o : void 0\n      });\n    });else if (r.length > 0) {\n      const e = r[0].ssrcIds[0],\n        n = r[0].ssrcIds[1];\n      i.push({\n        ssrcId: e,\n        rtx: t ? n : void 0\n      });\n    } else {\n      if (0 === o.length) throw new Error(\"No ssrcs found on local media description.\");\n      i.push({\n        ssrcId: o[0].ssrcId\n      });\n    }\n    return i;\n  }\n  function kD(e, t) {\n    const {\n      cname: i\n    } = e;\n    let r;\n    t && t.ip && \"number\" == typeof t.port ? (r = [{\n      foundation: \"udpcandidate\",\n      componentId: \"1\",\n      transport: \"udp\",\n      priority: \"2103266323\",\n      connectionAddress: t.ip,\n      port: t.port.toString(),\n      type: \"host\",\n      extension: {}\n    }], NE.debug(\"Using remote candidate from AP \".concat(t.ip, \":\").concat(t.port)), t.ip6 && (r.push({\n      foundation: \"udpcandidate\",\n      componentId: \"1\",\n      transport: \"udp\",\n      priority: \"2103266323\",\n      connectionAddress: t.ip6,\n      port: t.port.toString(),\n      type: \"host\",\n      extension: {}\n    }), NE.debug(\"Using IPV6 remote candidate from AP \".concat(t.ip6, \":\").concat(t.port)))) : r = e.iceParameters.candidates.map(e => ({\n      foundation: e.foundation,\n      componentId: \"1\",\n      transport: e.protocol,\n      priority: e.priority.toString(),\n      connectionAddress: e.ip,\n      port: e.port.toString(),\n      type: e.type,\n      extension: {}\n    }));\n    const n = {\n        fingerprints: e.dtlsParameters.fingerprints.map(e => ({\n          hashFunction: e.algorithm,\n          fingerprint: e.fingerprint\n        }))\n      },\n      o = {\n        iceUfrag: e.iceParameters.iceUfrag,\n        icePwd: e.iceParameters.icePwd\n      };\n    let s;\n    switch (e.dtlsParameters.role) {\n      case \"server\":\n        s = \"passive\";\n        break;\n      case \"client\":\n        s = \"active\";\n        break;\n      case \"auto\":\n        s = \"actpass\";\n    }\n    return {\n      dtlsParameters: n,\n      iceParameters: o,\n      candidates: r,\n      rtpCapabilities: HD(e.rtpCapabilities),\n      setup: s,\n      cname: i\n    };\n  }\n  function MD(e, t, i) {\n    const r = [],\n      n = [];\n    return e.forEach(e => {\n      let {\n        ssrcId: o,\n        rtx: s\n      } = e;\n      const a = MR(8, \"track-\"),\n        c = {\n          ssrcId: o,\n          attributes: ND({\n            label: a,\n            mslabel: i = i || MR(10, \"\"),\n            msid: \"\".concat(i, \" \").concat(a)\n          }, t && {\n            cname: t\n          })\n        };\n      if (r.push(c), void 0 !== s) {\n        const e = {\n          ssrcId: s,\n          attributes: ND({\n            label: a,\n            mslabel: i,\n            msid: \"\".concat(i, \" \").concat(a)\n          }, t && {\n            cname: t\n          })\n        };\n        r.push(e), n.push({\n          semantic: \"FID\",\n          ssrcIds: [o, s]\n        });\n      }\n    }), e.length > 1 && n.push({\n      semantic: \"SIM\",\n      ssrcIds: e.map(e => {\n        let {\n          ssrcId: t\n        } = e;\n        return t;\n      })\n    }), {\n      ssrcs: r,\n      ssrcGroups: n\n    };\n  }\n  function UD(e, t) {\n    t instanceof aR && e.attributes.payloads.forEach(e => {\n      var i;\n      const r = null === (i = e.rtpMap) || void 0 === i ? void 0 : i.encodingName.toLowerCase();\n      if (!r || -1 === [\"opus\", \"pcmu\", \"pcma\", \"g722\"].indexOf(r)) return;\n      e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters.minptime = \"10\", e.fmtp.parameters.useinbandfec = \"1\";\n      const n = t._encoderConfig;\n      n && \"pcmu\" !== r && \"pcma\" !== r && \"g722\" !== r && (n.bitrate && !Qh() && (e.fmtp.parameters.maxaveragebitrate = \"\".concat(Math.floor(1e3 * n.bitrate))), n.sampleRate && (e.fmtp.parameters.maxplaybackrate = \"\".concat(n.sampleRate), e.fmtp.parameters[\"sprop-maxcapturerate\"] = \"\".concat(n.sampleRate)), n.stereo && (e.fmtp.parameters.stereo = \"1\", e.fmtp.parameters[\"sprop-stereo\"] = \"1\"));\n    });\n  }\n  function xD(e) {\n    const t = e.attributes.unrecognized.findIndex(e => \"x-google-flag\" === e.attField && \"conference\" === e.attValue);\n    -1 !== t && e.attributes.unrecognized.splice(t, 1);\n  }\n  function VD(e, t) {\n    if (!(t instanceof Ew && t._encoderConfig && -1 === t._hints.indexOf(lg.SCREEN_TRACK))) return;\n    const i = t._encoderConfig;\n    jg().supportMinBitrate && i.bitrateMin && e.attributes.payloads.forEach(e => {\n      var t;\n      [\"h264\", \"vp8\", \"vp9\", \"av1\"].includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\") && (e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters[\"x-google-min-bitrate\"] = \"\".concat(i.bitrateMin));\n    }), jg().supportMinBitrate && !t._hints.includes(lg.LOW_STREAM) && i.bitrateMax && e.attributes.payloads.forEach(e => {\n      var t;\n      [\"h264\", \"vp8\", \"vp9\", \"av1\"].includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\") && (e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters[\"x-google-start-bitrate\"] = \"\".concat(HE(\"X_GOOGLE_START_BITRATE\") || Math.floor(i.bitrateMax)));\n    });\n  }\n  function jD(e) {\n    if (\"video\" !== e.media.mediaType) return;\n    const t = Bh();\n    if (t.name !== xh.SAFARI && t.os !== Uh.IOS) return;\n    const i = e.attributes.extmaps.findIndex(e => /video-orientation/g.test(e.extensionName));\n    -1 !== i && e.attributes.extmaps.splice(i, 1);\n  }\n  function FD(e, t, i) {\n    if (!t) return;\n    let r, n;\n    if (\"video\" === e.media.mediaType ? (r = i.videoExtensions, n = i.videoCodecs) : (r = i.audioExtensions, n = i.audioCodecs), !0 === t.tcc) {\n      const t = r.find(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName);\n      if (t) {\n        e.attributes.extmaps.find(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName) || e.attributes.extmaps.push({\n          entry: t.entry,\n          extensionName: \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\"\n        });\n        (function (e, t) {\n          return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => \"transport-cc\" === e.type)));\n        })(n, e.attributes.payloads).forEach(e => {\n          e.rtcpFeedbacks.find(e => \"transport-cc\" === e.type) || e.rtcpFeedbacks.push({\n            type: \"transport-cc\"\n          });\n        });\n      }\n    } else if (!1 === t.tcc) {\n      const t = e.attributes.extmaps.findIndex(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName);\n      -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {\n        const t = e.rtcpFeedbacks.findIndex(e => \"transport-cc\" === e.type);\n        -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n      });\n    }\n    if (!0 === t.remb) {\n      const t = r.find(e => \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e.extensionName);\n      if (t) {\n        e.attributes.extmaps.find(e => \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e.extensionName) || e.attributes.extmaps.push({\n          entry: t.entry,\n          extensionName: \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\"\n        });\n        (function (e, t) {\n          return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => \"goog-remb\" === e.type)));\n        })(n, e.attributes.payloads).forEach(e => {\n          e.rtcpFeedbacks.find(e => \"goog-remb\" === e.type) || e.rtcpFeedbacks.push({\n            type: \"goog-remb\"\n          });\n        });\n      }\n    } else if (!1 === t.remb) {\n      const t = e.attributes.extmaps.findIndex(e => \"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\" === e.extensionName);\n      -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {\n        const t = e.rtcpFeedbacks.findIndex(e => \"goog-remb\" === e.type);\n        -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n      });\n    }\n  }\n  function BD(e, t, i) {\n    if (Qh()) return;\n    if (\"video\" !== e.media.mediaType) return;\n    if (!(t instanceof Ew)) return;\n    if (\"vp9\" !== i && \"vp8\" !== i) return;\n    if (\"vp8\" === i && !HE(\"SIMULCAST\")) return;\n    if (void 0 === t._scalabiltyMode || t._scalabiltyMode.numSpatialLayers <= 1) return;\n    const r = \"vp8\" === i ? 2 : t._scalabiltyMode.numSpatialLayers,\n      n = e.attributes.ssrcs[0],\n      o = e.attributes.ssrcGroups.find(e => \"FID\" === e.semantic && e.ssrcIds[0] === n.ssrcId),\n      s = {\n        semantic: \"SIM\",\n        ssrcIds: [n.ssrcId]\n      };\n    for (let t = 1; t < r; t++) e.attributes.ssrcs.push({\n      ssrcId: n.ssrcId + t,\n      attributes: qR(n.attributes)\n    }), s.ssrcIds.push(n.ssrcId + t), o && (e.attributes.ssrcs.push({\n      ssrcId: o.ssrcIds[1] + t,\n      attributes: qR(n.attributes)\n    }), e.attributes.ssrcGroups.push({\n      semantic: \"FID\",\n      ssrcIds: [n.ssrcId + t, o.ssrcIds[1] + t]\n    }));\n    e.attributes.ssrcGroups.unshift(s);\n  }\n  async function GD(e, t, i, r, n) {\n    const o = new RTCPeerConnection();\n    o.addTransceiver(\"video\", {\n      direction: \"sendonly\"\n    }), o.addTransceiver(\"audio\", {\n      direction: \"sendonly\"\n    }), o.addTransceiver(\"video\", {\n      direction: \"recvonly\"\n    }), o.addTransceiver(\"audio\", {\n      direction: \"recvonly\"\n    });\n    const s = (await o.createOffer()).sdp,\n      a = DD(s, e, t, i, r, n, \"sendonly\"),\n      c = DD(s, e, t, i, r, n, \"recvonly\"),\n      d = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      },\n      u = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      },\n      l = {\n        audioCodecs: [],\n        audioExtensions: [],\n        videoCodecs: [],\n        videoExtensions: []\n      };\n    if (WD(a, c, \"videoExtensions\", d, u, l), WD(a, c, \"videoCodecs\", d, u, l), WD(a, c, \"audioExtensions\", d, u, l), WD(a, c, \"audioCodecs\", d, u, l), HE(\"RAISE_H264_BASELINE_PRIORITY\")) {\n      const e = l.videoCodecs.findIndex(e => {\n        var t, i;\n        return \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && \"42001f\" === (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]);\n      });\n      if (-1 !== e) {\n        const t = l.videoCodecs.findIndex(e => {\n          var t;\n          return \"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase());\n        });\n        if (t < e) {\n          NE.debug(\"raising H264 baseline profile priority\");\n          const i = l.videoCodecs[e];\n          l.videoCodecs.splice(e, 1), l.videoCodecs.splice(t, 0, i);\n        }\n        -1 !== t && (u.videoCodecs = u.videoCodecs.filter(e => {\n          var t, i;\n          return !(\"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && \"42001f\" !== (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]));\n        })), -1 !== t && HE(\"FILTER_SEND_H264_BASELINE\") && (d.videoCodecs = d.videoCodecs.filter(e => {\n          var t, i;\n          return !(\"h264\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && \"42001f\" !== (null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]));\n        }));\n      }\n    }\n    try {\n      o.close();\n    } catch (e) {}\n    return {\n      send: d,\n      recv: u,\n      sendrecv: l\n    };\n  }\n  function WD(e, t, i, r, n, o) {\n    if (\"videoExtensions\" === i || \"audioExtensions\" === i) {\n      const s = [];\n      return e[i].forEach(e => {\n        t[i].some((t, i) => {\n          if (e.entry === t.entry && e.extensionName === t.extensionName) return s.push(i), !0;\n        }) ? o[i].push(e) : r[i].push(e);\n      }), void t[i].forEach((e, t) => {\n        -1 === s.indexOf(t) && n[i].push(e);\n      });\n    }\n    if (\"videoCodecs\" === i || \"audioCodecs\" === i) {\n      const s = [];\n      return e[i].forEach(e => {\n        t[i].some((t, i) => {\n          if (e.payloadType === t.payloadType && JSON.stringify(e) === JSON.stringify(t)) return s.push(i), !0;\n        }) ? o[i].push(e) : r[i].push(e);\n      }), void t[i].forEach((e, t) => {\n        -1 === s.indexOf(t) && n[i].push(e);\n      });\n    }\n  }\n  function HD(e) {\n    const {\n      send: t,\n      recv: i,\n      sendrecv: r\n    } = e;\n    if (!r) {\n      if (!t || !i) throw new Error(\"cannot merge rtp capabilities because one of send or recv is empty!\");\n      return {\n        send: t,\n        recv: i\n      };\n    }\n    let n, o;\n    return t ? (n = {\n      audioCodecs: [],\n      audioExtensions: [],\n      videoCodecs: [],\n      videoExtensions: []\n    }, n.audioCodecs = [...t.audioCodecs, ...r.audioCodecs], n.videoCodecs = [...t.videoCodecs, ...r.videoCodecs], n.audioExtensions = [...t.audioExtensions, ...r.audioExtensions], n.videoExtensions = [...t.videoExtensions, ...r.videoExtensions]) : n = r, i ? (o = {\n      audioCodecs: [],\n      audioExtensions: [],\n      videoCodecs: [],\n      videoExtensions: []\n    }, o.audioCodecs = [...i.audioCodecs, ...r.audioCodecs], o.videoCodecs = [...i.videoCodecs, ...r.videoCodecs], o.audioExtensions = [...i.audioExtensions, ...r.audioExtensions], o.videoExtensions = [...i.videoExtensions, ...r.videoExtensions]) : o = r, {\n      send: n,\n      recv: o\n    };\n  }\n  function KD(e) {\n    if (\"audio\" !== e.media.mediaType) return;\n    e.attributes.payloads.filter(e => {\n      var t;\n      return \"opus\" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase());\n    }).forEach(e => {\n      e.fmtp || (e.fmtp = {\n        parameters: {}\n      }), e.fmtp.parameters.stereo = \"1\", e.fmtp.parameters[\"sprop-stereo\"] = \"1\";\n    });\n  }\n  !function (e, t) {\n    e.exports = (() => {\n      var e = {\n          8: (e, t, i) => {\n            i.r(t), i.d(t, {\n              Parser: () => R,\n              Printer: () => O,\n              parse: () => D,\n              print: () => P\n            });\n            const r = \"\\n\",\n              n = \"\".concat(\"\\r\").concat(r),\n              o = \" \";\n            let s;\n            function a(e) {\n              return e >= \"0\" && e <= \"9\";\n            }\n            function c(e) {\n              return e >= \"!\" && e <= \"~\";\n            }\n            function d(e) {\n              return c(e) || e >= \"Â\" && e <= \"Ã¿\";\n            }\n            function u(e) {\n              return \"!\" === e || e >= \"#\" && e <= \"'\" || e >= \"*\" && e <= \"+\" || e >= \"-\" && e <= \".\" || e >= \"0\" && e <= \"9\" || e >= \"A\" && e <= \"Z\" || e >= \"^\" && e <= \"~\";\n            }\n            function l(e) {\n              return e >= \"1\" && e <= \"9\";\n            }\n            function h(e) {\n              return e >= \"A\" && e <= \"Z\" || e >= \"a\" && e <= \"z\";\n            }\n            function p(e) {\n              return \"d\" === e || \"h\" === e || \"m\" === e || \"s\" === e;\n            }\n            function _(e) {\n              return e > \"\u0001\" && e < \"\\t\" || e > \"\\v\" && e < \"\\f\" || e > \"\u000e\" && e < \"Ã¿\";\n            }\n            function E(e) {\n              return h(e) || a(e) || \"+\" === e || \"/\" === e;\n            }\n            function f(e) {\n              return a(e) || h(e) || \"+\" === e || \"/\" === e || \"-\" === e || \"_\" === e;\n            }\n            function m(e) {\n              return h(e) || a(e) || \"+\" === e || \"/\" === e;\n            }\n            function g(e, t) {\n              var i = Object.keys(e);\n              if (Object.getOwnPropertySymbols) {\n                var r = Object.getOwnPropertySymbols(e);\n                t && (r = r.filter(function (t) {\n                  return Object.getOwnPropertyDescriptor(e, t).enumerable;\n                })), i.push.apply(i, r);\n              }\n              return i;\n            }\n            function S(e) {\n              for (var t = 1; t < arguments.length; t++) {\n                var i = null != arguments[t] ? arguments[t] : {};\n                t % 2 ? g(Object(i), !0).forEach(function (t) {\n                  T(e, t, i[t]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : g(Object(i)).forEach(function (t) {\n                  Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n                });\n              }\n              return e;\n            }\n            function T(e, t, i) {\n              return t in e ? Object.defineProperty(e, t, {\n                value: i,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n              }) : e[t] = i, e;\n            }\n            !function (e) {\n              e.VERSION = \"v\", e.ORIGIN = \"o\", e.SESSION_NAME = \"s\", e.INFORMATION = \"i\", e.URI = \"u\", e.EMAIL = \"e\", e.PHONE = \"p\", e.CONNECTION = \"c\", e.BANDWIDTH = \"b\", e.TIME = \"t\", e.REPEAT = \"r\", e.ZONE_ADJUSTMENTS = \"z\", e.KEY = \"k\", e.ATTRIBUTE = \"a\", e.MEDIA = \"m\";\n            }(s || (s = {}));\n            class v {\n              consumeText(e, t) {\n                let i = t;\n                for (; i < e.length;) {\n                  const t = e[i];\n                  if (\"\\0\" === t || \"\\r\" === t || t === r) break;\n                  i += 1;\n                }\n                if (i - t == 0) throw new Error(\"Invalid text, at \".concat(e));\n                return i;\n              }\n              consumeUnicastAddress(e, t, i) {\n                return this.consumeTill(e, t, o);\n              }\n              consumeOneOrMore(e, t, i) {\n                let r = t;\n                for (; i(e[r]);) r++;\n                if (r - t == 0) throw new Error(\"Invalid rule at \".concat(t, \".\"));\n                return r;\n              }\n              consumeSpace(e, t) {\n                if (e[t] === o) return t + 1;\n                throw new Error(\"Invalid space at \".concat(t, \".\"));\n              }\n              consumeIP4Address(e, t) {\n                let i = t;\n                for (let t = 0; t < 4; t++) if (i = this.consumeDecimalUChar(e, i), 3 !== t) {\n                  if (\".\" !== e[i]) throw new Error(\"Invalid IP4 address.\");\n                  i++;\n                }\n                return i;\n              }\n              consumeDecimalUChar(e, t) {\n                let i = t;\n                for (let t = 0; t < 3 && a(e[i]); t++, i++);\n                if (i - t == 0) throw new Error(\"Invalid decimal uchar.\");\n                const r = parseInt(e.slice(t, i));\n                if (r >= 0 && r <= 255) return i;\n                throw new Error(\"Invalid decimal uchar\");\n              }\n              consumeIP6Address(e, t) {\n                let i = this.consumeHexpart(e, t);\n                return \":\" === e[i] ? (i += 1, i = this.consumeIP4Address(e, i), i) : i;\n              }\n              consumeHexpart(e, t) {\n                let i = t;\n                if (\":\" === e[i] && \":\" === e[i + 1]) {\n                  i += 2;\n                  try {\n                    i = this.consumeHexseq(e, i);\n                  } catch (e) {}\n                  return i;\n                }\n                if (i = this.consumeHexseq(e, i), \":\" === e[i] && \":\" === e[i + 1]) {\n                  i += 2;\n                  try {\n                    i = this.consumeHexseq(e, i);\n                  } catch (e) {}\n                  return i;\n                }\n                return i;\n              }\n              consumeHexseq(e, t) {\n                let i = t;\n                for (; i = this.consumeHex4(e, i), \":\" === e[i] && \":\" !== e[i + 1];) i += 1;\n                return i;\n              }\n              consumeHex4(e, t) {\n                let i = 0;\n                for (; i < 4; i++) if (!((r = e[t + i]) >= \"0\" && r <= \"9\" || r >= \"a\" && r <= \"f\" || r >= \"A\" && r <= \"F\")) {\n                  if (0 === i) throw new Error(\"Invalid hex 4\");\n                  break;\n                }\n                var r;\n                return t + i;\n              }\n              consumeFQDN(e, t) {\n                let i = t;\n                for (; a(e[i]) || h(e[i]) || \"-\" === e[i] || \".\" === e[i];) i += 1;\n                if (i - t < 4) throw new Error(\"Invalid FQDN\");\n                return i;\n              }\n              consumeExtnAddr(e, t) {\n                return this.consumeOneOrMore(e, t, d);\n              }\n              consumeMulticastAddress(e, t, i) {\n                switch (i) {\n                  case \"IP4\":\n                  case \"ip4\":\n                    return this.consumeIP4MulticastAddress(e, t);\n                  case \"IP6\":\n                  case \"ip6\":\n                    return this.consumeIP6MulticastAddress(e, t);\n                  default:\n                    try {\n                      return this.consumeFQDN(e, t);\n                    } catch (i) {\n                      return this.consumeExtnAddr(e, t);\n                    }\n                }\n              }\n              consumeIP6MulticastAddress(e, t) {\n                const i = this.consumeHexpart(e, t);\n                return \"/\" === e[i] ? this.consumeInteger(e, i + 1) : i;\n              }\n              consumeIP4MulticastAddress(e, t) {\n                let i = t + 3;\n                const r = e.slice(t, i),\n                  n = parseInt(r);\n                if (n < 224 || n > 239) throw new Error(\"Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.\");\n                for (let t = 0; t < 3; t++) {\n                  if (\".\" !== e[i]) throw new Error(\"Invalid IP4 multicast address.\");\n                  i += 1, i = this.consumeDecimalUChar(e, i);\n                }\n                return \"/\" === e[i] && (i += 1), i = this.consumeTTL(e, i), \"/\" === e[i] && (i = this.consumeInteger(e, i)), i;\n              }\n              consumeInteger(e, t) {\n                if (!l(e[t])) throw new Error(\"Invalid integer.\");\n                for (t += 1; a(e[t]);) t += 1;\n                return t;\n              }\n              consumeTTL(e, t) {\n                if (\"0\" === e[t]) return t + 1;\n                if (!l(e[t])) throw new Error(\"Invalid TTL.\");\n                t += 1;\n                for (let i = 0; i < 2 && a(e[t]); i++) t += 1;\n                return t;\n              }\n              consumeToken(e, t) {\n                return this.consumeOneOrMore(e, t, u);\n              }\n              consumeTime(e, t) {\n                let i = t;\n                if (\"0\" === e[i]) return i + 1;\n                for (l(e[i]) && (i += 1); a(e[i]);) i++;\n                if (i - t < 10) throw new Error(\"Invalid time\");\n                return i;\n              }\n              consumeAddress(e, t) {\n                return this.consumeTill(e, t, o);\n              }\n              consumeTypedTime(e, t) {\n                let i = t;\n                return i = this.consumeOneOrMore(e, i, a), p(e[i]) ? i + 1 : i;\n              }\n              consumeRepeatInterval(e, t) {\n                if (!l(e[t])) throw new Error(\"Invalid repeat interval\");\n                for (t += 1; a(e[t]);) t += 1;\n                return p(e[t]) && (t += 1), t;\n              }\n              consumePort(e, t) {\n                return this.consumeOneOrMore(e, t, a);\n              }\n              consume(e, t, i) {\n                for (let r = 0; r < i.length; r++) {\n                  if (t + r >= e.length) throw new Error(\"consume exceeding value length\");\n                  if (e[t + r] !== i[r]) throw new Error(\"consume \".concat(i, \" failed at \").concat(r));\n                }\n                return t + i.length;\n              }\n              consumeTill(e, t, i) {\n                let r = t;\n                for (; r < e.length && (\"string\" != typeof i || e[r] !== i) && (\"function\" != typeof i || !i(e[r]));) r++;\n                return r;\n              }\n            }\n            class R extends v {\n              constructor() {\n                super(), T(this, \"records\", []), T(this, \"currentLine\", 0);\n              }\n              parse(e) {\n                const t = this.probeEOL(e);\n                this.records = e.split(t).filter(e => !!e.trim()).map(this.parseLine), this.currentLine = 0;\n                const i = this.parseVersion(),\n                  r = this.parseOrigin(),\n                  n = this.parseSessionName(),\n                  o = this.parseInformation(),\n                  s = this.parseUri(),\n                  a = this.parseEmail(),\n                  c = this.parsePhone(),\n                  d = this.parseConnection(),\n                  u = this.parseBandWidth(),\n                  l = this.parseTimeFields(),\n                  h = this.parseKey(),\n                  p = this.parseSessionAttribute(),\n                  _ = this.parseMediaDescription();\n                if (this.currentLine !== this.records.length) throw new Error(\"parsing failed, non exhaustive sdp lines.\");\n                return {\n                  version: i,\n                  origin: r,\n                  sessionName: n,\n                  information: o,\n                  uri: s,\n                  emails: a,\n                  phones: c,\n                  connection: d,\n                  bandwidths: u,\n                  timeFields: l,\n                  key: h,\n                  attributes: p,\n                  mediaDescriptions: _\n                };\n              }\n              getCurrentRecord() {\n                const e = this.records[this.currentLine];\n                if (!e) throw new Error(\"Record doesn't exit.\");\n                return e;\n              }\n              probeEOL(e) {\n                for (let t = 0; t < e.length; t++) if (e[t] === r) return \"\\r\" === e[t - 1] ? n : r;\n                throw new Error(\"Invalid newline character.\");\n              }\n              parseLine(e, t) {\n                if (e.length < 2) throw new Error(\"Invalid sdp line, sdp line should be of form <type>=<value>.\");\n                const i = e[0];\n                if (\"=\" !== e[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an \"=\" sign.');\n                return {\n                  type: i,\n                  value: e.slice(2),\n                  line: t,\n                  cur: 0\n                };\n              }\n              parseSessionAttribute() {\n                const e = new y();\n                for (; this.currentLine < this.records.length;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.ATTRIBUTE) break;\n                  const i = {\n                    attField: this.extractOneOrMore(t, e => u(e) && \":\" !== e),\n                    _cur: 0\n                  };\n                  \":\" === t.value[t.cur] && (t.cur += 1, i.attValue = this.extractOneOrMore(t, _)), e.parse(i), this.currentLine++;\n                }\n                return e.digest();\n              }\n              parseMediaAttributes(e) {\n                const t = new C(e);\n                for (; this.currentLine < this.records.length;) {\n                  const e = this.getCurrentRecord();\n                  if (e.type !== s.ATTRIBUTE) break;\n                  const i = {\n                    attField: this.extractOneOrMore(e, e => u(e) && \":\" !== e),\n                    _cur: 0\n                  };\n                  \":\" === e.value[e.cur] && (e.cur += 1, i.attValue = this.extractOneOrMore(e, _)), t.parse(i), this.currentLine++;\n                }\n                return t.digest();\n              }\n              parseKey() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.KEY) {\n                  if (\"prompt\" === e.value || \"clear:\" === e.value || \"base64:\" === e.value || \"uri:\" === e.value) return e.value;\n                  throw this.currentLine++, new Error(\"Invalid key.\");\n                }\n              }\n              parseZone() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.ZONE_ADJUSTMENTS) {\n                  const t = [];\n                  for (;;) try {\n                    const i = this.extract(e, this.consumeTime);\n                    this.consumeSpaceForRecord(e);\n                    let r = !1;\n                    \"-\" === e.value[e.cur] && (r = !0, e.cur += 1);\n                    const n = this.extract(e, this.consumeTypedTime);\n                    t.push({\n                      time: i,\n                      typedTime: n,\n                      back: r\n                    });\n                  } catch (e) {\n                    break;\n                  }\n                  if (0 === t.length) throw new Error(\"Invalid zone adjustments\");\n                  return this.currentLine++, t;\n                }\n                return [];\n              }\n              parseRepeat() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.REPEAT) break;\n                  {\n                    const i = this.extract(t, this.consumeRepeatInterval),\n                      r = this.parseTypedTime(t);\n                    e.push({\n                      repeatInterval: i,\n                      typedTimes: r\n                    }), this.currentLine++;\n                  }\n                }\n                return e;\n              }\n              parseTypedTime(e) {\n                const t = [];\n                for (;;) try {\n                  this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeTypedTime));\n                } catch (e) {\n                  break;\n                }\n                if (0 === t.length) throw new Error(\"Invalid typed time.\");\n                return t;\n              }\n              parseTime() {\n                const e = this.getCurrentRecord(),\n                  t = this.extract(e, this.consumeTime);\n                this.consumeSpaceForRecord(e);\n                const i = this.extract(e, this.consumeTime);\n                return this.currentLine++, {\n                  startTime: t,\n                  stopTime: i\n                };\n              }\n              parseBandWidth() {\n                const e = [];\n                for (; this.currentLine < this.records.length;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.BANDWIDTH) break;\n                  {\n                    const i = this.extractOneOrMore(t, u);\n                    if (\":\" !== t.value[t.cur]) throw new Error(\"Invalid bandwidth field.\");\n                    t.cur++;\n                    const r = this.extractOneOrMore(t, a);\n                    e.push({\n                      bwtype: i,\n                      bandwidth: r\n                    }), this.currentLine++;\n                  }\n                }\n                return e;\n              }\n              parseVersion() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.VERSION) throw new Error(\"first sdp record must be version\");\n                const t = e.value.slice(0, this.consumeOneOrMore(e.value, 0, a));\n                if (t.length !== e.value.length) throw new Error('invalid proto version, \"v='.concat(e.value, '\"'));\n                return this.currentLine++, t;\n              }\n              parseOrigin() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.ORIGIN) throw new Error(\"second line of sdp must be origin\");\n                const t = this.extractOneOrMore(e, d);\n                this.consumeSpaceForRecord(e);\n                const i = this.extractOneOrMore(e, a);\n                this.consumeSpaceForRecord(e);\n                const r = this.extractOneOrMore(e, a);\n                this.consumeSpaceForRecord(e);\n                const n = this.extractOneOrMore(e, u);\n                this.consumeSpaceForRecord(e);\n                const o = this.extractOneOrMore(e, u);\n                this.consumeSpaceForRecord(e);\n                const c = this.extract(e, this.consumeUnicastAddress);\n                return this.currentLine++, {\n                  username: t,\n                  sessId: i,\n                  sessVersion: r,\n                  nettype: n,\n                  addrtype: o,\n                  unicastAddress: c\n                };\n              }\n              parseSessionName() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.SESSION_NAME) {\n                  const t = this.extract(e, this.consumeText);\n                  return this.currentLine++, t;\n                }\n              }\n              parseInformation() {\n                const e = this.getCurrentRecord();\n                if (e.type !== s.INFORMATION) return;\n                const t = this.extract(e, this.consumeText);\n                return this.currentLine++, t;\n              }\n              parseUri() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.URI) return this.currentLine++, e.value;\n              }\n              parseEmail() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.EMAIL) break;\n                  e.push(t.value), this.currentLine++;\n                }\n                return e;\n              }\n              parsePhone() {\n                const e = [];\n                for (;;) {\n                  const t = this.getCurrentRecord();\n                  if (t.type !== s.PHONE) break;\n                  e.push(t.value), this.currentLine++;\n                }\n                return e;\n              }\n              parseConnection() {\n                const e = this.getCurrentRecord();\n                if (e.type === s.CONNECTION) {\n                  const t = this.extractOneOrMore(e, u);\n                  this.consumeSpaceForRecord(e);\n                  const i = this.extractOneOrMore(e, u);\n                  this.consumeSpaceForRecord(e);\n                  const r = this.extract(e, this.consumeAddress);\n                  return this.currentLine++, {\n                    nettype: t,\n                    addrtype: i,\n                    address: r\n                  };\n                }\n              }\n              parseMedia() {\n                const e = this.getCurrentRecord(),\n                  t = this.extract(e, this.consumeToken);\n                this.consumeSpaceForRecord(e);\n                let i = this.extract(e, this.consumePort);\n                \"/\" === e.value[e.cur] && (e.cur += 1, i += this.extract(e, this.consumeInteger)), this.consumeSpaceForRecord(e);\n                const r = [];\n                for (r.push(this.extract(e, this.consumeToken)); \"/\" === e.value[e.cur];) e.cur += 1, r.push(this.extract(e, this.consumeToken));\n                if (0 === r.length) throw new Error(\"Invalid proto\");\n                const n = this.parseFmt(e);\n                return this.currentLine++, {\n                  mediaType: t,\n                  port: i,\n                  protos: r,\n                  fmts: n\n                };\n              }\n              parseTimeFields() {\n                const e = [];\n                for (; this.getCurrentRecord().type === s.TIME;) {\n                  const t = this.parseTime(),\n                    i = this.parseRepeat(),\n                    r = this.parseZone();\n                  e.push({\n                    time: t,\n                    repeats: i,\n                    zones: r\n                  });\n                }\n                return e;\n              }\n              parseMediaDescription() {\n                const e = [];\n                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.MEDIA;) {\n                  const t = this.parseMedia(),\n                    i = this.parseInformation(),\n                    r = this.parseConnections(),\n                    n = this.parseBandWidth(),\n                    o = this.parseKey(),\n                    s = this.parseMediaAttributes(t);\n                  e.push({\n                    media: t,\n                    information: i,\n                    connections: r,\n                    bandwidths: n,\n                    key: o,\n                    attributes: s\n                  });\n                }\n                return e;\n              }\n              parseConnections() {\n                const e = [];\n                for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.CONNECTION;) e.push(this.parseConnection());\n                return e;\n              }\n              parseFmt(e) {\n                const t = [];\n                for (;;) try {\n                  this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeToken));\n                } catch (e) {\n                  break;\n                }\n                if (0 === t.length) throw new Error(\"Invalid fmts\");\n                return t;\n              }\n              extract(e, t) {\n                for (var _len = arguments.length, i = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n                  i[_key - 2] = arguments[_key];\n                }\n                const r = t.call(this, e.value, e.cur, ...i),\n                  n = e.value.slice(e.cur, r);\n                return e.cur = r, n;\n              }\n              extractOneOrMore(e, t) {\n                const i = this.consumeOneOrMore(e.value, e.cur, t),\n                  r = e.value.slice(e.cur, i);\n                return e.cur = i, r;\n              }\n              consumeSpaceForRecord(e) {\n                if (e.value[e.cur] !== o) throw new Error(\"Invalid space at \".concat(e.cur, \".\"));\n                e.cur += 1;\n              }\n            }\n            class I extends v {\n              constructor() {\n                super(...arguments), T(this, \"attributes\", void 0), T(this, \"digested\", !1);\n              }\n              extractOneOrMore(e, t, i) {\n                const r = this.consumeOneOrMore(e.attValue, e._cur, t),\n                  n = e.attValue.slice(e._cur, r),\n                  [o, s] = i || [];\n                if (\"number\" == typeof o && n.length < o) throw new Error(\"error in length, should be more or equal than \".concat(o, \" characters.\"));\n                if (\"number\" == typeof s && n.length > s) throw new Error(\"error in length, should be less or equal than \".concat(s, \" characters.\"));\n                return e._cur = r, n;\n              }\n              consumeAttributeSpace(e) {\n                if (e.attValue[e._cur] !== o) throw new Error(\"Invalid space at \".concat(e._cur, \".\"));\n                e._cur += 1;\n              }\n              extract(e, t) {\n                if (!e.attValue) throw new Error(\"Nothing to extract from attValue.\");\n                for (var _len2 = arguments.length, i = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n                  i[_key2 - 2] = arguments[_key2];\n                }\n                const r = t.call(this, e.attValue, e._cur, ...i),\n                  n = e.attValue.slice(e._cur, r);\n                return e._cur = r, n;\n              }\n              atEnd(e) {\n                if (!e.attValue) throw new Error();\n                return e._cur >= e.attValue.length;\n              }\n              peekChar(e) {\n                if (!e.attValue) throw new Error();\n                return e.attValue[e._cur];\n              }\n              peek(e, t) {\n                if (!e.attValue) throw new Error();\n                for (let i = 0; i < t.length; i++) if (t[i] !== e.attValue[e._cur + i]) return !1;\n                return !0;\n              }\n              parseIceUfrag(e) {\n                if (this.attributes.iceUfrag) throw new Error(\"Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'\");\n                this.attributes.iceUfrag = this.extractOneOrMore(e, E, [4, 256]);\n              }\n              parseIcePwd(e) {\n                if (this.attributes.icePwd) throw new Error(\"Invalid ice-pwd, should be only a single line if 'a=ice-pwd'\");\n                this.attributes.icePwd = this.extractOneOrMore(e, E, [22, 256]);\n              }\n              parseIceOptions(e) {\n                if (this.attributes.iceOptions) throw new Error(\"Invalid ice-options, should be only one 'ice-options' line\");\n                const t = [];\n                for (; !this.atEnd(e);) {\n                  t.push(this.extractOneOrMore(e, E));\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (t) {\n                    if (this.atEnd(e)) break;\n                    throw t;\n                  }\n                }\n                this.attributes.iceOptions = t;\n              }\n              parseFingerprint(e) {\n                const t = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill);\n                this.attributes.fingerprints.push({\n                  hashFunction: t,\n                  fingerprint: i\n                });\n              }\n              parseExtmap(e) {\n                const t = this.extractOneOrMore(e, a);\n                let i;\n                \"/\" === this.peekChar(e) && (this.extract(e, this.consume, \"/\"), i = this.extract(e, this.consumeToken)), this.consumeAttributeSpace(e);\n                const r = this.extract(e, this.consumeTill, o),\n                  n = S(S({\n                    entry: parseInt(t, 10)\n                  }, i && {\n                    direction: i\n                  }), {}, {\n                    extensionName: r\n                  });\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), n.extensionAttributes = this.extract(e, this.consumeTill)), this.attributes.extmaps.push(n);\n              }\n              parseSetup(e) {\n                if (this.attributes.setup) throw new Error(\"must only be one single 'a=setup' line.\");\n                const t = this.extract(e, this.consumeTill);\n                if (\"active\" !== t && \"passive\" !== t && \"actpass\" !== t && \"holdconn\" !== t) throw new Error(\"role must be one of 'active', 'passive', 'actpass', 'holdconn'.\");\n                this.attributes.setup = t;\n              }\n            }\n            class y extends I {\n              constructor() {\n                super(...arguments), T(this, \"attributes\", {\n                  unrecognized: [],\n                  groups: [],\n                  extmaps: [],\n                  fingerprints: [],\n                  identities: []\n                });\n              }\n              parse(e) {\n                if (this.digested) throw new Error(\"already digested\");\n                try {\n                  switch (e.attField) {\n                    case \"group\":\n                      this.parseGroup(e);\n                      break;\n                    case \"ice-lite\":\n                      this.parseIceLite();\n                      break;\n                    case \"ice-ufrag\":\n                      this.parseIceUfrag(e);\n                      break;\n                    case \"ice-pwd\":\n                      this.parseIcePwd(e);\n                      break;\n                    case \"ice-options\":\n                      this.parseIceOptions(e);\n                      break;\n                    case \"fingerprint\":\n                      this.parseFingerprint(e);\n                      break;\n                    case \"setup\":\n                      this.parseSetup(e);\n                      break;\n                    case \"tls-id\":\n                      this.parseTlsId(e);\n                      break;\n                    case \"identity\":\n                      this.parseIdentity(e);\n                      break;\n                    case \"extmap\":\n                      this.parseExtmap(e);\n                      break;\n                    case \"msid-semantic\":\n                      this.parseMsidSemantic(e);\n                      break;\n                    default:\n                      e.ignored = !0, this.attributes.unrecognized.push(e);\n                  }\n                } catch (t) {\n                  throw console.error(\"parsing session attribute \".concat(e.attField, ' error, \"a=').concat(e.attField, \":\").concat(e.attValue, '\"')), t;\n                }\n                if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error(\"attribute parsing error\");\n              }\n              digest() {\n                return this.digested = !0, this.attributes;\n              }\n              parseGroup(e) {\n                const t = this.extract(e, this.consumeToken),\n                  i = [];\n                for (; !this.atEnd(e) && this.peekChar(e) === o;) this.consumeAttributeSpace(e), i.push(this.extract(e, this.consumeToken));\n                this.attributes.groups.push({\n                  semantic: t,\n                  identificationTag: i\n                });\n              }\n              parseIceLite() {\n                if (this.attributes.iceLite) throw new Error(\"Invalid ice-lite, should be only a single line of 'a=ice-lite'\");\n                this.attributes.iceLite = !0;\n              }\n              parseTlsId(e) {\n                if (this.attributes.tlsId) throw new Error(\"must be only one tld-id line\");\n                this.attributes.tlsId = this.extractOneOrMore(e, f);\n              }\n              parseIdentity(e) {\n                const t = this.extractOneOrMore(e, m),\n                  i = [];\n                for (; !this.atEnd(e) && this.peekChar(e) === o;) {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeToken);\n                  this.extract(e, this.consume, \"=\");\n                  const r = this.extractOneOrMore(e, e => e !== o && _(e));\n                  i.push({\n                    name: t,\n                    value: r\n                  });\n                }\n                this.attributes.identities.push({\n                  assertionValue: t,\n                  extensions: i\n                });\n              }\n              parseMsidSemantic(e) {\n                this.peekChar(e) === o && this.consumeAttributeSpace(e);\n                const t = {\n                  semantic: this.extract(e, this.consumeToken),\n                  identifierList: []\n                };\n                for (;;) {\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (e) {\n                    break;\n                  }\n                  if (\"*\" === this.peekChar(e)) {\n                    this.extract(e, this.consume, \"*\"), t.applyForAll = !0;\n                    break;\n                  }\n                  {\n                    const i = this.extract(e, this.consumeTill, o);\n                    t.identifierList.push(i);\n                  }\n                }\n                this.attributes.msidSemantic = t;\n              }\n            }\n            class C extends I {\n              constructor(e) {\n                super(), T(this, \"attributes\", void 0), -1 !== e.protos.indexOf(\"RTP\") || e.protos.indexOf(\"rtp\"), this.attributes = {\n                  unrecognized: [],\n                  candidates: [],\n                  extmaps: [],\n                  fingerprints: [],\n                  imageattr: [],\n                  msids: [],\n                  remoteCandidatesList: [],\n                  rids: [],\n                  ssrcs: [],\n                  ssrcGroups: [],\n                  rtcpFeedbackWildcards: [],\n                  payloads: []\n                };\n              }\n              parse(e) {\n                if (this.digested) throw new Error(\"already digested\");\n                try {\n                  switch (e.attField) {\n                    case \"extmap\":\n                      this.parseExtmap(e);\n                      break;\n                    case \"setup\":\n                      this.parseSetup(e);\n                      break;\n                    case \"ice-ufrag\":\n                      this.parseIceUfrag(e);\n                      break;\n                    case \"ice-pwd\":\n                      this.parseIcePwd(e);\n                      break;\n                    case \"ice-options\":\n                      this.parseIceOptions(e);\n                      break;\n                    case \"candidate\":\n                      this.parseCandidate(e);\n                      break;\n                    case \"remote-candidate\":\n                      this.parseRemoteCandidate(e);\n                      break;\n                    case \"end-of-candidates\":\n                      this.parseEndOfCandidates();\n                      break;\n                    case \"fingerprint\":\n                      this.parseFingerprint(e);\n                      break;\n                    case \"rtpmap\":\n                      this.parseRtpmap(e);\n                      break;\n                    case \"ptime\":\n                      this.parsePtime(e);\n                      break;\n                    case \"maxptime\":\n                      this.parseMaxPtime(e);\n                      break;\n                    case \"sendrecv\":\n                    case \"recvonly\":\n                    case \"sendonly\":\n                    case \"inactive\":\n                      this.parseDirection(e);\n                      break;\n                    case \"ssrc\":\n                      this.parseSSRC(e);\n                      break;\n                    case \"fmtp\":\n                      this.parseFmtp(e);\n                      break;\n                    case \"rtcp-fb\":\n                      this.parseRtcpFb(e);\n                      break;\n                    case \"rtcp-mux\":\n                      this.parseRTCPMux();\n                      break;\n                    case \"rtcp-mux-only\":\n                      this.parseRTCPMuxOnly();\n                      break;\n                    case \"rtcp-rsize\":\n                      this.parseRTCPRsize();\n                      break;\n                    case \"rtcp\":\n                      this.parseRTCP(e);\n                      break;\n                    case \"mid\":\n                      this.parseMid(e);\n                      break;\n                    case \"msid\":\n                      this.parseMsid(e);\n                      break;\n                    case \"imageattr\":\n                      this.parseImageAttr(e);\n                      break;\n                    case \"rid\":\n                      this.parseRid(e);\n                      break;\n                    case \"simulcast\":\n                      this.parseSimulcast(e);\n                      break;\n                    case \"sctp-port\":\n                      this.parseSctpPort(e);\n                      break;\n                    case \"max-message-size\":\n                      this.parseMaxMessageSize(e);\n                      break;\n                    case \"ssrc-group\":\n                      this.parseSSRCGroup(e);\n                      break;\n                    default:\n                      e.ignored = !0, this.attributes.unrecognized.push(e);\n                  }\n                } catch (t) {\n                  throw console.error(\"parsing media attribute \".concat(e.attField, ' error, \"a=').concat(e.attField, \":\").concat(e.attValue, '\"')), t;\n                }\n                if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error(\"attribute parsing error\");\n              }\n              parseCandidate(e) {\n                const t = this.extractOneOrMore(e, E, [1, 32]);\n                this.consumeAttributeSpace(e);\n                const i = this.extractOneOrMore(e, a, [1, 5]);\n                this.consumeAttributeSpace(e);\n                const r = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const n = this.extractOneOrMore(e, a, [1, 10]);\n                this.consumeAttributeSpace(e);\n                const s = this.extract(e, this.consumeAddress);\n                this.consumeAttributeSpace(e);\n                const d = this.extract(e, this.consumePort);\n                this.consumeAttributeSpace(e), this.extract(e, this.consume, \"typ\"), this.consumeAttributeSpace(e);\n                const u = {\n                  foundation: t,\n                  componentId: i,\n                  transport: r,\n                  priority: n,\n                  connectionAddress: s,\n                  port: d,\n                  type: this.extract(e, this.consumeToken),\n                  extension: {}\n                };\n                for (this.peek(e, \" raddr\") && (this.extract(e, this.consume, \" raddr\"), this.consumeAttributeSpace(e), u.relAddr = this.extract(e, this.consumeAddress)), this.peek(e, \" rport\") && (this.extract(e, this.consume, \" rport\"), this.consumeAttributeSpace(e), u.relPort = this.extract(e, this.consumePort)); this.peekChar(e) === o;) {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeToken);\n                  this.consumeAttributeSpace(e), u.extension[t] = this.extractOneOrMore(e, c);\n                }\n                this.attributes.candidates.push(u);\n              }\n              parseRemoteCandidate(e) {\n                const t = [];\n                for (;;) {\n                  const i = this.extractOneOrMore(e, a, [1, 5]);\n                  this.consumeAttributeSpace(e);\n                  const r = this.extract(e, this.consumeAddress);\n                  this.consumeAttributeSpace(e);\n                  const n = this.extract(e, this.consumePort);\n                  t.push({\n                    componentId: i,\n                    connectionAddress: r,\n                    port: n\n                  });\n                  try {\n                    this.consumeAttributeSpace(e);\n                  } catch (e) {\n                    break;\n                  }\n                }\n                this.attributes.remoteCandidatesList.push(t);\n              }\n              parseEndOfCandidates() {\n                if (this.attributes.endOfCandidates) throw new Error(\"must be only one line of end-of-candidates\");\n                this.attributes.endOfCandidates = !0;\n              }\n              parseRtpmap(e) {\n                const t = this.extract(e, this.consumeToken);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, \"/\");\n                this.extract(e, this.consume, \"/\");\n                const r = {\n                  encodingName: i,\n                  clockRate: this.extractOneOrMore(e, a)\n                };\n                this.atEnd(e) || \"/\" !== this.peekChar(e) || (this.extract(e, this.consume, \"/\"), r.encodingParameters = parseInt(this.extract(e, this.consumeTill), 10));\n                const n = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                n ? n.rtpMap = r : this.attributes.payloads.push({\n                  payloadType: parseInt(t, 10),\n                  rtpMap: r,\n                  rtcpFeedbacks: []\n                });\n              }\n              parsePtime(e) {\n                if (this.attributes.ptime) throw new Error(\"must be only one line of ptime\");\n                this.attributes.ptime = this.extract(e, this.consumeTill);\n              }\n              parseMaxPtime(e) {\n                if (this.attributes.maxPtime) throw new Error(\"must be only one line of ptime\");\n                this.attributes.maxPtime = this.extract(e, this.consumeTill);\n              }\n              parseDirection(e) {\n                if (this.attributes.direction) throw new Error(\"must be only one line of direction info\");\n                this.attributes.direction = e.attField;\n              }\n              parseSSRC(e) {\n                const t = this.extractOneOrMore(e, a);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, \":\");\n                let r;\n                \":\" === this.peekChar(e) && (this.extract(e, this.consume, \":\"), r = this.extract(e, this.consumeTill));\n                const n = this.attributes.ssrcs.find(e => e.ssrcId === parseInt(t, 10));\n                n ? n.attributes[i] = r : this.attributes.ssrcs.push({\n                  ssrcId: parseInt(t, 10),\n                  attributes: {\n                    [i]: r\n                  }\n                });\n              }\n              parseFmtp(e) {\n                const t = this.extract(e, this.consumeTill, o);\n                this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill),\n                  r = {};\n                i.split(\";\").forEach(e => {\n                  let [t, i] = e.split(\"=\");\n                  t = t.trim();\n                  const n = \"string\" == typeof i ? i.trim() : null;\n                  \"string\" == typeof t && t.length > 0 && (r[t] = n);\n                });\n                const n = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                n ? n.fmtp = {\n                  parameters: r\n                } : this.attributes.payloads.push({\n                  payloadType: parseInt(t, 10),\n                  rtcpFeedbacks: [],\n                  fmtp: {\n                    parameters: r\n                  }\n                });\n              }\n              parseFmtParameters(e) {\n                const t = {},\n                  i = this.extract(e, this.consumeTill, \"=\");\n                e._cur++;\n                const r = this.extract(e, this.consumeTill, \";\");\n                for (t[i] = r; \";\" === e.attValue[e._cur];) {\n                  const i = this.extract(e, this.consumeTill, \"=\");\n                  e._cur++;\n                  const r = this.extract(e, this.consumeTill, \";\");\n                  t[i] = r;\n                }\n                return t;\n              }\n              parseRtcpFb(e) {\n                let t = \"\";\n                t = \"*\" === this.peekChar(e) ? this.extract(e, this.consume, \"*\") : this.extract(e, this.consumeTill, o), this.consumeAttributeSpace(e);\n                const i = this.extract(e, this.consumeTill, o);\n                let r;\n                switch (i) {\n                  case \"trr-int\":\n                    r = {\n                      type: i,\n                      interval: this.extract(e, this.consumeTill)\n                    };\n                    break;\n                  case \"ack\":\n                  case \"nack\":\n                  default:\n                    {\n                      const t = {\n                        type: i\n                      };\n                      this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.parameter = this.extract(e, this.consumeToken), this.peekChar(e) === o && (t.additional = this.extract(e, this.consumeTill))), r = t;\n                    }\n                }\n                if (\"*\" === t) this.attributes.rtcpFeedbackWildcards.push(r);else {\n                  const e = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));\n                  e ? e.rtcpFeedbacks.push(r) : this.attributes.payloads.push({\n                    payloadType: parseInt(t, 10),\n                    rtcpFeedbacks: [r]\n                  });\n                }\n              }\n              parseRTCPMux() {\n                if (this.attributes.rtcpMux) throw new Error(\"must be single line of rtcp-mux\");\n                this.attributes.rtcpMux = !0;\n              }\n              parseRTCPMuxOnly() {\n                if (this.attributes.rtcpMuxOnly) throw new Error(\"must be single line of rtcp-only\");\n                this.attributes.rtcpMuxOnly = !0;\n              }\n              parseRTCPRsize() {\n                if (this.attributes.rtcpRsize) throw new Error(\"must be single line of rtcp-rsize\");\n                this.attributes.rtcpRsize = !0;\n              }\n              parseRTCP(e) {\n                if (this.attributes.rtcp) throw new Error(\"must be single line of rtcp\");\n                const t = {\n                  port: this.extract(e, this.consumePort)\n                };\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.netType = this.extractOneOrMore(e, u), this.consumeAttributeSpace(e), t.addressType = this.extractOneOrMore(e, u), this.consumeAttributeSpace(e), t.address = this.extract(e, this.consumeAddress)), this.attributes.rtcp = t;\n              }\n              parseMsid(e) {\n                const t = {\n                  id: this.extractOneOrMore(e, u, [1, 64])\n                };\n                this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.appdata = this.extractOneOrMore(e, u, [1, 64])), this.attributes.msids.push(t);\n              }\n              parseImageAttr(e) {\n                this.attributes.imageattr.push(e.attValue);\n              }\n              parseRid(e) {\n                const t = this.extractOneOrMore(e, e => h(e) || a(e) || \"_\" === e || \"-\" === e);\n                this.consumeAttributeSpace(e);\n                const i = {\n                  id: t,\n                  direction: this.extract(e, this.consumeToken),\n                  params: []\n                };\n                if (this.peekChar(e) === o) {\n                  if (this.consumeAttributeSpace(e), this.peek(e, \"pt=\")) {\n                    this.extract(e, this.consume, \"pt=\");\n                    const t = [];\n                    for (;;) {\n                      const i = this.extract(e, this.consumeToken);\n                      t.push(i);\n                      try {\n                        this.extract(e, this.consume, \",\");\n                      } catch (e) {\n                        break;\n                      }\n                    }\n                    i.payloads = t, this.peekChar(e) === o && this.extract(e, this.consume, o);\n                  }\n                  for (;;) {\n                    const t = this.extract(e, this.consumeToken);\n                    switch (t) {\n                      case \"depend\":\n                        {\n                          const r = {\n                            type: t,\n                            rids: this.extract(e, this.consume, \"=\").split(\",\")\n                          };\n                          i.params.push(r);\n                          break;\n                        }\n                      case \"max-width\":\n                      case \"height-width\":\n                      case \"max-fps\":\n                      case \"max-fs\":\n                      case \"max-br\":\n                      case \"max-pps\":\n                      case \"max-bpp\":\n                      default:\n                        {\n                          const r = {\n                            type: t\n                          };\n                          \"=\" === this.peekChar(e) && (this.extract(e, this.consume, \"=\"), r.val = this.extract(e, this.consumeTill, \";\")), i.params.push(r);\n                        }\n                    }\n                    try {\n                      this.extract(e, this.consume, \";\");\n                    } catch (e) {\n                      break;\n                    }\n                  }\n                }\n                this.attributes.rids.push(i);\n              }\n              parseSimulcast(e) {\n                if (this.attributes.simulcast) throw new Error(\"must be single line of simulcast\");\n                this.attributes.simulcast = e.attValue, this.extract(e, this.consumeTill);\n              }\n              parseSctpPort(e) {\n                this.attributes.sctpPort = this.extractOneOrMore(e, a, [1, 5]);\n              }\n              parseMaxMessageSize(e) {\n                this.attributes.maxMessageSize = this.extractOneOrMore(e, a, [1, void 0]);\n              }\n              digest() {\n                return this.digested = !0, this.attributes;\n              }\n              parseMid(e) {\n                this.attributes.mid = this.extract(e, this.consumeToken);\n              }\n              parseSSRCGroup(e) {\n                const t = this.extract(e, this.consumeToken),\n                  i = [];\n                for (;;) try {\n                  this.consumeAttributeSpace(e);\n                  const t = this.extract(e, this.consumeInteger);\n                  i.push(parseInt(t, 10));\n                } catch (e) {\n                  break;\n                }\n                this.attributes.ssrcGroups.push({\n                  semantic: t,\n                  ssrcIds: i\n                });\n              }\n            }\n            function A(e, t, i) {\n              return t in e ? Object.defineProperty(e, t, {\n                value: i,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n              }) : e[t] = i, e;\n            }\n            class O {\n              constructor() {\n                A(this, \"eol\", n);\n              }\n              print(e, t) {\n                let i = \"\";\n                return t && (this.eol = t), i += this.printVersion(e.version), i += this.printOrigin(e.origin), i += this.printSessionName(e.sessionName), i += this.printInformation(e.information), i += this.printUri(e.uri), i += this.printEmail(e.emails), i += this.printPhone(e.phones), i += this.printConnection(e.connection), i += this.printBandwidth(e.bandwidths), i += this.printTimeFields(e.timeFields), i += this.printKey(e.key), i += this.printSessionAttributes(e.attributes), i += this.printMediaDescription(e.mediaDescriptions), i;\n              }\n              printVersion(e) {\n                return \"v=\".concat(e).concat(this.eol);\n              }\n              printOrigin(e) {\n                return \"o=\".concat(e.username, \" \").concat(e.sessId, \" \").concat(e.sessVersion, \" \").concat(e.nettype, \" \").concat(e.addrtype, \" \").concat(e.unicastAddress).concat(this.eol);\n              }\n              printSessionName(e) {\n                return e ? \"s=\".concat(e).concat(this.eol) : \"\";\n              }\n              printInformation(e) {\n                return e ? \"i=\".concat(e).concat(this.eol) : \"\";\n              }\n              printUri(e) {\n                return e ? \"u=\".concat(e).concat(this.eol) : \"\";\n              }\n              printEmail(e) {\n                let t = \"\";\n                for (const i of e) t += \"e=\".concat(i).concat(this.eol);\n                return t;\n              }\n              printPhone(e) {\n                let t = \"\";\n                for (const i of e) t += \"e=\".concat(i).concat(this.eol);\n                return t;\n              }\n              printConnection(e) {\n                return e ? \"c=\".concat(e.nettype, \" \").concat(e.addrtype, \" \").concat(e.address).concat(this.eol) : \"\";\n              }\n              printBandwidth(e) {\n                let t = \"\";\n                for (const i of e) t += \"b=\".concat(i.bwtype, \":\").concat(i.bandwidth).concat(this.eol);\n                return t;\n              }\n              printTimeFields(e) {\n                let t = \"\";\n                for (const i of e) {\n                  t += \"t=\".concat(i.time.startTime, \" \").concat(i.time.startTime).concat(this.eol);\n                  for (const e of i.repeats) t += \"r=\".concat(e.repeatInterval, \" \").concat(e.typedTimes.join(\" \")).concat(this.eol);\n                  i.zoneAdjustments && (t += \"z=\", t += \"z=\".concat(i.zoneAdjustments.map(e => \"\".concat(e.time, \" \").concat(e.back ? \"-\" : \"\", \" \").concat(e.typedTime)).join(\" \")).concat(this.eol), t += this.eol);\n                }\n                return t;\n              }\n              printKey(e) {\n                return e ? \"k=\".concat(e).concat(this.eol) : \"\";\n              }\n              printAttributes(e) {\n                let t = \"\";\n                for (const i of e) t += \"a=\".concat(i.attField).concat(i.attValue ? \":\".concat(i.attValue) : \"\").concat(this.eol);\n                return t;\n              }\n              printMediaDescription(e) {\n                let t = \"\";\n                for (const i of e) t += this.printMedia(i.media), t += this.printInformation(i.information), t += this.printConnections(i.connections), t += this.printBandwidth(i.bandwidths), t += this.printKey(i.key), t += this.printMediaAttributes(i);\n                return t;\n              }\n              printConnections(e) {\n                let t = \"\";\n                for (const i of e) t += this.printConnection(i);\n                return t;\n              }\n              printMedia(e) {\n                return \"m=\".concat(e.mediaType, \" \").concat(e.port, \" \").concat(e.protos.join(\"/\"), \" \").concat(e.fmts.join(\" \")).concat(this.eol);\n              }\n              printSessionAttributes(e) {\n                return new w(this.eol).print(e);\n              }\n              printMediaAttributes(e) {\n                return new N(this.eol).print(e);\n              }\n            }\n            class b {\n              constructor(e) {\n                A(this, \"eol\", void 0), this.eol = e;\n              }\n              printIceUfrag(e) {\n                return void 0 === e ? \"\" : \"a=ice-ufrag:\".concat(e).concat(this.eol);\n              }\n              printIcePwd(e) {\n                return void 0 === e ? \"\" : \"a=ice-pwd:\".concat(e).concat(this.eol);\n              }\n              printIceOptions(e) {\n                return void 0 === e ? \"\" : \"a=ice-options:\".concat(e.join(o)).concat(this.eol);\n              }\n              printFingerprints(e) {\n                return e.length > 0 ? e.map(e => \"a=fingerprint:\".concat(e.hashFunction).concat(o).concat(e.fingerprint)).join(this.eol) + this.eol : \"\";\n              }\n              printExtmap(e) {\n                return e.map(e => \"a=extmap:\".concat(e.entry).concat(e.direction ? \"/\".concat(e.direction) : \"\").concat(o).concat(e.extensionName).concat(e.extensionAttributes ? \"\".concat(o).concat(e.extensionAttributes) : \"\").concat(this.eol)).join(\"\");\n              }\n              printSetup(e) {\n                return void 0 === e ? \"\" : \"a=setup:\".concat(e).concat(this.eol);\n              }\n              printUnrecognized(e) {\n                return e.map(e => \"a=\".concat(e.attField).concat(e.attValue ? \":\".concat(e.attValue) : \"\").concat(this.eol)).join(\"\");\n              }\n            }\n            class w extends b {\n              print(e) {\n                let t = \"\";\n                return t += this.printGroups(e.groups), t += this.printMsidSemantic(e.msidSemantic), t += this.printIceLite(e.iceLite), t += this.printIceUfrag(e.iceUfrag), t += this.printIcePwd(e.icePwd), t += this.printIceOptions(e.iceOptions), t += this.printFingerprints(e.fingerprints), t += this.printSetup(e.setup), t += this.printTlsId(e.tlsId), t += this.printIdentity(e.identities), t += this.printExtmap(e.extmaps), t += this.printUnrecognized(e.unrecognized), t;\n              }\n              printGroups(e) {\n                let t = \"\";\n                return e.length > 0 && (t += e.map(e => \"a=group:\".concat(e.semantic).concat(e.identificationTag.map(e => \"\".concat(o).concat(e)).join(\"\")).concat(this.eol)).join(\"\")), t;\n              }\n              printIceLite(e) {\n                return void 0 === e ? \"\" : \"a=ice-lite\" + this.eol;\n              }\n              printTlsId(e) {\n                return e ? \"a=tls-id:\".concat(e).concat(this.eol) : \"\";\n              }\n              printIdentity(e) {\n                return 0 === e.length ? \"\" : e.map(e => \"a=identity:\".concat(e.assertionValue).concat(e.extensions.map(e => \"\".concat(o).concat(e.name).concat(e.value ? \"=\".concat(e.value) : \"\")))).join(this.eol) + this.eol;\n              }\n              printMsidSemantic(e) {\n                if (!e) return \"\";\n                let t = \"a=msid-semantic:\".concat(e.semantic);\n                return e.applyForAll ? t += \"\".concat(o, \"*\") : e.identifierList.length > 0 && (t += e.identifierList.map(e => \"\".concat(o).concat(e))), t + this.eol;\n              }\n            }\n            class N extends b {\n              print(e) {\n                const t = e.attributes;\n                let i = \"\";\n                return i += this.printRTCP(t.rtcp), i += this.printIceUfrag(t.iceUfrag), i += this.printIcePwd(t.icePwd), i += this.printIceOptions(t.iceOptions), i += this.printCandidates(t.candidates), i += this.printRemoteCandidatesList(t.remoteCandidatesList), i += this.printEndOfCandidates(t.endOfCandidates), i += this.printFingerprints(t.fingerprints), i += this.printSetup(t.setup), i += this.printMid(t.mid), i += this.printExtmap(t.extmaps), i += this.printRTPRelated(t), i += this.printPtime(t.ptime), i += this.printMaxPtime(t.maxPtime), i += this.printDirection(t.direction), i += this.printSSRCGroups(t.ssrcGroups), i += this.printSSRC(t.ssrcs), i += this.printRTCPMux(t.rtcpMux), i += this.printRTCPMuxOnly(t.rtcpMuxOnly), i += this.printRTCPRsize(t.rtcpRsize), i += this.printMSId(t.msids), i += this.printImageattr(t.imageattr), i += this.printRid(t.rids), i += this.printSimulcast(t.simulcast), i += this.printSCTPPort(t.sctpPort), i += this.printMaxMessageSize(t.maxMessageSize), i += this.printUnrecognized(t.unrecognized), i;\n              }\n              printCandidates(e) {\n                return e.map(e => \"a=candidate:\".concat(e.foundation).concat(o).concat(e.componentId).concat(o).concat(e.transport).concat(o).concat(e.priority).concat(o).concat(e.connectionAddress).concat(o).concat(e.port).concat(o, \"typ\").concat(o).concat(e.type).concat(e.relAddr ? \"\".concat(o, \"raddr\").concat(o).concat(e.relAddr) : \"\").concat(e.relPort ? \"\".concat(o, \"rport\").concat(o).concat(e.relPort) : \"\").concat(Object.keys(e.extension).map(t => \"\".concat(o).concat(t).concat(o).concat(e.extension[t])).join(\"\")).concat(this.eol)).join(\"\");\n              }\n              printRemoteCandidatesList(e) {\n                return e.map(e => \"a=remote-candidates:\".concat(e.join(o)).concat(this.eol)).join(\"\");\n              }\n              printEndOfCandidates(e) {\n                return void 0 === e ? \"\" : \"a=end-of-candidates\" + this.eol;\n              }\n              printRTPRelated(e) {\n                if (!e.payloads) return \"\";\n                const t = e.payloads;\n                let i = \"\";\n                i += e.rtcpFeedbackWildcards.map(e => this.printRTCPFeedback(\"*\", e)).join(\"\");\n                for (const e of t) i += this.printRtpMap(e.payloadType, e.rtpMap), i += this.printFmtp(e.payloadType, e.fmtp), i += e.rtcpFeedbacks.map(t => this.printRTCPFeedback(e.payloadType, t)).join(\"\");\n                return i;\n              }\n              printFmtp(e, t) {\n                if (!t) return \"\";\n                const i = Object.keys(t.parameters);\n                return 1 === i.length && null === t.parameters[i[0]] ? \"a=fmtp:\".concat(e).concat(o).concat(i[0]).concat(this.eol) : \"a=fmtp:\".concat(e).concat(o).concat(Object.keys(t.parameters).map(e => \"\".concat(e, \"=\").concat(t.parameters[e])).join(\";\")).concat(this.eol);\n              }\n              printRtpMap(e, t) {\n                return t ? \"a=rtpmap:\".concat(e).concat(o).concat(t.encodingName, \"/\").concat(t.clockRate).concat(t.encodingParameters ? \"/\".concat(t.encodingParameters) : \"\").concat(this.eol) : \"\";\n              }\n              printRTCPFeedback(e, t) {\n                let i = \"a=rtcp-fb:\".concat(e).concat(o),\n                  r = t;\n                switch (r.type) {\n                  case \"trr-int\":\n                    i += \"ttr-int\".concat(o).concat(r.interval);\n                    break;\n                  case \"ack\":\n                  case \"nack\":\n                  default:\n                    r = r, i += \"\".concat(r.type), r.parameter && (i += \"\".concat(o).concat(r.parameter), r.additional && (i += \"\".concat(o).concat(r.additional)));\n                }\n                return i + this.eol;\n              }\n              printPtime(e) {\n                return void 0 === e ? \"\" : \"a=ptime:\".concat(e).concat(this.eol);\n              }\n              printMaxPtime(e) {\n                return void 0 === e ? \"\" : \"a=maxptime:\".concat(e).concat(this.eol);\n              }\n              printDirection(e) {\n                return void 0 === e ? \"\" : \"a=\".concat(e).concat(this.eol);\n              }\n              printSSRC(e) {\n                return e.map(e => Object.keys(e.attributes).map(t => \"a=ssrc:\".concat(e.ssrcId.toString(10)).concat(o).concat(t).concat(e.attributes[t] ? \":\".concat(e.attributes[t]) : \"\").concat(this.eol)).join(\"\")).join(\"\");\n              }\n              printRTCPMux(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-mux\".concat(this.eol);\n              }\n              printRTCPMuxOnly(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-mux-only\".concat(this.eol);\n              }\n              printRTCPRsize(e) {\n                return void 0 === e ? \"\" : \"a=rtcp-rsize\".concat(this.eol);\n              }\n              printRTCP(e) {\n                if (void 0 === e) return \"\";\n                let t = \"a=rtcp:\".concat(e.port);\n                return e.netType && (t += \"\".concat(o).concat(e.netType)), e.addressType && (t += \"\".concat(o).concat(e.addressType)), e.address && (t += \"\".concat(o).concat(e.address)), t + this.eol;\n              }\n              printMSId(e) {\n                return e.map(e => \"a=msid:\".concat(e.id).concat(e.appdata ? \"\".concat(o).concat(e.appdata) : \"\").concat(this.eol)).join(\"\");\n              }\n              printImageattr(e) {\n                return e.map(e => \"a=imageattr:\".concat(e).concat(this.eol)).join(\"\");\n              }\n              printRid(e) {\n                return e.map(e => {\n                  let t = \"a=rid:\".concat(e.id).concat(o).concat(e.direction);\n                  return e.payloads && (t += \"\".concat(o, \"pt=\").concat(e.payloads.join(\",\"))), e.params.length > 0 && (t += \"\".concat(o).concat(e.params.map(e => \"depend\" === e.type ? \"depend=\".concat(e.rids.join(\",\")) : \"\".concat(e.type, \"=\").concat(e.val)).join(\";\"))), t + this.eol;\n                }).join(\"\");\n              }\n              printSimulcast(e) {\n                return void 0 === e ? \"\" : \"a=simulcast:\".concat(e).concat(this.eol);\n              }\n              printSCTPPort(e) {\n                return void 0 === e ? \"\" : \"a=sctp-port:\".concat(e).concat(this.eol);\n              }\n              printMaxMessageSize(e) {\n                return void 0 === e ? \"\" : \"a=max-message-size:\".concat(e).concat(this.eol);\n              }\n              printMid(e) {\n                return void 0 === e ? \"\" : \"a=mid:\".concat(e).concat(this.eol);\n              }\n              printSSRCGroups(e) {\n                return e.map(e => \"a=ssrc-group:\".concat(e.semantic).concat(e.ssrcIds.map(e => \"\".concat(o).concat(e.toString(10))).join(\"\")).concat(this.eol)).join(\"\");\n              }\n            }\n            function D(e) {\n              return new R().parse(e);\n            }\n            function P(e, t) {\n              return new O().print(e, t);\n            }\n          }\n        },\n        t = {};\n      function i(r) {\n        if (t[r]) return t[r].exports;\n        var n = t[r] = {\n          exports: {}\n        };\n        return e[r](n, n.exports, i), n.exports;\n      }\n      return i.d = (e, t) => {\n        for (var r in t) i.o(t, r) && !i.o(e, r) && Object.defineProperty(e, r, {\n          enumerable: !0,\n          get: t[r]\n        });\n      }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), i.r = e => {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(e, \"__esModule\", {\n          value: !0\n        });\n      }, i(8);\n    })();\n  }(bD);\n  class YD {\n    constructor(e) {\n      mp(this, \"sessionDesc\", void 0), mp(this, \"localCapabilities\", void 0), mp(this, \"rtpCapabilities\", void 0), mp(this, \"candidates\", void 0), mp(this, \"iceParameters\", void 0), mp(this, \"dtlsParameters\", void 0), mp(this, \"setup\", void 0), mp(this, \"currentMidIndex\", void 0), mp(this, \"cname\", void 0), e = qR(e);\n      const {\n          remoteIceParameters: t,\n          remoteDtlsParameters: i,\n          candidates: r,\n          remoteRTPCapabilities: n,\n          remoteSetup: o,\n          localCapabilities: s,\n          sdkCodec: a,\n          cname: c\n        } = e,\n        d = bD.exports.parse(\"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE audio video\\na=msid-semantic: WMS\\na=ice-lite\\nm=audio 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendrecv\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:audio\\nm=video 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendrecv\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:video\\n\");\n      this.rtpCapabilities = n, this.candidates = r, this.iceParameters = t, this.dtlsParameters = i, this.setup = o, this.localCapabilities = s, this.cname = c;\n      for (let e = 0; e < d.mediaDescriptions.length; e++) {\n        const s = d.mediaDescriptions[e];\n        if (s.attributes.iceUfrag = t.iceUfrag, s.attributes.icePwd = t.icePwd, s.attributes.fingerprints = i.fingerprints, s.attributes.candidates = r, s.attributes.setup = o, \"video\" === s.media.mediaType) {\n          s.media.fmts = n.videoCodecs.map(e => e.payloadType.toString(10));\n          const e = n.videoCodecs.filter(e => {\n            var t;\n            return null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase().includes(a);\n          });\n          if (0 === e.length) throw new Error(\"Codec \".concat(a, \" not supported by remote SDP.\"));\n          s.attributes.payloads = e, s.attributes.extmaps = n.videoExtensions;\n        }\n        \"audio\" === s.media.mediaType && (s.media.fmts = n.audioCodecs.map(e => e.payloadType.toString(10)), s.attributes.payloads = n.audioCodecs, s.attributes.extmaps = n.audioExtensions), d.mediaDescriptions[e] = this.mungMediaDesc(s);\n      }\n      this.sessionDesc = d, this.currentMidIndex = d.mediaDescriptions.length - 1;\n    }\n    toString() {\n      return bD.exports.print(this.sessionDesc);\n    }\n    send(e, t, i) {\n      const {\n          ssrcs: r,\n          ssrcGroups: n\n        } = MD(t, this.cname),\n        o = this.sessionDesc.mediaDescriptions.find(t => e === yg.VIDEO ? \"video\" === t.media.mediaType : \"audio\" === t.media.mediaType),\n        s = r[0].attributes.label,\n        a = r[0].attributes.mslabel;\n      return o.attributes.ssrcs = o.attributes.ssrcs.concat(r), o.attributes.ssrcGroups = o.attributes.ssrcGroups.concat(n), {\n        id: s,\n        mslabel: a\n      };\n    }\n    batchSend(e) {\n      return e.map(e => {\n        let {\n          kind: t,\n          ssrcMsg: i\n        } = e;\n        return this.send(t, i, void 0);\n      });\n    }\n    stopSending(e) {\n      this.sessionDesc.mediaDescriptions.forEach(t => {\n        const i = [],\n          r = [],\n          n = [];\n        t.attributes.ssrcs.forEach(t => {\n          e.includes(t.attributes.label || \"\") ? n.push(t) : i.push(t);\n        }), t.attributes.ssrcGroups.forEach(e => {\n          n.map(e => e.ssrcId).includes(e.ssrcIds[0]) || r.push(e);\n        }), t.attributes.ssrcs = i, t.attributes.ssrcGroups = r;\n      });\n    }\n    mute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.mute.\"));\n      t.attributes.direction = \"inactive\";\n    }\n    unmute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.unmute.\"));\n      t.attributes.direction = \"sendonly\";\n    }\n    receive(e, t, i) {\n      e.forEach((e, t) => {\n        const i = e._mediaStreamTrack,\n          r = this.sessionDesc.mediaDescriptions.findIndex(e => e.attributes.mid === i.kind),\n          n = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r], e);\n        this.sessionDesc.mediaDescriptions[r] = n;\n      });\n    }\n    stopReceiving(e) {}\n    restartICE(e) {\n      e = qR(e), this.iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n        t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n      });\n    }\n    predictReceivingMids(e) {\n      const t = [];\n      for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n      return t;\n    }\n    mungRecvMediaDsec(e, t) {\n      const i = qR(e);\n      return UD(i, t), VD(i, t), i;\n    }\n    updateRecvMedia(e, t) {\n      const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n      if (-1 !== i) {\n        const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n        this.sessionDesc.mediaDescriptions[i] = e;\n      }\n    }\n    bumpMid(e) {\n      this.currentMidIndex += e;\n    }\n    updateTrackLabel(e, t, i) {\n      const r = this.sessionDesc.mediaDescriptions.find(t => e === yg.VIDEO ? \"video\" === t.attributes.mid : \"audio\" === t.attributes.mid);\n      if (r) {\n        const e = r.attributes.ssrcs.find(e => e.attributes.label === t);\n        var n;\n        if (e) e.attributes.label = i, null === (n = e.attributes.msid) || void 0 === n || n.replace(t, i);\n      }\n    }\n    mungMediaDesc(e) {\n      const t = qR(e);\n      return xD(t), function (e) {\n        const t = e.attributes.extmaps.find(e => \"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\" === e.extensionName);\n        t && e.attributes.extmaps.splice(e.attributes.extmaps.indexOf(t), 1), e.attributes.payloads.forEach(e => {\n          const t = e.rtcpFeedbacks.findIndex(e => \"transport-cc\" === e.type);\n          -1 !== t && e.rtcpFeedbacks.splice(t, 1);\n        });\n      }(t), t;\n    }\n    getSSRC(e) {\n      for (const t of this.sessionDesc.mediaDescriptions) for (const i of t.attributes.ssrcs) if (i.attributes.label === e) return [i];\n    }\n  }\n  function qD(e) {\n    if (Array.isArray(e)) return e.map(function (e) {\n      return e;\n    });\n    if (!JD(e)) return e;\n    var t = {};\n    for (var i in e) JD(e[i]) || Array.isArray(e[i]) ? t[i] = qD(e[i]) : t[i] = e[i];\n    return t;\n  }\n  function JD(e) {\n    return !(\"object\" != typeof e || Array.isArray(e) || !e);\n  }\n  var XD = function () {\n      function e(e) {\n        this.input = [], this.size = e;\n      }\n      return e.prototype.add = function (e) {\n        this.input.push(e), this.input.length > this.size && this.input.splice(0, 1);\n      }, e.prototype.diffMean = function () {\n        return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length;\n      }, e;\n    }(),\n    zD = function (e, t) {\n      return (zD = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function (e, t) {\n        e.__proto__ = t;\n      } || function (e, t) {\n        for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i]);\n      })(e, t);\n    };\n  /*! *****************************************************************************\n  \tCopyright (c) Microsoft Corporation. All rights reserved.\n  \tLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n  \tthis file except in compliance with the License. You may obtain a copy of the\n  \tLicense at http://www.apache.org/licenses/LICENSE-2.0\n  \n  \tTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n  \tKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n  \tWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n  \tMERCHANTABLITY OR NON-INFRINGEMENT.\n  \n  \tSee the Apache Version 2.0 License for specific language governing permissions\n  \tand limitations under the License.\n  \t***************************************************************************** */\n  function QD(e, t) {\n    function i() {\n      this.constructor = e;\n    }\n    zD(e, t), e.prototype = null === t ? Object.create(t) : (i.prototype = t.prototype, new i());\n  }\n  var ZD = function () {\n    return (ZD = Object.assign || function (e) {\n      for (var t, i = 1, r = arguments.length; i < r; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n      return e;\n    }).apply(this, arguments);\n  };\n  function $D(e, t, i, r) {\n    return new (i || (i = Promise))(function (n, o) {\n      function s(e) {\n        try {\n          c(r.next(e));\n        } catch (e) {\n          o(e);\n        }\n      }\n      function a(e) {\n        try {\n          c(r.throw(e));\n        } catch (e) {\n          o(e);\n        }\n      }\n      function c(e) {\n        e.done ? n(e.value) : new i(function (t) {\n          t(e.value);\n        }).then(s, a);\n      }\n      c((r = r.apply(e, t || [])).next());\n    });\n  }\n  function eP(e, t) {\n    var i,\n      r,\n      n,\n      o,\n      s = {\n        label: 0,\n        sent: function () {\n          if (1 & n[0]) throw n[1];\n          return n[1];\n        },\n        trys: [],\n        ops: []\n      };\n    return o = {\n      next: a(0),\n      throw: a(1),\n      return: a(2)\n    }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n      return this;\n    }), o;\n    function a(o) {\n      return function (a) {\n        return function (o) {\n          if (i) throw new TypeError(\"Generator is already executing.\");\n          for (; s;) try {\n            if (i = 1, r && (n = 2 & o[0] ? r.return : o[0] ? r.throw || ((n = r.return) && n.call(r), 0) : r.next) && !(n = n.call(r, o[1])).done) return n;\n            switch (r = 0, n && (o = [2 & o[0], n.value]), o[0]) {\n              case 0:\n              case 1:\n                n = o;\n                break;\n              case 4:\n                return s.label++, {\n                  value: o[1],\n                  done: !1\n                };\n              case 5:\n                s.label++, r = o[1], o = [0];\n                continue;\n              case 7:\n                o = s.ops.pop(), s.trys.pop();\n                continue;\n              default:\n                if (!(n = s.trys, (n = n.length > 0 && n[n.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n                  s = 0;\n                  continue;\n                }\n                if (3 === o[0] && (!n || o[1] > n[0] && o[1] < n[3])) {\n                  s.label = o[1];\n                  break;\n                }\n                if (6 === o[0] && s.label < n[1]) {\n                  s.label = n[1], n = o;\n                  break;\n                }\n                if (n && s.label < n[2]) {\n                  s.label = n[2], s.ops.push(o);\n                  break;\n                }\n                n[2] && s.ops.pop(), s.trys.pop();\n                continue;\n            }\n            o = t.call(e, s);\n          } catch (e) {\n            o = [6, e], r = 0;\n          } finally {\n            i = n = 0;\n          }\n          if (5 & o[0]) throw o[1];\n          return {\n            value: o[0] ? o[1] : void 0,\n            done: !0\n          };\n        }([o, a]);\n      };\n    }\n  }\n  var tP,\n    iP = {\n      address: \"unknown\",\n      candidateType: \"unknown\",\n      id: \"unknown\",\n      port: 0,\n      priority: 0,\n      protocol: \"unknown\",\n      type: \"unknown\"\n    },\n    rP = {\n      timestamp: 0,\n      bitrate: {\n        actualEncoded: 0,\n        transmit: 0\n      },\n      sendPacketLossRate: 0,\n      recvPacketLossRate: 0,\n      videoRecv: [],\n      videoSend: [],\n      audioRecv: [],\n      audioSend: [],\n      selectedCandidatePair: {\n        id: \"unknown\",\n        localCandidate: iP,\n        remoteCandidate: iP\n      }\n    },\n    nP = {\n      firsCount: 0,\n      nacksCount: 0,\n      plisCount: 0,\n      framesDecodeCount: 0,\n      framesDecodeInterval: 0,\n      framesDecodeFreezeTime: 0,\n      decodeFrameRate: 0,\n      bytes: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      packets: 0,\n      ssrc: 0,\n      qpSumPerFrame: 0\n    },\n    oP = {\n      firsCount: 0,\n      nacksCount: 0,\n      plisCount: 0,\n      frameCount: 0,\n      bytes: 0,\n      packets: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      ssrc: 0,\n      rttMs: 0,\n      qpSumPerFrame: 0\n    },\n    sP = {\n      bytes: 0,\n      packets: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      ssrc: 0,\n      rttMs: 0\n    },\n    aP = {\n      jitterBufferMs: 0,\n      jitterMs: 0,\n      bytes: 0,\n      packetsLost: 0,\n      packetLostRate: 0,\n      packets: 0,\n      ssrc: 0,\n      receivedFrames: 0,\n      droppedFrames: 0,\n      concealedSamples: 0\n    },\n    cP = function () {\n      function e(e, t) {\n        var i = this;\n        this.videoIsReady = !1, this.videoIsReady2 = {}, this.stats = qD(rP), this.isFirstVideoReceived = {}, this.isFirstVideoDecoded = {}, this.isFirstAudioReceived = {}, this.isFirstAudioDecoded = {}, this.lossRateWindowStats = [], this.pc = e, this.options = t, this.intervalTimer = window.setInterval(function () {\n          return $D(i, void 0, void 0, function () {\n            return eP(this, function (e) {\n              return this.updateStats(), [2];\n            });\n          });\n        }, this.options.updateInterval);\n      }\n      return e.prototype.getStats = function () {\n        return this.stats;\n      }, e.prototype.setVideoIsReady = function (e) {\n        this.videoIsReady = e;\n      }, e.prototype.setVideoIsReady2 = function (e, t) {\n        this.videoIsReady2[e] = t;\n      }, e.prototype.getVideoIsReady = function (e) {\n        return this.videoIsReady2[e] || !1;\n      }, e.prototype.setIsFirstAudioDecoded = function (e) {}, e.prototype.destroy = function () {\n        window.clearInterval(this.intervalTimer), this.pc = void 0;\n      }, e.prototype.calcLossRate = function (e) {\n        var t = this;\n        this.lossRateWindowStats.push(e), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);\n        for (var i = this.lossRateWindowStats.length, r = 0, n = 0, o = 0, s = 0, a = function (a) {\n            e[a].forEach(function (e, c) {\n              if (t.lossRateWindowStats[i - 1][a][c] && t.lossRateWindowStats[0][a][c]) {\n                var d = t.lossRateWindowStats[i - 1][a][c].packets - t.lossRateWindowStats[0][a][c].packets,\n                  u = t.lossRateWindowStats[i - 1][a][c].packetsLost - t.lossRateWindowStats[0][a][c].packetsLost;\n                \"videoSend\" === a || \"audioSend\" === a ? (r += d, o += u) : (n += d, s += u), Number.isNaN(d) || Number.isNaN(d) ? e.packetLostRate = 0 : e.packetLostRate = d <= 0 || u <= 0 ? 0 : u / (d + u);\n              }\n            });\n          }, c = 0, d = [\"videoSend\", \"audioSend\", \"videoRecv\", \"audioRecv\"]; c < d.length; c++) {\n          a(d[c]);\n        }\n        e.sendPacketLossRate = r <= 0 || o <= 0 ? 0 : o / (r + o), e.recvPacketLossRate = n <= 0 || s <= 0 ? 0 : s / (n + s);\n      }, e;\n    }(),\n    dP = function (e) {\n      function t() {\n        var t = null !== e && e.apply(this, arguments) || this;\n        return t._stats = rP, t.lastDecodeVideoReceiverStats = new Map(), t;\n      }\n      return QD(t, e), t.prototype.updateStats = function () {\n        return $D(this, void 0, void 0, function () {\n          var e, t, i, r;\n          return eP(this, function (n) {\n            switch (n.label) {\n              case 0:\n                return [4, this._getStats()];\n              case 1:\n                return e = n.sent(), t = this.statsResponsesToObjects(e), this._stats = qD(rP), i = t.filter(function (e) {\n                  return \"ssrc\" === e.type;\n                }), this.processSSRCStats(i), (r = t.find(function (e) {\n                  return \"VideoBwe\" === e.type;\n                })) && this.processBandwidthStats(r), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];\n            }\n          });\n        });\n      }, t.prototype.processBandwidthStats = function (e) {\n        this._stats.bitrate = {\n          actualEncoded: Number(e.googActualEncBitrate),\n          targetEncoded: Number(e.googTargetEncBitrate),\n          retransmit: Number(e.googRetransmitBitrate),\n          transmit: Number(e.googTransmitBitrate)\n        }, this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth);\n      }, t.prototype.processSSRCStats = function (e) {\n        var t = this;\n        e.forEach(function (e) {\n          var i = e.id.includes(\"send\");\n          switch (\"\".concat(e.mediaType, \"_\").concat(i ? \"send\" : \"recv\")) {\n            case \"video_send\":\n              var r = qD(oP);\n              r.codec = e.googCodecName, r.adaptionChangeReason = \"none\", e.googCpuLimitedResolution && (r.adaptionChangeReason = \"cpu\"), e.googBandwidthLimitedResolution && (r.adaptionChangeReason = \"bandwidth\"), r.avgEncodeMs = Number(e.googAvgEncodeMs), r.inputFrame = {\n                width: Number(e.googFrameWidthInput) || Number(e.googFrameWidthSent),\n                height: Number(e.googFrameHeightInput) || Number(e.googFrameHeightSent),\n                frameRate: Number(e.googFrameRateInput)\n              }, r.sentFrame = {\n                width: Number(e.googFrameWidthSent),\n                height: Number(e.googFrameHeightSent),\n                frameRate: Number(e.googFrameRateInput)\n              }, r.firsCount = Number(e.googFirReceived), r.nacksCount = Number(e.googNacksReceived), r.plisCount = Number(e.googPlisReceived), r.frameCount = Number(e.framesEncoded), r.bytes = Number(e.bytesSent), r.packets = Number(e.packetsSent), r.packetsLost = Number(e.packetsLost), r.ssrc = Number(e.ssrc), r.rttMs = Number(e.googRtt || 0), t._stats.videoSend.push(r), t._stats.rtt = r.rttMs;\n              break;\n            case \"video_recv\":\n              var n = qD(nP),\n                o = t.lastDecodeVideoReceiverStats.get(Number(e.ssrc));\n              if (n.codec = e.googCodecName, n.targetDelayMs = Number(e.googTargetDelayMs), n.renderDelayMs = Number(e.googRenderDelayMs), n.currentDelayMs = Number(e.googCurrentDelayMs), n.minPlayoutDelayMs = Number(e.googMinPlayoutDelayMs), n.decodeMs = Number(e.googDecodeMs), n.maxDecodeMs = Number(e.googMaxDecodeMs), n.receivedFrame = {\n                width: Number(e.googFrameWidthReceived),\n                height: Number(e.googFrameHeightReceived),\n                frameRate: Number(e.googFrameRateReceived)\n              }, n.decodedFrame = {\n                width: Number(e.googFrameWidthReceived),\n                height: Number(e.googFrameHeightReceived),\n                frameRate: Number(e.googFrameRateDecoded)\n              }, n.decodeFrameRate = Number(e.googFrameRateDecoded), n.outputFrame = {\n                width: Number(e.googFrameWidthReceived),\n                height: Number(e.googFrameHeightReceived),\n                frameRate: Number(e.googFrameRateOutput)\n              }, n.jitterBufferMs = Number(e.googJitterBufferMs), n.firsCount = Number(e.googFirsSent), n.nacksCount = Number(e.googNacksSent), n.plisCount = Number(e.googPlisSent), n.framesDecodeCount = Number(e.framesDecoded), n.bytes = Number(e.bytesReceived), n.packets = Number(e.packetsReceived), n.packetsLost = Number(e.packetsLost), n.ssrc = Number(e.ssrc), n.packets > 0 && !t.isFirstVideoReceived[n.ssrc] && (t.onFirstVideoReceived && t.onFirstVideoReceived(n.ssrc), t.isFirstVideoReceived[n.ssrc] = !0), n.framesDecodeCount > 0 && !t.isFirstVideoDecoded[n.ssrc] && (t.onFirstVideoDecoded && t.onFirstVideoDecoded(n.ssrc, n.decodedFrame.width, n.decodedFrame.height), t.isFirstVideoDecoded[n.ssrc] = !0), o) {\n                var s = o.stats,\n                  a = Date.now() - o.lts;\n                n.framesDecodeFreezeTime = s.framesDecodeFreezeTime, n.framesDecodeInterval = s.framesDecodeInterval, n.framesDecodeCount > s.framesDecodeCount && t.isFirstVideoDecoded[n.ssrc] ? (o.lts = Date.now(), n.framesDecodeInterval = a, n.framesDecodeInterval >= t.options.freezeRateLimit && (t.getVideoIsReady(parseInt(e.ssrc, 10)) ? n.framesDecodeFreezeTime += n.framesDecodeInterval : t.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : n.framesDecodeCount < o.stats.framesDecodeCount && (n.framesDecodeInterval = 0);\n              }\n              t.lastDecodeVideoReceiverStats.set(n.ssrc, {\n                stats: ZD({}, n),\n                lts: Date.now()\n              }), t._stats.videoRecv.push(n);\n              break;\n            case \"audio_recv\":\n              var c = qD(aP);\n              c.codec = e.googCodecName, c.outputLevel = Math.abs(Number(e.audioOutputLevel)) / 32767, c.decodingCNG = Number(e.googDecodingCNG), c.decodingCTN = Number(e.googDecodingCTN), c.decodingCTSG = Number(e.googDecodingCTSG), c.decodingNormal = Number(e.googDecodingNormal), c.decodingPLC = Number(e.googDecodingPLC), c.decodingPLCCNG = Number(e.googDecodingPLCCNG), c.expandRate = Number(e.googExpandRate), c.accelerateRate = Number(e.googAccelerateRate), c.preemptiveExpandRate = Number(e.googPreemptiveExpandRate), c.secondaryDecodedRate = Number(e.googSecondaryDecodedRate), c.speechExpandRate = Number(e.googSpeechExpandRate), c.preferredJitterBufferMs = Number(e.googPreferredJitterBufferMs), c.jitterBufferMs = Number(e.googJitterBufferMs), c.jitterMs = Number(e.googJitterReceived), c.bytes = Number(e.bytesReceived), c.packets = Number(e.packetsReceived), c.packetsLost = Number(e.packetsLost), c.ssrc = Number(e.ssrc), c.receivedFrames = Number(e.googDecodingCTN) || Number(e.packetsReceived), c.droppedFrames = Number(e.googDecodingPLC) + Number(e.googDecodingPLCCNG) || Number(e.packetsLost), c.receivedFrames > 0 && !t.isFirstAudioReceived[c.ssrc] && (t.onFirstAudioReceived && t.onFirstAudioReceived(c.ssrc), t.isFirstAudioReceived[c.ssrc] = !0), c.decodingNormal > 0 && !t.isFirstAudioDecoded[c.ssrc] && (t.onFirstAudioDecoded && t.onFirstAudioDecoded(c.ssrc), t.isFirstAudioDecoded[c.ssrc] = !0), t._stats.audioRecv.push(c);\n              break;\n            case \"audio_send\":\n              var d = qD(sP);\n              d.codec = e.googCodecName, d.inputLevel = Math.abs(Number(e.audioInputLevel)) / 32767, d.aecReturnLoss = Number(e.googEchoCancellationReturnLoss || 0), d.aecReturnLossEnhancement = Number(e.googEchoCancellationReturnLossEnhancement || 0), d.residualEchoLikelihood = Number(e.googResidualEchoLikelihood || 0), d.residualEchoLikelihoodRecentMax = Number(e.googResidualEchoLikelihoodRecentMax || 0), d.bytes = Number(e.bytesSent), d.packets = Number(e.packetsSent), d.packetsLost = Number(e.packetsLost), d.ssrc = Number(e.ssrc), d.rttMs = Number(e.googRtt || 0), t._stats.rtt = d.rttMs, t._stats.audioSend.push(d);\n          }\n        });\n      }, t.prototype._getStats = function () {\n        var e = this;\n        return new Promise(function (t, i) {\n          e.pc.getStats(t, i);\n        });\n      }, t.prototype.statsResponsesToObjects = function (e) {\n        var t = [];\n        return e.result().forEach(function (e) {\n          var i = {\n            id: e.id,\n            timestamp: e.timestamp.valueOf().toString(),\n            type: e.type\n          };\n          e.names().forEach(function (t) {\n            i[t] = e.stat(t);\n          }), t.push(i);\n        }), t;\n      }, t;\n    }(cP);\n  !function (e) {\n    e.CERTIFICATE = \"certificate\", e.CODEC = \"codec\", e.CANDIDATE_PAIR = \"candidate-pair\", e.LOCAL_CANDIDATE = \"local-candidate\", e.REMOTE_CANDIDATE = \"remote-candidate\", e.INBOUND = \"inbound-rtp\", e.TRACK = \"track\", e.OUTBOUND = \"outbound-rtp\", e.PC = \"peer-connection\", e.REMOTE_INBOUND = \"remote-inbound-rtp\", e.REMOTE_OUTBOUND = \"remote-outbound-rtp\", e.TRANSPORT = \"transport\", e.CSRC = \"csrc\", e.DATA_CHANNEL = \"data-channel\", e.STREAM = \"stream\", e.SENDER = \"sender\", e.RECEIVER = \"receiver\";\n  }(tP || (tP = {}));\n  var uP,\n    lP = function (e) {\n      function t() {\n        var t = null !== e && e.apply(this, arguments) || this;\n        return t._stats = rP, t.lastDecodeVideoReceiverStats = new Map(), t.lastVideoFramesRecv = new Map(), t.lastVideoFramesSent = new Map(), t.lastVideoFramesDecode = new Map(), t.lastVideoJBDelay = new Map(), t.lastAudioJBDelay = new Map(), t.mediaBytesSent = new Map(), t.mediaBytesRetransmit = new Map(), t.mediaBytesTargetEncode = new Map(), t.lastEncoderMs = new Map(), t;\n      }\n      return QD(t, e), t.prototype.updateStats = function () {\n        return $D(this, void 0, void 0, function () {\n          var e,\n            t = this;\n          return eP(this, function (i) {\n            switch (i.label) {\n              case 0:\n                return e = this, [4, this.pc.getStats()];\n              case 1:\n                return e.report = i.sent(), this._stats = qD(rP), this.report.forEach(function (e) {\n                  switch (e.type) {\n                    case tP.OUTBOUND:\n                      \"audio\" === e.mediaType ? t.processAudioOutboundStats(e) : \"video\" === e.mediaType && t.processVideoOutboundStats(e);\n                      break;\n                    case tP.INBOUND:\n                      \"audio\" === e.mediaType ? t.processAudioInboundStats(e) : \"video\" === e.mediaType && t.processVideoInboundStats(e);\n                      break;\n                    case tP.TRANSPORT:\n                      var i = t.report.get(e.selectedCandidatePairId);\n                      i && t.processCandidatePairStats(i);\n                      break;\n                    case tP.CANDIDATE_PAIR:\n                      e.selected && t.processCandidatePairStats(e);\n                  }\n                }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2];\n            }\n          });\n        });\n      }, t.prototype.processCandidatePairStats = function (e) {\n        if (this._stats.sendBandwidth = e.availableOutgoingBitrate || 0, e.currentRoundTripTime && (this._stats.rtt = 1e3 * e.currentRoundTripTime), this._stats.videoSend.forEach(function (t) {\n          !t.rttMs && e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);\n        }), this._stats.audioSend.forEach(function (t) {\n          !t.rttMs && e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime);\n        }), this._stats.selectedCandidatePair.id = e.id, e.localCandidateId) {\n          var t = this.report.get(e.localCandidateId);\n          t && this.processCandidateStats(t);\n        }\n        if (e.remoteCandidateId) {\n          var i = this.report.get(e.remoteCandidateId);\n          i && this.processCandidateStats(i);\n        }\n      }, t.prototype.processCandidateStats = function (e) {\n        var t;\n        e.type === tP.LOCAL_CANDIDATE && (t = this._stats.selectedCandidatePair.localCandidate), e.type === tP.REMOTE_CANDIDATE && (t = this._stats.selectedCandidatePair.remoteCandidate), t && (t.type = e.type, t.id = e.id, e.address && (t.address = e.address), e.candidateType && (t.candidateType = e.candidateType), e.port && (t.port = e.port), e.priority && (t.priority = e.priority), e.protocol && (t.protocol = e.protocol), e.relayProtocol && (t.relayProtocol = e.relayProtocol), e.type === tP.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged(ZD({}, t), ZD({}, this.stats.selectedCandidatePair.localCandidate)), e.type === tP.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged(ZD({}, t), ZD({}, this.stats.selectedCandidatePair.remoteCandidate)));\n      }, t.prototype.processAudioInboundStats = function (e) {\n        var t = this._stats.audioRecv.find(function (t) {\n          return t.ssrc === e.ssrc;\n        });\n        t || (t = qD(aP), this._stats.audioRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.jitterMs = 1e3 * e.jitter, this.processAudioTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), t.receivedFrames || (t.receivedFrames = e.packetsReceived), t.droppedFrames || (t.droppedFrames = e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.outputLevel && t.outputLevel > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), \"number\" == typeof e.concealedSamples && (t.concealedSamples = e.concealedSamples);\n      }, t.prototype.processVideoInboundStats = function (e) {\n        var t = this._stats.videoRecv.find(function (t) {\n          return t.ssrc === e.ssrc;\n        });\n        t || (t = qD(nP), this._stats.videoRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.framesDecodeCount = e.framesDecoded, t.totalInterFrameDelay = e.totalInterFrameDelay, t.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay;\n        var i = this.lastDecodeVideoReceiverStats.get(t.ssrc),\n          r = this.lastVideoFramesDecode.get(t.ssrc),\n          n = Date.now();\n        if (t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc]) {\n          var o = t.decodedFrame ? t.decodedFrame.width : 0,\n            s = t.decodedFrame ? t.decodedFrame.height : 0;\n          this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, o, s), this.isFirstVideoDecoded[t.ssrc] = !0;\n        }\n        if (i) {\n          var a = i.stats,\n            c = n - i.lts;\n          t.framesDecodeFreezeTime = a.framesDecodeFreezeTime, t.framesDecodeInterval = a.framesDecodeInterval, !this.isFirstVideoDecoded[t.ssrc] && c > this.options.firstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t.ssrc), t.framesDecodeCount > a.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (i.lts = Date.now(), t.framesDecodeInterval = c, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < a.framesDecodeCount && (t.framesDecodeInterval = 0), e.framesDecoded && e.qpSum && (i.stats.framesDecodeCount > e.framesDecoded ? t.qpSumPerFrame = e.qpSum / e.framesDecoded : t.qpSumPerFrame = (e.qpSum - i.qpSum) / (e.framesDecoded - i.stats.framesDecodeCount));\n        }\n        r && n - r.lts >= 800 ? (t.decodeFrameRate = Math.round((t.framesDecodeCount - r.count) / ((n - r.lts) / 1e3)), this.lastVideoFramesDecode.set(t.ssrc, {\n          count: t.framesDecodeCount,\n          lts: n,\n          rate: t.decodeFrameRate\n        })) : r ? t.decodeFrameRate = r.rate : this.lastVideoFramesDecode.set(t.ssrc, {\n          count: t.framesDecodeCount,\n          lts: n,\n          rate: 0\n        }), e.totalDecodeTime && (t.decodeMs = 1e3 * e.totalDecodeTime), this.processVideoTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.framerateMean && (t.framesRateFirefox = e.framerateMean), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), this.lastDecodeVideoReceiverStats.set(t.ssrc, {\n          stats: ZD({}, t),\n          lts: i ? i.lts : Date.now(),\n          qpSum: e.qpSum\n        });\n      }, t.prototype.processVideoOutboundStats = function (e) {\n        var t = this._stats.videoSend.find(function (t) {\n          return t.ssrc === e.ssrc;\n        });\n        t || (t = qD(oP), this._stats.videoSend.push(t));\n        var i,\n          r = this.mediaBytesSent.get(e.ssrc);\n        r ? r.add(e.bytesSent) : ((o = new XD(10)).add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, o));\n        if (void 0 !== e.retransmittedBytesSent) {\n          var n = this.mediaBytesRetransmit.get(e.ssrc);\n          if (n) n.add(e.retransmittedBytesSent);else (o = new XD(10)).add(e.retransmittedBytesSent), this.mediaBytesRetransmit.set(e.ssrc, o);\n        }\n        if (e.totalEncodedBytesTarget) {\n          var o,\n            s = this.mediaBytesTargetEncode.get(e.ssrc);\n          if (s) s.add(e.totalEncodedBytesTarget);else (o = new XD(10)).add(e.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e.ssrc, o);\n        }\n        if (t.ssrc = e.ssrc, t.bytes = e.bytesSent, t.packets = e.packetsSent, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.frameCount = e.framesEncoded, t.adaptionChangeReason = e.qualityLimitationReason, e.totalEncodeTime && e.framesEncoded) if (!(i = this.lastEncoderMs.get(e.ssrc)) || i.lastFrameCount > e.framesEncoded) t.avgEncodeMs = 1e3 * e.totalEncodeTime / e.framesEncoded;else {\n          var a = e.framesEncoded - i.lastFrameCount,\n            c = e.totalEncodeTime - i.lastEncoderTime;\n          t.avgEncodeMs = 1e3 * c / a;\n        }\n        e.framesEncoded && e.qpSum && (!(i = this.lastEncoderMs.get(e.ssrc)) || i.lastFrameCount > e.framesEncoded ? t.qpSumPerFrame = e.qpSum / e.framesEncoded : t.qpSumPerFrame = (e.qpSum - i.lastQpSum) / (e.framesEncoded - i.lastFrameCount));\n        if (this.lastEncoderMs.set(e.ssrc, {\n          lastFrameCount: e.framesEncoded,\n          lastEncoderTime: e.totalEncodeTime,\n          lastQpSum: e.qpSum,\n          lts: Date.now()\n        }), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, t), this.processVideoTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t);else {\n          var d = this.findRemoteStatsId(e.ssrc, tP.REMOTE_INBOUND);\n          d && this.processRemoteInboundStats(d, t);\n        }\n      }, t.prototype.processAudioOutboundStats = function (e) {\n        var t = this._stats.audioSend.find(function (t) {\n          return t.ssrc === e.ssrc;\n        });\n        if (t || (t = qD(sP), this._stats.audioSend.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsSent, t.bytes = e.bytesSent, e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), this.processAudioTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t);else {\n          var i = this.findRemoteStatsId(e.ssrc, tP.REMOTE_INBOUND);\n          i && this.processRemoteInboundStats(i, t);\n        }\n      }, t.prototype.findRemoteStatsId = function (e, t) {\n        var i = Array.from(this.report.values()).find(function (i) {\n          return i.type === t && i.ssrc === e;\n        });\n        return i ? i.id : null;\n      }, t.prototype.processVideoMediaSource = function (e, t) {\n        var i = this.report.get(e);\n        i && i.width && i.height && i.framesPerSecond && (t.inputFrame = {\n          width: i.width,\n          height: i.height,\n          frameRate: i.framesPerSecond\n        });\n      }, t.prototype.processAudioMediaSource = function (e, t) {\n        var i = this.report.get(e);\n        i && (t.inputLevel = i.audioLevel);\n      }, t.prototype.processVideoTrackSenderStats = function (e, t, i) {\n        var r,\n          n,\n          o,\n          s = t ? this.report.get(t) : void 0,\n          a = null !== (r = null == s ? void 0 : s.framesSent) && void 0 !== r ? r : e.framesSent,\n          c = null !== (n = null == s ? void 0 : s.frameWidth) && void 0 !== n ? n : e.frameWidth,\n          d = null !== (o = null == s ? void 0 : s.frameHeight) && void 0 !== o ? o : e.frameHeight;\n        if (\"number\" == typeof a && \"number\" == typeof c && \"number\" == typeof d) {\n          var u = 0,\n            l = Date.now(),\n            h = this.lastVideoFramesSent.get(i.ssrc);\n          h && l - h.lts >= 800 ? (u = Math.round((a - h.count) / ((l - h.lts) / 1e3)), this.lastVideoFramesSent.set(i.ssrc, {\n            count: a,\n            lts: l,\n            rate: u\n          })) : h ? u = h.rate : this.lastVideoFramesSent.set(i.ssrc, {\n            count: a,\n            lts: l,\n            rate: 0\n          }), i.sentFrame = {\n            width: c,\n            height: d,\n            frameRate: u\n          };\n        }\n      }, t.prototype.processVideoTrackReceiverStats = function (e, t, i) {\n        var r,\n          n,\n          o,\n          s,\n          a,\n          c = t ? this.report.get(t) : void 0,\n          d = null !== (r = null == c ? void 0 : c.framesReceived) && void 0 !== r ? r : e.framesReceived,\n          u = null !== (n = null == c ? void 0 : c.frameWidth) && void 0 !== n ? n : e.frameWidth,\n          l = null !== (o = null == c ? void 0 : c.frameHeight) && void 0 !== o ? o : e.frameHeight,\n          h = null !== (s = null == c ? void 0 : c.jitterBufferDelay) && void 0 !== s ? s : e.jitterBufferDelay,\n          p = null !== (a = null == c ? void 0 : c.jitterBufferEmittedCount) && void 0 !== a ? a : e.jitterBufferEmittedCount;\n        if (\"number\" == typeof d) {\n          var _ = this.lastVideoFramesRecv.get(i.ssrc),\n            E = Date.now();\n          i.framesReceivedCount = d;\n          var f = 0;\n          _ && E - _.lts >= 800 ? (f = Math.round((d - _.count) / ((E - _.lts) / 1e3)), this.lastVideoFramesRecv.set(i.ssrc, {\n            count: d,\n            lts: E,\n            rate: f\n          })) : _ ? f = _.rate : this.lastVideoFramesRecv.set(i.ssrc, {\n            count: d,\n            lts: E,\n            rate: 0\n          }), i.receivedFrame = {\n            width: u || 0,\n            height: l || 0,\n            frameRate: f || 0\n          }, i.decodedFrame = {\n            width: u || 0,\n            height: l || 0,\n            frameRate: i.decodeFrameRate || 0\n          }, i.outputFrame = {\n            width: u || 0,\n            height: l || 0,\n            frameRate: i.decodeFrameRate || 0\n          };\n        }\n        if (h && p) {\n          var m = this.lastVideoJBDelay.get(i.ssrc);\n          this.lastVideoJBDelay.set(i.ssrc, {\n            jitterBufferDelay: h,\n            jitterBufferEmittedCount: p\n          }), m || (m = {\n            jitterBufferDelay: 0,\n            jitterBufferEmittedCount: 0\n          });\n          var g = 1e3 * (h - m.jitterBufferDelay) / (p - m.jitterBufferEmittedCount);\n          i.jitterBufferMs = g, i.currentDelayMs = Math.round(g);\n        }\n      }, t.prototype.processAudioTrackSenderStats = function (e, t, i) {\n        var r,\n          n,\n          o,\n          s,\n          a = t ? this.report.get(t) : void 0,\n          c = null !== (n = null !== (r = null == a ? void 0 : a.echoReturnLoss) && void 0 !== r ? r : e.echoReturnLoss) && void 0 !== n ? n : 0,\n          d = null !== (s = null !== (o = null == a ? void 0 : a.echoReturnLossEnhancement) && void 0 !== o ? o : e.echoReturnLossEnhancement) && void 0 !== s ? s : 0;\n        i.aecReturnLoss = c, i.aecReturnLossEnhancement = d;\n      }, t.prototype.processAudioTrackReceiverStats = function (e, t, i) {\n        var r,\n          n,\n          o,\n          s,\n          a,\n          c,\n          d,\n          u = t ? this.report.get(t) : void 0,\n          l = null !== (r = null == u ? void 0 : u.removedSamplesForAcceleration) && void 0 !== r ? r : e.removedSamplesForAcceleration,\n          h = null !== (n = null == u ? void 0 : u.totalSamplesReceived) && void 0 !== n ? n : e.totalSamplesReceived,\n          p = null !== (o = null == u ? void 0 : u.jitterBufferDelay) && void 0 !== o ? o : e.jitterBufferDelay,\n          _ = null !== (s = null == u ? void 0 : u.jitterBufferEmittedCount) && void 0 !== s ? s : e.jitterBufferEmittedCount,\n          E = null !== (a = null == u ? void 0 : u.audioLevel) && void 0 !== a ? a : null == e ? void 0 : e.audioLevel,\n          f = null !== (c = null == u ? void 0 : u.totalSamplesDuration) && void 0 !== c ? c : null == e ? void 0 : e.totalSamplesDuration,\n          m = null !== (d = null == u ? void 0 : u.concealedSamples) && void 0 !== d ? d : e.concealedSamples;\n        if (l && h && (i.accelerateRate = l / h), p && _) {\n          var g = this.lastAudioJBDelay.get(i.ssrc);\n          this.lastAudioJBDelay.set(i.ssrc, {\n            jitterBufferDelay: p,\n            jitterBufferEmittedCount: _\n          }), g || (g = {\n            jitterBufferDelay: 0,\n            jitterBufferEmittedCount: 0\n          });\n          var S = 1e3 * (p - g.jitterBufferDelay) / (_ - g.jitterBufferEmittedCount);\n          i.jitterBufferMs = Math.round(S);\n        }\n        i.outputLevel = E;\n        var T = 1920;\n        f && h && (T = h / f / 50, i.receivedFrames = Math.round(h / T)), m && (i.droppedFrames = Math.round(m / T));\n      }, t.prototype.processRemoteInboundStats = function (e, t) {\n        var i = this.report.get(e);\n        i && (t.packetsLost = i.packetsLost, i.roundTripTime && (t.rttMs = 1e3 * i.roundTripTime));\n      }, t.prototype.getCodecFromCodecStats = function (e) {\n        var t = this.report.get(e);\n        if (!t) return \"\";\n        var i = t.mimeType.match(/\\/(.*)$/);\n        return i && i[1] ? i[1] : \"\";\n      }, t.prototype.updateSendBitrate = function () {\n        var e = 0,\n          t = null,\n          i = null;\n        this.mediaBytesSent.forEach(function (t) {\n          e += t.diffMean();\n        }), this.mediaBytesRetransmit.forEach(function (e) {\n          t = null === t ? e.diffMean() : t + e.diffMean();\n        }), this.mediaBytesTargetEncode.forEach(function (e) {\n          i = null === i ? e.diffMean() : i + e.diffMean();\n        });\n        var r = null !== t ? e - t : e;\n        this._stats.bitrate = {\n          actualEncoded: 8 * r / (this.options.updateInterval / 1e3),\n          transmit: 8 * e / (this.options.updateInterval / 1e3)\n        }, null !== t && (this._stats.bitrate.retransmit = 8 * t / (this.options.updateInterval / 1e3)), null !== i && (this._stats.bitrate.targetEncoded = 8 * i / (this.options.updateInterval / 1e3));\n      }, t;\n    }(cP),\n    hP = function (e) {\n      function t() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n      return QD(t, e), t.prototype.updateStats = function () {\n        return Promise.resolve();\n      }, t;\n    }(cP);\n  function pP(e, t, i, r, n) {\n    void 0 === t && (t = 250), void 0 === i && (i = 8), void 0 === r && (r = 500), void 0 === n && (n = 1e4);\n    var o,\n      s = (o = navigator.userAgent.toLocaleLowerCase().match(/chrome\\/[\\d]*/i)) && o[0] ? Number(o[0].split(\"/\")[1]) : null;\n    return s ? s < 76 ? new dP(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: r,\n      firstVideoDecodedTimeout: n\n    }) : new lP(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: r,\n      firstVideoDecodedTimeout: n\n    }) : function (e) {\n      return !!window.RTCStatsReport && e.getStats() instanceof Promise;\n    }(e) ? new lP(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: r,\n      firstVideoDecodedTimeout: n\n    }) : new hP(e, {\n      updateInterval: t,\n      lossRateInterval: i,\n      freezeRateLimit: r,\n      firstVideoDecodedTimeout: n\n    });\n  }\n  function _P(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function EP(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? _P(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : _P(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let fP = (ZS((uP = class e extends xg {\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    constructor(t, i) {\n      super(t, i), mp(this, \"store\", void 0), mp(this, \"peerConnection\", void 0), mp(this, \"remoteSDP\", void 0), mp(this, \"initialOffer\", void 0), mp(this, \"statsFilter\", void 0), mp(this, \"useRTX\", !1), mp(this, \"localCapabilities\", void 0), mp(this, \"localCandidateCount\", 0), mp(this, \"allCandidatesReceived\", !1), mp(this, \"mutex\", new OT(\"P2PConnection-mutex\")), this.store = i, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.statsFilter = pP(this.peerConnection, void 0, void 0, Qh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;\n    }\n    async establish() {\n      try {\n        const e = await this.peerConnection.createOffer({\n          offerToReceiveAudio: !0,\n          offerToReceiveVideo: !0\n        });\n        if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n        const t = PD(e.sdp),\n          i = DD(e.sdp, !this.useRTX, HE(\"FILTER_VIDEO_FEC\"), HE(\"FILTER_AUDIO_FEC\"), [\"opus\"]);\n        return this.localCapabilities = i, this.initialOffer = e, EP(EP({}, t), {}, {\n          rtpCapabilities: {\n            send: {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            },\n            recv: {\n              audioCodecs: [],\n              audioExtensions: [],\n              videoCodecs: [],\n              videoExtensions: []\n            },\n            sendrecv: i\n          },\n          offerSDP: e.sdp\n        });\n      } catch (e) {\n        throw new vE(TE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e, t, i, r, n, o) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish P2PConnection without initial offer.\");\n        this.remoteSDP = new YD({\n          remoteIceParameters: e,\n          remoteDtlsParameters: t,\n          candidates: i,\n          remoteRTPCapabilities: r.send,\n          remoteSetup: n,\n          localCapabilities: this.localCapabilities,\n          sdkCodec: this.store.codec,\n          cname: o\n        });\n        const s = this.remoteSDP.toString();\n        await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: s\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.connect failed; \".concat(e.toString()));\n      }\n    }\n    send(e, t) {\n      var i = this;\n      return ID(function* () {\n        const r = yield yD(i.mutex.lock());\n        try {\n          if (!i.remoteSDP) throw new Error(\"Cannot call P2PConnection.send before remote SDP created\");\n          const n = e.map(e => i.peerConnection.addTrack(e._mediaStreamTrack)),\n            o = yield yD(i.peerConnection.createOffer()),\n            s = bD.exports.parse(o.sdp),\n            a = e.map(e => {\n              const t = e._mediaStreamTrack,\n                r = s.mediaDescriptions.find(e => e.attributes.mid === t.kind);\n              if (!r) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n              return function (e, t, i) {\n                const r = e.attributes.ssrcs.filter(e => e.attributes.label === t),\n                  n = e.attributes.ssrcGroups;\n                if (0 === r.length) throw new Error(\"Cannot extract ssrc from plan-b SDP.\");\n                if (n && r.length > 1) {\n                  const e = n.find(e => -1 !== e.ssrcIds.indexOf(r[0].ssrcId));\n                  return e ? [{\n                    ssrcId: e.ssrcIds[0],\n                    rtx: i ? e.ssrcIds[1] : void 0\n                  }] : [{\n                    ssrcId: r[0].ssrcId\n                  }];\n                }\n                return [{\n                  ssrcId: r[0].ssrcId\n                }];\n              }(r, t.id, i.useRTX);\n            });\n          let c;\n          try {\n            c = yield a;\n          } catch (e) {\n            throw n.forEach(e => {\n              zh() && e.replaceTrack(null), i.peerConnection.removeTrack(e);\n            }), e;\n          }\n          const d = i.mungSendOfferSDP(o.sdp, e);\n          i.remoteSDP.receive(e, t, c);\n          const u = i.remoteSDP.toString();\n          return yield yD(i.peerConnection.setLocalDescription({\n            type: \"offer\",\n            sdp: d\n          })), yield yD(i.applySendEncodings(n, e)), yield yD(i.peerConnection.setRemoteDescription({\n            type: \"answer\",\n            sdp: u\n          })), e.map((e, t) => {\n            const i = e._mediaStreamTrack.id;\n            return {\n              localSSRC: a[t],\n              id: i\n            };\n          });\n        } catch (e) {\n          throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.send failed; \".concat(e.toString()));\n        } finally {\n          r();\n        }\n      })();\n    }\n    async stopSending(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getSenders().filter(t => {\n          var i;\n          return -1 !== e.indexOf((null === (i = t.track) || void 0 === i ? void 0 : i.id) || \"\");\n        });\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.\");\n        t.map(e => {\n          zh() && e.replaceTrack(null), this.peerConnection.removeTrack(e);\n        });\n        const i = await this.peerConnection.createOffer();\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.stopReceiving(e);\n        const r = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.stopSending failed; \".concat(e.toString()));\n      }\n    }\n    async receive(e, t, i, r) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const {\n            id: i,\n            mslabel: n\n          } = this.remoteSDP.send(e, t, r),\n          o = new Cl((t, r) => {\n            const o = setTimeout(() => {\n                r(new Error(\"Cannot receive track, id: \".concat(i)));\n              }, 1e4),\n              s = r => {\n                const a = Bh();\n                if ((\"Safari\" === a.name && 11 === Number(a.version) || Zh()) && r.track.id !== i && r.streams[0].id === n) {\n                  var c;\n                  const n = r.streams[0].getTracks()[0];\n                  return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(e, i, r.track.id), this.peerConnection.removeEventListener(\"track\", s), clearTimeout(o), void t(n);\n                }\n                if (r.track.id === i) return this.peerConnection.removeEventListener(\"track\", s), clearTimeout(o), void t(r.track);\n              };\n            this.peerConnection.addEventListener(\"track\", s);\n          }),\n          s = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: s\n        });\n        const a = await this.peerConnection.createAnswer();\n        await this.peerConnection.setLocalDescription(a);\n        return {\n          track: await o,\n          id: i\n        };\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const i = await this.peerConnection.createAnswer();\n        await this.peerConnection.setLocalDescription(i);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async muteRemote(e) {}\n    async unmuteRemote(e) {}\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getSenders().filter(t => {\n          var i;\n          return -1 !== e.indexOf((null === (i = t.track) || void 0 === i ? void 0 : i.id) || \"\");\n        });\n        if (t.length !== e.length) throw new Error(\"sender' length doesn't match mids' length.\");\n        t.map(e => {\n          if (zh() && e.track) e.track.enabled = !1;else {\n            const t = e.getParameters();\n            t.encodings.forEach(e => e.active = !1), e.setParameters(t);\n          }\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getSenders().filter(t => {\n          var i;\n          return -1 !== e.indexOf((null === (i = t.track) || void 0 === i ? void 0 : i.id) || \"\");\n        });\n        if (t.length !== e.length) throw new Error(\"Senders' length doesn't match mids' length.\");\n        t.map(async e => {\n          if (zh() && e.track) e.track.enabled = !0;else {\n            const t = e.getParameters();\n            t.encodings.forEach(e => e.active = !0), await e.setParameters(t);\n          }\n        });\n        const i = await this.peerConnection.createOffer();\n        await this.peerConnection.setLocalDescription(i);\n        const r = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    restartICE() {\n      var e = this;\n      return ID(function* () {\n        const t = yield yD(e.mutex.lock(\"From P2PConnection.restartICE\"));\n        try {\n          const i = yield yD(e.peerConnection.createOffer({\n            iceRestart: !0\n          }));\n          if (!i.sdp) throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n          const r = PD(i.sdp),\n            {\n              remoteIceParameters: n\n            } = yield r.iceParameters;\n          if (!e.remoteSDP) throw new Error(\"Cannot restartICE before remoteSDP created.\");\n          e.remoteSDP.restartICE(n);\n          const o = e.remoteSDP.toString();\n          yield yD(e.peerConnection.setLocalDescription(i)), yield yD(e.peerConnection.setRemoteDescription({\n            type: \"answer\",\n            sdp: o\n          }));\n        } catch (e) {\n          NE.warning(\"restart ICE failed, abort operation\", e);\n        } finally {\n          t();\n        }\n      })();\n    }\n    close() {\n      var e;\n      this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy();\n    }\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.updateEncoderConfig before remote SDP created.\");\n        const e = await this.peerConnection.createOffer(),\n          i = this.mungSendOfferSDP(e.sdp, [t]);\n        this.remoteSDP.updateRecvMedia(t._mediaStreamTrack.kind, t);\n        const r = this.remoteSDP.toString();\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: i\n        }), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: r\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getSenders().filter(t => {\n        var i;\n        return (null === (i = t.track) || void 0 === i ? void 0 : i.id) === e;\n      });\n      1 === i.length && (await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getSenders().find(e => {\n        var i;\n        return (null === (i = e.track) || void 0 === i ? void 0 : i.id) === t;\n      });\n      i && (await i.replaceTrack(e._mediaStreamTrack));\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e;\n        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.peerConnection.onicecandidate = e => {\n        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, NE.debug(\"[pc-\".concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount));\n      }, setTimeout(() => {\n        this.allCandidatesReceived || (this.allCandidatesReceived = !0, NE.debug(\"[pc-\".concat(this.store.p2pId, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, HE(\"CANDIDATE_TIMEOUT\"));\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: [],\n        sdpSemantics: \"plan-b\"\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (xm(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), HE(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!jg().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let r = 0; r < e.length; r++) {\n          var i;\n          const n = e[r],\n            o = t[r];\n          if (!o) continue;\n          const s = {},\n            a = {};\n          if (o instanceof Ew) switch (o._optimizationMode) {\n            case \"motion\":\n              s.degradationPreference = \"maintain-framerate\";\n              break;\n            case \"detail\":\n              s.degradationPreference = \"maintain-resolution\";\n              break;\n            default:\n              s.degradationPreference = \"balanced\";\n          }\n          if (HE(\"DSCP_TYPE\") && ap()) {\n            const e = HE(\"DSCP_TYPE\");\n            [\"very-low\", \"low\", \"medium\", \"high\"].includes(e) && (a.networkPriority = e);\n          }\n          const c = n.getParameters(),\n            d = null === (i = c.encodings) || void 0 === i ? void 0 : i[0];\n          d && Object.assign(d, a), Object.assign(c, s), await n.setParameters(c);\n        }\n      } catch (e) {\n        NE.debug(\"Apply RTPSendEncodings failed.\");\n      }\n    }\n    mungSendOfferSDP(e, t) {\n      const i = bD.exports.parse(e);\n      return t.forEach((e, t) => {\n        const r = e._mediaStreamTrack,\n          n = i.mediaDescriptions.find(e => e.attributes.mid === r.kind);\n        n && UD(n, e);\n      }), bD.exports.print(i);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var r;\n        null === (r = this.onFirstVideoDecoded) || void 0 === r || r.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0;\n    }\n    async batchReceive(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.batchReceive before remoteSDP created.\");\n        const t = this.remoteSDP.batchSend(e).map((t, i) => {\n            let {\n              id: r,\n              mslabel: n\n            } = t;\n            const {\n              kind: o\n            } = e[i];\n            return new Cl((e, t) => {\n              const i = setTimeout(() => {\n                  t(new Error(\"Cannot receive track, id: \".concat(r)));\n                }, 1e4),\n                s = t => {\n                  const a = Bh();\n                  if (\"Safari\" === a.name && 11 === Number(a.version) && t.track.id !== r && t.streams[0].id === n) {\n                    var c;\n                    const n = t.streams[0].getTracks()[0];\n                    return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(o, r, t.track.id), this.peerConnection.removeEventListener(\"track\", s), clearTimeout(i), void e({\n                      track: n,\n                      id: r\n                    });\n                  }\n                  if (t.track.id === r) return this.peerConnection.removeEventListener(\"track\", s), clearTimeout(i), void e({\n                    track: t.track,\n                    id: r\n                  });\n                };\n              this.peerConnection.addEventListener(\"track\", s);\n            });\n          }),\n          i = this.remoteSDP.toString();\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: i\n        });\n        const r = await this.peerConnection.createAnswer();\n        return await this.peerConnection.setLocalDescription(r), await Cl.all(t);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async getRemoteSSRC(e) {\n      if (!this.remoteSDP) return;\n      const t = this.remoteSDP.getSSRC(e);\n      return null == t ? void 0 : t[0].ssrcId;\n    }\n  }).prototype, \"connect\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"connect\"), uP.prototype), ZS(uP.prototype, \"stopSending\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"stopSending\"), uP.prototype), ZS(uP.prototype, \"receive\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"receive\"), uP.prototype), ZS(uP.prototype, \"stopReceiving\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"stopReceiving\"), uP.prototype), ZS(uP.prototype, \"muteRemote\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"muteRemote\"), uP.prototype), ZS(uP.prototype, \"unmuteRemote\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"unmuteRemote\"), uP.prototype), ZS(uP.prototype, \"muteLocal\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"muteLocal\"), uP.prototype), ZS(uP.prototype, \"unmuteLocal\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"unmuteLocal\"), uP.prototype), ZS(uP.prototype, \"close\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"close\"), uP.prototype), ZS(uP.prototype, \"updateEncoderConfig\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"updateEncoderConfig\"), uP.prototype), ZS(uP.prototype, \"updateSendParameters\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"updateSendParameters\"), uP.prototype), ZS(uP.prototype, \"replaceTrack\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"replaceTrack\"), uP.prototype), ZS(uP.prototype, \"getRemoteSSRC\", [mP], Object.getOwnPropertyDescriptor(uP.prototype, \"getRemoteSSRC\"), uP.prototype), uP);\n  function mP(e, t, i) {\n    const r = e[t];\n    if (\"function\" != typeof r) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"Locking from P2PConnection.\".concat(t));\n      try {\n        for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];\n        return await r.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  const gP = \"9\",\n    SP = 4e4;\n  class TP {\n    get localCapabilities() {\n      return qR(this._localCapabilities);\n    }\n    get rtpCapabilities() {\n      return qR(this._rtpCapabilities);\n    }\n    get candidates() {\n      return qR(this._candidates);\n    }\n    get iceParameters() {\n      return qR(this._iceParameters);\n    }\n    get dtlsParameters() {\n      return qR(this._dtlsParameters);\n    }\n    constructor(e) {\n      mp(this, \"sessionDesc\", void 0), mp(this, \"_localCapabilities\", void 0), mp(this, \"_rtpCapabilities\", void 0), mp(this, \"_candidates\", void 0), mp(this, \"_iceParameters\", void 0), mp(this, \"_dtlsParameters\", void 0), mp(this, \"setup\", void 0), mp(this, \"currentMidIndex\", void 0), mp(this, \"cname\", void 0), mp(this, \"firefoxSsrcMidMap\", new Map()), e = qR(e);\n      const {\n          remoteIceParameters: t,\n          remoteDtlsParameters: i,\n          candidates: r,\n          remoteRTPCapabilities: n,\n          remoteSetup: o,\n          localCapabilities: s,\n          cname: a\n        } = e,\n        c = bD.exports.parse(\"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE 0 1\\na=msid-semantic: WMS\\na=ice-lite\\nm=video 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:0\\nm=audio 9 UDP/TLS/RTP/SAVPF 0\\nc=IN IP4 127.0.0.1\\na=rtcp:9 IN IP4 0.0.0.0\\na=sendonly\\na=rtcp-mux\\na=rtcp-rsize\\na=mid:1\\n\");\n      this._rtpCapabilities = n, this._candidates = r, this._iceParameters = t, this._dtlsParameters = i, this._localCapabilities = s, this.setup = o, this.cname = a;\n      const d = this.rtpCapabilities.send;\n      for (const e of c.mediaDescriptions) {\n        if (e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = i.fingerprints, e.attributes.candidates = r, e.attributes.setup = o, \"video\" === e.media.mediaType && (e.media.fmts = d.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.videoCodecs, e.attributes.extmaps = d.videoExtensions, HE(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const {\n            ssrcs: t,\n            ssrcGroups: i\n          } = MD([{\n            ssrcId: SP,\n            rtx: HE(\"USE_RTX\") ? 40001 : void 0\n          }], this.cname);\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n        if (\"audio\" === e.media.mediaType && (e.media.fmts = d.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.audioCodecs, e.attributes.extmaps = d.audioExtensions, KD(e), HE(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const {\n            ssrcs: t,\n            ssrcGroups: i\n          } = MD([{\n            ssrcId: 2e4\n          }], this.cname);\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n      }\n      this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1;\n    }\n    preloadRemoteMedia() {\n      const e = HE(\"PRELOAD_MEDIA_COUNT\");\n      this.rtpCapabilities;\n      const t = this.candidates,\n        i = this.dtlsParameters,\n        r = this.iceParameters,\n        n = this.rtpCapabilities.send;\n      for (let o = 1; o < e; o++) {\n        const e = 2 * o + 2e4,\n          s = 2 * o + SP,\n          {\n            ssrcs: a,\n            ssrcGroups: c\n          } = MD([{\n            ssrcId: e\n          }], this.cname),\n          {\n            ssrcs: d,\n            ssrcGroups: u\n          } = MD([{\n            ssrcId: s,\n            rtx: HE(\"USE_RTX\") ? s + 1 : void 0\n          }], this.cname);\n        this.sessionDesc.mediaDescriptions.push({\n          media: {\n            mediaType: \"video\",\n            port: gP,\n            protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n            fmts: n.videoCodecs.map(e => e.payloadType.toString(10))\n          },\n          connections: [{\n            nettype: \"IN\",\n            addrtype: \"IP4\",\n            address: \"127.0.0.1\"\n          }],\n          bandwidths: [],\n          attributes: {\n            iceUfrag: r.iceUfrag,\n            icePwd: r.icePwd,\n            unrecognized: [],\n            candidates: t,\n            extmaps: n.videoExtensions,\n            fingerprints: i.fingerprints,\n            imageattr: [],\n            msids: [],\n            remoteCandidatesList: [],\n            rids: [],\n            ssrcs: d,\n            ssrcGroups: u,\n            rtcpFeedbackWildcards: [],\n            payloads: n.videoCodecs,\n            rtcp: {\n              port: \"9\",\n              netType: \"IN\",\n              addressType: \"IP4\",\n              address: \"0.0.0.0\"\n            },\n            setup: this.setup,\n            direction: \"sendonly\",\n            rtcpMux: !0,\n            rtcpRsize: !0,\n            mid: \"\".concat(2 * o)\n          }\n        }), this.sessionDesc.mediaDescriptions.push({\n          media: {\n            mediaType: \"audio\",\n            port: gP,\n            protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n            fmts: n.audioCodecs.map(e => e.payloadType.toString(10))\n          },\n          connections: [{\n            nettype: \"IN\",\n            addrtype: \"IP4\",\n            address: \"127.0.0.1\"\n          }],\n          bandwidths: [],\n          attributes: {\n            iceUfrag: r.iceUfrag,\n            icePwd: r.icePwd,\n            unrecognized: [],\n            candidates: t,\n            extmaps: n.audioExtensions,\n            fingerprints: i.fingerprints,\n            imageattr: [],\n            msids: [],\n            remoteCandidatesList: [],\n            rids: [],\n            ssrcs: a,\n            ssrcGroups: c,\n            rtcpFeedbackWildcards: [],\n            payloads: n.audioCodecs,\n            rtcp: {\n              port: \"9\",\n              netType: \"IN\",\n              addressType: \"IP4\",\n              address: \"0.0.0.0\"\n            },\n            setup: this.setup,\n            direction: \"sendonly\",\n            rtcpMux: !0,\n            rtcpRsize: !0,\n            mid: \"\".concat(2 * o + 1)\n          }\n        }), this.currentMidIndex += 2;\n      }\n      this.updateBundleMids();\n    }\n    toString() {\n      return bD.exports.print(this.sessionDesc);\n    }\n    send(e, t, i, r) {\n      const {\n          ssrcs: n,\n          ssrcGroups: o\n        } = MD(t, this.cname, i),\n        s = this.findPreloadMediaDesc(n);\n      if (s) {\n        if (Qh() && this.firefoxSsrcMidMap.set(n[0].ssrcId, s.attributes.mid), r && (r.tcc || r.remb)) {\n          const e = this.sessionDesc.mediaDescriptions.indexOf(s);\n          return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, r), {\n            mid: s.attributes.mid,\n            needExchangeSDP: !0\n          };\n        }\n        return {\n          mid: s.attributes.mid,\n          needExchangeSDP: !1\n        };\n      }\n      {\n        const t = this.findAvailableMediaIndex(e, n);\n        let i;\n        return -1 === t || zh() || Zh() || $h() ? (i = this.createOrRecycleSendMedia(e, n, o, \"sendonly\", r), this.updateBundleMids()) : (i = qR(this.sessionDesc.mediaDescriptions[t]), i.attributes.direction = \"sendonly\", i.attributes.ssrcs = n, i.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(i, r)), Qh() && this.firefoxSsrcMidMap.set(n[0].ssrcId, i.attributes.mid), {\n          mid: i.attributes.mid,\n          needExchangeSDP: !0\n        };\n      }\n    }\n    batchSend(e) {\n      const t = e.map(e => {\n          let {\n            kind: t,\n            ssrcMsg: i,\n            mslabel: r\n          } = e;\n          return this.send(t, i, r);\n        }),\n        i = [];\n      let r = !1;\n      return t.forEach(e => {\n        let {\n          mid: t,\n          needExchangeSDP: n\n        } = e;\n        n && (r = !0), i.push(t);\n      }), {\n        mids: i,\n        needExchangeSDP: r\n      };\n    }\n    stopSending(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.\");\n      t.forEach(e => {\n        \"0\" === e.attributes.mid || Qh() || zh() || Zh() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = \"inactive\", e.media.port = \"0\");\n      }), this.updateBundleMids();\n    }\n    mute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.mute.\"));\n      t.attributes.direction = \"inactive\";\n    }\n    unmute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.unmute.\"));\n      t.attributes.direction = \"sendonly\";\n    }\n    muteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"inactive\";\n      });\n    }\n    unmuteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"recvonly\";\n      });\n    }\n    receive(e, t, i, r) {\n      e.forEach((e, n) => {\n        this.createOrRecycleRecvMedia(e, [], \"recvonly\", t, i, r[n]);\n      }), this.updateBundleMids();\n    }\n    stopReceiving(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.\");\n      t.forEach(e => {\n        e.media.port = \"0\", e.attributes.direction = \"inactive\";\n      }), this.updateBundleMids();\n    }\n    restartICE(e) {\n      e = qR(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n        t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n      });\n    }\n    predictReceivingMids(e) {\n      const t = [];\n      for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n      return t;\n    }\n    findAvailableMediaIndex(e, t) {\n      return this.sessionDesc.mediaDescriptions.findIndex(i => {\n        const r = i.media.mediaType === e && \"0\" !== i.media.port && (\"sendonly\" === i.attributes.direction || \"sendrecv\" === i.attributes.direction) && 0 === i.attributes.ssrcs.length;\n        if (Qh()) {\n          if (r) {\n            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);\n            return !(e || \"0\" !== i.attributes.mid && \"1\" !== i.attributes.mid) || !(!e || e !== i.attributes.mid);\n          }\n          return !1;\n        }\n        return r;\n      });\n    }\n    createOrRecycleRecvMedia(e, t, i, r, n, o) {\n      const s = e._mediaStreamTrack.kind,\n        a = this.rtpCapabilities.recv,\n        c = this.localCapabilities.send;\n      let d = [];\n      if (s === yg.VIDEO) {\n        var u, l;\n        if (HE(\"H264_PROFILE_LEVEL_ID\") && \"h264\" === r && (d = a.videoCodecs.filter(e => {\n          var t, i;\n          return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(r) && (null == e || null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]) === HE(\"H264_PROFILE_LEVEL_ID\");\n        })), !d || 0 === (null === (u = d) || void 0 === u ? void 0 : u.length)) {\n          const e = c.videoCodecs.filter(e => {\n            var t;\n            return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(r);\n          });\n          0 !== e.length && (d = a.videoCodecs.filter(t => e.some(e => e.payloadType === t.payloadType)));\n        }\n        if (HE(\"USE_RTX\")) {\n          const e = d.map(e => e.payloadType.toString()),\n            t = a.videoCodecs.filter(t => {\n              var i, r;\n              return \"rtx\" === (null === (i = t.rtpMap) || void 0 === i ? void 0 : i.encodingName) && e.includes((null === (r = t.fmtp) || void 0 === r ? void 0 : r.parameters.apt) || \"\");\n            });\n          d = [...d, ...t];\n        }\n        if (0 === d.length) NE.warning(\"codec \".concat(r, \" not included in rtpCapabilities, fallback to default payloads: \").concat(null === (l = a.videoCodecs[0].rtpMap) || void 0 === l ? void 0 : l.encodingName)), d = a.videoCodecs;\n      } else d = a.audioCodecs.filter(e => {\n        var t;\n        return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(n);\n      }), 0 === d.length && (NE.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to opus\")), d = a.audioCodecs.filter(e => {\n        var t;\n        return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(\"opus\");\n      }));\n      const h = s === yg.VIDEO ? a.videoExtensions : a.audioExtensions;\n      this.currentMidIndex += 1;\n      const p = \"\".concat(this.currentMidIndex);\n      let _ = {\n        media: {\n          mediaType: s,\n          port: gP,\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: d.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: this.candidates,\n          extmaps: h,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: [],\n          rtcpFeedbackWildcards: [],\n          payloads: d,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: i,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(p)\n        }\n      };\n      _ = this.mungRecvMediaDsec(_, e, o);\n      const E = this.findFirstClosedMedia(s);\n      if (E) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(E);\n        this.sessionDesc.mediaDescriptions[e] = _;\n      } else this.sessionDesc.mediaDescriptions.push(_);\n      return _;\n    }\n    createOrRecycleSendMedia(e, t, i, r, n) {\n      const o = this.rtpCapabilities.send,\n        s = e === yg.VIDEO ? o.videoCodecs : o.audioCodecs,\n        a = e === yg.VIDEO ? o.videoExtensions : o.audioExtensions;\n      this.currentMidIndex += 1;\n      const c = \"\".concat(this.currentMidIndex);\n      let d = {\n        media: {\n          mediaType: e,\n          port: gP,\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: s.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: this.candidates,\n          extmaps: a,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: i,\n          rtcpFeedbackWildcards: [],\n          payloads: s,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: r,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(c)\n        }\n      };\n      d = this.mungSendMediaDesc(d, n);\n      const u = this.findFirstClosedMedia(e);\n      if (u) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(u);\n        this.sessionDesc.mediaDescriptions[e] = d;\n      } else this.sessionDesc.mediaDescriptions.push(d);\n      return d;\n    }\n    updateBundleMids() {\n      this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => \"0\" !== e.media.port).map(e => e.attributes.mid);\n    }\n    mungRecvMediaDsec(e, t, i) {\n      const r = qR(e);\n      return xD(r), UD(r, t), VD(r, t), jD(r), FD(r, i, this.localCapabilities.send), r;\n    }\n    mungSendMediaDesc(e, t) {\n      const i = qR(e);\n      return FD(i, t, this.localCapabilities.recv), KD(i), i;\n    }\n    updateRecvMedia(e, t) {\n      const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n      if (-1 !== i) {\n        const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n        this.sessionDesc.mediaDescriptions[i] = e;\n      }\n    }\n    bumpMid(e) {\n      this.currentMidIndex += e;\n    }\n    findFirstClosedMedia(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => Qh() ? \"0\" === t.media.port && t.media.mediaType === e : \"0\" === t.media.port);\n    }\n    findPreloadMediaDesc(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => {\n        var i, r;\n        return (null === (i = t.attributes) || void 0 === i || null === (r = i.ssrcs[0]) || void 0 === r ? void 0 : r.ssrcId) === e[0].ssrcId;\n      });\n    }\n    getSSRC(e) {\n      var t;\n      return null === (t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === t ? void 0 : t.attributes.ssrcs;\n    }\n  }\n  var vP;\n  function RP(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function IP(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? RP(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : RP(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let yP = (ZS((vP = class e extends xg {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    constructor(t, i) {\n      super(t, i), mp(this, \"store\", void 0), mp(this, \"peerConnection\", void 0), mp(this, \"remoteSDP\", void 0), mp(this, \"initialOffer\", void 0), mp(this, \"transportEventReceiver\", void 0), mp(this, \"statsFilter\", void 0), mp(this, \"useRTX\", HE(\"USE_RTX\")), mp(this, \"localCapabilities\", void 0), mp(this, \"localCandidateCount\", 0), mp(this, \"allCandidatesReceived\", !1), mp(this, \"mutex\", new OT(\"P2PConnection-mutex\")), this.store = i, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.statsFilter = pP(this.peerConnection, void 0, void 0, Qh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;\n    }\n    async establish() {\n      try {\n        this.peerConnection.addTransceiver(\"video\", {\n          direction: \"recvonly\"\n        }), this.peerConnection.addTransceiver(\"audio\", {\n          direction: \"recvonly\"\n        });\n        const e = await this.peerConnection.createOffer();\n        if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n        const t = PD(e.sdp),\n          i = await GD(!this.useRTX, HE(\"FILTER_VIDEO_FEC\"), HE(\"FILTER_AUDIO_FEC\"));\n        return this.localCapabilities = HD(i), this.initialOffer = e, IP(IP({}, t), {}, {\n          rtpCapabilities: i,\n          offerSDP: e.sdp\n        });\n      } catch (e) {\n        throw new vE(TE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e, t, i, r, n, o) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish P2PConnection without initial offer.\");\n        this.remoteSDP = new TP({\n          remoteIceParameters: e,\n          remoteDtlsParameters: t,\n          candidates: i,\n          remoteRTPCapabilities: r,\n          remoteSetup: n,\n          localCapabilities: this.localCapabilities,\n          cname: o\n        });\n        const s = this.remoteSDP.toString(),\n          a = bD.exports.parse(this.initialOffer.sdp),\n          c = a.mediaDescriptions.find(e => \"audio\" === e.media.mediaType);\n        c && KD(c);\n        const d = bD.exports.print(a),\n          u = this.logSDPExchange(d || \"\", \"offer\", \"local\", \"connect\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: d\n        }), null == u || u(s), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: s\n        });\n        const l = this.peerConnection.getTransceivers()[0];\n        if (null != l && l.receiver && this.tryBindTransportEvents(l.receiver), HE(\"PRELOAD_MEDIA_COUNT\") > 0) {\n          this.remoteSDP.preloadRemoteMedia();\n          const e = this.remoteSDP.toString();\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const t = await this.peerConnection.createAnswer();\n          await this.peerConnection.setLocalDescription(t);\n        }\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.connect failed; \".concat(e.toString()));\n      }\n    }\n    send(e, t, i) {\n      var r = this;\n      return ID(function* () {\n        const n = yield yD(r.mutex.lock(\"From P2PConnection.send\"));\n        try {\n          if (!r.remoteSDP) throw new Error(\"Cannot call P2PConnection.send before remote SDP created\");\n          const o = [];\n          e.forEach(e => {\n            const t = r.peerConnection.addTransceiver(e._mediaStreamTrack, {\n              direction: \"sendonly\"\n            });\n            o.push(t);\n          }), Qh() && !0 === HE(\"SIMULCAST\") && (yield yD(r.applySimulcastForFirefox(o, e)));\n          const s = yield yD(r.peerConnection.createOffer()),\n            a = r.remoteSDP.predictReceivingMids(e.length),\n            c = r.mungSendOfferSDP(s.sdp, e, a),\n            d = bD.exports.parse(c),\n            u = a.map(e => {\n              const t = d.mediaDescriptions.find(t => t.attributes.mid === e);\n              if (!t) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n              return LD(t, r.useRTX);\n            });\n          let l;\n          try {\n            l = yield u;\n          } catch (n) {\n            l = [], r.remoteSDP.receive(e, t, i, l);\n            const o = r.remoteSDP.toString();\n            throw yield yD(r.peerConnection.setLocalDescription({\n              type: \"offer\",\n              sdp: c\n            })), yield yD(r.peerConnection.setRemoteDescription({\n              type: \"answer\",\n              sdp: o\n            })), yield yD(r.stopSending(a, !0)), n;\n          }\n          r.remoteSDP.receive(e, t, i, l);\n          const h = r.remoteSDP.toString(),\n            p = r.logSDPExchange(c, \"offer\", \"local\", \"send\");\n          return yield yD(r.peerConnection.setLocalDescription({\n            type: \"offer\",\n            sdp: c\n          })), yield yD(r.applySimulcastEncodings(o, e)), yield yD(r.applySendEncodings(o, e)), null == p || p(h), yield yD(r.peerConnection.setRemoteDescription({\n            type: \"answer\",\n            sdp: h\n          })), o.map((e, t) => {\n            const i = a[t];\n            return {\n              localSSRC: u[t],\n              id: i,\n              transceiver: e\n            };\n          });\n        } catch (e) {\n          throw e instanceof vE ? e : new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.send failed; \".concat(e.toString()));\n        } finally {\n          n();\n        }\n      })();\n    }\n    async stopSending(e, t) {\n      const i = t ? void 0 : await this.mutex.lock(\"From P2PConnection.stopSending\");\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.\");\n        t.map(e => {\n          var t;\n          e.direction = \"inactive\", null === (t = e.stop) || void 0 === t || t.call(e);\n        });\n        const r = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(r.sdp || \"\", \"offer\", \"local\", \"stopSending\");\n        await this.peerConnection.setLocalDescription(r), this.remoteSDP.stopReceiving(e);\n        const o = this.remoteSDP.toString();\n        null == n || n(o), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: o\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.stopSending failed; \".concat(e.toString()));\n      } finally {\n        i && i();\n      }\n    }\n    async receive(e, t, i, r) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const {\n          mid: n,\n          needExchangeSDP: o\n        } = this.remoteSDP.send(e, t, i, r);\n        if (o) {\n          const t = this.remoteSDP.toString(),\n            i = this.logSDPExchange(t, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: t\n          });\n          const r = await this.peerConnection.createAnswer(),\n            o = this.mungReceiveAnswerSDP(r.sdp, n, e);\n          null == i || i(o || \"\"), await this.peerConnection.setLocalDescription({\n            type: \"answer\",\n            sdp: o\n          }), NE.debug(\"[P2PConnection] receive \".concat(e, \" by exchanging SDP.\"));\n        } else NE.debug(\"[P2PConnection] receive \".concat(e, \" no need to exchange SDP.\"));\n        const s = this.peerConnection.getTransceivers().find(e => e.mid === n);\n        if (!s) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n        return {\n          track: s.receiver.track,\n          id: n\n        };\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async batchReceive(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.batchReceive before remoteSDP created.\");\n        const {\n          mids: t,\n          needExchangeSDP: i\n        } = this.remoteSDP.batchSend(e);\n        if (i) {\n          const e = this.remoteSDP.toString(),\n            t = this.logSDPExchange(e, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const i = await this.peerConnection.createAnswer();\n          null == t || t(i.sdp || \"\"), await this.peerConnection.setLocalDescription(i), NE.debug(\"[P2PConnection] batchReceive by exchanging SDP.\");\n        } else NE.debug(\"[P2PConnection] batchReceive no need to exchange SDP.\");\n        return t.map(e => {\n          const t = this.peerConnection.getTransceivers().find(t => t.mid === e);\n          if (!t) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n          return {\n            track: t.receiver.track,\n            id: e\n          };\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"stopReceiving\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const r = await this.peerConnection.createAnswer();\n        null == i || i(r.sdp || \"\"), await this.peerConnection.setLocalDescription(r);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async muteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.mute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"muteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const r = await this.peerConnection.createAnswer();\n        null == i || i(r.sdp || \"\"), await this.peerConnection.setLocalDescription(r);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.muteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.unmute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"unmuteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const r = await this.peerConnection.createAnswer();\n        null == i || i(r.sdp || \"\"), await this.peerConnection.setLocalDescription(r);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(e => {\n          e.direction = \"inactive\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);\n        const n = this.remoteSDP.toString();\n        null == r || r(n), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(async (e, t) => {\n          e.direction = \"sendonly\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"unmuteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);\n        const n = this.remoteSDP.toString();\n        null == r || r(n), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"P2PConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    restartICE() {\n      var e = this;\n      return ID(function* () {\n        const t = yield yD(e.mutex.lock(\"From P2PConnection.restartICE\"));\n        try {\n          const i = yield yD(e.peerConnection.createOffer({\n            iceRestart: !0\n          }));\n          if (!i.sdp) throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n          const r = PD(i.sdp),\n            {\n              remoteIceParameters: n\n            } = yield r.iceParameters;\n          if (!e.remoteSDP) throw new Error(\"Cannot restartICE before remoteSDP created.\");\n          e.remoteSDP.restartICE(n);\n          const o = e.remoteSDP.toString(),\n            s = e.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"restartICE\");\n          yield yD(e.peerConnection.setLocalDescription(i)), null == s || s(o), yield yD(e.peerConnection.setRemoteDescription({\n            type: \"answer\",\n            sdp: o\n          }));\n        } catch (e) {\n          NE.warning(\"restart ICE failed, abort operation\", e);\n        } finally {\n          t();\n        }\n      })();\n    }\n    close() {\n      var e;\n      this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();\n    }\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call P2PConnection.updateEncoderConfig before remote SDP created.\");\n        const i = await this.peerConnection.createOffer(),\n          r = this.mungSendOfferSDP(i.sdp, [t], [e]);\n        this.remoteSDP.updateRecvMedia(e, t);\n        const n = this.remoteSDP.toString(),\n          o = this.logSDPExchange(r, \"offer\", \"local\", \"updateEncoderConfig\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: r\n        }), null == o || o(n), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getTransceivers().filter(t => t.mid === e);\n      1 === i.length && (this.isVP8Simulcast(t) ? Qh() || (await this.applySimulcastEncodings(i, [t])) : await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getTransceivers().find(e => e.mid === t);\n      i && (await i.sender.replaceTrack(e._mediaStreamTrack));\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e;\n        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.peerConnection.onicecandidate = e => {\n        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, NE.debug(\"[pc-\".concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount));\n      }, setTimeout(() => {\n        this.allCandidatesReceived || (this.allCandidatesReceived = !0, NE.debug(\"[pc-\".concat(this.store.p2pId, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, HE(\"CANDIDATE_TIMEOUT\"));\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: []\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (xm(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), HE(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), HE(\"FORCE_TURN_TCP\") ? i.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(TR(e.turnServerURL), \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && !HE(\"FORCE_TURN_TCP\") && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    tryBindTransportEvents(e) {\n      e.transport && (this.transportEventReceiver = e, e.transport.onstatechange = () => {\n        var t, i;\n        null !== (t = e.transport) && void 0 !== t && t.state && (null === (i = this.onDTLSTransportStateChange) || void 0 === i || i.call(this, e.transport.state));\n      }, e.transport.onerror = e => {\n        var t;\n        null === (t = this.onDTLSTransportError) || void 0 === t || t.call(this, e.error);\n      }, e.transport.iceTransport && (e.transport.iceTransport.onstatechange = () => {\n        var t, i, r;\n        null !== (t = e.transport) && void 0 !== t && t.iceTransport.state && (null === (i = this.onICETransportStateChange) || void 0 === i || i.call(this, null === (r = e.transport) || void 0 === r ? void 0 : r.iceTransport.state));\n      }));\n    }\n    tryUnbindTransportEvents() {\n      this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null));\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!jg().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let c = 0; c < e.length; c++) {\n          const d = e[c],\n            u = t[c];\n          if (u && u instanceof Ew) {\n            var i, r;\n            if (this.isVP8Simulcast(u)) continue;\n            const e = {},\n              t = {};\n            switch (u._optimizationMode) {\n              case \"motion\":\n                e.degradationPreference = \"maintain-framerate\";\n                break;\n              case \"detail\":\n                e.degradationPreference = \"maintain-resolution\";\n                break;\n              default:\n                e.degradationPreference = \"balanced\";\n            }\n            var n, o, s, a;\n            if (null !== (i = u._encoderConfig) && void 0 !== i && i.bitrateMax) t.maxBitrate = 1e3 * (null === (n = u._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax);\n            if (u._hints.includes(lg.LOW_STREAM)) null !== (o = u._encoderConfig) && void 0 !== o && o.frameRate && (t.maxFramerate = RR(u._encoderConfig.frameRate)), null !== (s = u._encoderConfig) && void 0 !== s && s.scaleResolutionDownBy && (null === (a = u._encoderConfig) || void 0 === a ? void 0 : a.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = u._encoderConfig.scaleResolutionDownBy);\n            if (HE(\"DSCP_TYPE\") && ap()) {\n              const e = HE(\"DSCP_TYPE\");\n              [\"very-low\", \"low\", \"medium\", \"high\"].includes(e) && (t.networkPriority = e);\n            }\n            const c = d.sender.getParameters(),\n              l = null === (r = c.encodings) || void 0 === r ? void 0 : r[0];\n            Qh() && !l && (e.encodings = [t]), l && Object.assign(l, t), Object.assign(c, e), await d.sender.setParameters(c);\n          }\n        }\n      } catch (e) {\n        NE.debug(\"Apply RTPSendEncodings failed.\");\n      }\n    }\n    mungSendOfferSDP(e, t, i) {\n      const r = bD.exports.parse(e);\n      return t.forEach((e, t) => {\n        const n = i[t],\n          o = r.mediaDescriptions.find(e => e.attributes.mid === n);\n        o && (UD(o, e), BD(o, e, this.store.codec));\n      }), bD.exports.print(r);\n    }\n    mungReceiveAnswerSDP(e, t, i) {\n      const r = bD.exports.parse(e),\n        n = r.mediaDescriptions.find(e => e.attributes.mid === t);\n      return n && i === yg.AUDIO && \"audio\" === n.media.mediaType && KD(n), bD.exports.print(r);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var r;\n        null === (r = this.onFirstVideoDecoded) || void 0 === r || r.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onFirstVideoDecodedTimeout = e => {\n        var t;\n        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;\n    }\n    async applySimulcastForFirefox(e, t) {\n      if (e.length === t.length) for (let s = 0; s < e.length; s++) {\n        var i, r, n, o;\n        const a = e[s],\n          c = t[s];\n        if (c instanceof Ew && !c._hints.includes(lg.LOW_STREAM) && null !== (i = c._encoderConfig) && void 0 !== i && i.bitrateMax && (null === (r = c._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (n = c._scalabiltyMode) && void 0 !== n && n.numSpatialLayers && (null === (o = c._scalabiltyMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1 && \"vp8\" === this.store.codec) {\n          const e = {},\n            t = {\n              high: 1e3 * (c._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          e.encodings = [{\n            rid: \"m\",\n            active: !0,\n            maxBitrate: t.medium,\n            scaleResolutionDownBy: 4\n          }, {\n            rid: \"h\",\n            active: !0,\n            maxBitrate: t.high\n          }];\n          const i = a.sender.getParameters();\n          await a.sender.setParameters(Object.assign(i, e));\n        }\n      }\n    }\n    async applySimulcastEncodings(e, t) {\n      if (!Qh() && e.length === t.length) for (let i = 0; i < e.length; i++) {\n        const r = t[i];\n        if (r instanceof Ew && this.isVP8Simulcast(r)) {\n          const t = e[i],\n            n = {},\n            o = {\n              high: 1e3 * (r._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          n.encodings = [{\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"high\",\n            priority: \"high\",\n            maxBitrate: o.high\n          }, {\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"low\",\n            priority: \"low\",\n            maxBitrate: o.medium,\n            scaleResolutionDownBy: 4\n          }];\n          const s = t.sender.getParameters();\n          await t.sender.setParameters(Object.assign(s, n));\n        }\n      }\n    }\n    isVP8Simulcast(e) {\n      var t, i, r, n;\n      return !!(e instanceof Ew && HE(\"SIMULCAST\") && \"vp8\" === this.store.codec && !e._hints.includes(lg.LOW_STREAM) && null !== (t = e._encoderConfig) && void 0 !== t && t.bitrateMax && (null === (i = e._encoderConfig) || void 0 === i ? void 0 : i.bitrateMax) > 200 && null !== (r = e._scalabiltyMode) && void 0 !== r && r.numSpatialLayers && (null === (n = e._scalabiltyMode) || void 0 === n ? void 0 : n.numSpatialLayers) > 1);\n    }\n    logSDPExchange(e, t, i, r) {\n      if (HE(\"SDP_LOGGING\")) return NE.upload(\"exchanging \".concat(i, \" \").concat(t, \" SDP during P2PConnection.\").concat(r, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", r);\n      } : void 0;\n    }\n    async getRemoteSSRC(e) {\n      if (!this.remoteSDP) return;\n      const t = this.remoteSDP.getSSRC(e);\n      return null == t ? void 0 : t[0].ssrcId;\n    }\n  }).prototype, \"connect\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"connect\"), vP.prototype), ZS(vP.prototype, \"receive\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"receive\"), vP.prototype), ZS(vP.prototype, \"batchReceive\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"batchReceive\"), vP.prototype), ZS(vP.prototype, \"stopReceiving\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"stopReceiving\"), vP.prototype), ZS(vP.prototype, \"muteRemote\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"muteRemote\"), vP.prototype), ZS(vP.prototype, \"unmuteRemote\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"unmuteRemote\"), vP.prototype), ZS(vP.prototype, \"muteLocal\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"muteLocal\"), vP.prototype), ZS(vP.prototype, \"unmuteLocal\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"unmuteLocal\"), vP.prototype), ZS(vP.prototype, \"close\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"close\"), vP.prototype), ZS(vP.prototype, \"updateEncoderConfig\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"updateEncoderConfig\"), vP.prototype), ZS(vP.prototype, \"updateSendParameters\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"updateSendParameters\"), vP.prototype), ZS(vP.prototype, \"replaceTrack\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"replaceTrack\"), vP.prototype), ZS(vP.prototype, \"getRemoteSSRC\", [CP], Object.getOwnPropertyDescriptor(vP.prototype, \"getRemoteSSRC\"), vP.prototype), vP);\n  function CP(e, t, i) {\n    const r = e[t];\n    if (\"function\" != typeof r) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From P2PConnection.\".concat(t));\n      try {\n        for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];\n        return await r.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  function AP(e, t) {\n    let i = document.createElement(\"video\"),\n      r = document.createElement(\"canvas\");\n    i.setAttribute(\"style\", \"display:none\"), r.setAttribute(\"style\", \"display:none\"), i.setAttribute(\"muted\", \"\"), i.muted = !0, i.setAttribute(\"autoplay\", \"\"), i.autoplay = !0, i.setAttribute(\"playsinline\", \"\"), r.width = RR(t.width), r.height = RR(t.height);\n    const n = RR(t.framerate || 15);\n    document.body.append(i), document.body.append(r);\n    let o = e._mediaStreamTrack;\n    i.srcObject = new MediaStream([o]), i.play();\n    const s = r.getContext(\"2d\");\n    if (!s) throw new vE(TE.UNEXPECTED_ERROR, \"can not get canvas context\");\n    const a = jg(),\n      c = r.captureStream(a.supportRequestFrame ? 0 : n).getVideoTracks()[0],\n      d = VT(() => (() => {\n        if (i.paused && i.play(), i.videoHeight > 2 && i.videoWidth > 2) {\n          const e = i.videoWidth,\n            t = i.videoHeight / e,\n            n = r.width * t;\n          Math.abs(n - r.height) >= 2 && (NE.debug(\"adjust low stream resolution\", \"\".concat(r.width, \"x\").concat(r.height, \" -> \").concat(r.width, \"x\").concat(n)), r.height = n);\n        }\n        s.drawImage(i, 0, 0, r.width, r.height), c.requestFrame && c.requestFrame(), o !== e._mediaStreamTrack && (o = e._mediaStreamTrack, i.srcObject = new MediaStream([o]));\n      })(), n),\n      u = c.stop;\n    return c.stop = () => {\n      u.call(c), d(), i && (i.remove(), i = null), r && (r.width = 0, r.remove(), r = null), NE.debug(\"clean low stream renderer\");\n    }, c;\n  }\n  var OP, bP, wP, NP, DP, PP, LP, kP, MP, UP, xP, VP;\n  function jP(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function FP(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? jP(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : jP(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class BP extends yT {\n    getUserId() {\n      return this._userId;\n    }\n    constructor(e, t, i, r) {\n      super(e, \"track-\".concat(e.kind, \"-\").concat(t, \"-\").concat(r.clientId, \"_\").concat(MR(5, \"\"))), mp(this, \"_userId\", void 0), mp(this, \"_uintId\", void 0), mp(this, \"_isDestroyed\", !1), mp(this, \"store\", void 0), mp(this, \"processor\", void 0), mp(this, \"processorContext\", void 0), this._userId = t, this._uintId = i, this.store = r;\n    }\n    _updateOriginMediaStreamTrack(e) {\n      this._originMediaStreamTrack = e, this._mediaStreamTrack = e, this._updatePlayerSource(), this.processor && this.processor.updateInput({\n        track: this._originMediaStreamTrack,\n        context: this.processorContext\n      });\n    }\n    _destroy() {\n      this._isDestroyed = !0, NE.info(\"[\".concat(this.getTrackId(), \"] is destroyed\")), this.stop(), super.close();\n    }\n    getProcessorStats() {\n      return this.processorContext.gatherStats();\n    }\n    getProcessorUsage() {\n      return this.processorContext.gatherUsage();\n    }\n  }\n  let GP = (OP = RT({\n      argsMap: (e, t, i) => [e.getTrackId(), \"string\" == typeof t ? t : \"HTMLElement\", i]\n    }), bP = RT({\n      argsMap: e => [e.getTrackId()]\n    }), wP = RT({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), NP = RT({\n      argsMap: e => [e.getTrackId()]\n    }), ZS((DP = class extends BP {\n      get isPlaying() {\n        return !(!this._player || this._player.videoElementStatus !== am.PLAYING);\n      }\n      get __className__() {\n        return \"RemoteVideoTrack\";\n      }\n      constructor(e, t, i, r) {\n        super(e, t, i, r), mp(this, \"_videoVisibleTimer\", null), mp(this, \"_previousVideoVisibleStatus\", void 0), mp(this, \"_clearPreviousVideoVisibleStatus\", () => this._previousVideoVisibleStatus = void 0), mp(this, \"trackMediaType\", \"video\"), mp(this, \"_videoWidth\", void 0), mp(this, \"_videoHeight\", void 0), mp(this, \"_player\", void 0), mp(this, \"processorDestination\", void 0), mp(this, \"processorContext\", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new eR(this.getTrackId(), \"remote\"), this.processorDestination = new $v(this.processorContext), this.bindProcessorDestinationEvents();\n      }\n      getStats() {\n        XR(() => {\n          NE.warning(\"[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead\");\n        }, \"remoteVideoTrackGetStatsWarning\");\n        return GR(this, ug.GET_STATS) || FP({}, Hm);\n      }\n      play(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        if (\"string\" == typeof e) {\n          const t = document.getElementById(e);\n          t ? e = t : (NE.warning(\"[\".concat(this.getTrackId(), '] can not find \"#').concat(e, '\" element, use document.body')), e = document.body);\n        }\n        NE.debug(\"[\".concat(this.getTrackId(), \"] start video playback\"), JSON.stringify(t));\n        const i = FP(FP({\n          fit: \"cover\"\n        }, t), {}, {\n          trackId: this.getTrackId(),\n          element: e\n        });\n        this._player ? this._player.updateConfig(i) : (this._player = new ob(i), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = () => {\n          this.store.subscribe(this.getUserId(), \"video\", void 0, void 0, Date.now()), this.emit(Eg.FIRST_FRAME_DECODED);\n        }), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {\n          try {\n            const e = this.getVideoElementVisibleStatus();\n            this.emit(Eg.VIDEO_ELEMENT_VISIBLE_STATUS, e);\n          } catch (e) {}\n        }, HE(\"CHECK_VIDEO_VISIBLE_INTERVAL\"));\n      }\n      stop() {\n        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, NE.debug(\"[\".concat(this.getTrackId(), \"] stop video playback\")));\n      }\n      getCurrentFrameData() {\n        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2);\n      }\n      updateMediaStreamTrackResolution() {\n        VR(this._originMediaStreamTrack).then(e => {\n          let [t, i] = e;\n          this._videoHeight = i, this._videoWidth = t;\n        }).catch(xR);\n      }\n      _updatePlayerSource() {\n        NE.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack);\n      }\n      getVideoElementVisibleStatus() {\n        try {\n          var e, t;\n          const i = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),\n            r = {\n              track: this,\n              element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),\n              slot: null == i ? void 0 : i.parentElement\n            },\n            {\n              element: n,\n              slot: o\n            } = r;\n          if (this.isPlaying && n instanceof HTMLVideoElement && o instanceof HTMLElement) {\n            const e = hw.checkOneElementVisible(n),\n              t = Object.assign({}, e);\n            if (t.visible !== this._previousVideoVisibleStatus) {\n              this._previousVideoVisibleStatus = t.visible;\n              const e = IT.reportApiInvoke(null, {\n                tag: fm.TRACER,\n                name: Em.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,\n                options: [this.getTrackId()]\n              });\n              t.visible ? e.onSuccess(\"Video is visible\") : e.onSuccess(\"Invisible because of \".concat(t.reason));\n            }\n            return t;\n          }\n          return;\n        } catch (e) {\n          throw new vE(TE.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message);\n        }\n      }\n      pipe(e) {\n        if (this.processor === e) return e;\n        if (e._source) throw new vE(TE.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        if (!this.processor) return;\n        const e = this.processor;\n        this.processor._source = void 0, this.processor = void 0, e.reset();\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(Ng.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(Ng.ON_TRACK);\n      }\n      _destroy() {\n        super._destroy(), this.unbindProcessorDestinationEvents();\n      }\n    }).prototype, \"play\", [OP], Object.getOwnPropertyDescriptor(DP.prototype, \"play\"), DP.prototype), ZS(DP.prototype, \"stop\", [bP], Object.getOwnPropertyDescriptor(DP.prototype, \"stop\"), DP.prototype), ZS(DP.prototype, \"pipe\", [wP], Object.getOwnPropertyDescriptor(DP.prototype, \"pipe\"), DP.prototype), ZS(DP.prototype, \"unpipe\", [NP], Object.getOwnPropertyDescriptor(DP.prototype, \"unpipe\"), DP.prototype), DP),\n    WP = (PP = RT({\n      argsMap: (e, t) => [e.getTrackId(), t],\n      throttleTime: 300\n    }), LP = RT({\n      argsMap: (e, t) => [e.getTrackId(), t]\n    }), kP = RT({\n      argsMap: e => [e.getTrackId()]\n    }), MP = RT({\n      argsMap: e => [e.getTrackId()]\n    }), UP = RT({\n      argsMap: (e, t) => [e.getTrackId(), t.name]\n    }), xP = RT({\n      argsMap: e => [e.getTrackId()]\n    }), ZS((VP = class extends BP {\n      get isPlaying() {\n        return this._useAudioElement ? nv.isPlaying(this.getTrackId()) : this._source.isPlayed;\n      }\n      get __className__() {\n        return \"RemoteAudioTrack\";\n      }\n      constructor(e, t, i, r) {\n        super(e, t, i, r), mp(this, \"trackMediaType\", \"audio\"), mp(this, \"_source\", void 0), mp(this, \"_useAudioElement\", !0), mp(this, \"_volume\", 100), mp(this, \"processorContext\", void 0), mp(this, \"processorDestination\", void 0), mp(this, \"_played\", !1), mp(this, \"_bypassWebAudio\", !1), HE(\"DISABLE_WEBAUDIO\") ? (this._source = new rR(), this._bypassWebAudio = !0, this._useAudioElement = !0) : (this._source = new WT(e, !0), HE(\"REMOTE_AUDIO_TRACK_USES_WEB_AUDIO\") && (this._useAudioElement = !1)), this._source.once(km.RECEIVE_TRACK_BUFFER, () => {\n          this.emit(Eg.FIRST_FRAME_DECODED);\n        }), this.processorContext = new iR(this._source.context, this.getTrackId(), \"remote\"), this.processorDestination = new tR(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(km.UPDATE_SOURCE, () => {\n          this.processor && this.processor.updateInput({\n            node: this._source.processSourceNode,\n            context: this.processorContext\n          });\n        });\n      }\n      setAudioFrameCallback(e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;\n        if (!e) return this._source.removeAllListeners(km.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();\n        this._source.startGetAudioBuffer(t), this._source.removeAllListeners(km.ON_AUDIO_BUFFER), this._source.on(km.ON_AUDIO_BUFFER, t => e(t));\n      }\n      setVolume(e) {\n        this._volume = e, this._useAudioElement ? nv.setVolume(this.getTrackId(), e) : this._source.setVolume(e / 100);\n      }\n      async setPlaybackDevice(e) {\n        if (!this._useAudioElement) throw new vE(TE.NOT_SUPPORTED, \"your browser does not support setting the audio output device\");\n        await nv.setSinkID(this.getTrackId(), e);\n      }\n      getVolumeLevel() {\n        return this._source.getAccurateVolumeLevel();\n      }\n      getStats() {\n        XR(() => {\n          NE.warning(\"[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead\");\n        }, \"remoteAudioTrackGetStatsWarning\");\n        return GR(this, ug.GET_STATS) || FP({}, Gm);\n      }\n      play() {\n        NE.debug(\"[\".concat(this.getTrackId(), \"] start audio playback\")), this._played = !0, this._useAudioElement ? (NE.debug(\"[\".concat(this.getTrackId(), \"] use audio element to play\")), nv.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play();\n      }\n      stop() {\n        NE.debug(\"[\".concat(this.getTrackId(), \"] stop audio playback\")), this._played = !1, this._useAudioElement ? nv.stop(this.getTrackId()) : this._source.stop();\n      }\n      _destroy() {\n        super._destroy(), this._played = !1, this.unbindProcessorDestinationEvents(), this._source.destroy();\n      }\n      _isFreeze() {\n        return this._source.isFreeze;\n      }\n      _updatePlayerSource() {\n        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n        NE.debug(\"[\".concat(this.getTrackId(), \"] update player source track\")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && nv.updateTrack(this.getTrackId(), this._mediaStreamTrack);\n      }\n      pipe(e) {\n        if (this._bypassWebAudio) throw new vE(TE.NOT_SUPPORTED, \"can not pipe extension when WebAudio disabled\");\n        if (this.processor === e) return e;\n        if (e._source) throw new vE(TE.INVALID_OPERATION, \"Processor \".concat(e.name, \" already piped, please call unpipe beforehand.\"));\n        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({\n          track: this._originMediaStreamTrack,\n          node: this._source.processSourceNode,\n          context: this.processorContext\n        }), e;\n      }\n      unpipe() {\n        var e;\n        if (this._bypassWebAudio) throw new vE(TE.NOT_SUPPORTED, \"can not unpipe extension when WebAudio disabled\");\n        if (!this.processor) return;\n        const t = this.processor;\n        null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset();\n      }\n      bindProcessorDestinationEvents() {\n        this.processorDestination.on(Ng.ON_TRACK, async e => {\n          e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource());\n        }), this.processorDestination.on(Ng.ON_NODE, e => {\n          this._source.processedNode = e;\n          const t = !e;\n          this._useAudioElement !== t && (this._played ? (this.stop(), this._useAudioElement = t, this.play()) : this._useAudioElement = t);\n        });\n      }\n      unbindProcessorDestinationEvents() {\n        this.processorDestination.removeAllListeners(Ng.ON_TRACK), this.processorDestination.removeAllListeners(Ng.ON_NODE);\n      }\n    }).prototype, \"setVolume\", [PP], Object.getOwnPropertyDescriptor(VP.prototype, \"setVolume\"), VP.prototype), ZS(VP.prototype, \"setPlaybackDevice\", [LP], Object.getOwnPropertyDescriptor(VP.prototype, \"setPlaybackDevice\"), VP.prototype), ZS(VP.prototype, \"play\", [kP], Object.getOwnPropertyDescriptor(VP.prototype, \"play\"), VP.prototype), ZS(VP.prototype, \"stop\", [MP], Object.getOwnPropertyDescriptor(VP.prototype, \"stop\"), VP.prototype), ZS(VP.prototype, \"pipe\", [UP], Object.getOwnPropertyDescriptor(VP.prototype, \"pipe\"), VP.prototype), ZS(VP.prototype, \"unpipe\", [xP], Object.getOwnPropertyDescriptor(VP.prototype, \"unpipe\"), VP.prototype), VP);\n  function HP(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function KP(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? HP(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : HP(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  class YP extends gE {\n    constructor() {\n      super(), mp(this, \"uplinkStatsUploadInterval\", void 0), mp(this, \"uplinkStatsUploadSlowInterval\", void 0), mp(this, \"uplinkRelatedStatsUploadInterval\", void 0), mp(this, \"uplinkDenoiserStatsUploadInterval\", void 0), mp(this, \"transportStatsUploadInterval\", void 0), mp(this, \"uplinkExtensionStatsUploadInterval\", void 0), mp(this, \"downlinkExtensionStatsUploadInterval\", void 0), mp(this, \"extensionUsageStatsUploadInterval\", void 0), mp(this, \"downlinkStatsUploadInterval\", void 0), mp(this, \"downlinkStatsUploadSlowInterval\", void 0), mp(this, \"downlinkRelatedStatsUploadInterval\", void 0), mp(this, \"lastStats\", void 0), mp(this, \"uploadUnplinkStarted\", !1), mp(this, \"uploadDownlinkStarted\", !1), mp(this, \"uploadTransportStarted\", !1), mp(this, \"uploadExtensionUsageStarted\", !1), mp(this, \"requestStats\", void 0), mp(this, \"requestLocalMedia\", void 0), mp(this, \"requestRemoteMedia\", void 0), mp(this, \"requestAllTracks\", void 0), mp(this, \"requestVideoIsReady\", void 0), mp(this, \"requestUpload\", void 0);\n    }\n    startUploadTransportStats() {\n      this.uploadTransportStarted || (this.uploadTransportStarted = !0, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadTransportStats(t);\n      }, 6e3));\n    }\n    startUploadExtensionUsageStats() {\n      if (this.uploadExtensionUsageStarted) return;\n      this.uploadExtensionUsageStarted = !0, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval);\n      const e = new Map();\n      this.extensionUsageStatsUploadInterval = window.setInterval(async () => {\n        var t, i, r;\n        const n = Date.now(),\n          o = {\n            connectionInterval: HE(\"EXTENSION_USAGE_UPLOAD_INTERVAL\") / 1e3,\n            details: [],\n            lts: n\n          };\n        let s = [];\n        const a = (null === (t = this.requestAllTracks) || void 0 === t ? void 0 : t.call(this)) || [];\n        for (const e of a) !e.muted && e.enabled && (s = s.concat(await e.getProcessorUsage()));\n        const c = (null === (i = this.requestRemoteMedia) || void 0 === i ? void 0 : i.call(this)) || [];\n        for (const [e, t] of c) t.has(yg.VIDEO) && e.videoTrack && (s = s.concat(await e.videoTrack.getProcessorUsage())), t.has(yg.AUDIO) && e.audioTrack && (s = s.concat(await e.audioTrack.getProcessorUsage()));\n        if (0 === s.length) return;\n        o.details = function (e, t) {\n          const i = {};\n          for (const {\n            id: s,\n            value: a,\n            level: c,\n            direction: d\n          } of e) {\n            var r;\n            const e = null !== (r = t.get(s)) && void 0 !== r ? r : 0,\n              u = 2 === a ? e + HE(\"EXTENSION_USAGE_UPLOAD_INTERVAL\") / 1e3 : e;\n            var n, o;\n            t.set(s, u), i[s] ? (2 === a && (i[s].value = a), c > i[s].level && (i[s].level = c), \"remote\" === d && (i[s].remoteUidCount += 1), i[s].totalTs = null !== (n = t.get(s)) && void 0 !== n ? n : 0) : i[s] = {\n              value: a,\n              level: c,\n              remoteUidCount: \"local\" === d ? 0 : 1,\n              totalTs: null !== (o = t.get(s)) && void 0 !== o ? o : 0\n            };\n          }\n          return Object.keys(i).map(e => {\n            const {\n              level: t,\n              value: r,\n              totalTs: n\n            } = i[e];\n            return {\n              id: e,\n              level: t,\n              value: r,\n              totalTs: n\n            };\n          });\n        }(s, e);\n        const d = Date.now(),\n          u = d > n ? d : n + 1;\n        null === (r = this.requestUpload) || void 0 === r || r.call(this, Dm.EXTENSION_USAGE_STATS, {\n          usageStats: o,\n          sendTs: u\n        });\n      }, HE(\"EXTENSION_USAGE_UPLOAD_INTERVAL\"));\n    }\n    startUploadUplinkStats() {\n      this.uploadUnplinkStarted || (this.uploadUnplinkStarted = !0, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);\n        t && (this.uploadUplinkStats(t, this.lastStats), this.lastStats = t);\n      }, 3e3), this.uplinkStatsUploadSlowInterval && window.clearInterval(this.uplinkStatsUploadSlowInterval), this.uplinkStatsUploadSlowInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadSlowUplinkStats(t);\n      }, 6e4), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadRelatedUplinkStats(t, this.lastStats), this.lastStats = t;\n      }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestAllTracks) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadDenoiserStats(t);\n      }, 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestAllTracks) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadExtensionStats(t);\n      }, 2e3));\n    }\n    uploadTransportStats(e) {\n      YR(() => {\n        var t;\n        null === (t = this.requestUpload) || void 0 === t || t.call(this, Dm.TRANSPORT_STATS, function (e) {\n          const t = {\n            connectionType: 100\n          };\n          if (\"relay\" === e.selectedCandidatePair.localCandidate.candidateType) {\n            const i = e.selectedCandidatePair.localCandidate.relayProtocol;\n            \"udp\" === i && (t.connectionType = 101), \"tcp\" === i && (t.connectionType = 103), \"tls\" === i && (t.connectionType = 104);\n          }\n          return t;\n        }(e));\n      });\n    }\n    uploadUplinkStats(e, t) {\n      var i;\n      ((null === (i = this.requestLocalMedia) || void 0 === i ? void 0 : i.call(this)) || []).forEach(i => {\n        let [r, {\n          track: n,\n          ssrcs: o\n        }] = i;\n        switch (r) {\n          case Cg.LocalVideoLowTrack:\n          case Cg.LocalVideoTrack:\n            {\n              const i = function (e, t, i) {\n                  var r;\n                  const n = t.videoSend.find(t => t.ssrc === e);\n                  if (!n) return null;\n                  const o = {\n                    id: MR(10, \"\"),\n                    timestamp: new Date(t.timestamp).toISOString(),\n                    mediaType: \"video\",\n                    type: \"ssrc\",\n                    ssrc: n.ssrc.toString()\n                  };\n                  switch (o.A_vstd = i._originMediaStreamTrack && !i._originMediaStreamTrack.enabled || i._mediaStreamTrack && !i._mediaStreamTrack.enabled ? \"1\" : \"0\", n.sentFrame && (o.A_fhs = n.sentFrame.height.toString(), o.A_frs = n.sentFrame.frameRate.toString(), o.A_fws = n.sentFrame.width.toString()), n.adaptionChangeReason) {\n                    case \"none\":\n                      o.A_ac = \"0\";\n                      break;\n                    case \"cpu\":\n                      o.A_ac = \"1\";\n                      break;\n                    case \"bandwidth\":\n                      o.A_ac = \"2\";\n                      break;\n                    case \"other\":\n                      o.A_ac = \"3\";\n                  }\n                  return o.A_lvps = cm[i._player ? i._player.videoElementStatus : \"uninit\"].toString(), o.A_nr = null === (r = n.nacksCount) || void 0 === r ? void 0 : r.toString(), n.avgEncodeMs && (o.A_aem = n.avgEncodeMs.toFixed(0).toString()), o;\n                }(o[0].ssrcId, e, n),\n                s = yR(o[0].ssrcId, e, t);\n              i && YR(() => {\n                var e;\n                return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, Dm.PUBLISH_STATS, {\n                  stream_type: r === Cg.LocalVideoLowTrack ? \"low\" : \"high\",\n                  stats: KP(KP({}, i), s)\n                });\n              });\n              const a = function (e) {\n                const t = {\n                  id: \"bweforvideo\",\n                  timestamp: new Date(e.timestamp).toISOString(),\n                  type: \"VideoBwe\"\n                };\n                return e.bitrate.retransmit && (t.A_rb = e.bitrate.retransmit.toString()), e.bitrate.targetEncoded && (t.A_teb = e.bitrate.targetEncoded.toString()), t.A_aeb = e.bitrate.actualEncoded.toString(), t.A_tb = e.bitrate.transmit.toString(), void 0 !== e.sendBandwidth && (t.A_asb = e.sendBandwidth.toString()), t;\n              }(e);\n              a && setTimeout(() => {\n                var e;\n                return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, Dm.PUBLISH_STATS, {\n                  stream_type: r === Cg.LocalVideoLowTrack ? \"low\" : \"high\",\n                  stats: a\n                });\n              }, 1e3);\n              break;\n            }\n          case Cg.LocalAudioTrack:\n            {\n              const t = function (e, t, i) {\n                const r = t.audioSend.find(t => t.ssrc === e);\n                if (!r) return null;\n                const n = {\n                  id: MR(10, \"\"),\n                  timestamp: new Date(t.timestamp).toISOString(),\n                  mediaType: \"audio\",\n                  type: \"ssrc\",\n                  ssrc: r.ssrc.toString()\n                };\n                return n.A_astd = i._originMediaStreamTrack.enabled && i._mediaStreamTrack.enabled ? \"0\" : \"1\", r.inputLevel ? n.A_ail = Math.round(100 * r.inputLevel).toString() : n.A_ail = Math.round(100 * i._source.getAccurateVolumeLevel()).toString(), n.A_apil = Math.round(100 * i._source.getAccurateVolumeLevel()).toString(), r.aecReturnLoss && (n.A_ecrl = Math.round(r.aecReturnLoss).toString()), r.aecReturnLossEnhancement && (n.A_ecrle = Math.round(r.aecReturnLossEnhancement).toString()), n;\n              }(o[0].ssrcId, e, n);\n              t && YR(() => {\n                var e;\n                return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, Dm.PUBLISH_STATS, {\n                  stream_type: \"high\",\n                  stats: t\n                });\n              });\n              break;\n            }\n        }\n      });\n    }\n    uploadSlowUplinkStats(e) {\n      var t;\n      ((null === (t = this.requestLocalMedia) || void 0 === t ? void 0 : t.call(this)) || []).filter(e => {\n        let [t] = e;\n        return t === Cg.LocalVideoLowTrack || t === Cg.LocalVideoTrack;\n      }).forEach(t => {\n        let [i, {\n          ssrcs: r\n        }] = t;\n        const n = yR(r[0].ssrcId, e);\n        n && YR(() => {\n          var e;\n          return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, Dm.PUBLISH_STATS, {\n            stream_type: i === Cg.LocalVideoLowTrack ? \"low\" : \"high\",\n            stats: n\n          });\n        });\n      });\n    }\n    uploadRelatedUplinkStats(e, t) {\n      var i;\n      ((null === (i = this.requestLocalMedia) || void 0 === i ? void 0 : i.call(this)) || []).filter(e => {\n        let [t] = e;\n        return t === Cg.LocalVideoLowTrack || t === Cg.LocalVideoTrack;\n      }).forEach(t => {\n        let [i, {\n          ssrcs: r\n        }] = t;\n        const n = function (e, t) {\n          const i = t.videoSend.find(t => t.ssrc === e);\n          return i ? {\n            mediaType: \"video\",\n            isVideoMute: !1,\n            frameRateInput: i.inputFrame && i.inputFrame.frameRate.toString(),\n            frameRateSent: i.sentFrame && i.sentFrame.frameRate.toString(),\n            googRtt: i.rttMs.toString(),\n            qpSumPerFrame: Math.floor(i.qpSumPerFrame).toString()\n          } : null;\n        }(r[0].ssrcId, e);\n        n && YR(() => {\n          var e;\n          null === (e = this.requestUpload) || void 0 === e || e.call(this, Dm.PUBLISH_RELATED_STATS, {\n            stream_type: i === Cg.LocalVideoLowTrack ? \"low\" : \"high\",\n            stats: n\n          });\n        });\n      });\n    }\n    uploadDenoiserStats(e) {\n      for (let n = 0; n < e.length; n++) {\n        const o = e[n];\n        if (o instanceof cR) {\n          var t, i, r;\n          const e = null === (t = (i = o._external).getDenoiserStats) || void 0 === t ? void 0 : t.call(i);\n          return void (e && (null === (r = this.requestUpload) || void 0 === r || r.call(this, Dm.DENOISER_STATS, e)));\n        }\n      }\n    }\n    uploadExtensionStats(e) {\n      for (let t = 0; t < e.length; t++) {\n        e[t].getProcessorStats().forEach(e => {\n          var t;\n          null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats);\n        });\n      }\n    }\n    stopUploadUplinkStats() {\n      this.uploadUnplinkStarted && (this.uploadUnplinkStarted = !1, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0);\n    }\n    startUploadDownlinkStats() {\n      if (this.uploadDownlinkStarted) return;\n      let e;\n      this.uploadDownlinkStarted = !0, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval);\n      let t = !1;\n      this.downlinkStatsUploadInterval = window.setInterval(() => {\n        var i;\n        const r = null === (i = this.requestStats) || void 0 === i ? void 0 : i.call(this);\n        r && (this.uploadDownlinkStats(r, t, e), e = r), t = !t;\n      }, 3e3), this.downlinkStatsUploadSlowInterval && window.clearInterval(this.downlinkStatsUploadSlowInterval), this.downlinkStatsUploadSlowInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadSlowDownlinkStats(t);\n      }, 6e4), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);\n        t && (this.uploadRelatedDownlinkStats(t, this.lastStats), this.lastStats = t);\n      }, 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval(() => {\n        var e;\n        const t = null === (e = this.requestRemoteMedia) || void 0 === e ? void 0 : e.call(this);\n        t && this.uploadDownlinkExtensionStats(t);\n      }, 2e3);\n    }\n    uploadDownlinkStats(e, t, i) {\n      var r;\n      ((null === (r = this.requestRemoteMedia) || void 0 === r ? void 0 : r.call(this)) || []).forEach(r => {\n        let [n, o] = r;\n        if (o.has(yg.VIDEO) && n.videoTrack) {\n          const r = n.videoTrack ? function (e, t, i, r, n) {\n            const o = t.videoRecv.find(t => t.ssrc === e);\n            if (!o) return null;\n            const s = {\n              id: MR(10, \"\"),\n              timestamp: new Date(t.timestamp).toISOString(),\n              mediaType: \"video\",\n              type: \"ssrc\",\n              ssrc: o.ssrc.toString()\n            };\n            var a, c;\n            if (s.bytesReceived = o.bytes.toString(), s.packetsLost = o.packetsLost.toString(), s.packetsReceived = o.packets.toString(), o.framesRateFirefox && (s.A_frr = o.framesRateFirefox.toString()), o.receivedFrame ? (s.A_frr = o.receivedFrame.frameRate.toString(), s.A_fhr = o.receivedFrame.height.toString(), s.A_fwr = o.receivedFrame.width.toString()) : (s.A_fhr = null === (a = r._videoHeight) || void 0 === a ? void 0 : a.toString(), s.A_fwr = null === (c = r._videoWidth) || void 0 === c ? void 0 : c.toString()), s.A_frd = o.decodeFrameRate.toString(), o.outputFrame && (s.A_fro = o.outputFrame.frameRate.toString()), void 0 !== o.jitterBufferMs && (s.A_jbm = Math.floor(o.jitterBufferMs).toString()), void 0 !== o.currentDelayMs && (s.A_cdm = Math.floor(o.currentDelayMs).toString()), s.A_fs = o.firsCount.toString(), s.A_ns = o.nacksCount.toString(), s.A_ps = o.plisCount.toString(), r && (s.A_vrtd = r._originMediaStreamTrack.enabled && r._mediaStreamTrack.enabled ? \"0\" : \"1\"), r._player && r._player.freezeTimeCounterList.length > 0 && (s.A_vrft = Math.round(r._player.freezeTimeCounterList.splice(0, 1)[0]).toString()), n && r._player && \"visible\" === mR.visibility) {\n              const e = Math.min(6e3, r._player.renderFreezeAccTime);\n              s.A_vrrft = Math.round(e).toString(), r._player.renderFreezeAccTime = Math.max(0, r._player.renderFreezeAccTime - e);\n            }\n            if (s.A_rvps = cm[r._player ? r._player.videoElementStatus : \"uninit\"].toString(), i) {\n              const t = i.videoRecv.find(t => t.ssrc === e);\n              if (t && void 0 !== o.totalInterFrameDelay && void 0 !== o.totalSquaredInterFrameDelay && void 0 !== t.totalInterFrameDelay && void 0 !== t.totalSquaredInterFrameDelay) {\n                const e = o.totalInterFrameDelay - t.totalInterFrameDelay,\n                  i = o.totalSquaredInterFrameDelay - t.totalSquaredInterFrameDelay,\n                  r = o.framesDecodeCount - t.framesDecodeCount,\n                  n = e / r * 1e3,\n                  a = Math.round(1e3 * Math.sqrt((i - Math.pow(e, 2) / r) / r));\n                !isNaN(a) && n + a > Math.max(3 * n, n + 150) && (s.A_ifdsd = a.toString());\n              }\n            }\n            return s;\n          }(n._videoSSRC, e, i, n.videoTrack, t) : void 0;\n          r && YR(() => {\n            var e;\n            return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, Dm.SUBSCRIBE_STATS, {\n              stream_id: n.uid,\n              stats: r\n            });\n          });\n        }\n        if (o.has(yg.AUDIO) && n.audioTrack) {\n          const t = n.audioTrack ? function (e, t, i, r) {\n            const n = t.audioRecv.find(t => t.ssrc === e);\n            if (!n) return null;\n            const o = {\n              id: MR(10, \"\"),\n              timestamp: new Date(t.timestamp).toISOString(),\n              mediaType: \"audio\",\n              type: \"ssrc\",\n              ssrc: n.ssrc.toString()\n            };\n            if (o.bytesReceived = n.bytes.toString(), o.packetsLost = n.packetsLost.toString(), o.packetsReceived = n.packets.toString(), n.outputLevel ? o.A_aol = Math.round(100 * n.outputLevel).toString() : o.A_aol = Math.round(100 * r._source.getAccurateVolumeLevel()).toString(), o.A_apol = Math.round(100 * r._source.getAccurateVolumeLevel()).toString(), r && (o.A_artd = r._originMediaStreamTrack.enabled && r._mediaStreamTrack.enabled ? \"0\" : \"1\"), o.A_jr = n.jitterMs.toString(), o.A_jbm = Math.floor(n.jitterBufferMs).toString(), o.A_cdm = Math.floor(n.jitterBufferMs).toString(), o.A_raps = cm[nv.getPlayerState(r.getTrackId())].toString(), i) {\n              const t = i.audioRecv.find(t => t.ssrc === e);\n              if (t) {\n                const e = n.concealedSamples - t.concealedSamples;\n                e > 0 && (o.A_cs = Math.round(e).toString());\n              }\n            }\n            return o;\n          }(n._audioSSRC, e, i, n.audioTrack) : void 0;\n          t && YR(() => {\n            var e;\n            return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, Dm.SUBSCRIBE_STATS, {\n              stream_id: n.uid,\n              stats: t\n            });\n          });\n        }\n      });\n    }\n    uploadSlowDownlinkStats(e) {}\n    uploadRelatedDownlinkStats(e, t) {\n      var i;\n      ((null === (i = this.requestRemoteMedia) || void 0 === i ? void 0 : i.call(this)) || []).forEach(i => {\n        let [r, n] = i;\n        if (n.has(yg.VIDEO) && r.videoTrack) {\n          var o;\n          const i = !0 === (r._videoSSRC && (null === (o = this.requestVideoIsReady) || void 0 === o ? void 0 : o.call(this, r._videoSSRC)) || !1),\n            n = function (e, t, i, r, n, o) {\n              const s = i.videoRecv.find(t => t.ssrc === e),\n                a = n ? n.videoRecv.find(t => t.ssrc === e) : void 0;\n              if (!s) return null;\n              const c = fR.isRemoteVideoFreeze(o, s, a) && t,\n                d = {\n                  mediaType: \"video\",\n                  isVideoMute: !1,\n                  peerId: r,\n                  frameRateReceived: s.receivedFrame && s.receivedFrame.frameRate.toString(),\n                  frameRateDecoded: s.decodedFrame && s.decodedFrame.frameRate.toString(),\n                  isFreeze: c,\n                  bytesReceived: s.bytes.toString(),\n                  packetsReceived: s.packets.toString(),\n                  packetsLost: s.packetsLost.toString(),\n                  qpSumPerFrame: Math.floor(s.qpSumPerFrame).toString()\n                };\n              return s.framesRateFirefox && (d.frameRateDecoded = s.framesRateFirefox.toString(), d.frameRateReceived = s.framesRateFirefox.toString()), d;\n            }(r._videoSSRC, i, e, r.uid, t, r.videoTrack);\n          n && YR(() => {\n            var e;\n            null === (e = this.requestUpload) || void 0 === e || e.call(this, Dm.SUBSCRIBE_RELATED_STATS, {\n              stream_id: r.uid,\n              stats: n\n            });\n          });\n        }\n        if (n.has(yg.AUDIO) && r.audioTrack) {\n          const t = function (e, t, i, r) {\n            const n = t.audioRecv.find(t => t.ssrc === e);\n            if (!n) return null;\n            const o = fR.isRemoteAudioFreeze(r);\n            return {\n              mediaType: \"audio\",\n              isAudioMute: !1,\n              peerId: i,\n              googJitterReceived: n.jitterMs.toString(),\n              isFreeze: o,\n              bytesReceived: n.bytes.toString(),\n              packetsReceived: n.packets.toString(),\n              packetsLost: n.packetsLost.toString(),\n              frameReceived: n.receivedFrames.toString(),\n              frameDropped: n.droppedFrames.toString()\n            };\n          }(r._audioSSRC, e, r.uid, r.audioTrack);\n          t && YR(() => {\n            var e;\n            null === (e = this.requestUpload) || void 0 === e || e.call(this, Dm.SUBSCRIBE_RELATED_STATS, {\n              stream_id: r.uid,\n              stats: t\n            });\n          });\n        }\n      });\n    }\n    stopUploadDownlinkStats() {\n      this.uploadDownlinkStarted && (this.uploadDownlinkStarted = !1, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0);\n    }\n    stopUploadTransportStats() {\n      this.uploadTransportStarted && (this.uploadTransportStarted = !1, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0);\n    }\n    stopUploadExtensionUsageStats() {\n      this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = !1, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0);\n    }\n    uploadDownlinkExtensionStats(e) {\n      e.forEach(e => {\n        let [t, i] = e;\n        if (i.has(yg.VIDEO) && t.videoTrack) {\n          t.videoTrack.getProcessorStats().forEach(e => {\n            var t;\n            null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats);\n          });\n        }\n        if (i.has(yg.AUDIO) && t.audioTrack) {\n          t.audioTrack.getProcessorStats().forEach(e => {\n            var t;\n            null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats);\n          });\n        }\n      });\n    }\n  }\n  const qP = \"v=0\\no=- 0 0 IN IP4 127.0.0.1\\ns=AgoraGateway\\nt=0 0\\na=group:BUNDLE 0\\na=msid-semantic: WMS\\na=ice-lite\\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\\nc=IN IP4 127.0.0.1\\na=mid:0\\n\",\n    JP = \"9\",\n    XP = 2e4,\n    zP = 4e4;\n  class QP {\n    get localCapabilities() {\n      return qR(this._localCapabilities);\n    }\n    get rtpCapabilities() {\n      return qR(this._rtpCapabilities);\n    }\n    get candidates() {\n      return qR(this._candidates);\n    }\n    get iceParameters() {\n      return qR(this._iceParameters);\n    }\n    get dtlsParameters() {\n      return qR(this._dtlsParameters);\n    }\n    constructor(e) {\n      mp(this, \"sessionDesc\", void 0), mp(this, \"_localCapabilities\", void 0), mp(this, \"_rtpCapabilities\", void 0), mp(this, \"_candidates\", void 0), mp(this, \"_iceParameters\", void 0), mp(this, \"_dtlsParameters\", void 0), mp(this, \"setup\", void 0), mp(this, \"currentMidIndex\", void 0), mp(this, \"cname\", void 0), mp(this, \"firefoxSsrcMidMap\", new Map()), e = qR(e);\n      const {\n          remoteIceParameters: t,\n          remoteDtlsParameters: i,\n          candidates: r,\n          remoteRTPCapabilities: n,\n          remoteSetup: o,\n          localCapabilities: s,\n          cname: a\n        } = e,\n        c = bD.exports.parse(qP);\n      this._rtpCapabilities = n, this._candidates = r, this._iceParameters = t, this._dtlsParameters = i, this._localCapabilities = s, this.setup = o, this.cname = a;\n      const d = this.rtpCapabilities.send;\n      for (const e of c.mediaDescriptions) {\n        if (e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = i.fingerprints, e.attributes.candidates = r, e.attributes.setup = o, \"application\" === e.media.mediaType && (e.attributes.sctpPort = \"5000\"), \"video\" === e.media.mediaType && (e.media.fmts = d.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.videoCodecs, e.attributes.extmaps = d.videoExtensions, HE(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const {\n            ssrcs: t,\n            ssrcGroups: i\n          } = MD([{\n            ssrcId: zP,\n            rtx: HE(\"USE_RTX\") ? 40001 : void 0\n          }], this.cname);\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n        if (\"audio\" === e.media.mediaType && (e.media.fmts = d.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = d.audioCodecs, e.attributes.extmaps = d.audioExtensions, KD(e), HE(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const {\n            ssrcs: t,\n            ssrcGroups: i\n          } = MD([{\n            ssrcId: XP\n          }], this.cname);\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n      }\n      this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1;\n    }\n    updateRemoteRTPCapabilities(e) {\n      const t = bD.exports.parse(qP);\n      this._rtpCapabilities = e;\n      const i = this.rtpCapabilities.send;\n      for (const e of t.mediaDescriptions) {\n        if (e.attributes.iceUfrag = this._iceParameters.iceUfrag, e.attributes.icePwd = this._iceParameters.icePwd, e.attributes.fingerprints = this._dtlsParameters.fingerprints, e.attributes.candidates = this._candidates, e.attributes.setup = this.setup, \"application\" === e.media.mediaType && (e.attributes.sctpPort = \"5000\"), \"video\" === e.media.mediaType && (e.media.fmts = i.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = i.videoCodecs, e.attributes.extmaps = i.videoExtensions, HE(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const {\n            ssrcs: t,\n            ssrcGroups: i\n          } = MD([{\n            ssrcId: zP,\n            rtx: HE(\"USE_RTX\") ? 40001 : void 0\n          }], this.cname);\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n        if (\"audio\" === e.media.mediaType && (e.media.fmts = i.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = i.audioCodecs, e.attributes.extmaps = i.audioExtensions, HE(\"PRELOAD_MEDIA_COUNT\") > 0)) {\n          const {\n            ssrcs: t,\n            ssrcGroups: i\n          } = MD([{\n            ssrcId: XP\n          }], this.cname);\n          e.attributes.ssrcs = t, e.attributes.ssrcGroups = i;\n        }\n      }\n      this.sessionDesc = t, this.currentMidIndex = t.mediaDescriptions.length - 1;\n    }\n    preloadRemoteMedia(e) {\n      this.rtpCapabilities;\n      const t = this.candidates,\n        i = this.dtlsParameters,\n        r = this.iceParameters,\n        n = this.rtpCapabilities.send;\n      for (let o = 1; o < e; o++) {\n        const e = 2 * o + XP,\n          s = 2 * o + zP,\n          {\n            ssrcs: a,\n            ssrcGroups: c\n          } = MD([{\n            ssrcId: e\n          }], this.cname),\n          {\n            ssrcs: d,\n            ssrcGroups: u\n          } = MD([{\n            ssrcId: s,\n            rtx: HE(\"USE_RTX\") ? s + 1 : void 0\n          }], this.cname);\n        this.sessionDesc.mediaDescriptions.push({\n          media: {\n            mediaType: \"video\",\n            port: JP,\n            protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n            fmts: n.videoCodecs.map(e => e.payloadType.toString(10))\n          },\n          connections: [{\n            nettype: \"IN\",\n            addrtype: \"IP4\",\n            address: \"127.0.0.1\"\n          }],\n          bandwidths: [],\n          attributes: {\n            iceUfrag: r.iceUfrag,\n            icePwd: r.icePwd,\n            unrecognized: [],\n            candidates: t,\n            extmaps: n.videoExtensions,\n            fingerprints: i.fingerprints,\n            imageattr: [],\n            msids: [],\n            remoteCandidatesList: [],\n            rids: [],\n            ssrcs: d,\n            ssrcGroups: u,\n            rtcpFeedbackWildcards: [],\n            payloads: n.videoCodecs,\n            rtcp: {\n              port: \"9\",\n              netType: \"IN\",\n              addressType: \"IP4\",\n              address: \"0.0.0.0\"\n            },\n            setup: this.setup,\n            direction: \"sendonly\",\n            rtcpMux: !0,\n            rtcpRsize: !0,\n            mid: \"\".concat(2 * o - 1)\n          }\n        }), this.sessionDesc.mediaDescriptions.push({\n          media: {\n            mediaType: \"audio\",\n            port: JP,\n            protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n            fmts: n.audioCodecs.map(e => e.payloadType.toString(10))\n          },\n          connections: [{\n            nettype: \"IN\",\n            addrtype: \"IP4\",\n            address: \"127.0.0.1\"\n          }],\n          bandwidths: [],\n          attributes: {\n            iceUfrag: r.iceUfrag,\n            icePwd: r.icePwd,\n            unrecognized: [],\n            candidates: t,\n            extmaps: n.audioExtensions,\n            fingerprints: i.fingerprints,\n            imageattr: [],\n            msids: [],\n            remoteCandidatesList: [],\n            rids: [],\n            ssrcs: a,\n            ssrcGroups: c,\n            rtcpFeedbackWildcards: [],\n            payloads: n.audioCodecs,\n            rtcp: {\n              port: \"9\",\n              netType: \"IN\",\n              addressType: \"IP4\",\n              address: \"0.0.0.0\"\n            },\n            setup: this.setup,\n            direction: \"sendonly\",\n            rtcpMux: !0,\n            rtcpRsize: !0,\n            mid: \"\".concat(2 * o)\n          }\n        }), this.currentMidIndex += 2;\n      }\n      this.updateBundleMids();\n    }\n    toString() {\n      return bD.exports.print(this.sessionDesc);\n    }\n    send(e, t, i, r) {\n      const {\n          ssrcs: n,\n          ssrcGroups: o\n        } = MD(t, this.cname, i),\n        s = this.findPreloadMediaDesc(n);\n      if (s) {\n        if (Qh() && this.firefoxSsrcMidMap.set(n[0].ssrcId, s.attributes.mid), r && (r.tcc || r.remb)) {\n          const e = this.sessionDesc.mediaDescriptions.indexOf(s);\n          return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, r), {\n            mid: s.attributes.mid,\n            needExchangeSDP: !0\n          };\n        }\n        return {\n          mid: s.attributes.mid,\n          needExchangeSDP: !1\n        };\n      }\n      {\n        const t = this.findAvailableMediaIndex(e, n);\n        let i;\n        return -1 === t || zh() || Zh() || $h() ? (i = this.createOrRecycleSendMedia(e, n, o, \"sendonly\", r), this.updateBundleMids()) : (i = qR(this.sessionDesc.mediaDescriptions[t]), i.attributes.direction = \"sendonly\", i.attributes.ssrcs = n, i.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(i, r)), Qh() && this.firefoxSsrcMidMap.set(n[0].ssrcId, i.attributes.mid), {\n          mid: i.attributes.mid,\n          needExchangeSDP: !0\n        };\n      }\n    }\n    batchSend(e) {\n      const t = e.map(e => {\n          let {\n            kind: t,\n            ssrcMsg: i,\n            mslabel: r\n          } = e;\n          return this.send(t, i, r);\n        }),\n        i = [];\n      let r = !1;\n      return t.forEach(e => {\n        let {\n          mid: t,\n          needExchangeSDP: n\n        } = e;\n        n && (r = !0), i.push(t);\n      }), {\n        mids: i,\n        needExchangeSDP: r\n      };\n    }\n    stopSending(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.\");\n      t.forEach(e => {\n        \"0\" === e.attributes.mid || Qh() || zh() || Zh() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = \"inactive\", e.media.port = \"0\");\n      }), this.updateBundleMids();\n    }\n    mute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.mute.\"));\n      t.attributes.direction = \"inactive\";\n    }\n    unmute(e) {\n      const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);\n      if (!t) throw new Error(\"mediaDescription not found with \".concat(e, \" in remote SDP when calling RemoteSDP.unmute.\"));\n      t.attributes.direction = \"sendonly\";\n    }\n    muteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"inactive\";\n      });\n    }\n    unmuteRemote(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || \"\"));\n      if (t.length !== e.length) throw new Error(\"mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.\");\n      t.forEach(e => {\n        e.attributes.direction = \"recvonly\";\n      });\n    }\n    receive(e, t, i, r) {\n      e.forEach((e, n) => {\n        this.createOrRecycleRecvMedia(e, [], \"recvonly\", t, i, r[n]);\n      }), this.updateBundleMids();\n    }\n    stopReceiving(e) {\n      const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));\n      if (t.length !== e.length) throw new Error(\"MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.\");\n      t.forEach(e => {\n        e.media.port = \"0\", e.attributes.direction = \"inactive\";\n      }), this.updateBundleMids();\n    }\n    restartICE(e) {\n      e = qR(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {\n        t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd;\n      });\n    }\n    predictReceivingMids(e) {\n      const t = [];\n      for (let i = 0; i < e; i++) t.push((this.currentMidIndex + i + 1).toString(10));\n      return t;\n    }\n    findAvailableMediaIndex(e, t) {\n      return this.sessionDesc.mediaDescriptions.findIndex(i => {\n        const r = i.media.mediaType === e && \"0\" !== i.media.port && (\"sendonly\" === i.attributes.direction || \"sendrecv\" === i.attributes.direction) && 0 === i.attributes.ssrcs.length;\n        if (Qh()) {\n          if (r) {\n            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);\n            return !(e || \"0\" !== i.attributes.mid && \"1\" !== i.attributes.mid) || !(!e || e !== i.attributes.mid);\n          }\n          return !1;\n        }\n        return r;\n      });\n    }\n    createOrRecycleRecvMedia(e, t, i, r, n, o) {\n      const s = e._mediaStreamTrack.kind,\n        a = this.rtpCapabilities.recv,\n        c = this.localCapabilities.send;\n      let d = [];\n      if (s === yg.VIDEO) {\n        var u, l;\n        if (HE(\"H264_PROFILE_LEVEL_ID\") && \"h264\" === r && (d = a.videoCodecs.filter(e => {\n          var t, i;\n          return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(r) && (null == e || null === (i = e.fmtp) || void 0 === i ? void 0 : i.parameters[\"profile-level-id\"]) === HE(\"H264_PROFILE_LEVEL_ID\");\n        })), !d || 0 === (null === (u = d) || void 0 === u ? void 0 : u.length)) {\n          const e = c.videoCodecs.filter(e => {\n            var t;\n            return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(r);\n          });\n          0 !== e.length && (d = a.videoCodecs.filter(t => e.some(e => e.payloadType === t.payloadType)));\n        }\n        if (HE(\"USE_RTX\")) {\n          const e = d.map(e => e.payloadType.toString()),\n            t = a.videoCodecs.filter(t => {\n              var i, r;\n              return \"rtx\" === (null === (i = t.rtpMap) || void 0 === i ? void 0 : i.encodingName) && e.includes((null === (r = t.fmtp) || void 0 === r ? void 0 : r.parameters.apt) || \"\");\n            });\n          d = [...d, ...t];\n        }\n        if (0 === d.length) NE.warning(\"codec \".concat(r, \" not included in rtpCapabilities, fallback to default payloads: \").concat(null === (l = a.videoCodecs[0].rtpMap) || void 0 === l ? void 0 : l.encodingName)), d = a.videoCodecs;\n      } else d = a.audioCodecs.filter(e => {\n        var t;\n        return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(n);\n      }), 0 === d.length && (NE.warning(\"codec \".concat(n, \" not included in rtpCapabilities, fallback to opus\")), d = a.audioCodecs.filter(e => {\n        var t;\n        return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || \"\").includes(\"opus\");\n      }));\n      const h = s === yg.VIDEO ? a.videoExtensions : a.audioExtensions;\n      this.currentMidIndex += 1;\n      const p = \"\".concat(this.currentMidIndex);\n      let _ = {\n        media: {\n          mediaType: s,\n          port: JP,\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: d.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: this.candidates,\n          extmaps: h,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: [],\n          rtcpFeedbackWildcards: [],\n          payloads: d,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: i,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(p)\n        }\n      };\n      _ = this.mungRecvMediaDsec(_, e, o);\n      const E = this.findFirstClosedMedia(s);\n      if (E) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(E);\n        this.sessionDesc.mediaDescriptions[e] = _;\n      } else this.sessionDesc.mediaDescriptions.push(_);\n      return _;\n    }\n    createOrRecycleSendMedia(e, t, i, r, n) {\n      const o = this.rtpCapabilities.send,\n        s = e === yg.VIDEO ? o.videoCodecs : o.audioCodecs,\n        a = e === yg.VIDEO ? o.videoExtensions : o.audioExtensions;\n      this.currentMidIndex += 1;\n      const c = \"\".concat(this.currentMidIndex);\n      let d = {\n        media: {\n          mediaType: e,\n          port: JP,\n          protos: [\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"],\n          fmts: s.map(e => e.payloadType.toString(10))\n        },\n        connections: [{\n          nettype: \"IN\",\n          addrtype: \"IP4\",\n          address: \"127.0.0.1\"\n        }],\n        bandwidths: [],\n        attributes: {\n          iceUfrag: this.iceParameters.iceUfrag,\n          icePwd: this.iceParameters.icePwd,\n          unrecognized: [],\n          candidates: this.candidates,\n          extmaps: a,\n          fingerprints: this.dtlsParameters.fingerprints,\n          imageattr: [],\n          msids: [],\n          remoteCandidatesList: [],\n          rids: [],\n          ssrcs: t,\n          ssrcGroups: i,\n          rtcpFeedbackWildcards: [],\n          payloads: s,\n          rtcp: {\n            port: \"9\",\n            netType: \"IN\",\n            addressType: \"IP4\",\n            address: \"0.0.0.0\"\n          },\n          setup: this.setup,\n          direction: r,\n          rtcpMux: !0,\n          rtcpRsize: !0,\n          mid: \"\".concat(c)\n        }\n      };\n      d = this.mungSendMediaDesc(d, n);\n      const u = this.findFirstClosedMedia(e);\n      if (u) {\n        const e = this.sessionDesc.mediaDescriptions.indexOf(u);\n        this.sessionDesc.mediaDescriptions[e] = d;\n      } else this.sessionDesc.mediaDescriptions.push(d);\n      return d;\n    }\n    updateBundleMids() {\n      this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => \"0\" !== e.media.port).map(e => e.attributes.mid);\n    }\n    mungRecvMediaDsec(e, t, i) {\n      const r = qR(e);\n      return xD(r), UD(r, t), VD(r, t), jD(r), FD(r, i, this.localCapabilities.send), r;\n    }\n    mungSendMediaDesc(e, t) {\n      const i = qR(e);\n      return FD(i, t, this.localCapabilities.recv), KD(i), i;\n    }\n    updateRecvMedia(e, t) {\n      const i = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);\n      if (-1 !== i) {\n        const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i], t);\n        this.sessionDesc.mediaDescriptions[i] = e;\n      }\n    }\n    bumpMid(e) {\n      this.currentMidIndex += e;\n    }\n    findFirstClosedMedia(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => Qh() ? \"0\" === t.media.port && t.media.mediaType === e : \"0\" === t.media.port);\n    }\n    findPreloadMediaDesc(e) {\n      return this.sessionDesc.mediaDescriptions.find(t => {\n        var i, r;\n        return (null === (i = t.attributes) || void 0 === i || null === (r = i.ssrcs[0]) || void 0 === r ? void 0 : r.ssrcId) === e[0].ssrcId;\n      });\n    }\n    getSSRC(e) {\n      var t;\n      return null === (t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === t ? void 0 : t.attributes.ssrcs;\n    }\n  }\n  var ZP;\n  function $P(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function eL(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? $P(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : $P(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let tL = (ZS((ZP = class e extends xg {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    constructor(e, t, i) {\n      super(e, t), mp(this, \"store\", void 0), mp(this, \"peerConnection\", void 0), mp(this, \"remoteSDP\", void 0), mp(this, \"initialOffer\", void 0), mp(this, \"transportEventReceiver\", void 0), mp(this, \"statsFilter\", void 0), mp(this, \"useRTX\", HE(\"USE_RTX\")), mp(this, \"localCapabilities\", void 0), mp(this, \"localCandidateCount\", 0), mp(this, \"allCandidatesReceived\", !1), mp(this, \"mutex\", new OT(\"NVExtentionsConnection-mutex\")), mp(this, \"rtcMedia\", void 0), this.store = t, this.peerConnection = i, this.statsFilter = pP(this.peerConnection, void 0, void 0, Qh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1;\n    }\n    async establish(e) {\n      try {\n        const e = await this.peerConnection.createOffer();\n        if (!e.sdp) throw new Error(\"Cannot get initialOffer.sdp when trying to establish PeerConnection.\");\n        const t = PD(e.sdp),\n          i = await GD(!this.useRTX, HE(\"FILTER_VIDEO_FEC\"), HE(\"FILTER_AUDIO_FEC\"));\n        return this.localCapabilities = i, this.initialOffer = e, eL(eL({}, t), {}, {\n          rtpCapabilities: i,\n          offerSDP: e.sdp\n        });\n      } catch (e) {\n        throw new vE(TE.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString());\n      }\n    }\n    async connect(e, t, i, r, n, o) {\n      try {\n        if (!this.initialOffer) throw new Error(\"Cannot establish NVConnection without initial offer.\");\n        this.remoteSDP = new QP({\n          remoteIceParameters: e,\n          remoteDtlsParameters: t,\n          candidates: i,\n          remoteRTPCapabilities: r,\n          remoteSetup: n,\n          localCapabilities: HD(this.localCapabilities),\n          cname: o\n        });\n        const s = this.remoteSDP.toString(),\n          a = bD.exports.parse(this.initialOffer.sdp),\n          c = a.mediaDescriptions.find(e => \"audio\" === e.media.mediaType);\n        c && KD(c);\n        const d = bD.exports.print(a),\n          u = this.logSDPExchange(d || \"\", \"offer\", \"local\", \"connect\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: d\n        }), null == u || u(s), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: s\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NV.connect failed; \".concat(e.toString()));\n      }\n    }\n    async updateRemoteConnect(e) {\n      var t, i, r;\n      null === (t = this.remoteSDP) || void 0 === t || t.updateRemoteRTPCapabilities(e), null === (i = this.remoteSDP) || void 0 === i || i.preloadRemoteMedia(2);\n      const n = null === (r = this.remoteSDP) || void 0 === r ? void 0 : r.toString();\n      await this.peerConnection.setRemoteDescription({\n        type: \"offer\",\n        sdp: n\n      });\n      const o = await this.peerConnection.createAnswer();\n      await this.peerConnection.setLocalDescription(o), NE.debug(\"[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.\");\n    }\n    send(e, t, i) {\n      var r = this;\n      return ID(function* () {\n        const n = yield yD(r.mutex.lock(\"From NVExtentionsConnection.send\"));\n        try {\n          if (!r.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.send before remote SDP created\");\n          const o = [];\n          e.forEach(e => {\n            const t = r.peerConnection.addTransceiver(e._mediaStreamTrack, {\n              direction: \"sendonly\"\n            });\n            o.push(t);\n          }), Qh() && !0 === HE(\"SIMULCAST\") && (yield yD(r.applySimulcastForFirefox(o, e)));\n          const s = yield yD(r.peerConnection.createOffer()),\n            a = r.remoteSDP.predictReceivingMids(e.length),\n            c = r.mungSendOfferSDP(s.sdp, e, a),\n            d = bD.exports.parse(c),\n            u = a.map(e => {\n              const t = d.mediaDescriptions.find(t => t.attributes.mid === e);\n              if (!t) throw new Error(\"Cannot extract ssrc from mediaDescription.\");\n              return LD(t, r.useRTX);\n            });\n          let l;\n          try {\n            l = yield u;\n          } catch (n) {\n            l = [], r.remoteSDP.receive(e, t, i, l);\n            const o = r.remoteSDP.toString();\n            throw yield yD(r.peerConnection.setLocalDescription({\n              type: \"offer\",\n              sdp: c\n            })), yield yD(r.peerConnection.setRemoteDescription({\n              type: \"answer\",\n              sdp: o\n            })), yield yD(r.stopSending(a, !0)), n;\n          }\n          r.remoteSDP.receive(e, t, i, l);\n          const h = r.remoteSDP.toString(),\n            p = r.logSDPExchange(c, \"offer\", \"local\", \"send\");\n          return yield yD(r.peerConnection.setLocalDescription({\n            type: \"offer\",\n            sdp: c\n          })), yield yD(r.applySimulcastEncodings(o, e)), yield yD(r.applySendEncodings(o, e)), null == p || p(h), yield yD(r.peerConnection.setRemoteDescription({\n            type: \"answer\",\n            sdp: h\n          })), o.map((e, t) => {\n            const i = a[t];\n            return {\n              localSSRC: u[t],\n              id: i,\n              transceiver: e\n            };\n          });\n        } catch (e) {\n          throw e instanceof vE ? e : new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.send failed; \".concat(e.toString()));\n        } finally {\n          n();\n        }\n      })();\n    }\n    async stopSending(e, t) {\n      const i = t ? void 0 : await this.mutex.lock(\"From NVExtentionsConnection.stopSending\");\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.stopSending before remote SDP created\");\n        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.\");\n        t.map(e => {\n          var t;\n          e.direction = \"inactive\", null === (t = e.stop) || void 0 === t || t.call(e);\n        });\n        const r = await this.peerConnection.createOffer(),\n          n = this.logSDPExchange(r.sdp || \"\", \"offer\", \"local\", \"stopSending\");\n        await this.peerConnection.setLocalDescription(r), this.remoteSDP.stopReceiving(e);\n        const o = this.remoteSDP.toString();\n        null == n || n(o), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: o\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.stopSending failed; \".concat(e.toString()));\n      } finally {\n        i && i();\n      }\n    }\n    async receive(e, t, i, r) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.receive \".concat(e, \" before remoteSDP created.\"));\n        const {\n          mid: n,\n          needExchangeSDP: o\n        } = this.remoteSDP.send(e, t, i, r);\n        if (o) {\n          const t = this.remoteSDP.toString(),\n            i = this.logSDPExchange(t, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: t\n          });\n          const r = await this.peerConnection.createAnswer(),\n            o = this.mungReceiveAnswerSDP(r.sdp, n, e);\n          null == i || i(o || \"\"), await this.peerConnection.setLocalDescription({\n            type: \"answer\",\n            sdp: o\n          }), NE.debug(\"[NVExtentionsConnection] receive \".concat(e, \" by exchanging SDP.\"));\n        } else NE.debug(\"[NVExtentionsConnection] receive \".concat(e, \" no need to exchange SDP.\"));\n        const s = this.peerConnection.getTransceivers().find(e => e.mid === n);\n        if (!s) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n        return {\n          track: s.receiver.track,\n          id: n\n        };\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async batchReceive(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.\");\n        const {\n          mids: t,\n          needExchangeSDP: i\n        } = this.remoteSDP.batchSend(e);\n        if (i) {\n          const e = this.remoteSDP.toString(),\n            t = this.logSDPExchange(e, \"offer\", \"remote\", \"receive\");\n          await this.peerConnection.setRemoteDescription({\n            type: \"offer\",\n            sdp: e\n          });\n          const i = await this.peerConnection.createAnswer();\n          null == t || t(i.sdp || \"\"), await this.peerConnection.setLocalDescription(i), NE.debug(\"[NVExtentionsConnection] batchReceive by exchanging SDP.\");\n        } else NE.debug(\"[NVExtentionsConnection] batchReceive no need to exchange SDP.\");\n        return t.map(e => {\n          const t = this.peerConnection.getTransceivers().find(t => t.mid === e);\n          if (!t) throw new Error(\"Cannot get transceiver after setLocalDescription.\");\n          return {\n            track: t.receiver.track,\n            id: e\n          };\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.receive failed; \".concat(e.toString()));\n      }\n    }\n    async stopReceiving(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.\");\n        this.remoteSDP.stopSending(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"stopReceiving\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const r = await this.peerConnection.createAnswer();\n        null == i || i(r.sdp || \"\"), await this.peerConnection.setLocalDescription(r);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection stopReceiving failed; \".concat(e.toString()));\n      }\n    }\n    async muteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.muteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.mute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"muteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const r = await this.peerConnection.createAnswer();\n        null == i || i(r.sdp || \"\"), await this.peerConnection.setLocalDescription(r);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.muteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteRemote(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.unmuteRemote mid=\".concat(e, \" before remote SDP created.\"));\n        this.remoteSDP.unmute(e);\n        const t = this.remoteSDP.toString(),\n          i = this.logSDPExchange(t, \"offer\", \"remote\", \"unmuteRemote\");\n        await this.peerConnection.setRemoteDescription({\n          type: \"offer\",\n          sdp: t\n        });\n        const r = await this.peerConnection.createAnswer();\n        null == i || i(r.sdp || \"\"), await this.peerConnection.setLocalDescription(r);\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.unmuteRemote failed; \".concat(e.toString()));\n      }\n    }\n    async muteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.muteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(e => {\n          e.direction = \"inactive\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"muteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.muteRemote(e);\n        const n = this.remoteSDP.toString();\n        null == r || r(n), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.muteLocal failed; \".concat(e.toString()));\n      }\n    }\n    async unmuteLocal(e) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.\");\n        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));\n        if (t.length !== e.length) throw new Error(\"Transceivers' length doesn't match mids' length.\");\n        t.map(async (e, t) => {\n          e.direction = \"sendonly\";\n        });\n        const i = await this.peerConnection.createOffer(),\n          r = this.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"unmuteLocal\");\n        await this.peerConnection.setLocalDescription(i), this.remoteSDP.unmuteRemote(e);\n        const n = this.remoteSDP.toString();\n        null == r || r(n), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, \"NVExtentionsConnection.unmuteLocal failed; \".concat(e.toString()));\n      }\n    }\n    restartICE() {\n      var e = this;\n      return ID(function* () {\n        const t = yield yD(e.mutex.lock(\"From NVExtentionsConnection.restartICE\"));\n        try {\n          const i = yield yD(e.peerConnection.createOffer({\n            iceRestart: !0\n          }));\n          if (!i.sdp) throw new Error(\"Cannot restartICE because restart offer SDP does not exist.\");\n          const r = PD(i.sdp),\n            {\n              remoteIceParameters: n\n            } = yield r.iceParameters;\n          if (!e.remoteSDP) throw new Error(\"Cannot restartICE before remoteSDP created.\");\n          e.remoteSDP.restartICE(n);\n          const o = e.remoteSDP.toString(),\n            s = e.logSDPExchange(i.sdp || \"\", \"offer\", \"local\", \"restartICE\");\n          yield yD(e.peerConnection.setLocalDescription(i)), null == s || s(o), yield yD(e.peerConnection.setRemoteDescription({\n            type: \"answer\",\n            sdp: o\n          }));\n        } catch (e) {\n          NE.warning(\"restart ICE failed, abort operation\", e);\n        } finally {\n          t();\n        }\n      })();\n    }\n    close() {\n      var e;\n      null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, \"closed\"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy();\n    }\n    getStats() {\n      return this.statsFilter.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this.statsFilter.getVideoIsReady(e);\n    }\n    async updateEncoderConfig(e, t) {\n      try {\n        if (!this.remoteSDP) throw new Error(\"Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.\");\n        const i = await this.peerConnection.createOffer(),\n          r = this.mungSendOfferSDP(i.sdp, [t], [e]);\n        this.remoteSDP.updateRecvMedia(e, t);\n        const n = this.remoteSDP.toString(),\n          o = this.logSDPExchange(r, \"offer\", \"local\", \"updateEncoderConfig\");\n        await this.peerConnection.setLocalDescription({\n          type: \"offer\",\n          sdp: r\n        }), null == o || o(n), await this.peerConnection.setRemoteDescription({\n          type: \"answer\",\n          sdp: n\n        });\n      } catch (e) {\n        throw new vE(TE.EXCHANGE_SDP_FAILED, e.toString());\n      }\n    }\n    async updateSendParameters(e, t) {\n      const i = this.peerConnection.getTransceivers().filter(t => t.mid === e);\n      1 === i.length && (this.isVP8Simulcast(t) ? Qh() || (await this.applySimulcastEncodings(i, [t])) : await this.applySendEncodings(i, [t]));\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this.statsFilter.setVideoIsReady2(e, t);\n    }\n    async replaceTrack(e, t) {\n      const i = this.peerConnection.getTransceivers().find(e => e.mid === t);\n      i && (await i.sender.replaceTrack(e._mediaStreamTrack));\n    }\n    getP2PConnectionParams() {\n      var e;\n      if (null === (e = this.peerConnection.currentLocalDescription) || void 0 === e || !e.sdp || !this.localCapabilities) throw new Error();\n      return eL(eL({}, PD(this.peerConnection.currentLocalDescription.sdp)), {}, {\n        rtpCapabilities: this.localCapabilities\n      });\n    }\n    bindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = () => {\n        var e;\n        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState);\n      }, this.peerConnection.onconnectionstatechange = () => {\n        var e;\n        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState);\n      }, this.peerConnection.onicecandidate = e => {\n        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, NE.debug(\"[pc-\".concat(this.store.p2pId, \"] local candidate count\"), this.localCandidateCount));\n      }, setTimeout(() => {\n        this.allCandidatesReceived || (this.allCandidatesReceived = !0, NE.debug(\"[pc-\".concat(this.store.p2pId, \"] onicecandidate timeout, local candidate count\"), this.localCandidateCount));\n      }, HE(\"CANDIDATE_TIMEOUT\"));\n    }\n    unbindPCEvents() {\n      this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: []\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (xm(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), HE(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), HE(\"FORCE_TURN_TCP\") ? i.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(TR(e.turnServerURL), \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && !HE(\"FORCE_TURN_TCP\") && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    async applySendEncodings(e, t) {\n      try {\n        if (!jg().supportSetRtpSenderParameters) return;\n        if (e.length !== t.length) return;\n        for (let c = 0; c < e.length; c++) {\n          const d = e[c],\n            u = t[c];\n          if (u && u instanceof Ew) {\n            var i, r;\n            if (this.isVP8Simulcast(u)) continue;\n            const e = {},\n              t = {};\n            switch (u._optimizationMode) {\n              case \"motion\":\n                e.degradationPreference = \"maintain-framerate\";\n                break;\n              case \"detail\":\n                e.degradationPreference = \"maintain-resolution\";\n                break;\n              default:\n                e.degradationPreference = \"balanced\";\n            }\n            var n, o, s, a;\n            if (null !== (i = u._encoderConfig) && void 0 !== i && i.bitrateMax) t.maxBitrate = 1e3 * (null === (n = u._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax);\n            if (u._hints.includes(lg.LOW_STREAM)) null !== (o = u._encoderConfig) && void 0 !== o && o.frameRate && (t.maxFramerate = RR(u._encoderConfig.frameRate)), null !== (s = u._encoderConfig) && void 0 !== s && s.scaleResolutionDownBy && (null === (a = u._encoderConfig) || void 0 === a ? void 0 : a.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = u._encoderConfig.scaleResolutionDownBy);\n            if (HE(\"DSCP_TYPE\") && ap()) {\n              const e = HE(\"DSCP_TYPE\");\n              [\"very-low\", \"low\", \"medium\", \"high\"].includes(e) && (t.networkPriority = e);\n            }\n            const c = d.sender.getParameters(),\n              l = null === (r = c.encodings) || void 0 === r ? void 0 : r[0];\n            Qh() && !l && (e.encodings = [t]), l && Object.assign(l, t), Object.assign(c, e), await d.sender.setParameters(c);\n          }\n        }\n      } catch (e) {\n        NE.debug(\"Apply RTPSendEncodings failed.\");\n      }\n    }\n    mungSendOfferSDP(e, t, i) {\n      const r = bD.exports.parse(e);\n      return t.forEach((e, t) => {\n        const n = i[t],\n          o = r.mediaDescriptions.find(e => e.attributes.mid === n);\n        o && (UD(o, e), BD(o, e, this.store.codec));\n      }), bD.exports.print(r);\n    }\n    mungReceiveAnswerSDP(e, t, i) {\n      const r = bD.exports.parse(e),\n        n = r.mediaDescriptions.find(e => e.attributes.mid === t);\n      return n && i === yg.AUDIO && \"audio\" === n.media.mediaType && KD(n), bD.exports.print(r);\n    }\n    bindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = e => {\n        var t;\n        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoReceived = e => {\n        var t;\n        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstAudioDecoded = e => {\n        var t;\n        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e);\n      }, this.statsFilter.onFirstVideoDecoded = (e, t, i) => {\n        var r;\n        null === (r = this.onFirstVideoDecoded) || void 0 === r || r.call(this, e, t, i);\n      }, this.statsFilter.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i || i.call(this, e, t);\n      }, this.statsFilter.onFirstVideoDecodedTimeout = e => {\n        var t;\n        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e);\n      };\n    }\n    unbindStatsEvents() {\n      this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0;\n    }\n    async applySimulcastForFirefox(e, t) {\n      if (e.length === t.length) for (let s = 0; s < e.length; s++) {\n        var i, r, n, o;\n        const a = e[s],\n          c = t[s];\n        if (c instanceof Ew && !c._hints.includes(lg.LOW_STREAM) && null !== (i = c._encoderConfig) && void 0 !== i && i.bitrateMax && (null === (r = c._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (n = c._scalabiltyMode) && void 0 !== n && n.numSpatialLayers && (null === (o = c._scalabiltyMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1 && \"vp8\" === this.store.codec) {\n          const e = {},\n            t = {\n              high: 1e3 * (c._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          e.encodings = [{\n            rid: \"m\",\n            active: !0,\n            maxBitrate: t.medium,\n            scaleResolutionDownBy: 4\n          }, {\n            rid: \"h\",\n            active: !0,\n            maxBitrate: t.high\n          }];\n          const i = a.sender.getParameters();\n          await a.sender.setParameters(Object.assign(i, e));\n        }\n      }\n    }\n    async applySimulcastEncodings(e, t) {\n      if (!Qh() && e.length === t.length) for (let i = 0; i < e.length; i++) {\n        const r = t[i];\n        if (r instanceof Ew && this.isVP8Simulcast(r)) {\n          const t = e[i],\n            n = {},\n            o = {\n              high: 1e3 * (r._encoderConfig.bitrateMax - 50),\n              medium: 5e4\n            };\n          n.encodings = [{\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"high\",\n            priority: \"high\",\n            maxBitrate: o.high\n          }, {\n            active: !0,\n            adaptivePtime: !1,\n            networkPriority: \"low\",\n            priority: \"low\",\n            maxBitrate: o.medium,\n            scaleResolutionDownBy: 4\n          }];\n          const s = t.sender.getParameters();\n          await t.sender.setParameters(Object.assign(s, n));\n        }\n      }\n    }\n    isVP8Simulcast(e) {\n      var t, i, r, n;\n      return !!(e instanceof Ew && HE(\"SIMULCAST\") && \"vp8\" === this.store.codec && !e._hints.includes(lg.LOW_STREAM) && null !== (t = e._encoderConfig) && void 0 !== t && t.bitrateMax && (null === (i = e._encoderConfig) || void 0 === i ? void 0 : i.bitrateMax) > 200 && null !== (r = e._scalabiltyMode) && void 0 !== r && r.numSpatialLayers && (null === (n = e._scalabiltyMode) || void 0 === n ? void 0 : n.numSpatialLayers) > 1);\n    }\n    logSDPExchange(e, t, i, r) {\n      if (HE(\"SDP_LOGGING\")) return NE.upload(\"exchanging \".concat(i, \" \").concat(t, \" SDP during NVExtentionsConnection.\").concat(r, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", r);\n      } : void 0;\n    }\n    async getRemoteSSRC(e) {\n      if (!this.remoteSDP) return;\n      const t = this.remoteSDP.getSSRC(e);\n      return null == t ? void 0 : t[0].ssrcId;\n    }\n  }).prototype, \"connect\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"connect\"), ZP.prototype), ZS(ZP.prototype, \"updateRemoteConnect\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"updateRemoteConnect\"), ZP.prototype), ZS(ZP.prototype, \"receive\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"receive\"), ZP.prototype), ZS(ZP.prototype, \"batchReceive\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"batchReceive\"), ZP.prototype), ZS(ZP.prototype, \"stopReceiving\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"stopReceiving\"), ZP.prototype), ZS(ZP.prototype, \"muteRemote\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"muteRemote\"), ZP.prototype), ZS(ZP.prototype, \"unmuteRemote\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"unmuteRemote\"), ZP.prototype), ZS(ZP.prototype, \"muteLocal\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"muteLocal\"), ZP.prototype), ZS(ZP.prototype, \"unmuteLocal\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"unmuteLocal\"), ZP.prototype), ZS(ZP.prototype, \"close\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"close\"), ZP.prototype), ZS(ZP.prototype, \"updateEncoderConfig\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"updateEncoderConfig\"), ZP.prototype), ZS(ZP.prototype, \"updateSendParameters\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"updateSendParameters\"), ZP.prototype), ZS(ZP.prototype, \"replaceTrack\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"replaceTrack\"), ZP.prototype), ZS(ZP.prototype, \"getRemoteSSRC\", [iL], Object.getOwnPropertyDescriptor(ZP.prototype, \"getRemoteSSRC\"), ZP.prototype), ZP);\n  function iL(e, t, i) {\n    const r = e[t];\n    if (\"function\" != typeof r) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From NVExtentionsConnection.\".concat(t));\n      try {\n        for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];\n        return await r.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  var rL;\n  function nL(e) {\n    var t,\n      i,\n      r,\n      n = 2;\n    for (\"undefined\" != typeof Symbol && (i = OD, r = Symbol.iterator); n--;) {\n      if (i && null != (t = e[i])) return t.call(e);\n      if (r && null != (t = e[r])) return new oL(t.call(e));\n      i = \"@@asyncIterator\", r = \"@@iterator\";\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n  function oL(e) {\n    function t(e) {\n      if (Object(e) !== e) return Cl.reject(new TypeError(e + \" is not an object.\"));\n      var t = e.done;\n      return Cl.resolve(e.value).then(function (e) {\n        return {\n          value: e,\n          done: t\n        };\n      });\n    }\n    return (oL = function (e) {\n      this.s = e, this.n = e.next;\n    }).prototype = {\n      s: null,\n      n: null,\n      next: function () {\n        return t(this.n.apply(this.s, arguments));\n      },\n      return: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Cl.resolve({\n          value: e,\n          done: !0\n        }) : t(i.apply(this.s, arguments));\n      },\n      throw: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Cl.reject(e) : t(i.apply(this.s, arguments));\n      }\n    }, new oL(e);\n  }\n  let sL = (ZS((rL = class e extends xg {\n    get currentLocalDescription() {\n      return this.peerConnection.currentLocalDescription;\n    }\n    get currentRemoteDescription() {\n      return this.peerConnection.currentRemoteDescription;\n    }\n    get peerConnectionState() {\n      return this.peerConnection.connectionState;\n    }\n    get iceConnectionState() {\n      return this.peerConnection.iceConnectionState;\n    }\n    constructor(t, i) {\n      super(t, i), mp(this, \"store\", void 0), mp(this, \"peerConnection\", void 0), mp(this, \"cname\", void 0), mp(this, \"mutex\", new OT(\"DataChannelConnection-mutex\")), mp(this, \"dataChannel\", void 0), mp(this, \"_p2pConnection\", void 0), mp(this, \"_nvMedia\", void 0), this.store = i, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {\n        optional: [{\n          googDscp: !0\n        }]\n      }), this.dataChannel = this.peerConnection.createDataChannel(\"agora-signal\", {\n        ordered: !1,\n        maxPacketLifeTime: 50\n      }), this.dataChannel.binaryType = \"arraybuffer\", this._p2pConnection = new tL(t, i, this.peerConnection), this.bindPCEvents();\n    }\n    async establish() {\n      var e;\n      const t = null === (e = this._nvMedia) || void 0 === e ? void 0 : e.getLocalRtpCapabilities();\n      return await this._p2pConnection.establish(t);\n    }\n    getP2PConnectionParams() {\n      return this._p2pConnection.getP2PConnectionParams();\n    }\n    async connect(e, t, i, r, n, o) {\n      return this.cname = o, await this._p2pConnection.connect(e, t, i, r, n, o), await new Cl((e, t) => {\n        const r = setTimeout(() => {\n          this.closeSignal(), t(new vE(TE.DATACHANNEL_CONNECTION_TIMEOUT, \"Datachannel connection timed out, candidates: \".concat(JSON.stringify(i))));\n        }, 2e3);\n        this.dataChannel.onopen = () => {\n          if (\"open\" === this.dataChannel.readyState) return clearTimeout(r), void e();\n        }, this.dataChannel.onerror = e => {\n          this.closeSignal(), t(e);\n        };\n      }), {\n        transmitter: this.dataChannel,\n        close: this.closeSignal.bind(this)\n      };\n    }\n    send(e, t, i) {\n      var r = this;\n      return ID(function* () {\n        const n = yield yD(r.mutex.lock(\"From DataChannelConnection.send\"));\n        try {\n          return yield* AD(nL(r._p2pConnection.send(e, t, i)), yD);\n        } finally {\n          n();\n        }\n      })();\n    }\n    async stopSending(e, t) {\n      return this._p2pConnection.stopSending(e, t);\n    }\n    async receive(e, t, i, r) {\n      return this._nvMedia ? (NE.debug(\"[DataChannelConnection] receive \".concat(e, \" by DataChannel.\")), await this._nvMedia.reveiveByRTCMedia(e, t, this.cname)) : (NE.debug(\"[DataChannelConnection] receive \".concat(e, \" by WebRTC.\")), await this._p2pConnection.receive(e, t, i, r));\n    }\n    async batchReceive(e) {\n      return [...(await this._p2pConnection.batchReceive(e))];\n    }\n    async stopReceiving(e) {\n      return await this._p2pConnection.stopReceiving(e);\n    }\n    async muteRemote(e) {\n      return await this._p2pConnection.muteRemote(e);\n    }\n    async unmuteRemote(e) {\n      return await this._p2pConnection.unmuteRemote(e);\n    }\n    async muteLocal(e) {\n      return await this._p2pConnection.muteLocal(e);\n    }\n    async unmuteLocal(e) {\n      return await this._p2pConnection.unmuteLocal(e);\n    }\n    restartICE() {\n      var e = this;\n      return ID(function* () {\n        return yield* AD(nL(e._p2pConnection.restartICE()), yD);\n      })();\n    }\n    close() {\n      var e;\n      null === (e = this._nvMedia) || void 0 === e || e.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection);\n    }\n    getStats() {\n      return this._p2pConnection.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      return this._p2pConnection.getRemoteVideoIsReady(e);\n    }\n    updateRemoteConnect(e) {\n      var t;\n      null === (t = this._nvMedia) || void 0 === t || t.setRemoteRtpCapabilities(e), this._p2pConnection.updateRemoteConnect(e);\n    }\n    async updateEncoderConfig(e, t) {\n      return await this._p2pConnection.updateEncoderConfig(e, t);\n    }\n    async updateSendParameters(e, t) {\n      return await this._p2pConnection.updateSendParameters(e, t);\n    }\n    setStatsRemoteVideoIsReady(e, t) {\n      this._p2pConnection.setStatsRemoteVideoIsReady(e, t);\n    }\n    async replaceTrack(e, t) {\n      return await this._p2pConnection.replaceTrack(e, t);\n    }\n    async getRemoteSSRC(e) {\n      return this._p2pConnection.getRemoteSSRC(e);\n    }\n    logSDPExchange(e, t, i, r) {\n      if (HE(\"SDP_LOGGING\")) return NE.upload(\"exchanging \".concat(i, \" \").concat(t, \" SDP during DataChannelConnection.\").concat(r, \"\\n\"), e), \"offer\" === t ? e => {\n        this.logSDPExchange(e, \"answer\", \"local\" === i ? \"remote\" : \"local\", r);\n      } : void 0;\n    }\n    static resolvePCConfiguration(t) {\n      const i = {\n        iceServers: []\n      };\n      return t.iceServers ? i.iceServers = t.iceServers : t.turnServer && \"off\" !== t.turnServer.mode && (xm(t.turnServer.servers) ? i.iceServers = t.turnServer.servers : (i.iceServers && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), HE(\"USE_TURN_SERVER_OF_GATEWAY\") && i.iceServers && t.turnServer.serversFromGateway && i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), HE(\"FORCE_TURN_TCP\") ? i.iceTransportPolicy = \"relay\" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {\n        e.forceturn && (i.iceTransportPolicy = \"relay\");\n      }))), i;\n    }\n    static turnServerConfigToIceServers(e) {\n      const t = [];\n      return e.forEach(e => {\n        e.security ? e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turns:\".concat(TR(e.turnServerURL), \":\").concat(e.tcpport, \"?transport=tcp\")\n        }) : (e.udpport && !HE(\"FORCE_TURN_TCP\") && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.udpport, \"?transport=udp\")\n        }), e.tcpport && t.push({\n          username: e.username,\n          credential: e.password,\n          credentialType: \"password\",\n          urls: \"turn:\".concat(e.turnServerURL, \":\").concat(e.tcpport, \"?transport=tcp\")\n        }));\n      }), t;\n    }\n    bindPCEvents() {\n      this._p2pConnection.onICEConnectionStateChange = e => {\n        var t;\n        return null === (t = this.onICEConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onConnectionStateChange = e => {\n        var t;\n        return null === (t = this.onConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onDTLSTransportStateChange = e => {\n        var t;\n        return null === (t = this.onDTLSTransportStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onDTLSTransportError = e => {\n        var t;\n        return null === (t = this.onDTLSTransportError) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onICETransportStateChange = e => {\n        var t;\n        return null === (t = this.onICETransportStateChange) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstAudioReceived = e => {\n        var t;\n        return null === (t = this.onFirstAudioReceived) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstVideoReceived = e => {\n        var t;\n        return null === (t = this.onFirstVideoReceived) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstAudioDecoded = e => {\n        var t;\n        return null === (t = this.onFirstAudioDecoded) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onFirstVideoDecoded = (e, t, i) => {\n        var r;\n        return null === (r = this.onFirstVideoDecoded) || void 0 === r ? void 0 : r.call(this, e, t, i);\n      }, this._p2pConnection.onFirstVideoDecodedTimeout = e => {\n        var t;\n        return null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t ? void 0 : t.call(this, e);\n      }, this._p2pConnection.onSelectedLocalCandidateChanged = (e, t) => {\n        var i;\n        return null === (i = this.onSelectedLocalCandidateChanged) || void 0 === i ? void 0 : i.call(this, e, t);\n      }, this._p2pConnection.onSelectedRemoteCandidateChanged = (e, t) => {\n        var i;\n        return null === (i = this.onSelectedRemoteCandidateChanged) || void 0 === i ? void 0 : i.call(this, e, t);\n      };\n    }\n    closeSignal() {\n      this.dataChannel.close(), this.peerConnection.close();\n    }\n    unbindConnectionEvents(e) {\n      e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0;\n    }\n  }).prototype, \"connect\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"connect\"), rL.prototype), ZS(rL.prototype, \"receive\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"receive\"), rL.prototype), ZS(rL.prototype, \"stopReceiving\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"stopReceiving\"), rL.prototype), ZS(rL.prototype, \"muteRemote\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"muteRemote\"), rL.prototype), ZS(rL.prototype, \"unmuteRemote\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"unmuteRemote\"), rL.prototype), ZS(rL.prototype, \"muteLocal\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"muteLocal\"), rL.prototype), ZS(rL.prototype, \"unmuteLocal\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"unmuteLocal\"), rL.prototype), ZS(rL.prototype, \"close\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"close\"), rL.prototype), ZS(rL.prototype, \"updateEncoderConfig\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"updateEncoderConfig\"), rL.prototype), ZS(rL.prototype, \"updateSendParameters\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"updateSendParameters\"), rL.prototype), ZS(rL.prototype, \"replaceTrack\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"replaceTrack\"), rL.prototype), ZS(rL.prototype, \"getRemoteSSRC\", [aL], Object.getOwnPropertyDescriptor(rL.prototype, \"getRemoteSSRC\"), rL.prototype), rL);\n  function aL(e, t, i) {\n    const r = e[t];\n    if (\"function\" != typeof r) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From DataChannelConnection.\".concat(t));\n      try {\n        for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];\n        return await r.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  var cL;\n  function dL(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function uL(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? dL(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : dL(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function lL(e) {\n    var t,\n      i,\n      r,\n      n = 2;\n    for (\"undefined\" != typeof Symbol && (i = OD, r = Symbol.iterator); n--;) {\n      if (i && null != (t = e[i])) return t.call(e);\n      if (r && null != (t = e[r])) return new hL(t.call(e));\n      i = \"@@asyncIterator\", r = \"@@iterator\";\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n  function hL(e) {\n    function t(e) {\n      if (Object(e) !== e) return Cl.reject(new TypeError(e + \" is not an object.\"));\n      var t = e.done;\n      return Cl.resolve(e.value).then(function (e) {\n        return {\n          value: e,\n          done: t\n        };\n      });\n    }\n    return (hL = function (e) {\n      this.s = e, this.n = e.next;\n    }).prototype = {\n      s: null,\n      n: null,\n      next: function () {\n        return t(this.n.apply(this.s, arguments));\n      },\n      return: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Cl.resolve({\n          value: e,\n          done: !0\n        }) : t(i.apply(this.s, arguments));\n      },\n      throw: function (e) {\n        var i = this.s.return;\n        return void 0 === i ? Cl.reject(e) : t(i.apply(this.s, arguments));\n      }\n    }, new hL(e);\n  }\n  let pL = (ZS((cL = class extends gE {\n    get state() {\n      return this._state;\n    }\n    set state(e) {\n      const t = this._state;\n      this._state = e, this.emit(Og.StateChange, t, this._state);\n    }\n    constructor(e, t) {\n      super(), mp(this, \"store\", void 0), mp(this, \"statsUploader\", void 0), mp(this, \"connection\", void 0), mp(this, \"localTrackMap\", new Map()), mp(this, \"remoteUserMap\", new Map()), mp(this, \"pendingLocalTracks\", []), mp(this, \"pendingRemoteTracks\", []), mp(this, \"statsCollector\", void 0), mp(this, \"isPlanB\", !1), mp(this, \"iceFailedCount\", 0), mp(this, \"dtlsFailedCount\", 0), mp(this, \"mutex\", new OT(\"P2PChannel-mutex\")), mp(this, \"_state\", Ag.Disconnected), mp(this, \"handleMuteLocalTrack\", async (e, t, i) => {\n        const r = await this.mutex.lock(\"Locking from P2PChannel.handleMuteLocalTrack\");\n        try {\n          if (!this.connection || this.state !== Ag.Connected) return void i(new vE(TE.INVALID_OPERATION, \"Cannot call P2PChannel.handleMuteLocalTrack before connection established.\"));\n          const n = this.filterTobeMutedTracks(e);\n          if (0 === n.length) return void t();\n          const o = n.find(e => \"videoLowTrack\" === e[0]);\n          if (o) {\n            o[1].track._originMediaStreamTrack.stop();\n          }\n          await this.connection.muteLocal(n.map(e => {\n            let [, {\n              id: t\n            }] = e;\n            return t;\n          }));\n          const s = this.createMuteMessage(n);\n          await BR(this, Og.RequestMuteLocal, s), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          r();\n        }\n      }), mp(this, \"handleUnmuteLocalTrack\", async (e, t, i) => {\n        const r = await this.mutex.lock(\"Locking from P2PChannel.handleUnmuteLocalTrack\");\n        try {\n          if (!this.connection || this.state !== Ag.Connected) return void i(new vE(TE.INVALID_OPERATION, \"Cannot call P2PChannel.handleUnmuteLocalTrack before connection established.\"));\n          const n = this.filterTobeUnmutedTracks(e);\n          if (0 === n.length) return void t();\n          const o = n.find(e => \"videoLowTrack\" === e[0]);\n          if (o) {\n            const t = o[1];\n            if (t.track._originMediaStreamTrack.stop(), jg().supportDualStreamEncoding) {\n              const i = e._mediaStreamTrack.clone();\n              t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i;\n            } else {\n              const i = AP(e, WR(this, Og.RequestLowStreamParameter));\n              t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i;\n            }\n            await new Cl((e, i) => {\n              this.handleReplaceTrack(t.track, e, i, !0);\n            });\n          }\n          await this.connection.unmuteLocal(n.map(e => {\n            let [, {\n              id: t\n            }] = e;\n            return t;\n          }));\n          const s = this.createUnmuteMessage(n);\n          await BR(this, Og.RequestUnmuteLocal, s), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          r();\n        }\n      }), mp(this, \"handleUpdateVideoEncoder\", async (e, t, i) => {\n        const r = await this.mutex.lock(\"Locking from P2PChannel.handleSetVideoEncoder\");\n        try {\n          const i = this.localTrackMap.get(Cg.LocalVideoTrack);\n          if (!this.connection || !i || i.track !== e || this.state !== Ag.Connected) return void t();\n          const {\n            id: n,\n            track: o\n          } = i;\n          await this.connection.updateSendParameters(n, o), await this.connection.updateEncoderConfig(n, o), this.emit(Og.UpdateVideoEncoder, o), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          r();\n        }\n      }), mp(this, \"handleSetOptimizationMode\", async (e, t, i) => {\n        const r = await this.mutex.lock(\"Locking from P2PChannel.handleSetOptimizationMode\");\n        try {\n          const i = this.localTrackMap.get(Cg.LocalVideoTrack);\n          if (!this.connection || !i || i.track !== e || this.state !== Ag.Connected) return;\n          const {\n            id: n,\n            track: o\n          } = i;\n          await this.connection.updateSendParameters(n, o), t();\n        } catch (e) {\n          i(e);\n        } finally {\n          r();\n        }\n      }), mp(this, \"handleReplaceTrack\", async (e, t, i, r) => {\n        let n;\n        NE.debug(\"P2PChannel handleReplaceTrack for [track-id-\".concat(e.getTrackId(), \"]\")), \"boolean\" == typeof r && r || (n = await this.mutex.lock(\"From P2PChannel.handleReplaceTrack\"));\n        try {\n          var o;\n          const i = Array.from(this.localTrackMap.entries()).find(t => {\n            let [, {\n              track: i\n            }] = t;\n            return e === i;\n          });\n          if (!this.connection || !i || this.state !== Ag.Connected) return void t();\n          if (await (null === (o = this.connection) || void 0 === o ? void 0 : o.replaceTrack(e, i[1].id)), this.isPlanB) {\n            const t = i[1];\n            t.id = e._mediaStreamTrack.id, this.localTrackMap.set(i[0], t);\n          }\n          if (i[0] === Cg.LocalVideoTrack && jg().supportDualStreamEncoding) {\n            const t = this.localTrackMap.get(Cg.LocalVideoLowTrack);\n            if (t) {\n              const i = e._mediaStreamTrack.clone();\n              t.track._originMediaStreamTrack.stop(), t.track._mediaStreamTrack = i, t.track._originMediaStreamTrack = i, await new Cl((e, i) => {\n                this.handleReplaceTrack(t.track, e, i, !0);\n              });\n            }\n          }\n          t();\n        } catch (e) {\n          i(e);\n        } finally {\n          var s;\n          null === (s = n) || void 0 === s || s();\n        }\n      }), mp(this, \"handleGetLocalVideoStats\", e => {\n        e(this.statsCollector.getLocalVideoTrackStats());\n      }), mp(this, \"handleGetLocalAudioStats\", e => {\n        e(this.statsCollector.getLocalAudioTrackStats());\n      }), mp(this, \"handleGetRemoteVideoStats\", e => this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid]), mp(this, \"handleGetRemoteAudioStats\", e => this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid]), this.store = e, this.statsCollector = t, this.statsCollector.addP2PChannel(this), this.statsUploader = new YP(), this.bindStatsUploaderEvents(), this.isPlanB = !jg().supportUnifiedPlan || HE(\"CHROME_FORCE_PLAN_B\") && ap();\n    }\n    async startP2PConnection(e, t) {\n      return this.state = Ag.New, this.connection = t ? new sL(e, this.store) : this.isPlanB ? new fP(e, this.store) : new yP(e, this.store), this.bindConnectionEvents(this.connection), this.connection.establish();\n    }\n    async connect(e, t, i, r, n, o) {\n      if (!this.connection) throw new vE(TE.UNEXPECTED_ERROR, \"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .\");\n      this.connection instanceof sL ? this.connection.updateRemoteConnect(r) : (this.store.peerConnectionStart(), await this.connection.connect(e, t, i, r, n, o), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Ag.Connected);\n    }\n    async preConnect(e, t, i, r, n, o) {\n      if (!this.connection) throw new vE(TE.UNEXPECTED_ERROR, \"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .\");\n      this.store.peerConnectionStart();\n      const s = await this.connection.connect(e, t, i, r, n, o);\n      return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Ag.Connected, s;\n    }\n    getEstablishParams() {\n      if (this.connection instanceof sL) return this.connection.getP2PConnectionParams();\n      throw new Error(\"Only DataChannelConnection needs to obtain establishParams\");\n    }\n    publish(e, t, i) {\n      var r = this;\n      return ID(function* () {\n        const n = yield yD(r.mutex.lock(\"From P2PChannel.publish\"));\n        try {\n          if (!r.connection || r.state !== Ag.Connected) {\n            if (r.state === Ag.Disconnected) throw new vE(TE.UNEXPECTED_ERROR, \"PeerConnection already disconnected.\");\n            r.throwIfTrackTypeNotMatch(e);\n            const t = e.filter(e => -1 === r.pendingLocalTracks.indexOf(e));\n            return void (r.pendingLocalTracks = r.pendingLocalTracks.concat(t));\n          }\n          r.store.pubId = r.store.pubId + 1, pR.markPublishStart(r.store.clientId, r.store.pubId);\n          const o = r.filterTobePublishedTracks(e, t, i);\n          if (0 === o.length) return void (yield yD(r.tryToUnmuteAudio(e)));\n          yield* AD(lL(r.doPublish(r.connection, o)), yD);\n        } finally {\n          n();\n        }\n      })();\n    }\n    doPublish(e, t) {\n      var i = this;\n      return ID(function* () {\n        t.forEach(e => {\n          let {\n            track: t,\n            type: r\n          } = e;\n          const n = Date.now();\n          i.store.publish(t.getTrackId(), r === Cg.LocalAudioTrack ? \"audio\" : \"video\", n);\n        }), i.bindLocalTrackEvents(t);\n        const r = yield yD(e.send(t.map(e => {\n            let {\n              track: t\n            } = e;\n            return t;\n          }), i.store.codec, i.store.audioCodec)),\n          n = (yield yD(r.next())).value,\n          o = i.createGatewayPublishMessage(t, n);\n        let s;\n        try {\n          s = yield o;\n        } catch (e) {\n          throw r.throw(e), (null == e ? void 0 : e.code) === TE.WS_ABORT && t.forEach(e => {\n            let {\n              track: t\n            } = e;\n            -1 === i.pendingLocalTracks.indexOf(t) && i.pendingLocalTracks.push(t);\n          }), i.unbindLocalTrackEvents(t), e;\n        }\n        const a = i.mapPubResToRemoteConfig(o, s),\n          c = (yield yD(r.next(a))).value;\n        t.forEach(e => {\n          let {\n            type: t\n          } = e;\n          i.statsCollector.addLocalStats(t);\n        }), i.assignLocalTracks(t, c), i.statsUploader.startUploadUplinkStats(), t.forEach(e => {\n          let {\n            track: t,\n            type: r\n          } = e;\n          const n = Date.now();\n          i.store.publish(t.getTrackId(), r === Cg.LocalAudioTrack ? \"audio\" : \"video\", void 0, n);\n        });\n      })();\n    }\n    publishLowStream(e) {\n      var t = this;\n      return ID(function* () {\n        if (!t.connection || t.state !== Ag.Connected) return;\n        const i = yield yD(t.mutex.lock(\"Locking from P2PChannel.publishLowStream\"));\n        try {\n          const n = t.localTrackMap.get(Cg.LocalVideoTrack);\n          if (!n) throw new vE(TE.UNEXPECTED_ERROR, \"Could not find high stream\");\n          if (t.localTrackMap.has(Cg.LocalVideoLowTrack)) throw new vE(TE.UNEXPECTED_ERROR, \"[\".concat(t.store.clientId, \"] Can't publish low stream when stream already publish\"));\n          const o = [{\n            track: t.getLowVideoTrack(n.track, e),\n            type: Cg.LocalVideoLowTrack\n          }];\n          if (yield* AD(lL(t.doPublish(t.connection, o)), yD), n.track.muted || !n.track.enabled) {\n            var r;\n            const e = null === (r = t.localTrackMap.get(Cg.LocalVideoLowTrack)) || void 0 === r ? void 0 : r.id;\n            void 0 !== e && (yield yD(t.connection.muteLocal([e])));\n          }\n        } finally {\n          i();\n        }\n      })();\n    }\n    async republish() {\n      this.pendingLocalTracks.length > 0 && (NE.debug(\"Emit P2PChannelEvents.RequestRePublish to republish tracks.\"), await FR(this, Og.RequestRePublish, this.pendingLocalTracks), this.emit(Og.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = []);\n    }\n    async reSubscribe(e) {\n      for (let e = this.pendingRemoteTracks.length - 1; e >= 0; e--) {\n        const {\n          user: t,\n          kind: i\n        } = this.pendingRemoteTracks[e];\n        (i !== yg.AUDIO || t._audio_added_ && t._audioSSRC) && (i !== yg.VIDEO || t._video_added_ && t._videoSSRC) || this.pendingRemoteTracks.splice(e, 1);\n      }\n      if (e) await FR(this, Og.RequestReSubscribe, this.pendingRemoteTracks);else for (const {\n        user: e,\n        kind: t\n      } of this.pendingRemoteTracks) await this.subscribe(e, t, t === yg.VIDEO ? e._videoSSRC : e._audioSSRC);\n      this.pendingRemoteTracks.forEach(e => {\n        let {\n          user: t\n        } = e;\n        this.emit(Og.MediaReconnectEnd, t.uid);\n      }), this.pendingRemoteTracks = [];\n    }\n    async unpublish(e) {\n      if (!this.connection || this.state !== Ag.Connected) return void e.forEach(e => {\n        const t = this.pendingLocalTracks.indexOf(e);\n        -1 !== t && this.pendingLocalTracks.splice(t, 1);\n      });\n      const t = this.filterTobeUnpublishedTracks(e);\n      if (0 === t.length) return;\n      const i = t.find(e => \"videoLowTrack\" === e[0]);\n      if (i) {\n        i[1].track.close();\n      }\n      return this.doUnpublish(this.connection, t);\n    }\n    async unpublishLowStream() {\n      if (!this.connection || this.state !== Ag.Connected) return;\n      const e = this.localTrackMap.get(Cg.LocalVideoLowTrack);\n      if (!e) return;\n      e.track.close();\n      const t = [[Cg.LocalVideoLowTrack, e]];\n      return this.doUnpublish(this.connection, t);\n    }\n    async doUnpublish(e, t) {\n      const i = this.createGatewayUnpublishMessage(t);\n      return await e.stopSending(t.map(e => {\n        let [, {\n          id: t\n        }] = e;\n        return t;\n      })), this.withdrawLocalTracks(t), this.unbindLocalTrackEvents(t.map(e => {\n        let [t, {\n          track: i\n        }] = e;\n        return {\n          type: t,\n          track: i\n        };\n      })), t.forEach(e => {\n        let [t] = e;\n        this.statsCollector.removeLocalStats(t);\n      }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), i;\n    }\n    async subscribe(e, t, i, r, n) {\n      var o;\n      if (!this.connection || this.state !== Ag.Connected) throw new vE(TE.INVALID_OPERATION, \"Cannot subscribe remote user when peerConnection disconnected.\");\n      if (null !== (o = this.remoteUserMap.get(e)) && void 0 !== o && o.has(t)) return;\n      let s, a;\n      if (n) {\n        const i = n.find(e => {\n          let {\n            stream_type: i\n          } = e;\n          return i === t;\n        });\n        if (!i) throw new vE(TE.UNEXPECTED_ERROR, \"Cannot subscribe to remote \".concat(t, \" for user: \").concat(e.uid, \" because subscribe answer from gateway does not contain stream_type: \").concat(t, \".\"));\n        const r = await this.connection.receive(t, i.ssrcs, String(e._uintid), i.attributes);\n        s = r.track, a = r.id;\n      } else {\n        const n = await this.connection.receive(t, [{\n          ssrcId: i,\n          rtx: r\n        }], String(e._uintid), void 0);\n        s = n.track, a = n.id;\n      }\n      t === yg.AUDIO ? (e._audioTrack ? e._audioTrack._updateOriginMediaStreamTrack(s) : (e._audioTrack = new WP(s, e.uid, e._uintid, this.store), NE.info(\"[\".concat(this.store.p2pId, \"] create remote audio track: \").concat(e._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(e, e._audioTrack)) : (e._videoTrack ? e._videoTrack._updateOriginMediaStreamTrack(s) : (e._videoTrack = new GP(s, e.uid, e._uintid, this.store), NE.info(\"[\".concat(this.store.p2pId, \"] create remote video track: \").concat(e._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(e, e._videoTrack));\n      const c = this.remoteUserMap.get(e);\n      c ? c.set(t, a) : this.remoteUserMap.set(e, new Map([[t, a]])), this.statsCollector.addRemoteStats(e.uid), this.statsUploader.startUploadDownlinkStats();\n      const d = this.pendingRemoteTracks.findIndex(i => {\n        let {\n          user: r,\n          kind: n\n        } = i;\n        return r.uid === e.uid && t === n;\n      });\n      -1 !== d && (this.pendingRemoteTracks.splice(d, 1), this.emit(Og.MediaReconnectEnd, e.uid));\n    }\n    async massSubscribe(e) {\n      return this.massSubscribeNoLock(e);\n    }\n    async massSubscribeNoLock(e) {\n      if (!this.connection || this.state !== Ag.Connected) throw new vE(TE.INVALID_OPERATION, \"Cannot subscribeAll remote users when peerConnection disconnected.\");\n      e = e.filter(e => {\n        var t;\n        let {\n          user: i,\n          mediaType: r\n        } = e;\n        return !(null !== (t = this.remoteUserMap.get(i)) && void 0 !== t && t.has(r));\n      });\n      const t = await this.connection.batchReceive(e.map(e => {\n        let {\n          user: t,\n          mediaType: i,\n          ssrcId: r,\n          rtxSsrcId: n\n        } = e;\n        return {\n          kind: i,\n          ssrcMsg: [{\n            ssrcId: r,\n            rtx: n\n          }],\n          mslabel: String(t._uintid)\n        };\n      }));\n      e.forEach((e, i) => {\n        let {\n          user: r,\n          mediaType: n\n        } = e;\n        const {\n          track: o,\n          id: s\n        } = t[i];\n        n === yg.AUDIO ? (r._audioTrack ? r._audioTrack._updateOriginMediaStreamTrack(o) : (r._audioTrack = new WP(o, r.uid, r._uintid, this.store), NE.info(\"[\".concat(this.store.p2pId, \"] create remote audio track: \").concat(r._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(r, r._audioTrack)) : (r._videoTrack ? r._videoTrack._updateOriginMediaStreamTrack(o) : (r._videoTrack = new GP(o, r.uid, r._uintid, this.store), NE.info(\"[\".concat(this.store.p2pId, \"] create remote video track: \").concat(r._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(r, r._videoTrack));\n        const a = this.remoteUserMap.get(r);\n        a ? a.set(n, s) : this.remoteUserMap.set(r, new Map([[n, s]])), this.statsCollector.addRemoteStats(r.uid), this.statsUploader.startUploadDownlinkStats();\n        const c = this.pendingRemoteTracks.findIndex(e => {\n          let {\n            user: t,\n            kind: i\n          } = e;\n          return t.uid === r.uid && n === i;\n        });\n        -1 !== c && (this.pendingRemoteTracks.splice(c, 1), this.emit(Og.MediaReconnectEnd, r.uid));\n      });\n    }\n    async unsubscribe(e, t, i) {\n      const r = this.pendingRemoteTracks.filter(i => {\n        let {\n          user: r,\n          kind: n\n        } = i;\n        return void 0 !== t ? r.uid === e.uid && t === n : r.uid === e.uid;\n      });\n      if (r.forEach(e => {\n        const t = this.pendingRemoteTracks.indexOf(e);\n        this.pendingRemoteTracks.splice(t, 1);\n      }), this.connection || i || r.forEach(t => {\n        let {\n          kind: i\n        } = t;\n        var r;\n        if (i === yg.AUDIO) null === (r = e._audioTrack) || void 0 === r || r._destroy(), e._audioTrack = void 0;else if (i === yg.VIDEO) {\n          var n;\n          null === (n = e._videoTrack) || void 0 === n || n._destroy(), e._videoTrack = void 0;\n        }\n      }), !this.connection) return;\n      const n = this.filterTobeUnSubscribedTracks(e, t);\n      if (0 === n.length) return;\n      await this.connection.stopReceiving(n.map(e => {\n        let [, {\n          id: t\n        }] = e;\n        return t;\n      }));\n      const o = this.createUnsubscribeMessage(n);\n      return this.withdrawRemoteTracks(n), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), n.forEach(e => {\n        let [t, {\n          kind: r\n        }] = e;\n        var n, o;\n        r === yg.VIDEO && t._videoSSRC && (null === (n = this.connection) || void 0 === n || n.setStatsRemoteVideoIsReady(t._videoSSRC, !1));\n        if (r === yg.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), i || (null === (o = t._videoTrack) || void 0 === o || o._destroy(), t._videoTrack = void 0);else if (r === yg.AUDIO) {\n          var s;\n          if (this.unbindRemoteTrackEvents(t._audioTrack), !i) null === (s = t._audioTrack) || void 0 === s || s._destroy(), t._audioTrack = void 0;\n        }\n      }), o;\n    }\n    async massUnsubscribe(e) {\n      return this.massUnsubscribeNoLock(e);\n    }\n    async massUnsubscribeNoLock(e) {\n      let t = [];\n      for (const {\n        user: i,\n        mediaType: r\n      } of e) {\n        const e = this.pendingRemoteTracks.filter(e => {\n          let {\n            user: t,\n            kind: n\n          } = e;\n          return void 0 !== r ? t.uid === i.uid && r === n : t.uid === i.uid;\n        });\n        e.forEach(e => {\n          const t = this.pendingRemoteTracks.indexOf(e);\n          this.pendingRemoteTracks.splice(t, 1);\n        }), t = t.concat(e);\n      }\n      if (!this.connection) return void t.forEach(e => {\n        let {\n          user: t,\n          kind: i\n        } = e;\n        var r;\n        if (i === yg.AUDIO) null === (r = t._audioTrack) || void 0 === r || r._destroy(), t._audioTrack = void 0;else if (i === yg.VIDEO) {\n          var n;\n          null === (n = t._videoTrack) || void 0 === n || n._destroy(), t._videoTrack = void 0;\n        }\n      });\n      const i = zi(e).call(e, (e, t) => {\n        let {\n          user: i,\n          mediaType: r\n        } = t;\n        const n = this.filterTobeUnSubscribedTracks(i, r);\n        return e.concat(n);\n      }, []);\n      if (0 === i.length) return;\n      await this.connection.stopReceiving(i.map(e => {\n        let [, {\n          id: t\n        }] = e;\n        return t;\n      }));\n      const r = this.createUnsubscribeAllMessage(i);\n      return this.withdrawRemoteTracks(i), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), i.forEach(e => {\n        let [t, {\n          kind: i\n        }] = e;\n        var r, n;\n        i === yg.VIDEO && t._videoSSRC && (null === (r = this.connection) || void 0 === r || r.setStatsRemoteVideoIsReady(t._videoSSRC, !1));\n        if (i === yg.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), null === (n = t._videoTrack) || void 0 === n || n._destroy(), t._videoTrack = void 0;else if (i === yg.AUDIO) {\n          var o;\n          this.unbindRemoteTrackEvents(t._audioTrack), null === (o = t._audioTrack) || void 0 === o || o._destroy(), t._audioTrack = void 0;\n        }\n      }), r;\n    }\n    async muteRemote(e, t) {\n      if (!this.connection) return;\n      const i = this.remoteUserMap.get(e);\n      if (!i) return void NE.warning(\"P2PChannel.muteRemote has no remote user \".concat(e.uid, \".\"));\n      if (!i.get(t)) return void NE.warning(\"P2PChannel.muteRemote has no remote user \".concat(e.uid, \" media type \").concat(t, \".\"));\n      const r = t === yg.VIDEO ? e._videoSSRC : e._audioSSRC;\n      void 0 !== r && this.connection.setStatsRemoteVideoIsReady(r, !1);\n    }\n    async unmuteRemote(e, t) {\n      return this.unmuteRemoteNoLock(e, t);\n    }\n    async unmuteRemoteNoLock(e, t) {\n      if (!this.connection) return;\n      const i = this.remoteUserMap.get(e);\n      if (!i) return void NE.warning(\"P2PChannel.unmuteRemote has no remote user \".concat(e.uid, \".\"));\n      i.get(t) || NE.warning(\"P2PChannel.unmuteRemote has no remote user \".concat(e.uid, \" media type \").concat(t, \".\"));\n    }\n    getAllTracks(e) {\n      const t = this.localTrackMap.get(Cg.LocalAudioTrack);\n      if ((null == t ? void 0 : t.track) instanceof uR) {\n        const i = t.track;\n        return Array.from(this.localTrackMap.entries()).filter(e => {\n          let [t] = e;\n          return t !== Cg.LocalAudioTrack;\n        }).filter(t => {\n          let [i] = t;\n          return !(e && i === Cg.LocalVideoLowTrack);\n        }).map(e => {\n          let [, {\n            track: t\n          }] = e;\n          return t;\n        }).concat(i.trackList);\n      }\n      return Array.from(this.localTrackMap.entries()).filter(t => {\n        let [i] = t;\n        return !(e && i === Cg.LocalVideoLowTrack);\n      }).map(e => {\n        let [, {\n          track: t\n        }] = e;\n        return t;\n      });\n    }\n    reportPublishEvent(e, t, i, r, n) {\n      if (e) {\n        const i = this.localTrackMap.get(Cg.LocalAudioTrack),\n          o = r ? this.localTrackMap.get(Cg.LocalVideoLowTrack) : this.localTrackMap.get(Cg.LocalVideoTrack);\n        IT.publish(this.store.sessionId, {\n          eventElapse: pR.measureFromPublishStart(this.store.clientId, this.store.pubId),\n          succ: e,\n          ec: t,\n          audioName: null == i ? void 0 : i.track.getTrackLabel(),\n          videoName: null == o ? void 0 : o.track.getTrackLabel(),\n          screenshare: -1 !== (null == o ? void 0 : o.track._hints.indexOf(lg.SCREEN_TRACK)),\n          audio: !!i,\n          video: !!o,\n          p2pid: this.store.p2pId,\n          publishRequestid: this.store.pubId,\n          extend: n\n        });\n      } else {\n        var o;\n        i || (i = []);\n        const s = i.find(e => e instanceof aR),\n          a = r ? null === (o = this.localTrackMap.get(Cg.LocalVideoTrack)) || void 0 === o ? void 0 : o.track : i.find(e => e instanceof Ew);\n        IT.publish(this.store.sessionId, {\n          eventElapse: pR.measureFromPublishStart(this.store.clientId, this.store.pubId),\n          succ: e,\n          ec: t,\n          audioName: null == s ? void 0 : s.getTrackLabel(),\n          videoName: null == a ? void 0 : a.getTrackLabel(),\n          screenshare: -1 !== (null == a ? void 0 : a._hints.indexOf(lg.SCREEN_TRACK)),\n          audio: !!s,\n          video: !!a,\n          p2pid: this.store.p2pId,\n          publishRequestid: this.store.pubId,\n          extend: n\n        });\n      }\n    }\n    reportSubscribeEvent(e, t, i, r) {\n      const n = r === yg.VIDEO ? i._videoSSRC : i._audioSSRC;\n      n && IT.subscribe(this.store.sessionId, {\n        succ: e,\n        ec: t,\n        video: r === yg.VIDEO,\n        audio: r === yg.AUDIO,\n        peerid: i.uid,\n        subscribeRequestid: r === yg.VIDEO ? i._videoSSRC : i._audioSSRC,\n        p2pid: this.store.p2pId,\n        eventElapse: pR.measureFromSubscribeStart(this.store.clientId, n)\n      });\n    }\n    reset() {\n      NE.debug(\"P2PChannel.reset\"), this.mutex = new OT(\"P2PChannel-mutex\"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = Ag.Disconnected;\n    }\n    getStats() {\n      var e;\n      return null === (e = this.connection) || void 0 === e ? void 0 : e.getStats();\n    }\n    getRemoteVideoIsReady(e) {\n      var t;\n      return (null === (t = this.connection) || void 0 === t ? void 0 : t.getRemoteVideoIsReady(e)) || !1;\n    }\n    getLocalAudioVolume() {\n      const e = this.localTrackMap.get(Cg.LocalAudioTrack);\n      if (e) return e.track.getVolumeLevel();\n    }\n    getLocalVideoSize() {\n      const e = this.localTrackMap.get(Cg.LocalVideoTrack);\n      if (e) return {\n        width: e.track._videoWidth || 0,\n        height: e.track._videoHeight || 0\n      };\n    }\n    getEncoderConfig(e) {\n      const t = this.localTrackMap.get(e);\n      return t && t.track instanceof Ew || t && t.track instanceof aR ? t.track._encoderConfig : void 0;\n    }\n    getLocalMedia(e) {\n      return this.localTrackMap.get(e);\n    }\n    hasLocalMedia() {\n      return this.localTrackMap.size > 0;\n    }\n    hasRemoteMedia(e, t) {\n      if (!e) return this.remoteUserMap.size > 0;\n      const i = this.remoteUserMap.get(e);\n      return !!i && (!t || i.has(t));\n    }\n    async hasRemoteMediaWithLock(e, t) {\n      if (!e) return this.remoteUserMap.size > 0;\n      const i = this.remoteUserMap.get(e);\n      return !!i && (!t || i.has(t));\n    }\n    getRemoteMedia(e) {\n      var t;\n      const i = Array.from(sT(t = this.remoteUserMap).call(t)).find(t => t.uid === e);\n      return i ? {\n        audioTrack: i.audioTrack,\n        audioSSRC: i._audioSSRC,\n        videoTrack: i.videoTrack,\n        videoSSRC: i._videoSSRC\n      } : {};\n    }\n    getAudioLevels() {\n      let e = Array.from(this.remoteUserMap.entries()).map(e => {\n        let [t] = e;\n        return {\n          uid: t.uid,\n          level: t.audioTrack ? 100 * t.audioTrack._source.getAccurateVolumeLevel() : 0\n        };\n      });\n      const t = this.localTrackMap.get(Cg.LocalAudioTrack);\n      return t && e.push({\n        level: 100 * t.track._source.getAccurateVolumeLevel(),\n        uid: this.store.uid\n      }), e = Yf(e).call(e, (e, t) => e.level - t.level), e;\n    }\n    async disconnectForReconnect() {\n      this.connection && (NE.debug(\"P2PChannel.disconnectForReconnect closing P2PConnection\"), this.state = Ag.Reconnecting, this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach(e => {\n        let [t, {\n          track: i\n        }] = e;\n        switch (t) {\n          case Cg.LocalVideoTrack:\n            i._hints.includes(lg.LOW_STREAM) ? i.close() : this.pendingLocalTracks.push(i);\n            break;\n          case Cg.LocalAudioTrack:\n            i instanceof uR ? this.pendingLocalTracks = this.pendingLocalTracks.concat(i.trackList) : this.pendingLocalTracks.push(i);\n            break;\n          case Cg.LocalVideoLowTrack:\n        }\n      }), this.emit(Og.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let [t, i] = e;\n        Array.from(sT(i).call(i)).forEach(e => {\n          this.setPendingRemoteMedia(t, e);\n        }), this.emit(Og.MediaReconnectStart, t.uid);\n      }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), NE.debug(\"P2PChannel disconnected, waiting to reconnect.\"));\n    }\n    hasPendingRemoteMedia(e, t) {\n      for (const i of this.pendingRemoteTracks) {\n        const {\n          user: r,\n          kind: n\n        } = i;\n        if ((e instanceof mw ? e.uid : e) === r.uid && t === n) return !0;\n      }\n      return !1;\n    }\n    setPendingRemoteMedia(e, t) {\n      this.hasPendingRemoteMedia(e, t) || this.pendingRemoteTracks.push({\n        user: e,\n        kind: t\n      });\n    }\n    restartICE() {\n      var e = this;\n      return ID(function* () {\n        if (!e.connection) throw new Error();\n        const t = yield yD(e.mutex.lock(\"From P2PChannel.restartICE\"));\n        try {\n          yield* AD(lL(e.connection.restartICE()), yD);\n        } finally {\n          t();\n        }\n      })();\n    }\n    getUplinkNetworkQuality() {\n      if (!this.connection) return 0;\n      const e = this.connection.getStats(),\n        t = this.localTrackMap.get(Cg.LocalVideoTrack),\n        i = this.localTrackMap.get(Cg.LocalAudioTrack),\n        r = e.videoSend.find(e => e.ssrc === (null == t ? void 0 : t.ssrcs[0].ssrcId)),\n        n = e.audioSend.find(e => e.ssrc === (null == i ? void 0 : i.ssrcs[0].ssrcId));\n      if (!r || !n) return 1;\n      const o = GR(this, Og.NeedSignalRTT),\n        s = r ? r.rttMs : void 0,\n        a = n ? n.rttMs : void 0,\n        c = s && a ? (s + a) / 2 : s || a,\n        d = (c && o ? (c + o) / 2 : c || o) || 0,\n        u = 100 * e.sendPacketLossRate * .7 / 50 + .3 * d / 1500,\n        l = u < .17 ? 1 : u < .36 ? 2 : u < .59 ? 3 : u < .1 ? 4 : 5,\n        h = null == t ? void 0 : t.track;\n      if (h && h._encoderConfig && -1 === h._hints.indexOf(lg.SCREEN_TRACK)) {\n        const t = h._encoderConfig.bitrateMax,\n          i = e.bitrate.actualEncoded;\n        if (t && i) {\n          const e = (1e3 * t - i) / (1e3 * t);\n          return QE[e < .15 ? 0 : e < .3 ? 1 : e < .45 ? 2 : e < .6 ? 3 : 4][l];\n        }\n      }\n      return l;\n    }\n    getDownlinkNetworkQuality() {\n      if (!this.connection) return 0;\n      const e = this.connection.getStats();\n      let t = 0;\n      return Array.from(this.remoteUserMap.entries()).forEach(i => {\n        let [r] = i;\n        const n = r._audioSSRC,\n          o = r._videoSSRC,\n          s = e.audioRecv.find(e => e.ssrc === n),\n          a = e.videoRecv.find(e => e.ssrc === o);\n        if (!s && !a) return void (t += 1);\n        const c = GR(this, Og.NeedSignalRTT),\n          d = e.rtt,\n          u = (d && c ? (d + c) / 2 : d || c) || 0,\n          l = s ? s.jitterMs : void 0,\n          h = e.recvPacketLossRate;\n        let p = .7 * h * 100 / 50 + .3 * u / 1500;\n        l && (p = .6 * h * 100 / 50 + .2 * u / 1500 + .2 * l / 400);\n        t += p < .1 ? 1 : p < .17 ? 2 : p < .36 ? 3 : p < .59 ? 4 : 5;\n      }), this.remoteUserMap.size > 0 ? Math.round(t / this.remoteUserMap.size) : t;\n    }\n    async muteLocalTrack(e) {\n      return new Cl((t, i) => {\n        this.handleMuteLocalTrack(e, t, i);\n      });\n    }\n    filterTobePublishedTracks(e, t, i) {\n      const r = [],\n        n = jg(),\n        o = this.getAllTracks();\n      e = KR(e = e.filter(e => -1 === o.indexOf(e)));\n      let s = !1,\n        a = !1;\n      for (const o of e) {\n        if (o instanceof Ew && (this.localTrackMap.has(Cg.LocalVideoTrack) || s ? new vE(TE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (r.push({\n          track: o,\n          type: Cg.LocalVideoTrack\n        }), s = !0), t)) {\n          const e = this.getLowVideoTrack(o, i);\n          r.push({\n            track: e,\n            type: Cg.LocalVideoLowTrack\n          });\n        }\n        if (o instanceof aR) {\n          const e = this.localTrackMap.get(Cg.LocalAudioTrack);\n          if (e) {\n            if (!(e.track instanceof uR)) throw new vE(TE.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing\");\n            if (o._bypassWebAudio) throw new vE(TE.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio\");\n            e.track.addAudioTrack(o), this.bindLocalAudioTrackEvents(o, !0);\n          } else if (a) {\n            const e = r.find(e => {\n              let {\n                type: t\n              } = e;\n              return t === Cg.LocalAudioTrack;\n            });\n            if (!(e.track instanceof uR)) throw new vE(TE.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing\");\n            if (o._bypassWebAudio) throw new vE(TE.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio\");\n            e.track.addAudioTrack(o);\n          } else {\n            if (!n.webAudioMediaStreamDest || o instanceof uR || o._bypassWebAudio) r.push({\n              track: o,\n              type: Cg.LocalAudioTrack\n            });else {\n              const e = new uR();\n              e.addAudioTrack(o), r.push({\n                track: e,\n                type: Cg.LocalAudioTrack\n              });\n            }\n            a = !0;\n          }\n        }\n      }\n      return r;\n    }\n    filterTobeUnpublishedTracks(e) {\n      const t = [],\n        i = this.getAllTracks();\n      e = KR(e = e.filter(e => -1 !== i.indexOf(e)));\n      for (const i of e) {\n        if (i instanceof aR) {\n          const e = this.localTrackMap.get(Cg.LocalAudioTrack);\n          if (!e) continue;\n          e.track instanceof uR ? (e.track.removeAudioTrack(i), this.unbindLocalAudioTrackEvents(i), 0 === e.track.trackList.length && (t.push([Cg.LocalAudioTrack, e]), e.track.close())) : t.push([Cg.LocalAudioTrack, e]);\n        }\n        if (i instanceof Ew) {\n          const e = this.localTrackMap.get(Cg.LocalVideoTrack);\n          if (!e) continue;\n          t.push([Cg.LocalVideoTrack, e]);\n          const i = this.localTrackMap.get(Cg.LocalVideoLowTrack);\n          i && t.push([Cg.LocalVideoLowTrack, i]);\n        }\n      }\n      return t;\n    }\n    bindLocalTrackEvents(e) {\n      e.forEach(e => {\n        let {\n          track: t,\n          type: i\n        } = e;\n        switch (i) {\n          case Cg.LocalVideoTrack:\n            t.addListener(ug.GET_STATS, this.handleGetLocalVideoStats), t.addListener(ug.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.addListener(ug.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.addListener(ug.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.addListener(ug.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t.addListener(ug.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.addListener(ug.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.addListener(ug.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n            break;\n          case Cg.LocalAudioTrack:\n            this.bindLocalAudioTrackEvents(t);\n            break;\n          case Cg.LocalVideoLowTrack:\n        }\n      });\n    }\n    bindLocalAudioTrackEvents(e, t) {\n      e instanceof uR ? e.trackList.forEach(e => {\n        e.addListener(ug.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(ug.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(ug.GET_STATS, this.handleGetLocalAudioStats), e.addListener(ug.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(ug.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n      }) : (e.addListener(ug.GET_STATS, this.handleGetLocalAudioStats), e.addListener(ug.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(ug.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(ug.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(ug.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t || e.addListener(ug.NEED_REPLACE_TRACK, this.handleReplaceTrack));\n    }\n    unbindLocalTrackEvents(e) {\n      e || (e = Array.from(this.localTrackMap.entries()).map(e => {\n        let [t, {\n          track: i\n        }] = e;\n        return {\n          track: i,\n          type: t\n        };\n      })), e.forEach(e => {\n        let {\n          track: t,\n          type: i\n        } = e;\n        switch (i) {\n          case Cg.LocalVideoTrack:\n            t.off(ug.GET_STATS, this.handleGetLocalVideoStats), t.off(ug.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.off(ug.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.off(ug.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.off(ug.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t.off(ug.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.off(ug.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.off(ug.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n            break;\n          case Cg.LocalAudioTrack:\n            this.unbindLocalAudioTrackEvents(t);\n            break;\n          case Cg.LocalVideoLowTrack:\n        }\n      });\n    }\n    unbindLocalAudioTrackEvents(e) {\n      e instanceof uR ? e.trackList.forEach(e => {\n        e.off(ug.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(ug.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(ug.GET_STATS, this.handleGetLocalAudioStats), e.off(ug.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(ug.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);\n      }) : (e.off(ug.GET_STATS, this.handleGetLocalAudioStats), e.off(ug.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(ug.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(ug.NEED_REPLACE_TRACK, this.handleReplaceTrack), e.off(ug.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(ug.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack));\n    }\n    bindRemoteTrackEvents(e, t) {\n      t instanceof GP && t.addListener(ug.GET_STATS, t => {\n        t(this.handleGetRemoteVideoStats(e));\n      }), t instanceof WP && t.addListener(ug.GET_STATS, t => {\n        t(this.handleGetRemoteAudioStats(e));\n      });\n    }\n    unbindRemoteTrackEvents(e) {\n      e && e.removeAllListeners(ug.GET_STATS);\n    }\n    unbindAllRemoteTrackEvents() {\n      Array.from(this.remoteUserMap.entries()).forEach(e => {\n        let [t, i] = e;\n        i.has(yg.AUDIO) && this.unbindRemoteTrackEvents(t._audioTrack), i.has(yg.VIDEO) && this.unbindRemoteTrackEvents(t._videoTrack);\n      });\n    }\n    createGatewayPublishMessage(e, t) {\n      return e.map((e, i) => {\n        let r,\n          n,\n          {\n            track: o,\n            type: s\n          } = e;\n        switch (s) {\n          case Cg.LocalAudioTrack:\n            r = ag.Audio, n = {\n              dtx: o instanceof cR && o._config.DTX,\n              hq: !1,\n              lq: !1,\n              stereo: !1,\n              speech: !1\n            };\n            break;\n          case Cg.LocalVideoTrack:\n            r = o._hints.includes(lg.SCREEN_TRACK) ? ag.Screen : ag.High, n = uL(uL({}, IR(o)), {}, {\n              codec: this.store.codec\n            });\n            break;\n          case Cg.LocalVideoLowTrack:\n            r = ag.Low, n = uL(uL({}, IR(o)), {}, {\n              codec: this.store.codec\n            });\n        }\n        return {\n          stream_type: r,\n          attributes: n,\n          ssrcs: t[i]\n        };\n      });\n    }\n    createGatewayUnpublishMessage(e) {\n      return e.map(e => {\n        let t,\n          [i, {\n            track: r,\n            ssrcs: n,\n            id: o\n          }] = e;\n        switch (i) {\n          case Cg.LocalVideoTrack:\n            t = r._hints.includes(lg.SCREEN_TRACK) ? ag.Screen : ag.High;\n            break;\n          case Cg.LocalAudioTrack:\n            t = ag.Audio;\n            break;\n          case Cg.LocalVideoLowTrack:\n            t = ag.Low;\n        }\n        return {\n          stream_type: t,\n          ssrcs: n,\n          mid: o\n        };\n      });\n    }\n    assignLocalTracks(e, t) {\n      e.forEach((e, i) => {\n        let {\n          track: r,\n          type: n\n        } = e;\n        this.localTrackMap.set(n, {\n          track: r,\n          id: t[i].id,\n          ssrcs: t[i].localSSRC\n        });\n      });\n    }\n    withdrawLocalTracks(e) {\n      e.forEach(e => {\n        let [t] = e;\n        this.localTrackMap.delete(t);\n      });\n    }\n    bindConnectionEvents(e) {\n      e.onConnectionStateChange = async t => {\n        if (NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.onConnectionStateChange(\").concat(t, \")\")), this.emit(Og.PeerConnectionStateChange, t), \"connected\" !== t || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), \"disconnected\" === t && \"disconnected\" === e.iceConnectionState) return setTimeout(() => {\n          if (\"disconnected\" === e.iceConnectionState && HE(\"ICE_RESTART\")) {\n            \"CONNECTED\" === GR(this, Og.QueryClientConnectionState) && this.emit(Og.RequestRestartICE);\n          }\n        }, 800), void setTimeout(() => {\n          \"disconnected\" === e.peerConnectionState && (NE.debug(\"P2PConnection disconnected timeout 4000ms, force reconnect\"), setTimeout(() => this.emit(Og.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect());\n        }, 4e3);\n        \"failed\" === t && (NE.debug(\"P2PConnection state failed, force reconnect\"), setTimeout(() => this.emit(Og.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect());\n      }, e.onICEConnectionStateChange = e => {\n        \"connected\" !== e || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.onICEConnectionStateChange(\").concat(e, \")\")), IT.reportApiInvoke(this.store.sessionId, {\n          name: \"ICEConnectionStateChange\",\n          options: e,\n          tag: fm.TRACER\n        }).onSuccess(), this.emit(Og.IceConnectionStateChange, e);\n      }, e.onICETransportStateChange = e => {\n        NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.onICETransportStateChange(\").concat(e, \")\"));\n      }, e.onDTLSTransportStateChange = e => {\n        NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.onDTLSTransportStateChange(\").concat(e, \")\"));\n      }, e.onDTLSTransportError = e => {\n        NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.onDTLSTransportError(\").concat(e, \")\"));\n      }, e.onFirstAudioDecoded = e => {\n        var t;\n        const i = Array.from(sT(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);\n        var r;\n        i && (this.store.subscribe(i.uid, \"audio\", void 0, void 0, void 0, Date.now()), null === (r = i.audioTrack) || void 0 === r || r.emit(Eg.FIRST_FRAME_DECODED), IT.firstRemoteFrame(this.store.sessionId, lm.FIRST_AUDIO_DECODE, hm.FIRST_AUDIO_DECODE, {\n          peer: i._uintid,\n          subscribeElapse: pR.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        }));\n      }, e.onFirstAudioReceived = e => {\n        var t;\n        const i = Array.from(sT(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);\n        i && IT.firstRemoteFrame(this.store.sessionId, lm.FIRST_AUDIO_RECEIVED, hm.FIRST_AUDIO_RECEIVED, {\n          peer: i._uintid,\n          subscribeElapse: pR.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        });\n      }, e.onFirstVideoDecoded = (e, t, i) => {\n        this.reportVideoFirstFrameDecoded(e, t, i);\n      }, e.onFirstVideoReceived = e => {\n        var t;\n        const i = Array.from(sT(t = this.remoteUserMap).call(t)).find(t => t._videoSSRC === e);\n        i && IT.firstRemoteFrame(this.store.sessionId, lm.FIRST_VIDEO_RECEIVED, hm.FIRST_VIDEO_RECEIVED, {\n          peer: i._uintid,\n          subscribeElapse: pR.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId\n        });\n      }, e.onSelectedLocalCandidateChanged = (e, t) => {\n        const i = \"relay\" === e.candidateType,\n          r = \"relay\" === t.candidateType;\n        \"unknown\" !== t.candidateType && i === r || this.emit(Og.ConnectionTypeChange, i), NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.SelectedLocalCandidateChanged(\").concat(JSON.stringify(wR(t)), \" -> \").concat(JSON.stringify(wR(e)), \")\"));\n      }, e.onSelectedRemoteCandidateChanged = (e, t) => {\n        NE.info(\"[p2pId: \".concat(this.store.p2pId, \"]: P2PConnection.SelectedRemoteCandidateChanged(\").concat(JSON.stringify(wR(t)), \" -> \").concat(JSON.stringify(wR(e)), \")\"));\n      }, e.onFirstVideoDecodedTimeout = e => {\n        this.reportVideoFirstFrameDecoded(e, void 0, void 0, !0);\n      };\n    }\n    unbindConnectionEvents(e) {\n      e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0;\n    }\n    filterTobeMutedTracks(e) {\n      const t = [];\n      if (-1 === this.getAllTracks().indexOf(e)) return t;\n      const i = this.localTrackMap.get(Cg.LocalAudioTrack);\n      if (e instanceof aR && (null == i ? void 0 : i.track) instanceof uR) return i.track.isActive || t.push([Cg.LocalAudioTrack, i]), t;\n      const r = Array.from(this.localTrackMap.entries()).find(t => {\n        let [, {\n          track: i\n        }] = t;\n        return e === i;\n      });\n      if (r && (t.push(r), r[0] === Cg.LocalVideoTrack)) {\n        const e = this.localTrackMap.get(Cg.LocalVideoLowTrack);\n        e && t.push([Cg.LocalVideoLowTrack, e]);\n      }\n      return t;\n    }\n    filterTobeUnmutedTracks(e) {\n      const t = [],\n        i = this.localTrackMap.get(Cg.LocalAudioTrack);\n      if (e instanceof aR && (null == i ? void 0 : i.track) instanceof uR) return i.track.isActive && t.push([Cg.LocalAudioTrack, i]), t;\n      const r = Array.from(this.localTrackMap.entries()).find(t => {\n        let [, {\n          track: i\n        }] = t;\n        return e === i;\n      });\n      if (r) if (r[0] === Cg.LocalVideoTrack) {\n        t.push(r);\n        const e = this.localTrackMap.get(Cg.LocalVideoLowTrack);\n        e && t.push([Cg.LocalVideoLowTrack, e]);\n      } else t.push(r);\n      return t;\n    }\n    createMuteMessage(e) {\n      return e.map(e => {\n        let t,\n          [i, {\n            track: r,\n            ssrcs: n,\n            id: o\n          }] = e;\n        switch (i) {\n          case Cg.LocalAudioTrack:\n            t = ag.Audio;\n            break;\n          case Cg.LocalVideoTrack:\n            t = r._hints.includes(lg.SCREEN_TRACK) ? ag.Screen : ag.High;\n            break;\n          case Cg.LocalVideoLowTrack:\n            t = ag.Low;\n        }\n        return {\n          stream_type: t,\n          ssrcs: n,\n          mid: o\n        };\n      });\n    }\n    createUnmuteMessage(e) {\n      return e.map(e => {\n        let t,\n          [i, {\n            track: r,\n            ssrcs: n,\n            id: o\n          }] = e;\n        switch (i) {\n          case Cg.LocalAudioTrack:\n            t = ag.Audio;\n            break;\n          case Cg.LocalVideoTrack:\n            t = r._hints.includes(lg.SCREEN_TRACK) ? ag.Screen : ag.High;\n            break;\n          case Cg.LocalVideoLowTrack:\n            t = ag.Low;\n        }\n        return {\n          stream_type: t,\n          ssrcs: n,\n          mid: o\n        };\n      });\n    }\n    filterTobeUnSubscribedTracks(e, t) {\n      const i = [],\n        r = this.remoteUserMap.get(e);\n      if (!r) return i;\n      if (t) {\n        const n = r.get(t);\n        if (!n) return i;\n        i.push([e, {\n          kind: t,\n          id: n\n        }]);\n      } else Array.from(r.entries()).forEach(t => {\n        let [r, n] = t;\n        i.push([e, {\n          kind: r,\n          id: n\n        }]);\n      });\n      return i;\n    }\n    createUnsubscribeMessage(e) {\n      const t = [];\n      return e.forEach(e => {\n        let [i, {\n          kind: r,\n          id: n\n        }] = e;\n        switch (r) {\n          case yg.VIDEO:\n            return void (i._videoSSRC && t.push({\n              stream_type: yg.VIDEO,\n              ssrcId: i._videoSSRC\n            }));\n          case yg.AUDIO:\n            return void (i._audioSSRC && t.push({\n              stream_type: yg.AUDIO,\n              ssrcId: i._audioSSRC\n            }));\n        }\n      }), t;\n    }\n    createUnsubscribeAllMessage(e) {\n      const t = new Map();\n      return e.forEach(e => {\n        let [i, {\n          kind: r\n        }] = e;\n        if (t.has(i)) {\n          let e = t.get(i);\n          r === yg.VIDEO ? e |= dg.Video : e |= dg.Audio, t.set(i, e);\n        } else r === yg.VIDEO ? t.set(i, dg.Video) : t.set(i, dg.Audio);\n      }), {\n        users: Array.from(t.entries()).map(e => {\n          let [t, i] = e;\n          return {\n            stream_id: t.uid,\n            stream_type: i\n          };\n        })\n      };\n    }\n    withdrawRemoteTracks(e) {\n      e.forEach(e => {\n        let [t, {\n          kind: i\n        }] = e;\n        const r = this.remoteUserMap.get(t);\n        r && (r.delete(i), 0 === Array.from(r.entries()).length && this.remoteUserMap.delete(t));\n      });\n    }\n    async updateBitrateLimit(e) {\n      const t = this.localTrackMap.get(Cg.LocalVideoTrack),\n        i = this.localTrackMap.get(Cg.LocalVideoLowTrack);\n      t && (await t.track.setBitrateLimit(e.uplink)), i && e.low_stream_uplink && (await i.track.setBitrateLimit({\n        max_bitrate: e.low_stream_uplink.bitrate,\n        min_bitrate: e.low_stream_uplink.bitrate || 0\n      }));\n    }\n    isP2PDisconnected() {\n      if (this.connection) {\n        return \"connected\" !== this.connection.peerConnectionState;\n      }\n      return !0;\n    }\n    mapPubResToRemoteConfig(e, t) {\n      return e.map((e, i) => {\n        var r;\n        let {\n          stream_type: n\n        } = e;\n        return null === (r = t.find(e => {\n          let {\n            stream_type: t\n          } = e;\n          return n === t;\n        })) || void 0 === r ? void 0 : r.attributes;\n      });\n    }\n    async tryToUnmuteAudio(e) {\n      for (let i = 0; i < e.length; i++) if (e[i] instanceof aR) {\n        var t;\n        const r = this.filterTobeUnmutedTracks(e[i]);\n        if (0 === r.length) continue;\n        await (null === (t = this.connection) || void 0 === t ? void 0 : t.unmuteLocal(r.map(e => {\n          let [, {\n            id: t\n          }] = e;\n          return t;\n        })));\n        const n = this.createUnmuteMessage(r);\n        return void (await BR(this, Og.RequestUnmuteLocal, n));\n      }\n    }\n    bindStatsUploaderEvents() {\n      this.statsUploader.requestStats = () => this.getStats(), this.statsUploader.requestLocalMedia = () => Array.from(this.localTrackMap.entries()), this.statsUploader.requestRemoteMedia = () => Array.from(this.remoteUserMap.entries()), this.statsUploader.requestVideoIsReady = e => {\n        var t;\n        return !(null === (t = this.connection) || void 0 === t || !t.getRemoteVideoIsReady(e));\n      }, this.statsUploader.requestUpload = (e, t) => this.emit(Og.RequestUploadStats, e, t), this.statsUploader.requestAllTracks = () => this.getAllTracks();\n    }\n    unbindStatsUploaderEvents() {\n      this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0;\n    }\n    async requestReconnect() {\n      this.dtlsFailedCount += 1, await LR(IE(this.dtlsFailedCount, RE)), this.emit(Og.RequestReconnect);\n    }\n    async reconnectP2P() {\n      const e = Array.from(this.localTrackMap.entries()),\n        t = this.createGatewayUnpublishMessage(e);\n      Array.from(this.remoteUserMap.entries()), t.length > 0 && (await FR(this, Og.RequestUnpublishForReconnectPC, t)), this.disconnectForReconnect(), this.emit(Og.RequestReconnectPC);\n    }\n    canPublishLowStream() {\n      return this.localTrackMap.has(Cg.LocalVideoTrack) || this.pendingLocalTracks.some(e => e instanceof Ew);\n    }\n    throwIfTrackTypeNotMatch(e) {\n      if (e.filter(e => e instanceof Ew).length > 1) throw new vE(TE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);\n      if (e.filter(e => e instanceof aR).length > 1 && (e.some(e => e instanceof aR && e._bypassWebAudio) || !jg().webAudioMediaStreamDest)) throw new vE(TE.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode\");\n      for (const t of e) {\n        if (t instanceof Ew && this.pendingLocalTracks.some(e => e instanceof Ew)) throw new vE(TE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);\n        if (t instanceof aR && this.pendingLocalTracks.some(e => e instanceof aR) && (!jg().webAudioMediaStreamDest || t._bypassWebAudio || this.pendingLocalTracks.some(e => e instanceof aR && e._bypassWebAudio))) throw new vE(TE.NOT_SUPPORTED, \"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode\");\n      }\n    }\n    getLowVideoTrack(e, t) {\n      const i = jg().supportDualStreamEncoding,\n        r = uL(uL({}, {\n          width: 160,\n          height: 120,\n          framerate: 15,\n          bitrate: 50\n        }), t);\n      let n;\n      n = i ? e._mediaStreamTrack.clone() : AP(e, r);\n      const o = MR(8, \"track-low-\"),\n        s = new Ew(n, uL(uL({}, i && {\n          scaleResolutionDownBy: bR(r, e)\n        }), {}, {\n          frameRate: r.framerate,\n          bitrateMax: r.bitrate,\n          bitrateMin: r.bitrate\n        }), void 0, void 0, o);\n      return s._hints.push(lg.LOW_STREAM), e.addListener(ug.NEED_CLOSE, () => {\n        s.close();\n      }), s;\n    }\n    async globalLock() {\n      return this.mutex.lock(\"From P2PChannel.globalLock\");\n    }\n    reportVideoFirstFrameDecoded(e, t, i, r) {\n      var n;\n      const o = Array.from(sT(n = this.remoteUserMap).call(n)).find(t => t._videoSSRC === e);\n      if (o) {\n        r || this.store.subscribe(o.uid, \"video\", void 0, void 0, void 0, void 0, Date.now());\n        const n = this.store.keyMetrics,\n          s = n.subscribe.find(e => e.userId === o.uid && \"video\" === e.type);\n        IT.firstRemoteVideoDecode(this.store.sessionId, lm.FIRST_VIDEO_DECODE, hm.FIRST_VIDEO_DECODE, {\n          peer: o._uintid,\n          videowidth: t,\n          videoheight: i,\n          subscribeElapse: pR.measureFromSubscribeStart(this.store.clientId, e),\n          subscribeRequestid: e,\n          p2pid: this.store.p2pId,\n          apEnd: n.requestAPEnd || 0,\n          apStart: n.requestAPStart || 0,\n          joinGwEnd: n.joinGatewayEnd || 0,\n          joinGwStart: n.joinGatewayStart || 0,\n          pcEnd: n.peerConnectionEnd || 0,\n          pcStart: n.peerConnectionStart || 0,\n          subscriberEnd: (null == s ? void 0 : s.subscribeEnd) || 0,\n          subscriberStart: (null == s ? void 0 : s.subscribeStart) || 0,\n          videoAddNotify: (null == s ? void 0 : s.streamAdded) || 0,\n          state: r ? 1 : 0\n        });\n      }\n    }\n    async remoteMediaSsrcChanged(e, t, i) {\n      if (!this.connection) return !1;\n      const r = this.remoteUserMap.get(e);\n      if (!r) return !1;\n      const n = r.get(t);\n      if (!n) return !1;\n      const o = await this.connection.getRemoteSSRC(n);\n      return void 0 !== o && o !== i;\n    }\n  }).prototype, \"startP2PConnection\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"startP2PConnection\"), cL.prototype), ZS(cL.prototype, \"connect\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"connect\"), cL.prototype), ZS(cL.prototype, \"preConnect\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"preConnect\"), cL.prototype), ZS(cL.prototype, \"unpublish\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"unpublish\"), cL.prototype), ZS(cL.prototype, \"unpublishLowStream\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"unpublishLowStream\"), cL.prototype), ZS(cL.prototype, \"subscribe\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"subscribe\"), cL.prototype), ZS(cL.prototype, \"massSubscribe\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"massSubscribe\"), cL.prototype), ZS(cL.prototype, \"unsubscribe\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"unsubscribe\"), cL.prototype), ZS(cL.prototype, \"massUnsubscribe\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"massUnsubscribe\"), cL.prototype), ZS(cL.prototype, \"muteRemote\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"muteRemote\"), cL.prototype), ZS(cL.prototype, \"unmuteRemote\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"unmuteRemote\"), cL.prototype), ZS(cL.prototype, \"hasRemoteMediaWithLock\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"hasRemoteMediaWithLock\"), cL.prototype), ZS(cL.prototype, \"disconnectForReconnect\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"disconnectForReconnect\"), cL.prototype), ZS(cL.prototype, \"updateBitrateLimit\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"updateBitrateLimit\"), cL.prototype), ZS(cL.prototype, \"remoteMediaSsrcChanged\", [_L], Object.getOwnPropertyDescriptor(cL.prototype, \"remoteMediaSsrcChanged\"), cL.prototype), cL);\n  function _L(e, t, i) {\n    const r = e[t];\n    if (\"function\" != typeof r) throw new Error(\"Cannot use mutex on object property.\");\n    return i.value = async function () {\n      const e = this.mutex,\n        i = await e.lock(\"From P2PChannel.\".concat(t));\n      try {\n        for (var n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];\n        return await r.apply(this, o);\n      } finally {\n        i();\n      }\n    }, i;\n  }\n  function EL(e) {\n    return \"Minified Redux error #\" + e + \"; visit https://redux.js.org/Errors?code=\" + e + \" for the full message or use the non-minified dev environment for full errors. \";\n  }\n  var fL,\n    mL = \"function\" == typeof Symbol && Symbol.observable || \"@@observable\",\n    gL = function () {\n      return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n    },\n    SL = {\n      INIT: \"@@redux/INIT\" + gL(),\n      REPLACE: \"@@redux/REPLACE\" + gL(),\n      PROBE_UNKNOWN_ACTION: function () {\n        return \"@@redux/PROBE_UNKNOWN_ACTION\" + gL();\n      }\n    };\n  function TL(e) {\n    if (\"object\" != typeof e || null === e) return !1;\n    for (var t = e; null !== Object.getPrototypeOf(t);) t = Object.getPrototypeOf(t);\n    return Object.getPrototypeOf(e) === t;\n  }\n  function vL(e, t, i) {\n    var r;\n    if (\"function\" == typeof t && \"function\" == typeof i || \"function\" == typeof i && \"function\" == typeof arguments[3]) throw new Error(EL(0));\n    if (\"function\" == typeof t && void 0 === i && (i = t, t = void 0), void 0 !== i) {\n      if (\"function\" != typeof i) throw new Error(EL(1));\n      return i(vL)(e, t);\n    }\n    if (\"function\" != typeof e) throw new Error(EL(2));\n    var n = e,\n      o = t,\n      s = [],\n      a = s,\n      c = !1;\n    function d() {\n      a === s && (a = s.slice());\n    }\n    function u() {\n      if (c) throw new Error(EL(3));\n      return o;\n    }\n    function l(e) {\n      if (\"function\" != typeof e) throw new Error(EL(4));\n      if (c) throw new Error(EL(5));\n      var t = !0;\n      return d(), a.push(e), function () {\n        if (t) {\n          if (c) throw new Error(EL(6));\n          t = !1, d();\n          var i = a.indexOf(e);\n          a.splice(i, 1), s = null;\n        }\n      };\n    }\n    function h(e) {\n      if (!TL(e)) throw new Error(EL(7));\n      if (void 0 === e.type) throw new Error(EL(8));\n      if (c) throw new Error(EL(9));\n      try {\n        c = !0, o = n(o, e);\n      } finally {\n        c = !1;\n      }\n      for (var t = s = a, i = 0; i < t.length; i++) {\n        (0, t[i])();\n      }\n      return e;\n    }\n    function p(e) {\n      if (\"function\" != typeof e) throw new Error(EL(10));\n      n = e, h({\n        type: SL.REPLACE\n      });\n    }\n    function _() {\n      var e,\n        t = l;\n      return (e = {\n        subscribe: function (e) {\n          if (\"object\" != typeof e || null === e) throw new Error(EL(11));\n          function i() {\n            e.next && e.next(u());\n          }\n          return i(), {\n            unsubscribe: t(i)\n          };\n        }\n      })[mL] = function () {\n        return this;\n      }, e;\n    }\n    return h({\n      type: SL.INIT\n    }), (r = {\n      dispatch: h,\n      subscribe: l,\n      getState: u,\n      replaceReducer: p\n    })[mL] = _, r;\n  }\n  function RL(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function IL(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? RL(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : RL(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  !function (e) {\n    e.SET_SESSION_ID = \"SET_SESSION_ID\", e.SET_P2P_ID = \"SET_P2P_id\", e.SET_DC_ID = \"SET_DC_id\", e.SET_UID = \"SET_UID\", e.SET_PUB_ID = \"SET_PUB_ID\", e.SET_CLOUD_PROXY_SERVER_MODE = \"SET_CLOUD_PROXY_SERVER_MODE\", e.KEY_METRIC_CLIENT_CREATED = \"KEY_METRIC_CLIENT_CREATED\", e.KEY_METRIC_JOIN_START = \"KEY_METRIC_JOIN_START\", e.AVOID_JOIN_START = \"AVOID_JOIN_START\", e.KEY_METRIC_JOIN_END = \"KEY_METRIC_JOIN_END\", e.KEY_METRIC_REQUEST_AP_START = \"KEY_METRIC_REQUEST_AP_START\", e.KEY_METRIC_REQUEST_AP_END = \"KEY_METRIC_REQUEST_AP_END\", e.KEY_METRIC_JOIN_GATEWAY_START = \"KEY_METRIC_JOIN_GATEWAY_START\", e.KEY_METRIC_JOIN_GATEWAY_END = \"KEY_METRIC_JOIN_GATEWAY_END\", e.KEY_METRIC_PEER_CONNECTION_START = \"KEY_METRIC_PEER_CONNECTION_START\", e.KEY_METRIC_PEER_CONNECTION_END = \"KEY_METRIC_PEER_CONNECTION_END\", e.KEY_METRIC_ICE_CONNECTION_END = \"KEY_METRIC_ICE_CONNECTION_END\", e.KEY_METRIC_SIGNAL_CHANNEL_OPEN = \"KEY_METRIC_SIGNAL_CHANNEL_OPEN\", e.KEY_METRIC_PUBLISH = \"KEY_METRIC_PUBLISH\", e.KEY_METRIC_SUBSCRIBE = \"KEY_METRIC_SUBSCRIBE\", e.RECORD_JOIN_CHANNEL_SERVICE = \"RECORD_JOIN_CHANNEL_SERVICE\", e.RESET_JOIN_CHANNEL_SERVICE_RECORDS = \"RESET_JOIN_CHANNEL_SERVICE_RECORDS\", e.RESET_KEY_METRICS = \"RESET_KEY_METRICS\";\n  }(fL || (fL = {}));\n  class yL {\n    constructor(e, t, i, r) {\n      mp(this, \"store\", void 0), mp(this, \"reducer\", void 0);\n      const n = {\n        codec: e,\n        audioCodec: t,\n        mode: i,\n        clientId: r,\n        sessionId: null,\n        p2pId: 0,\n        dcId: 0,\n        pubId: 0,\n        subId: 0,\n        avoidJoinStart: 0,\n        keyMetrics: {\n          publish: [],\n          subscribe: []\n        },\n        joinChannelServiceRecords: [],\n        cloudProxyServerMode: \"disabled\"\n      };\n      this.reducer = function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n,\n          t = arguments.length > 1 ? arguments[1] : void 0;\n        switch (t.type) {\n          case fL.SET_SESSION_ID:\n            return IL(IL({}, e), {}, {\n              sessionId: t.sessionId\n            });\n          case fL.SET_P2P_ID:\n            return IL(IL({}, e), {}, {\n              p2pId: t.p2pId\n            });\n          case fL.SET_UID:\n            return IL(IL({}, e), {}, {\n              uid: t.uid\n            });\n          case fL.SET_PUB_ID:\n            return IL(IL({}, e), {}, {\n              pubId: t.pubId\n            });\n          case fL.KEY_METRIC_CLIENT_CREATED:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                clientCreated: t.metric\n              })\n            });\n          case fL.KEY_METRIC_JOIN_START:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                joinStart: t.metric\n              })\n            });\n          case fL.AVOID_JOIN_START:\n            return IL(IL({}, e), {}, {\n              avoidJoinStart: t.avoidJoinStart\n            });\n          case fL.KEY_METRIC_JOIN_END:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                joinEnd: t.metric\n              })\n            });\n          case fL.KEY_METRIC_REQUEST_AP_START:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                requestAPStart: t.metric\n              })\n            });\n          case fL.KEY_METRIC_REQUEST_AP_END:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                requestAPEnd: t.metric\n              })\n            });\n          case fL.KEY_METRIC_JOIN_GATEWAY_START:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                joinGatewayStart: t.metric\n              })\n            });\n          case fL.KEY_METRIC_JOIN_GATEWAY_END:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                joinGatewayEnd: t.metric\n              })\n            });\n          case fL.KEY_METRIC_PEER_CONNECTION_START:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                peerConnectionStart: t.metric\n              })\n            });\n          case fL.KEY_METRIC_PEER_CONNECTION_END:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                peerConnectionEnd: t.metric\n              })\n            });\n          case fL.KEY_METRIC_SIGNAL_CHANNEL_OPEN:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                signalChannelOpen: t.metric\n              })\n            });\n          case fL.KEY_METRIC_ICE_CONNECTION_END:\n            return IL(IL({}, e), {}, {\n              keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                iceConnectionEnd: t.metric\n              })\n            });\n          case fL.KEY_METRIC_PUBLISH:\n            {\n              const i = e.keyMetrics.publish,\n                r = i.findIndex(e => e.trackId === t.metric.trackId);\n              return -1 !== r ? (i[r] = IL(IL({}, i[r]), t.metric), IL(IL({}, e), {}, {\n                keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                  publish: [...i]\n                })\n              })) : IL(IL({}, e), {}, {\n                keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                  publish: [...e.keyMetrics.publish, t.metric]\n                })\n              });\n            }\n          case fL.KEY_METRIC_SUBSCRIBE:\n            {\n              const i = e.keyMetrics.subscribe,\n                r = i.findIndex(e => e.userId === t.metric.userId && e.type === t.metric.type);\n              return -1 !== r ? (i[r] = IL(IL({}, i[r]), t.metric), IL(IL({}, e), {}, {\n                keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                  subscribe: [...i]\n                })\n              })) : IL(IL({}, e), {}, {\n                keyMetrics: IL(IL({}, e.keyMetrics), {}, {\n                  subscribe: [...e.keyMetrics.subscribe, t.metric]\n                })\n              });\n            }\n          case fL.SET_CLOUD_PROXY_SERVER_MODE:\n            return e.cloudProxyServerMode = t.mode, e;\n          case fL.RECORD_JOIN_CHANNEL_SERVICE:\n            return \"number\" != typeof t.index ? e.joinChannelServiceRecords = [...e.joinChannelServiceRecords, t.record] : (e.joinChannelServiceRecords[t.index] = IL(IL({}, e.joinChannelServiceRecords[t.index]), t.record), e.joinChannelServiceRecords = [...e.joinChannelServiceRecords]), e;\n          case fL.RESET_JOIN_CHANNEL_SERVICE_RECORDS:\n            return e.joinChannelServiceRecords = [], e;\n          case fL.RESET_KEY_METRICS:\n            return e.keyMetrics = {\n              publish: [],\n              subscribe: []\n            }, e;\n          default:\n            return e;\n        }\n      }, this.store = vL(this.reducer);\n    }\n    set sessionId(e) {\n      this.store.dispatch({\n        type: fL.SET_SESSION_ID,\n        sessionId: e\n      });\n    }\n    get sessionId() {\n      return this.store.getState().sessionId;\n    }\n    get codec() {\n      return this.store.getState().codec;\n    }\n    get audioCodec() {\n      return this.store.getState().audioCodec;\n    }\n    get clientId() {\n      return this.store.getState().clientId;\n    }\n    set p2pId(e) {\n      this.store.dispatch({\n        type: fL.SET_P2P_ID,\n        p2pId: e\n      });\n    }\n    get p2pId() {\n      return this.store.getState().p2pId;\n    }\n    set dcId(e) {\n      this.store.dispatch({\n        type: fL.SET_DC_ID,\n        dcId: e\n      });\n    }\n    get dcId() {\n      return this.store.getState().dcId;\n    }\n    set uid(e) {\n      this.store.dispatch({\n        type: fL.SET_UID,\n        uid: e\n      });\n    }\n    get uid() {\n      return this.store.getState().uid;\n    }\n    set pubId(e) {\n      this.store.dispatch({\n        type: fL.SET_PUB_ID,\n        pubId: e\n      });\n    }\n    get pubId() {\n      return this.store.getState().pubId;\n    }\n    set cloudProxyServerMode(e) {\n      this.store.dispatch({\n        type: fL.SET_CLOUD_PROXY_SERVER_MODE,\n        mode: e\n      });\n    }\n    get cloudProxyServerMode() {\n      return this.store.getState().cloudProxyServerMode;\n    }\n    clientCreated() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_CLIENT_CREATED,\n        metric: Date.now()\n      });\n    }\n    joinStart() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_JOIN_START,\n        metric: Date.now()\n      });\n    }\n    joinEnd() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_JOIN_END,\n        metric: Date.now()\n      });\n    }\n    requestAPStart() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_REQUEST_AP_START,\n        metric: Date.now()\n      });\n    }\n    requestAPEnd() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_REQUEST_AP_END,\n        metric: Date.now()\n      });\n    }\n    joinGatewayStart() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_JOIN_GATEWAY_START,\n        metric: Date.now()\n      });\n    }\n    joinGatewayEnd() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_JOIN_GATEWAY_END,\n        metric: Date.now()\n      });\n    }\n    peerConnectionStart() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_PEER_CONNECTION_START,\n        metric: Date.now()\n      });\n    }\n    peerConnectionEnd() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_PEER_CONNECTION_END,\n        metric: Date.now()\n      });\n    }\n    signalChannelOpen() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_SIGNAL_CHANNEL_OPEN,\n        metric: Date.now()\n      });\n    }\n    iceConnectionEnd() {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_ICE_CONNECTION_END,\n        metric: Date.now()\n      });\n    }\n    publish(e, t, i, r) {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_PUBLISH,\n        metric: IL(IL({\n          trackId: e,\n          type: t\n        }, i && {\n          publishStart: i\n        }), r && {\n          publishEnd: r\n        })\n      });\n    }\n    subscribe(e, t, i, r, n, o, s) {\n      this.store.dispatch({\n        type: fL.KEY_METRIC_SUBSCRIBE,\n        metric: IL(IL(IL(IL(IL({\n          userId: e,\n          type: t\n        }, i && {\n          subscribeStart: i\n        }), r && {\n          subscribeEnd: r\n        }), n && {\n          firstFrame: n\n        }), o && {\n          streamAdded: o\n        }), s && {\n          firstDecoded: s\n        })\n      });\n    }\n    massSubscribe(e, t, i, r) {\n      e.forEach(e => {\n        this.store.dispatch({\n          type: fL.KEY_METRIC_SUBSCRIBE,\n          metric: IL(IL(IL({\n            userId: e.userId,\n            type: e.type\n          }, t && {\n            subscribeStart: t\n          }), i && {\n            subscribeEnd: i\n          }), r && {\n            firstFrame: r\n          })\n        });\n      });\n    }\n    get keyMetrics() {\n      return this.store.getState().keyMetrics;\n    }\n    recordJoinChannelService(e, t) {\n      \"gateway\" === e.service && Array.isArray(e.urls) && (e.urls = e.urls.map(e => e.replace(/(\\d+)-\\d+-\\d+-(\\d+)/, \"$1-*-*-$2\")));\n      try {\n        return \"number\" != typeof t ? (this.store.dispatch({\n          type: fL.RECORD_JOIN_CHANNEL_SERVICE,\n          record: IL(IL({}, e), {}, {\n            sessionId: this.sessionId,\n            cloudProxyMode: this.cloudProxyServerMode,\n            uid: this.uid\n          })\n        }), this.store.getState().joinChannelServiceRecords.length - 1) : (t < 0 || t >= this.store.getState().joinChannelServiceRecords.length || this.store.dispatch({\n          type: fL.RECORD_JOIN_CHANNEL_SERVICE,\n          record: e,\n          index: t\n        }), t);\n      } catch (e) {\n        return 0;\n      }\n    }\n    resetJoinChannelServiceRecords() {\n      this.store.dispatch({\n        type: fL.RESET_JOIN_CHANNEL_SERVICE_RECORDS\n      });\n    }\n    resetKeyMetrics() {\n      this.store.dispatch({\n        type: fL.RESET_KEY_METRICS\n      });\n    }\n    get joinChannelServiceRecords() {\n      try {\n        return this.store.getState().joinChannelServiceRecords;\n      } catch (e) {\n        return [];\n      }\n    }\n    get avoidJoinStart() {\n      return this.store.getState().avoidJoinStart;\n    }\n    set avoidJoinStart(e) {\n      this.store.dispatch({\n        type: fL.AVOID_JOIN_START,\n        avoidJoinStart: e\n      });\n    }\n  }\n  let CL;\n  const AL = () => \"HTTPS\" === (CL || CL || (CL = (window.location.protocol.split(\":\")[0] || \"\").toUpperCase(), CL)),\n    OL = () => void 0 !== window.isSecureContext;\n  function bL(e) {\n    let t = jL();\n    return function (e, t) {\n      let i = e.appId;\n      void 0 !== i && ($L(t, 10), YL(t, i));\n      let r = e.cid;\n      void 0 !== r && ($L(t, 16), $L(t, r));\n      let n = e.cname;\n      void 0 !== n && ($L(t, 26), YL(t, n));\n      let o = e.deviceId;\n      void 0 !== o && ($L(t, 34), YL(t, o));\n      let s = e.elapse;\n      void 0 !== s && ($L(t, 40), ek(t, s));\n      let a = e.fileSize;\n      void 0 !== a && ($L(t, 48), ek(t, xL(a)));\n      let c = e.height;\n      void 0 !== c && ($L(t, 56), ek(t, xL(c)));\n      let d = e.jpg;\n      void 0 !== d && ($L(t, 66), $L(t, d.length), function (e, t) {\n        let i = WL(e, t.length);\n        e.bytes.set(t, i);\n      }(t, d));\n      let u = e.networkType;\n      void 0 !== u && ($L(t, 72), ek(t, xL(u)));\n      let l = e.osType;\n      void 0 !== l && ($L(t, 80), ek(t, xL(l)));\n      let h = e.requestId;\n      void 0 !== h && ($L(t, 90), YL(t, h));\n      let p = e.sdkVersion;\n      void 0 !== p && ($L(t, 98), YL(t, p));\n      let _ = e.sequence;\n      void 0 !== _ && ($L(t, 104), ek(t, xL(_)));\n      let E = e.sid;\n      void 0 !== E && ($L(t, 114), YL(t, E));\n      let f = e.timestamp;\n      void 0 !== f && ($L(t, 120), ek(t, f));\n      let m = e.uid;\n      void 0 !== m && ($L(t, 128), $L(t, m));\n      let g = e.vid;\n      void 0 !== g && ($L(t, 136), $L(t, g));\n      let S = e.width;\n      void 0 !== S && ($L(t, 144), ek(t, xL(S)));\n      let T = e.service;\n      void 0 !== T && ($L(t, 152), $L(t, T));\n      let v = e.callbackData;\n      void 0 !== v && ($L(t, 162), YL(t, v));\n      let R = e.jpgEncryption;\n      void 0 !== R && ($L(t, 168), $L(t, R));\n      let I = e.requestType;\n      void 0 !== I && ($L(t, 176), $L(t, I));\n      let y = e.scorePorn;\n      void 0 !== y && ($L(t, 185), QL(t, y));\n      let C = e.scoreSexy;\n      void 0 !== C && ($L(t, 193), QL(t, C));\n      let A = e.scoreNeutral;\n      void 0 !== A && ($L(t, 201), QL(t, A));\n      let O = e.scene;\n      void 0 !== O && ($L(t, 208), $L(t, O));\n      let b = e.ossFilePrefix;\n      void 0 !== b && ($L(t, 218), YL(t, b));\n      let w = e.serviceVendor;\n      if (void 0 !== w) for (let e of w) {\n        $L(t, 226);\n        let i = jL();\n        DL(e, i), $L(t, i.limit), qL(t, i), FL(i);\n      }\n    }(e, t), function (e) {\n      let t = e.bytes,\n        i = e.limit;\n      return t.length === i ? t : t.subarray(0, i);\n    }(t);\n  }\n  function wL(e) {\n    return function (e) {\n      let t = {};\n      e: for (; !GL(e);) {\n        let i = ZL(e);\n        switch (i >>> 3) {\n          case 0:\n            break e;\n          case 1:\n            t.code = ZL(e);\n            break;\n          case 2:\n            t.msg = KL(e, ZL(e));\n            break;\n          case 3:\n            {\n              let i = PL(e);\n              t.data = NL(e), e.limit = i;\n              break;\n            }\n          default:\n            LL(e, 7 & i);\n        }\n      }\n      return t;\n    }({\n      bytes: t = e,\n      offset: 0,\n      limit: t.length\n    });\n    var t;\n  }\n  function NL(e) {\n    let t = {};\n    e: for (; !GL(e);) {\n      let i = ZL(e);\n      switch (i >>> 3) {\n        case 0:\n          break e;\n        case 1:\n          t.requestId = KL(e, ZL(e));\n          break;\n        case 2:\n          t.requestType = ZL(e) >>> 0;\n          break;\n        case 3:\n          t.scorePorn = zL(e);\n          break;\n        case 4:\n          t.scoreSexy = zL(e);\n          break;\n        case 5:\n          t.scoreNeutral = zL(e);\n          break;\n        case 6:\n          t.requestScene = ZL(e) >>> 0;\n          break;\n        case 7:\n          t.scene = ZL(e) >>> 0;\n          break;\n        default:\n          LL(e, 7 & i);\n      }\n    }\n    return t;\n  }\n  function DL(e, t) {\n    let i = e.service;\n    void 0 !== i && ($L(t, 8), $L(t, i));\n    let r = e.vendor;\n    void 0 !== r && ($L(t, 16), $L(t, r));\n    let n = e.token;\n    void 0 !== n && ($L(t, 26), YL(t, n));\n    let o = e.callbackUrl;\n    void 0 !== o && ($L(t, 34), YL(t, o));\n  }\n  function PL(e) {\n    let t = ZL(e),\n      i = e.limit;\n    return e.limit = e.offset + t, i;\n  }\n  function LL(e, t) {\n    switch (t) {\n      case 0:\n        for (; 128 & JL(e););\n        break;\n      case 2:\n        BL(e, ZL(e));\n        break;\n      case 5:\n        BL(e, 4);\n        break;\n      case 1:\n        BL(e, 8);\n        break;\n      default:\n        throw new Error(\"Unimplemented type: \" + t);\n    }\n  }\n  let kL = new Float32Array(1);\n  new Uint8Array(kL.buffer);\n  let ML = new Float64Array(1),\n    UL = new Uint8Array(ML.buffer);\n  function xL(e) {\n    return {\n      low: e |= 0,\n      high: e >> 31,\n      unsigned: e >= 0\n    };\n  }\n  let VL = [];\n  function jL() {\n    const e = VL.pop();\n    return e ? (e.offset = e.limit = 0, e) : {\n      bytes: new Uint8Array(64),\n      offset: 0,\n      limit: 0\n    };\n  }\n  function FL(e) {\n    VL.push(e);\n  }\n  function BL(e, t) {\n    if (e.offset + t > e.limit) throw new Error(\"Skip past limit\");\n    e.offset += t;\n  }\n  function GL(e) {\n    return e.offset >= e.limit;\n  }\n  function WL(e, t) {\n    let i = e.bytes,\n      r = e.offset,\n      n = e.limit,\n      o = r + t;\n    if (o > i.length) {\n      let t = new Uint8Array(2 * o);\n      t.set(i), e.bytes = t;\n    }\n    return e.offset = o, o > n && (e.limit = o), r;\n  }\n  function HL(e, t) {\n    let i = e.offset;\n    if (i + t > e.limit) throw new Error(\"Read past limit\");\n    return e.offset += t, i;\n  }\n  function KL(e, t) {\n    let i = HL(e, t),\n      r = String.fromCharCode,\n      n = e.bytes,\n      o = \"ï¿½\",\n      s = \"\";\n    for (let e = 0; e < t; e++) {\n      let a,\n        c,\n        d,\n        u,\n        l = n[e + i];\n      0 == (128 & l) ? s += r(l) : 192 == (224 & l) ? e + 1 >= t ? s += o : (a = n[e + i + 1], 128 != (192 & a) ? s += o : (u = (31 & l) << 6 | 63 & a, u < 128 ? s += o : (s += r(u), e++))) : 224 == (240 & l) ? e + 2 >= t ? s += o : (a = n[e + i + 1], c = n[e + i + 2], 32896 != (49344 & (a | c << 8)) ? s += o : (u = (15 & l) << 12 | (63 & a) << 6 | 63 & c, u < 2048 || u >= 55296 && u <= 57343 ? s += o : (s += r(u), e += 2))) : 240 == (248 & l) ? e + 3 >= t ? s += o : (a = n[e + i + 1], c = n[e + i + 2], d = n[e + i + 3], 8421504 != (12632256 & (a | c << 8 | d << 16)) ? s += o : (u = (7 & l) << 18 | (63 & a) << 12 | (63 & c) << 6 | 63 & d, u < 65536 || u > 1114111 ? s += o : (u -= 65536, s += r(55296 + (u >> 10), 56320 + (1023 & u)), e += 3))) : s += o;\n    }\n    return s;\n  }\n  function YL(e, t) {\n    let i = t.length,\n      r = 0;\n    for (let e = 0; e < i; e++) {\n      let n = t.charCodeAt(e);\n      n >= 55296 && n <= 56319 && e + 1 < i && (n = (n << 10) + t.charCodeAt(++e) - 56613888), r += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;\n    }\n    $L(e, r);\n    let n = WL(e, r),\n      o = e.bytes;\n    for (let e = 0; e < i; e++) {\n      let r = t.charCodeAt(e);\n      r >= 55296 && r <= 56319 && e + 1 < i && (r = (r << 10) + t.charCodeAt(++e) - 56613888), r < 128 ? o[n++] = r : (r < 2048 ? o[n++] = r >> 6 & 31 | 192 : (r < 65536 ? o[n++] = r >> 12 & 15 | 224 : (o[n++] = r >> 18 & 7 | 240, o[n++] = r >> 12 & 63 | 128), o[n++] = r >> 6 & 63 | 128), o[n++] = 63 & r | 128);\n    }\n  }\n  function qL(e, t) {\n    let i = WL(e, t.limit),\n      r = e.bytes,\n      n = t.bytes;\n    for (let e = 0, o = t.limit; e < o; e++) r[e + i] = n[e];\n  }\n  function JL(e) {\n    return e.bytes[HL(e, 1)];\n  }\n  function XL(e, t) {\n    let i = WL(e, 1);\n    e.bytes[i] = t;\n  }\n  function zL(e) {\n    let t = HL(e, 8),\n      i = e.bytes;\n    return UL[0] = i[t++], UL[1] = i[t++], UL[2] = i[t++], UL[3] = i[t++], UL[4] = i[t++], UL[5] = i[t++], UL[6] = i[t++], UL[7] = i[t++], ML[0];\n  }\n  function QL(e, t) {\n    let i = WL(e, 8),\n      r = e.bytes;\n    ML[0] = t, r[i++] = UL[0], r[i++] = UL[1], r[i++] = UL[2], r[i++] = UL[3], r[i++] = UL[4], r[i++] = UL[5], r[i++] = UL[6], r[i++] = UL[7];\n  }\n  function ZL(e) {\n    let t,\n      i = 0,\n      r = 0;\n    do {\n      t = JL(e), i < 32 && (r |= (127 & t) << i), i += 7;\n    } while (128 & t);\n    return r;\n  }\n  function $L(e, t) {\n    for (t >>>= 0; t >= 128;) XL(e, 127 & t | 128), t >>>= 7;\n    XL(e, t);\n  }\n  function ek(e, t) {\n    let i = t.low >>> 0,\n      r = (t.low >>> 28 | t.high << 4) >>> 0,\n      n = t.high >>> 24,\n      o = 0 === n ? 0 === r ? i < 16384 ? i < 128 ? 1 : 2 : i < 1 << 21 ? 3 : 4 : r < 16384 ? r < 128 ? 5 : 6 : r < 1 << 21 ? 7 : 8 : n < 128 ? 9 : 10,\n      s = WL(e, o),\n      a = e.bytes;\n    switch (o) {\n      case 10:\n        a[s + 9] = n >>> 7 & 1;\n      case 9:\n        a[s + 8] = 9 !== o ? 128 | n : 127 & n;\n      case 8:\n        a[s + 7] = 8 !== o ? r >>> 21 | 128 : r >>> 21 & 127;\n      case 7:\n        a[s + 6] = 7 !== o ? r >>> 14 | 128 : r >>> 14 & 127;\n      case 6:\n        a[s + 5] = 6 !== o ? r >>> 7 | 128 : r >>> 7 & 127;\n      case 5:\n        a[s + 4] = 5 !== o ? 128 | r : 127 & r;\n      case 4:\n        a[s + 3] = 4 !== o ? i >>> 21 | 128 : i >>> 21 & 127;\n      case 3:\n        a[s + 2] = 3 !== o ? i >>> 14 | 128 : i >>> 14 & 127;\n      case 2:\n        a[s + 1] = 2 !== o ? i >>> 7 | 128 : i >>> 7 & 127;\n      case 1:\n        a[s] = 1 !== o ? 128 | i : 127 & i;\n    }\n  }\n  var tk = {};\n  Object.defineProperty(tk, \"__esModule\", {\n    value: !0\n  });\n  var ik = function () {\n      function e() {\n        this._dataLength = 0, this._bufferLength = 0, this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();\n      }\n      return e.hashStr = function (e, t) {\n        return void 0 === t && (t = !1), this.onePassHasher.start().appendStr(e).end(t);\n      }, e.hashAsciiStr = function (e, t) {\n        return void 0 === t && (t = !1), this.onePassHasher.start().appendAsciiStr(e).end(t);\n      }, e._hex = function (t) {\n        var i,\n          r,\n          n,\n          o,\n          s = e.hexChars,\n          a = e.hexOut;\n        for (o = 0; o < 4; o += 1) for (r = 8 * o, i = t[o], n = 0; n < 8; n += 2) a[r + 1 + n] = s.charAt(15 & i), i >>>= 4, a[r + 0 + n] = s.charAt(15 & i), i >>>= 4;\n        return a.join(\"\");\n      }, e._md5cycle = function (e, t) {\n        var i = e[0],\n          r = e[1],\n          n = e[2],\n          o = e[3];\n        r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & n | ~r & o) + t[0] - 680876936 | 0) << 7 | i >>> 25) + r | 0) & r | ~i & n) + t[1] - 389564586 | 0) << 12 | o >>> 20) + i | 0) & i | ~o & r) + t[2] + 606105819 | 0) << 17 | n >>> 15) + o | 0) & o | ~n & i) + t[3] - 1044525330 | 0) << 22 | r >>> 10) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & n | ~r & o) + t[4] - 176418897 | 0) << 7 | i >>> 25) + r | 0) & r | ~i & n) + t[5] + 1200080426 | 0) << 12 | o >>> 20) + i | 0) & i | ~o & r) + t[6] - 1473231341 | 0) << 17 | n >>> 15) + o | 0) & o | ~n & i) + t[7] - 45705983 | 0) << 22 | r >>> 10) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & n | ~r & o) + t[8] + 1770035416 | 0) << 7 | i >>> 25) + r | 0) & r | ~i & n) + t[9] - 1958414417 | 0) << 12 | o >>> 20) + i | 0) & i | ~o & r) + t[10] - 42063 | 0) << 17 | n >>> 15) + o | 0) & o | ~n & i) + t[11] - 1990404162 | 0) << 22 | r >>> 10) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & n | ~r & o) + t[12] + 1804603682 | 0) << 7 | i >>> 25) + r | 0) & r | ~i & n) + t[13] - 40341101 | 0) << 12 | o >>> 20) + i | 0) & i | ~o & r) + t[14] - 1502002290 | 0) << 17 | n >>> 15) + o | 0) & o | ~n & i) + t[15] + 1236535329 | 0) << 22 | r >>> 10) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & o | n & ~o) + t[1] - 165796510 | 0) << 5 | i >>> 27) + r | 0) & n | r & ~n) + t[6] - 1069501632 | 0) << 9 | o >>> 23) + i | 0) & r | i & ~r) + t[11] + 643717713 | 0) << 14 | n >>> 18) + o | 0) & i | o & ~i) + t[0] - 373897302 | 0) << 20 | r >>> 12) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & o | n & ~o) + t[5] - 701558691 | 0) << 5 | i >>> 27) + r | 0) & n | r & ~n) + t[10] + 38016083 | 0) << 9 | o >>> 23) + i | 0) & r | i & ~r) + t[15] - 660478335 | 0) << 14 | n >>> 18) + o | 0) & i | o & ~i) + t[4] - 405537848 | 0) << 20 | r >>> 12) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & o | n & ~o) + t[9] + 568446438 | 0) << 5 | i >>> 27) + r | 0) & n | r & ~n) + t[14] - 1019803690 | 0) << 9 | o >>> 23) + i | 0) & r | i & ~r) + t[3] - 187363961 | 0) << 14 | n >>> 18) + o | 0) & i | o & ~i) + t[8] + 1163531501 | 0) << 20 | r >>> 12) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r & o | n & ~o) + t[13] - 1444681467 | 0) << 5 | i >>> 27) + r | 0) & n | r & ~n) + t[2] - 51403784 | 0) << 9 | o >>> 23) + i | 0) & r | i & ~r) + t[7] + 1735328473 | 0) << 14 | n >>> 18) + o | 0) & i | o & ~i) + t[12] - 1926607734 | 0) << 20 | r >>> 12) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r ^ n ^ o) + t[5] - 378558 | 0) << 4 | i >>> 28) + r | 0) ^ r ^ n) + t[8] - 2022574463 | 0) << 11 | o >>> 21) + i | 0) ^ i ^ r) + t[11] + 1839030562 | 0) << 16 | n >>> 16) + o | 0) ^ o ^ i) + t[14] - 35309556 | 0) << 23 | r >>> 9) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r ^ n ^ o) + t[1] - 1530992060 | 0) << 4 | i >>> 28) + r | 0) ^ r ^ n) + t[4] + 1272893353 | 0) << 11 | o >>> 21) + i | 0) ^ i ^ r) + t[7] - 155497632 | 0) << 16 | n >>> 16) + o | 0) ^ o ^ i) + t[10] - 1094730640 | 0) << 23 | r >>> 9) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r ^ n ^ o) + t[13] + 681279174 | 0) << 4 | i >>> 28) + r | 0) ^ r ^ n) + t[0] - 358537222 | 0) << 11 | o >>> 21) + i | 0) ^ i ^ r) + t[3] - 722521979 | 0) << 16 | n >>> 16) + o | 0) ^ o ^ i) + t[6] + 76029189 | 0) << 23 | r >>> 9) + n | 0, r = ((r += ((n = ((n += ((o = ((o += ((i = ((i += (r ^ n ^ o) + t[9] - 640364487 | 0) << 4 | i >>> 28) + r | 0) ^ r ^ n) + t[12] - 421815835 | 0) << 11 | o >>> 21) + i | 0) ^ i ^ r) + t[15] + 530742520 | 0) << 16 | n >>> 16) + o | 0) ^ o ^ i) + t[2] - 995338651 | 0) << 23 | r >>> 9) + n | 0, r = ((r += ((o = ((o += (r ^ ((i = ((i += (n ^ (r | ~o)) + t[0] - 198630844 | 0) << 6 | i >>> 26) + r | 0) | ~n)) + t[7] + 1126891415 | 0) << 10 | o >>> 22) + i | 0) ^ ((n = ((n += (i ^ (o | ~r)) + t[14] - 1416354905 | 0) << 15 | n >>> 17) + o | 0) | ~i)) + t[5] - 57434055 | 0) << 21 | r >>> 11) + n | 0, r = ((r += ((o = ((o += (r ^ ((i = ((i += (n ^ (r | ~o)) + t[12] + 1700485571 | 0) << 6 | i >>> 26) + r | 0) | ~n)) + t[3] - 1894986606 | 0) << 10 | o >>> 22) + i | 0) ^ ((n = ((n += (i ^ (o | ~r)) + t[10] - 1051523 | 0) << 15 | n >>> 17) + o | 0) | ~i)) + t[1] - 2054922799 | 0) << 21 | r >>> 11) + n | 0, r = ((r += ((o = ((o += (r ^ ((i = ((i += (n ^ (r | ~o)) + t[8] + 1873313359 | 0) << 6 | i >>> 26) + r | 0) | ~n)) + t[15] - 30611744 | 0) << 10 | o >>> 22) + i | 0) ^ ((n = ((n += (i ^ (o | ~r)) + t[6] - 1560198380 | 0) << 15 | n >>> 17) + o | 0) | ~i)) + t[13] + 1309151649 | 0) << 21 | r >>> 11) + n | 0, r = ((r += ((o = ((o += (r ^ ((i = ((i += (n ^ (r | ~o)) + t[4] - 145523070 | 0) << 6 | i >>> 26) + r | 0) | ~n)) + t[11] - 1120210379 | 0) << 10 | o >>> 22) + i | 0) ^ ((n = ((n += (i ^ (o | ~r)) + t[2] + 718787259 | 0) << 15 | n >>> 17) + o | 0) | ~i)) + t[9] - 343485551 | 0) << 21 | r >>> 11) + n | 0, e[0] = i + e[0] | 0, e[1] = r + e[1] | 0, e[2] = n + e[2] | 0, e[3] = o + e[3] | 0;\n      }, e.prototype.start = function () {\n        return this._dataLength = 0, this._bufferLength = 0, this._state.set(e.stateIdentity), this;\n      }, e.prototype.appendStr = function (t) {\n        var i,\n          r,\n          n = this._buffer8,\n          o = this._buffer32,\n          s = this._bufferLength;\n        for (r = 0; r < t.length; r += 1) {\n          if ((i = t.charCodeAt(r)) < 128) n[s++] = i;else if (i < 2048) n[s++] = 192 + (i >>> 6), n[s++] = 63 & i | 128;else if (i < 55296 || i > 56319) n[s++] = 224 + (i >>> 12), n[s++] = i >>> 6 & 63 | 128, n[s++] = 63 & i | 128;else {\n            if ((i = 1024 * (i - 55296) + (t.charCodeAt(++r) - 56320) + 65536) > 1114111) throw new Error(\"Unicode standard supports code points up to U+10FFFF\");\n            n[s++] = 240 + (i >>> 18), n[s++] = i >>> 12 & 63 | 128, n[s++] = i >>> 6 & 63 | 128, n[s++] = 63 & i | 128;\n          }\n          s >= 64 && (this._dataLength += 64, e._md5cycle(this._state, o), s -= 64, o[0] = o[16]);\n        }\n        return this._bufferLength = s, this;\n      }, e.prototype.appendAsciiStr = function (t) {\n        for (var i, r = this._buffer8, n = this._buffer32, o = this._bufferLength, s = 0;;) {\n          for (i = Math.min(t.length - s, 64 - o); i--;) r[o++] = t.charCodeAt(s++);\n          if (o < 64) break;\n          this._dataLength += 64, e._md5cycle(this._state, n), o = 0;\n        }\n        return this._bufferLength = o, this;\n      }, e.prototype.appendByteArray = function (t) {\n        for (var i, r = this._buffer8, n = this._buffer32, o = this._bufferLength, s = 0;;) {\n          for (i = Math.min(t.length - s, 64 - o); i--;) r[o++] = t[s++];\n          if (o < 64) break;\n          this._dataLength += 64, e._md5cycle(this._state, n), o = 0;\n        }\n        return this._bufferLength = o, this;\n      }, e.prototype.getState = function () {\n        var e = this._state;\n        return {\n          buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),\n          buflen: this._bufferLength,\n          length: this._dataLength,\n          state: [e[0], e[1], e[2], e[3]]\n        };\n      }, e.prototype.setState = function (e) {\n        var t,\n          i = e.buffer,\n          r = e.state,\n          n = this._state;\n        for (this._dataLength = e.length, this._bufferLength = e.buflen, n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], t = 0; t < i.length; t += 1) this._buffer8[t] = i.charCodeAt(t);\n      }, e.prototype.end = function (t) {\n        void 0 === t && (t = !1);\n        var i = this._bufferLength,\n          r = this._buffer8,\n          n = this._buffer32,\n          o = 1 + (i >> 2);\n        this._dataLength += i;\n        var s = 8 * this._dataLength;\n        if (r[i] = 128, r[i + 1] = r[i + 2] = r[i + 3] = 0, n.set(e.buffer32Identity.subarray(o), o), i > 55 && (e._md5cycle(this._state, n), n.set(e.buffer32Identity)), s <= 4294967295) n[14] = s;else {\n          var a = s.toString(16).match(/(.*?)(.{0,8})$/);\n          if (null === a) return;\n          var c = parseInt(a[2], 16),\n            d = parseInt(a[1], 16) || 0;\n          n[14] = c, n[15] = d;\n        }\n        return e._md5cycle(this._state, n), t ? this._state : e._hex(this._state);\n      }, e.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]), e.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.hexChars = \"0123456789abcdef\", e.hexOut = [], e.onePassHasher = new e(), e;\n    }(),\n    rk = tk.Md5 = ik;\n  if (\"5d41402abc4b2a76b9719d911017c592\" !== ik.hashStr(\"hello\")) throw new Error(\"Md5 self test failed.\");\n  const nk = async (e, t, i) => await (async (e, t, i) => {\n    const r = \"\" + t + i,\n      n = new Uint8Array(rk.hashStr(r, !0).buffer).slice(0, 16),\n      o = n.slice(0, 12),\n      s = await window.crypto.subtle.importKey(\"raw\", n, \"AES-GCM\", !0, [\"encrypt\"]);\n    return new Uint8Array(await window.crypto.subtle.encrypt({\n      name: \"AES-GCM\",\n      iv: o\n    }, s, e));\n  })(e.buffer, t, i);\n  function ok(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  const sk = new Map([[\"moderation\", 1], [\"supervise\", 2]]);\n  class ak extends gE {\n    get connectionState() {\n      return this._connectionState;\n    }\n    set connectionState(e) {\n      if (this._connectionState === e) return;\n      const t = this._connectionState;\n      this._connectionState = e, this.emit(kg.CONNECTION_STATE_CHANGE, t, e);\n    }\n    get inspectType() {\n      return this._inspectType;\n    }\n    set inspectType(e) {\n      var t;\n      this._inspectMode = zi(t = e.map(e => sk.get(e) || 0)).call(t, (e, t) => e + t), this._inspectType = e;\n    }\n    get quality() {\n      return this._quality;\n    }\n    set quality(e) {\n      this._quality = e > 1 ? 1 : e < .1 ? .1 : e, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {\n        this.quality = this._quality / this.qualityRatio;\n      }, 6e4));\n    }\n    constructor(e) {\n      super(), mp(this, \"name\", \"AgoraRTCVideoContentInspect\"), mp(this, \"_connectionState\", Pg.CONNECTING), mp(this, \"_innerConnectionState\", void 0), mp(this, \"sequence\", 0), mp(this, \"inspectStartTime\", void 0), mp(this, \"workerManagerConnection\", void 0), mp(this, \"workerConnection\", void 0), mp(this, \"workerMessageLengthLimit\", void 0), mp(this, \"inspectIntervalMinimum\", void 0), mp(this, \"qualityRatio\", void 0), mp(this, \"_connectInfo\", void 0), mp(this, \"_cancelTokenSource\", fE.CancelToken.source()), mp(this, \"_retryConfig\", void 0), mp(this, \"wmSequence\", 0), mp(this, \"inspectInterval\", void 0), mp(this, \"inspectTimer\", null), mp(this, \"ossFilePrefix\", void 0), mp(this, \"extraInfo\", void 0), mp(this, \"_inspectType\", void 0), mp(this, \"_inspectMode\", void 0), mp(this, \"_quality\", 1), mp(this, \"qualityTimer\", null), mp(this, \"_inspectId\", void 0), mp(this, \"_needWorkUrlOnly\", !1), mp(this, \"inspectImage\", () => {\n        if (this.connectionState !== Pg.CONNECTED) throw new vE(TE.OPERATION_ABORTED, \"content inspect service connection status is \".concat(this.connectionState));\n        this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {\n          this.connectionState === Pg.CONNECTED ? this.requestToInspectImage() : NE.debug(\"[\".concat(this._inspectId, \"] Inspect State is not connected , \"), this.connectionState);\n        }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage();\n      }), this._inspectId = MR(5, \"inspect-\"), this.workerMessageLengthLimit = HE(\"VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT\"), this.inspectIntervalMinimum = HE(\"VIDEO_INSPECT_INTERVAL_MINIMUM\"), this.qualityRatio = HE(\"VIDEO_INSPECT_QUALITY_RATIO\"), this.inspectInterval = e.interval, this.ossFilePrefix = e.ossFilePrefix, this.extraInfo = e.extraInfo, this.inspectType = e.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new $A(\"worker-manager-\" + this._inspectId, RE), this.on(kg.STATE_CHANGE, (e, t) => {\n        this._innerConnectionState = e, NE.debug(\"[\".concat(this._inspectId, \"] Inspect operation :\").concat(Lg[e], \" \").concat(t || \"\"));\n      }), this.handleWorkerManagerEvents(), this.workerConnection = new $A(\"worker-\" + this._inspectId, RE), this.handleWorkerEvents();\n    }\n    async init(e, t) {\n      this.emit(kg.STATE_CHANGE, Lg.CONNECT_AP), this._connectInfo = e;\n      const i = this._cancelTokenSource.token;\n      return this._retryConfig = t, new Cl((r, n) => {\n        this.on(kg.CONNECTION_STATE_CHANGE, (e, t) => {\n          t === Pg.CONNECTED && r();\n        }), this.requestAP(e, i, t).then(e => {\n          this.connectWorkerManager(e);\n        }).catch(e => {\n          n(e);\n        });\n      });\n    }\n    async requestAP(e, t, i) {\n      const r = HE(\"WEBCS_DOMAIN\").map(e => \"https://\".concat(e, \"/api/v1\")),\n        n = await function (e, t, i, r) {\n          let {\n            appId: n,\n            areaCode: o,\n            cname: s,\n            sid: a,\n            token: c,\n            uid: d\n          } = t;\n          OO++;\n          const u = \"image_moderation_api\",\n            l = {\n              service_name: u,\n              json_body: JSON.stringify({\n                appId: n,\n                areaCode: o,\n                cname: s,\n                command: \"allocateEdge\",\n                requestId: OO,\n                seq: OO,\n                sid: a,\n                token: c,\n                ts: Date.now(),\n                uid: d + \"\"\n              })\n            };\n          let h,\n            p,\n            _ = e[0];\n          return yE(async () => {\n            h = Date.now();\n            const e = await lT(_, {\n              data: l,\n              cancelToken: i,\n              headers: {\n                \"X-Packet-Service-Type\": \"0\",\n                \"X-Packet-URI\": \"61\"\n              },\n              params: {\n                action: \"wrtc_gateway\"\n              }\n            });\n            if (p = Date.now() - h, 0 !== e.code) {\n              const t = new vE(TE.UNEXPECTED_RESPONSE, \"image inspect ap error, code\" + e.code, {\n                retry: !0,\n                responseTime: p\n              });\n              throw NE.error(t.toString()), t;\n            }\n            const t = JSON.parse(e.json_body);\n            if (200 !== t.code) {\n              const e = new vE(TE.UNEXPECTED_RESPONSE, \"image inspect ap error, code: \".concat(t.code, \", reason: \").concat(t.reason), {\n                code: t.code,\n                responseTime: p\n              });\n              throw NE.error(e.toString()), e;\n            }\n            if (!t.servers || !Array.isArray(t.servers) || 0 === t.servers.length) {\n              const e = new vE(TE.UNEXPECTED_RESPONSE, \"image inspect ap empty server\", {\n                code: t.code,\n                responseTime: p\n              });\n              throw NE.error(e.toString()), e;\n            }\n            const r = HE(\"VIDEO_INSPECT_WORKER_MANAGER_HOST\"),\n              n = HE(\"VIDEO_INSPECT_WORKER_MANAGER_PORT\");\n            return {\n              addressList: t.servers.map(e => {\n                let {\n                  address: t,\n                  wss: i\n                } = e;\n                if (t && i) return \"wss://\".concat(t.replace(/\\./g, \"-\"), \".\").concat(r, \":\").concat(n || i);\n              }).filter(e => !!e),\n              workerToken: t.workerToken,\n              vid: t.vid,\n              responseTime: p\n            };\n          }, (t, i) => (IT.apworkerEvent(a, {\n            success: !0,\n            sc: 200,\n            serviceName: u,\n            responseDetail: JSON.stringify(t.addressList),\n            firstSuccess: 0 === i,\n            responseTime: p,\n            serverIp: e[i % e.length]\n          }), !1), (t, i) => (IT.apworkerEvent(a, {\n            success: !1,\n            sc: t.data && t.data.code || 200,\n            serviceName: u,\n            responseTime: p,\n            serverIp: e[i % e.length]\n          }), !!(t.code !== TE.OPERATION_ABORTED && t.code !== TE.UNEXPECTED_RESPONSE || t.data && t.data.retry) && (_ = e[(i + 1) % e.length], !0)), r);\n        }(r, e, t, i);\n      this.emit(kg.STATE_CHANGE, Lg.AP_CONNECTED);\n      const {\n        addressList: o\n      } = n;\n      return this.wmSequence++, o;\n    }\n    async connectWorkerManager(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      this._needWorkUrlOnly = t, this.emit(kg.STATE_CHANGE, Lg.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e, 1e4);\n    }\n    async connectWorker(e) {\n      await this.workerConnection.init([e]);\n    }\n    handleWorkerManagerEvents() {\n      this.workerManagerConnection.on(Km.CONNECTED, async () => {\n        this.emit(kg.STATE_CHANGE, Lg.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({\n          appId: this._connectInfo.appId,\n          cname: this._connectInfo.cname,\n          uid: this._connectInfo.uid + \"\",\n          sdkVersion: \"4.16.1\",\n          sid: this._connectInfo.sid,\n          seq: this.wmSequence,\n          ts: Number(Date.now()),\n          requestId: Math.floor(1e12 * Math.random()),\n          allocate: !0,\n          clientRequest: {\n            command: \"join\"\n          }\n        }, !0);\n      }), this.workerManagerConnection.on(Km.CLOSED, () => {\n        this._innerConnectionState < Lg.GET_WORKER_MANAGER_RESPONSE && NE.debug(\"[\".concat(this._inspectId, \"] Inspect worker manager is closed before connecting worker\"));\n      }), this.workerManagerConnection.on(Km.FAILED, () => {\n        this._innerConnectionState < Lg.GET_WORKER_MANAGER_RESPONSE && NE.debug(\"[\".concat(this._inspectId, \"] Connecting inspect worker manager is failed before connecting worker\"));\n      }), this.workerManagerConnection.on(Km.RECONNECTING, () => {\n        this._innerConnectionState < Lg.GET_WORKER_MANAGER_RESPONSE && NE.debug(\"[\".concat(this._inspectId, \"] Inspect worker manager is reconnecting before connecting worker\"));\n      }), this.workerManagerConnection.on(Km.ON_MESSAGE, async e => {\n        this.emit(kg.STATE_CHANGE, Lg.GET_WORKER_MANAGER_RESPONSE);\n        const t = this.workerManagerConnection.url;\n        this.workerManagerConnection.close();\n        const i = JSON.parse(e.data);\n        if (200 !== i.code) throw NE.error(\"[\".concat(this._inspectId, \"] Unexpected code \").concat(i.code, \" from worker manager\")), new vE(TE.UNEXPECTED_RESPONSE, \"response code of worker is unexpected\", i);\n        if (!(i.serverResponse && i.serverResponse.portWss && t)) throw NE.error(\"[\".concat(this._inspectId, \"] Unexpected content from worker manager : \").concat(JSON.stringify(i))), new vE(TE.UNEXPECTED_RESPONSE, \"response content of worker is unexpected\", i);\n        {\n          const e = HE(\"VIDEO_INSPECT_WORKER_PORT\") || i.serverResponse.portWss,\n            r = t.replace(/:\\d+\\/?$/, \":\".concat(e));\n          this.emit(kg.STATE_CHANGE, Lg.CONNECT_WORKER, r), this._needWorkUrlOnly ? this.emit(kg.REQUEST_NEW_WORKER_URL, r) : await this.connectWorker(r);\n        }\n      }), this.workerManagerConnection.on(Km.WILL_RECONNECT, (e, t) => {\n        t(e);\n      }), this.workerManagerConnection.on(Km.REQUEST_NEW_URLS, (e, t) => {\n        this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(t);\n      });\n    }\n    handleWorkerEvents() {\n      this.workerConnection.on(Km.CONNECTED, async () => {\n        this.emit(kg.STATE_CHANGE, Lg.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = Pg.CONNECTED;\n      }), this.workerConnection.on(Km.ON_MESSAGE, async e => {\n        if (e.data instanceof ArrayBuffer) {\n          const i = wL(new Uint8Array(e.data));\n          if (HE(\"SHOW_VIDEO_INSPECT_WORKER_MESSAGE\") && NE.debug(\"[\".concat(this._inspectId, \"] Response message for worker of inspect content \"), JSON.stringify(i)), 200 === i.code) {\n            if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && \"supervise\" === this.inspectType[0]) return void this.emit(kg.INSPECT_RESULT, void 0, void 0);\n            if (i.data && i.data.scorePorn && i.data.scoreSexy && i.data.scoreNeutral) {\n              var t;\n              const e = {\n                  porn: i.data.scorePorn,\n                  sexy: i.data.scoreSexy,\n                  neutral: i.data.scoreNeutral\n                },\n                r = zi(t = Object.keys(e)).call(t, (t, i) => e[t] > e[i] ? t : i, \"porn\"),\n                n = Object.keys(e).find(e => e === r);\n              this.emit(kg.INSPECT_RESULT, n);\n            } else this.emit(kg.INSPECT_RESULT, void 0, new vE(TE.UNEXPECTED_RESPONSE, i.code + \"\", \"There is an unexpected data on message\"));\n          } else this.emit(kg.INSPECT_RESULT, void 0, new vE(TE.UNEXPECTED_RESPONSE, i.code + \"\", i.msg));\n        } else NE.error(\"[\".concat(this._inspectId, \"] Unexpected message type from worker\")), this.emit(kg.INSPECT_RESULT, void 0, new vE(TE.UNEXPECTED_RESPONSE, \"invalid worker message type\"));\n      }), this.workerConnection.on(Km.CLOSED, () => {\n        this.connectionState = Pg.CLOSED;\n      }), this.workerConnection.on(Km.FAILED, () => {\n        this.connectionState = Pg.CLOSED;\n      }), this.workerConnection.on(Km.RECONNECTING, () => {\n        this.connectionState = this.connectionState === Pg.CONNECTED ? Pg.RECONNECTING : Pg.CONNECTING;\n      }), this.workerConnection.on(Km.WILL_RECONNECT, (e, t) => {\n        \"recover\" === e && t(e), t(\"tryNext\");\n      }), this.workerConnection.on(Km.REQUEST_NEW_URLS, (e, t) => {\n        this.workerManagerConnection.close(), this.once(kg.REQUEST_NEW_WORKER_URL, t => {\n          e([t]);\n        }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e => {\n          this.connectWorkerManager(e, !0);\n        }).catch(e => {\n          t(e);\n        });\n      });\n    }\n    static intToLong(e) {\n      return {\n        low: e |= 0,\n        high: e >> 31,\n        unsigned: e >= 0\n      };\n    }\n    async requestToInspectImage() {\n      this.sequence++;\n      const e = GR(this, kg.CLIENT_LOCAL_VIDEO_TRACK),\n        t = {\n          appId: this._connectInfo.appId,\n          cname: this._connectInfo.cname,\n          cid: this._connectInfo.cid,\n          sid: this._connectInfo.sid,\n          uid: this._connectInfo.uid,\n          vid: this._connectInfo.vid\n        };\n      if (e) {\n        if (!e.isPlaying) return void this.emit(kg.INSPECT_RESULT, void 0, new vE(TE.INVALID_OPERATION, \"Only the track being played can be inspected\"));\n        const i = await this.generateRequestData(e, t);\n        this.workerConnection.sendMessage(i, !0, !0);\n      } else this.emit(kg.INSPECT_RESULT, void 0, new vE(TE.INVALID_OPERATION, \"Only the track being published can be inspected\"));\n    }\n    async generateRequestData(e, t) {\n      let {\n        appId: i,\n        cname: r,\n        cid: n,\n        vid: o,\n        sid: s,\n        uid: a\n      } = t;\n      const c = Date.now(),\n        d = await e.getCurrentFrameImage(\"image/jpeg\", this.quality),\n        u = await nk(d, i, r),\n        l = this.sequence + \"-\" + n + \"-\" + a + \"-\" + c + \"-\" + MR(12, \"\"),\n        h = {\n          appId: i,\n          cid: n,\n          cname: r,\n          deviceId: \"\",\n          elapse: ak.intToLong(Number(c - this.inspectStartTime)),\n          fileSize: u.byteLength,\n          jpgEncryption: 2,\n          height: d.height,\n          width: d.width,\n          jpg: u,\n          networkType: 6,\n          osType: 7,\n          requestId: l,\n          sdkVersion: \"4.16.1\",\n          sequence: this.sequence,\n          sid: s,\n          timestamp: ak.intToLong(c),\n          uid: a,\n          vid: o,\n          service: this._inspectMode,\n          callbackData: this.extraInfo,\n          ossFilePrefix: this.ossFilePrefix\n        };\n      void 0 === this.extraInfo && delete h.callbackData, void 0 === this.ossFilePrefix && delete h.ossFilePrefix;\n      const p = bL(h);\n      if (p.byteLength < this.workerMessageLengthLimit) {\n        if (HE(\"SHOW_VIDEO_INSPECT_WORKER_MESSAGE\")) {\n          const e = function (e) {\n            for (var t = 1; t < arguments.length; t++) {\n              var i = null != arguments[t] ? arguments[t] : {};\n              t % 2 ? ok(Object(i), !0).forEach(function (t) {\n                mp(e, t, i[t]);\n              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : ok(Object(i)).forEach(function (t) {\n                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n              });\n            }\n            return e;\n          }({}, h);\n          delete e.jpg, NE.debug(\"[\".concat(this._inspectId, \"] Request message for worker of inspect content \"), JSON.stringify(e));\n        }\n        return p;\n      }\n      {\n        const t = this.quality * this.qualityRatio;\n        return this.quality = t, await this.generateRequestData(e, {\n          appId: i,\n          cname: r,\n          cid: n,\n          vid: o,\n          sid: s,\n          uid: a\n        });\n      }\n    }\n    close() {\n      this._cancelTokenSource.cancel(), this._cancelTokenSource = fE.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = Pg.CLOSED, this.emit(kg.STATE_CHANGE, Lg.CLOSED);\n    }\n  }\n  var ck, dk, uk, lk, hk, pk, _k, Ek, fk, mk, gk, Sk, Tk, vk, Rk, Ik, yk, Ck, Ak, Ok, bk, wk, Nk, Dk, Pk, Lk, kk, Mk, Uk, xk, Vk, jk, Fk, Bk, Gk, Wk, Hk, Kk, Yk;\n  function qk(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function Jk(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? qk(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : qk(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  let Xk = (ck = RT(), dk = RT({\n    argsMap: (e, t) => (Array.isArray(t) || (t = [t]), t.map(e => e ? Object(e).toString() : \"null\"))\n  }), uk = RT({\n    argsMap: (e, t) => (t || (t = []), Array.isArray(t) || (t = [t]), t.map(e => e.getTrackId()))\n  }), lk = RT({\n    argsMap: (e, t, i) => [t.uid, i]\n  }), hk = RT({\n    argsMap: (e, t) => t.map(e => {\n      let {\n        user: t,\n        mediaType: i\n      } = e;\n      return [null == t ? void 0 : t.uid, i];\n    })\n  }), pk = RT({\n    argsMap: (e, t, i) => [t.uid, i]\n  }), _k = RT({\n    argsMap: (e, t) => t.map(e => {\n      let {\n        user: t,\n        mediaType: i\n      } = e;\n      return {\n        uid: null == t ? void 0 : t.uid,\n        mediaType: i\n      };\n    })\n  }), Ek = RT(), fk = RT(), mk = RT(), gk = RT(), Sk = RT(), Tk = RT(), vk = RT(), Rk = RT(), Ik = RT(), yk = RT(), Ck = RT(), Ak = RT(), Ok = RT(), bk = RT(), wk = RT({\n    argsMap: (e, t) => [t]\n  }), Nk = RT(), Dk = RT(), Pk = RT(), Lk = RT(), kk = RT(), Mk = RT(), Uk = RT(), xk = RT(), Vk = RT(), jk = RT(), Fk = RT({\n    argsMap: (e, t) => (Array.isArray(t) || (t = [t]), [JSON.stringify(t)])\n  }), Bk = RT(), Gk = RT(), Wk = RT(), Hk = RT({\n    reportResult: !0\n  }), Kk = RT(), ZS((Yk = class extends gE {\n    get connectionState() {\n      return this._gateway.state;\n    }\n    get remoteUsers() {\n      return this._users;\n    }\n    get localTracks() {\n      return this._p2pChannel.getAllTracks(!0);\n    }\n    get uid() {\n      return this._uid;\n    }\n    get channelName() {\n      return this._channelName;\n    }\n    get isStringUID() {\n      return !!this._joinInfo && !!this._joinInfo.stringUid;\n    }\n    get __className__() {\n      return \"Client\";\n    }\n    constructor(e) {\n      let t;\n      if (super(), mp(this, \"store\", void 0), mp(this, \"_uid\", void 0), mp(this, \"_channelName\", void 0), mp(this, \"_uintUid\", void 0), mp(this, \"_users\", []), mp(this, \"_codec\", void 0), mp(this, \"_mode\", void 0), mp(this, \"_config\", void 0), mp(this, \"_clientId\", void 0), mp(this, \"_appId\", void 0), mp(this, \"_sessionId\", null), mp(this, \"_key\", void 0), mp(this, \"_joinInfo\", void 0), mp(this, \"_gateway\", void 0), mp(this, \"_statsCollector\", void 0), mp(this, \"_configDistribute\", void 0), mp(this, \"_leaveMutex\", new OT(\"client-leave\")), mp(this, \"_publishMutex\", new OT(\"client-publish\")), mp(this, \"_renewTokenMutex\", new OT(\"client-renewtoken\")), mp(this, \"_subscribeMutex\", new OT(\"client-subscribe\")), mp(this, \"_encryptionMode\", \"none\"), mp(this, \"_encryptionSecret\", null), mp(this, \"_encryptionSalt\", null), mp(this, \"_proxyServer\", void 0), mp(this, \"_turnServer\", {\n        servers: [],\n        mode: \"auto\"\n      }), mp(this, \"_cloudProxyServerMode\", \"disabled\"), mp(this, \"_isDualStreamEnabled\", !1), mp(this, \"_defaultStreamFallbackType\", void 0), mp(this, \"_lowStreamParameter\", void 0), mp(this, \"_streamFallbackTypeCacheMap\", new Map()), mp(this, \"_remoteStreamTypeCacheMap\", new Map()), mp(this, \"_axiosCancelSource\", fE.CancelToken.source()), mp(this, \"_audioVolumeIndicationInterval\", void 0), mp(this, \"_networkQualityInterval\", void 0), mp(this, \"_userOfflineTimeout\", void 0), mp(this, \"_streamRemovedTimeout\", void 0), mp(this, \"_injectStreamingClient\", void 0), mp(this, \"_liveTranscodeStreamingClient\", void 0), mp(this, \"_liveRawStreamingClient\", void 0), mp(this, \"_channelMediaRelayClient\", void 0), mp(this, \"_networkQualitySensitivity\", \"normal\"), mp(this, \"_p2pChannel\", void 0), mp(this, \"_useLocalAccessPoint\", !1), mp(this, \"_setLocalAPVersion\", void 0), mp(this, \"_joinAndNotLeaveYet\", !1), mp(this, \"_numberOfJoinCount\", 0), mp(this, \"_remoteDefaultVideoStreamType\", void 0), mp(this, \"_inspect\", void 0), mp(this, \"_license\", void 0), mp(this, \"_handleLocalTrackEnable\", (e, t, i) => {\n        this.publish(e, !1).then(t).catch(i);\n      }), mp(this, \"_handleLocalTrackDisable\", (e, t, i) => {\n        this.unpublish(e).then(t).catch(i);\n      }), mp(this, \"_handleUserOnline\", e => {\n        this.isStringUID && \"string\" != typeof e.uid && NE.error(\"[\".concat(this._clientId, \"] StringUID is Mixed with UintUID\"));\n        const t = this._users.find(t => t.uid === e.uid);\n        if (t) t._trust_in_room_ = !0;else {\n          const t = new mw(e.uid, e.uint_id || e.uid);\n          this._users.push(t), NE.debug(\"[\".concat(this._clientId, \"] user online\"), e.uid), this.emit(Am.USER_JOINED, t);\n        }\n      }), mp(this, \"_handleUserOffline\", e => {\n        const t = this._users.find(t => t.uid === e.uid);\n        t && (this._handleRemoveStream(e), HR(this._users, t), this._remoteStreamTypeCacheMap.delete(t.uid), this._streamFallbackTypeCacheMap.delete(t.uid), NE.debug(\"[\".concat(this._clientId, \"] user offline\"), e.uid, \"reason:\", e.reason), this.emit(Am.USER_LEAVED, t, e.reason));\n      }), mp(this, \"_handleAddAudioOrVideoStream\", (e, t, i, r, n, o, s) => {\n        const a = this._users.find(e => e.uid === t);\n        if (!a) return void NE.error(\"[\".concat(this._clientId, \"] can not find target user!(on_add_stream)\"));\n        NE.debug(\"[\".concat(this._clientId, \"] stream added with uid \").concat(t, \", type \").concat(e)), this.store.subscribe(a.uid, e, void 0, void 0, void 0, Date.now());\n        const c = \"audio\" === e ? a.hasAudio : a.hasVideo;\n        a._uintid || (a._uintid = n || t), \"audio\" === e ? a._trust_audio_stream_added_state_ = !0 : a._trust_video_stream_added_state_ = !0, \"audio\" === e ? (a._audio_added_ = !0, void 0 !== i && (a._audioSSRC = i), void 0 !== r && (a._cname = r), o && (a._audioOrtc = o)) : (a._video_added_ = !0, void 0 !== i && (a._videoSSRC = i), void 0 !== r && (a._cname = r), void 0 !== s && (a._rtxSsrcId = s), o && (a._videoOrtc = o)), (\"audio\" === e ? a.hasAudio : a.hasVideo) && !c && (NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(a.uid, \" published \").concat(e)), this.emit(Am.USER_PUBLISHED, a, e)), \"video\" === e ? IT.onGatewayStream(this._sessionId, lm.ON_ADD_VIDEO_STREAM, hm.ON_ADD_VIDEO_STREAM, {\n          peer: n || t\n        }) : IT.onGatewayStream(this._sessionId, lm.ON_ADD_AUDIO_STREAM, hm.ON_ADD_AUDIO_STREAM, {\n          peer: n || t\n        }), this._p2pChannel.remoteMediaSsrcChanged(a, e, i).then(t => {\n          if (t) return NE.debug(\"[\".concat(this._clientId, \"] resubscribe \").concat(e, \" for user \").concat(a.uid, \" after rejoin because SSRC id changed.\")), this._p2pChannel.unsubscribe(a, e, !0).then(() => this._subscribe(a, e, !0).catch(e => {\n            NE.error(\"[\".concat(this._clientId, \"] resubscribe error\"), e.toString());\n          }));\n        }), this._p2pChannel.hasPendingRemoteMedia(a, e) && (NE.debug(\"[\".concat(this._clientId, \"] resubscribe \").concat(e, \" for user \").concat(a.uid, \" after reconnect.\")), this._subscribe(a, e, !0).catch(e => {\n          NE.error(\"[\".concat(this._clientId, \"] resubscribe error\"), e.toString());\n        }));\n      }), mp(this, \"_handleRemoveStream\", e => {\n        const t = this._users.find(t => t.uid === e.uid);\n        if (!t) return void NE.warning(\"[\".concat(this._clientId, \"] can not find target user!(on_remove_stream)\"));\n        NE.debug(\"[\".concat(this._clientId, \"] stream removed with uid \").concat(e.uid));\n        let i = () => {};\n        t.hasAudio && t.hasVideo ? i = () => {\n          NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished audio track\")), this.emit(Am.USER_UNPUBLISHED, t, \"audio\"), NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished video track\")), this.emit(Am.USER_UNPUBLISHED, t, \"video\");\n        } : t.hasVideo ? i = () => {\n          NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished video track\")), this.emit(Am.USER_UNPUBLISHED, t, \"video\");\n        } : t.hasAudio && (i = () => {\n          NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(t.uid, \" unpublished audio track\")), this.emit(Am.USER_UNPUBLISHED, t, \"audio\");\n        }), t._trust_audio_stream_added_state_ = !0, t._trust_video_stream_added_state_ = !0, t._audio_added_ = !1, t._video_added_ = !1, this._p2pChannel.unsubscribe(t).then(e => {\n          if (e) return this._gateway.unsubscribe(e, t.uid);\n        }), t._audioSSRC = void 0, t._videoSSRC = void 0, t._audioOrtc = void 0, t._videoOrtc = void 0, t._rtxSsrcId = void 0, IT.onGatewayStream(this._sessionId, lm.ON_REMOVE_STREAM, hm.ON_REMOVE_STREAM, {\n          peer: e.uint_id || e.uid\n        }), i();\n      }), mp(this, \"_handleSetStreamLocalEnable\", (e, t, i) => {\n        const r = this._users.find(e => e.uid === t);\n        if (!r) return void NE.error(\"[\".concat(this._clientId, \"] can not find target user!(disable_local)\"));\n        NE.debug(\"[\".concat(this._clientId, \"] local \").concat(e, \" \").concat(i ? \"enabled\" : \"disabled\", \" with uid \").concat(t));\n        const n = \"audio\" === e ? r.hasAudio : r.hasVideo;\n        if (\"audio\" === e) {\n          r._trust_audio_enabled_state_ = !0;\n          const e = r._audio_enabled_;\n          if (r._audio_enabled_ = i, r._audio_enabled_ === e) return;\n          {\n            const e = r._audio_enabled_ ? \"enable-local-audio\" : \"disable-local-audio\";\n            NE.debug(\"[\".concat(this._clientId, \"] user-info-updated, uid: \").concat(t, \", msg: \").concat(e)), this.emit(Am.USER_INFO_UPDATED, t, e);\n          }\n        } else {\n          r._trust_video_enabled_state_ = !0;\n          const e = r._video_enabled_;\n          if (r._video_enabled_ = i, r._video_enabled_ === e) return;\n          {\n            const e = r._video_enabled_ ? \"enable-local-video\" : \"disable-local-video\";\n            NE.debug(\"[\".concat(this._clientId, \"] user-info-update, uid: \").concat(t, \", msg: \").concat(e)), this.emit(Am.USER_INFO_UPDATED, t, e);\n          }\n        }\n        const o = \"audio\" === e ? r.hasAudio : r.hasVideo;\n        return n !== o ? !n && o ? (NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(t, \" published \").concat(e)), void this.emit(Am.USER_PUBLISHED, r, e)) : (\"video\" === e && r._videoTrack && r._videoTrack._destroy(), \"audio\" === e && r._audioTrack, this._p2pChannel.muteRemote(r, e), NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(t, \" unpublished \").concat(e)), void this.emit(Am.USER_UNPUBLISHED, r, e)) : void 0;\n      }), mp(this, \"_handleMuteStream\", (e, t, i) => {\n        NE.debug(\"[\".concat(this._clientId, \"] receive mute message\"), e, t, i);\n        const r = this._users.find(t => t.uid === e);\n        if (!r) return void NE.warning(\"[\".concat(this._clientId, \"] can not find remote user, ignore mute event, uid: \").concat(e));\n        const n = \"audio\" === t ? r.hasAudio : r.hasVideo;\n        if (\"audio\" === t) {\n          r._trust_audio_mute_state_ = !0;\n          const t = r._audio_muted_;\n          if (r._audio_muted_ = i, r._audio_muted_ === t) return;\n          {\n            const t = r._audio_muted_ ? \"mute-audio\" : \"unmute-audio\";\n            NE.debug(\"[\".concat(this._clientId, \"] user-info-update, uid: \").concat(e, \", msg: \").concat(t)), this.emit(Am.USER_INFO_UPDATED, e, t);\n          }\n        } else {\n          r._trust_video_mute_state_ = !0;\n          const t = r._video_muted_;\n          if (r._video_muted_ = i, r._video_muted_ === t) return;\n          {\n            const t = r._video_muted_ ? \"mute-video\" : \"unmute-video\";\n            NE.debug(\"[\".concat(this._clientId, \"] user-info-update, uid: \").concat(e, \", msg: \").concat(t)), this.emit(Am.USER_INFO_UPDATED, e, t);\n          }\n        }\n        const o = \"audio\" === t ? r.hasAudio : r.hasVideo;\n        if (n !== o) {\n          if (!n && o) {\n            return (\"audio\" === t ? r._audioSSRC : r._videoSSRC) ? (NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(e, \" published \").concat(t)), void this.emit(Am.USER_PUBLISHED, r, t)) : void NE.warning(\"[\".concat(this._clientId, \"] remote user \").concat(e, \" receive \").concat(t, \" unmute message  before add stream message, \").concat(t, \" SSRC doesn't exist yet.\"));\n          }\n          \"video\" === t && r._videoTrack && r._videoTrack._destroy(), \"audio\" === t && r._audioTrack, this._p2pChannel.muteRemote(r, t), NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(e, \" unpublished \").concat(t)), this.emit(Am.USER_UNPUBLISHED, r, t);\n        }\n      }), mp(this, \"_handleP2PLost\", async e => {\n        NE.debug(\"[\".concat(this._clientId, \"] receive p2p lost\"), e), parseInt(e.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : NE.warning(\"P2PLost stream not found\", e);\n      }), mp(this, \"_handleTokenWillExpire\", () => {\n        NE.debug(\"[\".concat(this._clientId, \"] received message onTokenPrivilegeWillExpire\")), this.emit(Am.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);\n      }), mp(this, \"_handleBeforeUnload\", e => {\n        \"beforeunload\" === e.type && void 0 !== e.returnValue && \"\" !== e.returnValue || (this.leave(), NE.info(\"[\".concat(this._clientId, \"] auto leave onbeforeunload or pagehide\")));\n      }), mp(this, \"_handleUpdateNetworkQuality\", () => {\n        if (\"normal\" === this._networkQualitySensitivity) return;\n        if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.emit(Am.NETWORK_QUALITY, {\n          downlinkNetworkQuality: 6,\n          uplinkNetworkQuality: 6\n        });\n        const e = {\n          downlinkNetworkQuality: 0,\n          uplinkNetworkQuality: 0\n        };\n        e.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.emit(Am.NETWORK_QUALITY, e);\n      }), this._codec = e.codec, this._mode = e.mode, this._clientId = MR(5, \"client-\"), this.store = new yL(e.codec, e.audioCodec, e.mode, this._clientId), this.store.clientCreated(), e.proxyServer && this.setProxyServer(e.proxyServer, !0), e.turnServer && this.setTurnServer(e.turnServer, !0), NE.info(\"[\".concat(this._clientId, \"] Initializing AgoraRTC client v\").concat(PE, \" build: \").concat(DE, \", mode: \").concat(this._mode, \", codec: \").concat(this._codec)), e.clientRoleOptions) try {\n        jm(e.clientRoleOptions), t = Object.assign({}, e.clientRoleOptions);\n      } catch (e) {\n        NE.warning(\"[\".concat(this._clientId, \"] \").concat(e.toString()));\n      }\n      this._statsCollector = new fR(this.store), this._statsCollector.onStatsException = (e, t, i) => {\n        NE.debug(\"[\".concat(this._clientId, \"] receive exception msg, code: \").concat(e, \", msg: \").concat(t, \", uid: \").concat(i)), this.emit(Am.EXCEPTION, {\n          code: e,\n          msg: t,\n          uid: i\n        });\n      }, this._statsCollector.onUploadPublishDuration = (e, t, i, r) => {\n        const n = this._users.find(t => t.uid === e);\n        n && IT.peerPublishStatus(this._sessionId, {\n          subscribeElapse: r,\n          audioPublishDuration: t,\n          videoPublishDuration: i,\n          peer: n._uintid\n        });\n      }, this._gateway = new _O(this.store, {\n        clientId: this._clientId,\n        mode: this._mode,\n        codec: this._codec,\n        websocketRetryConfig: e.websocketRetryConfig || RE,\n        httpRetryConfig: e.httpRetryConfig || RE,\n        forceWaitGatewayResponse: void 0 === e.forceWaitGatewayResponse || e.forceWaitGatewayResponse,\n        statsCollector: this._statsCollector,\n        role: e.role,\n        clientRoleOptions: t\n      }), this._config = e, this._configDistribute = new HO(), this._p2pChannel = new pL(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents();\n    }\n    async join(e, t, i, r, n) {\n      const o = ++this._numberOfJoinCount;\n      this.store.joinStart(), r && (this.store.uid = r);\n      const s = AL(),\n        a = OL() ? window.isSecureContext : \"Browser Not Support\";\n      if (!OL() && !s || !window.isSecureContext) {\n        const e = \"The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser\";\n        NE.warning(e);\n      }\n      const c = UR();\n      \"DISCONNECTED\" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), NE.debug(\"[\".concat(this._clientId, \"] set avoidJoinStart to \").concat(this.store.avoidJoinStart)));\n      const d = IT.reportApiInvoke(c, {\n        name: Em.JOIN,\n        options: [e, t, i, r],\n        states: {\n          isHttps: s,\n          isSecureContext: a\n        },\n        tag: fm.TRACER\n      });\n      IT.setAppId(e);\n      try {\n        if (!i && null !== i) throw new vE(TE.INVALID_PARAMS, \"Invalid token: \".concat(i, \". If you don not use token, set it to null\"));\n        i && Qf(i, \"token\", 1, 2047), Qf(e, \"appid\", 1, 2047), $f(t), r && em(r), n && Qf(n, \"optionalInfo\", 1, 2047);\n      } catch (e) {\n        throw d.onError(e), e;\n      }\n      if (NE.info(\"[\".concat(this._clientId, \"] start join channel \").concat(t, \", join number: \").concat(o)), this._leaveMutex.isLocked) {\n        NE.debug(\"[\".concat(this._clientId, \"] join: waiting leave operation\"));\n        (await this._leaveMutex.lock())(), NE.debug(\"[\".concat(this._clientId, \"] join: continue\"));\n      }\n      if (this._joinAndNotLeaveYet = !0, \"DISCONNECTED\" !== this.connectionState) {\n        const e = new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already in connecting/connected state\"));\n        throw d.onError(e), e;\n      }\n      this._sessionId || (this._sessionId = c, this.store.sessionId = this._sessionId), this._gateway.state = \"CONNECTING\";\n      const u = Jk({\n        clientId: this._clientId,\n        appId: e,\n        sid: this._sessionId,\n        cname: t,\n        uid: \"string\" != typeof r ? r : null,\n        turnServer: this._turnServer,\n        proxyServer: this._proxyServer,\n        token: i || e,\n        cloudProxyServer: this._cloudProxyServerMode,\n        optionalInfo: n,\n        license: this._license,\n        useLocalAccessPoint: this._useLocalAccessPoint\n      }, void 0 !== this._remoteDefaultVideoStreamType && {\n        defaultVideoStream: this._remoteDefaultVideoStreamType\n      });\n      if (this._useLocalAccessPoint && (u.setLocalAPVersion = this._setLocalAPVersion), \"string\" == typeof r && (u.stringUid = r, this._uintUid ? (u.uid = this._uintUid, this._uintUid = void 0) : u.uid = 0), \"none\" !== this._encryptionMode && this._encryptionSecret) {\n        if (u.aesmode = this._encryptionMode, u.aespassword = await (async e => {\n          const t = zR(\"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\\nxQiYDz3vqa6bP29adwIDAQAB\"),\n            i = await window.crypto.subtle.importKey(\"spki\", t, {\n              name: \"RSA-OAEP\",\n              hash: \"SHA-256\"\n            }, !0, [\"encrypt\"]),\n            r = mT(e),\n            n = await window.crypto.subtle.encrypt({\n              name: \"RSA-OAEP\"\n            }, i, r);\n          return QR(new Uint8Array(n));\n        })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already left\"));\n        this._encryptionSalt && (u.aessalt = this._encryptionSalt);\n      }\n      this._startSession(this._sessionId, {\n        channel: t,\n        appId: e\n      });\n      const l = this._sessionId;\n      setTimeout(() => {\n        \"CONNECTING\" === this.connectionState && l === this._sessionId && IT.joinChannelTimeout(this._sessionId, 5);\n      }, 5e3);\n      try {\n        let r;\n        const n = u.cloudProxyServer;\n        if ([\"proxy3\", \"proxy4\", \"proxy5\"].includes(n)) {\n          const e = HE(\"PROXY_SERVER_TYPE3\");\n          Array.isArray(e) ? u.proxyServer = e[0] : u.proxyServer = e;\n        }\n        if (IT.setProxyServer(u.proxyServer), NE.setProxyServer(u.proxyServer), this.store.requestAPStart(), u.stringUid && !u.uid) {\n          const e = await UO(u.stringUid, u, this._axiosCancelSource.token, this._config.httpRetryConfig || RE, this.store);\n          NE.debug(\"getUserAccount Success \".concat(u.stringUid, \" => \").concat(e)), u.uid = e, r = await MO(u, this._axiosCancelSource.token, this._config.httpRetryConfig || RE, !0, this.store);\n        } else r = await MO(u, this._axiosCancelSource.token, this._config.httpRetryConfig || RE, !0, this.store);\n        if (!this._joinAndNotLeaveYet) throw new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already left\"));\n        this.store.requestAPEnd(), setTimeout(() => {\n          this._configDistribute.startGetConfigDistribute(u, this._axiosCancelSource.token), this._configDistribute.on(Rg.UPDATE_BITRATE_LIMIT, e => {\n            this._p2pChannel.updateBitrateLimit(e);\n          });\n        }, 0), this._key = i || e;\n        const o = r.gatewayInfo;\n        this._joinInfo = Jk(Jk({}, u), {}, {\n          cid: o.cid,\n          uid: u.uid ? u.uid : o.uid,\n          vid: o.vid,\n          apResponse: o.res,\n          uni_lbs_ip: o.uni_lbs_ip,\n          gatewayAddrs: o.gatewayAddrs\n        });\n        const s = await this._joinGateway();\n        if (!this._joinAndNotLeaveYet) throw new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client already left\"));\n        d.onSuccess(s), this._appId = e, this._channelName = u.cname, this._uid = s, this.store.uid = s, setTimeout(() => {\n          this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(zh() ? \"beforeunload\" : \"pagehide\", this._handleBeforeUnload);\n        }, 0);\n        const a = u.stringUid ? \"string uid: \".concat(u.stringUid, \",uid: \").concat(u.uid) : \"uid: \".concat(this._uid);\n        return NE.info(\"[\".concat(this._clientId, \"] Joining channel success: channel: \").concat(t, \",\").concat(a)), setTimeout(() => {\n          NE.startUpload();\n        }, 5e3), this.store.joinEnd(), h = this, ZE.includes(h) || ZE.push(h), s;\n      } catch (e) {\n        const t = Array.isArray(e) ? e[0] : e;\n        throw NE.error(\"[\".concat(this._clientId, \"] join number: \").concat(o, \", Joining channel failed, rollback\"), t), t.code !== TE.OPERATION_ABORTED && this._numberOfJoinCount === o && (this._gateway.state = \"DISCONNECTED\", this._reset()), d.onError(t), t;\n      }\n      var h;\n    }\n    _joinGateway() {\n      if (!this._joinInfo || !this._key) throw new vE(TE.INVALID_OPERATION);\n      return this._gateway.join(this._joinInfo, this._key, !(\"disabled\" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !HE(\"JOIN_WITH_FALLBACK_SIGNAL_PROXY\"))).then(e => e).catch(e => {\n        if (e.code === TE.INIT_WEBSOCKET_TIMEOUT) return this._gateway.leave(!0, Cm.FALLBACK), e;\n        if (e.code === TE.INIT_DATACHANNEL_TIMEOUT) return this._gateway.leave(!0, Cm.FALLBACK), e;\n        throw e;\n      }).then(e => {\n        if (e instanceof vE) {\n          if (e.code === TE.INIT_WEBSOCKET_TIMEOUT) {\n            if (NE.info(\"[\".concat(this._clientId, \"] join timeout, fallback to proxy\")), !this._joinInfo || !this._key) throw new vE(TE.INVALID_OPERATION);\n            this._joinInfo.cloudProxyServer = \"fallback\", this._cloudProxyServerMode = \"fallback\", this.store.cloudProxyServerMode = \"fallback\";\n            const e = HE(\"PROXY_SERVER_TYPE3\");\n            if (Array.isArray(e)) {\n              if (this._joinInfo.apUrl) {\n                const t = new YA(this._joinInfo.apUrl).host.split(\".\"),\n                  i = t.slice(t.length - 2).join(\".\");\n                e.forEach(e => {\n                  this._joinInfo && e.includes(i) && (this._joinInfo.proxyServer = e);\n                }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e[0]);\n              } else this._joinInfo.proxyServer = e[0];\n            } else this._joinInfo.proxyServer = e;\n            const t = HE(\"LOG_UPLOAD_SERVER\").match(/.+:(\\d{1,5})$/);\n            t && t[1] && \"443\" !== t[1] && NE.setProxyServer(this._joinInfo.proxyServer), \"443\" !== HE(\"STATS_COLLECTOR_PORT\").toString() && IT.setProxyServer(this._joinInfo.proxyServer);\n            return IT.reportApiInvoke(this._sessionId, {\n              name: Em.JOIN_FALLBACK_TO_PROXY,\n              options: [this._joinInfo.proxyServer],\n              tag: fm.TRACER\n            }).onSuccess(), this.emit(Am.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), this._gateway.join(this._joinInfo, this._key);\n          }\n          if (NE.info(\"[\".concat(this._clientId, \"] join by datachannel timeout, fallback to websocket\")), !this._joinInfo || !this._key) throw new vE(TE.INVALID_OPERATION);\n          return IT.reportApiInvoke(this._sessionId, {\n            name: Em.DATACHANNEL_FAILBACK,\n            options: [this.store.clientId],\n            tag: fm.TRACER\n          }).onSuccess(), this._joinGateway();\n        }\n        return e;\n      }).then(e => e);\n    }\n    async leave() {\n      NE.info(\"[\".concat(this._clientId, \"] Leaving channel\")), window.removeEventListener(zh() ? \"beforeunload\" : \"pagehide\", this._handleBeforeUnload), this._reset(), function (e) {\n        const t = ZE.indexOf(e);\n        -1 !== t && ZE.splice(t, 1);\n      }(this);\n      const e = await this._leaveMutex.lock();\n      if (\"DISCONNECTED\" === this.connectionState) return NE.info(\"[\".concat(this._clientId, \"] Leaving channel repeated, success\")), void e();\n      await this._gateway.leave(\"CONNECTED\" !== this.connectionState), NE.info(\"[\".concat(this._clientId, \"] Leaving channel success\")), this._joinAndNotLeaveYet = !1, this.store.resetJoinChannelServiceRecords(), e();\n    }\n    async publish(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (Array.isArray(e) || (e = [e]), 0 === e.length) throw new vE(TE.INVALID_PARAMS, \"track list is empty\");\n      if (\"audience\" === this._gateway.role) throw new vE(TE.INVALID_OPERATION, \"audience can not publish stream\");\n      for (const i of e) {\n        if (!(i instanceof wT)) throw new vE(TE.INVALID_PARAMS, \"parameter is not local track\");\n        if (!i._enabled && t) throw new vE(TE.TRACK_IS_DISABLED, \"can not publish a disabled track: \".concat(i.getTrackId()));\n      }\n      NE.info(\"[\".concat(this._clientId, \"] Publishing tracks, id \").concat(e.map(e => \"\".concat(e.getTrackId(), \" \")))), await this._configDistribute.awaitConfigDistributeComplete(), t && e.forEach(e => {\n        const t = this._configDistribute.getBitrateLimit();\n        e instanceof Ew && t && e.setBitrateLimit(t.uplink);\n      });\n      const i = await this._publishMutex.lock();\n      try {\n        await this._publishHighStream(e), NE.info(\"[\".concat(this._clientId, \"] Publish success, id \").concat(e.map(e => \"\".concat(e.getTrackId(), \" \"))));\n      } catch (e) {\n        throw NE.error(\"[\".concat(this._clientId, \"] publish error\"), e.toString()), e;\n      } finally {\n        i();\n      }\n    }\n    async unpublish(e) {\n      if (!this._joinInfo || void 0 === this._uid) throw new vE(TE.INVALID_OPERATION, \"Can't unpublish stream, haven't joined yet!\");\n      e ? Array.isArray(e) || (e = [e]) : e = this._p2pChannel.getAllTracks(!0), NE.info(\"[\".concat(this._clientId, \"] Unpublish tracks, tracks \").concat(e.map(e => \"\".concat(e.getTrackId(), \" \")), \" \"));\n      const t = await this._publishMutex.lock();\n      try {\n        const i = await this._p2pChannel.unpublish(e);\n        i && (await this._gateway.unpublish(i, this._uid)), NE.info(\"[\".concat(this._clientId, \"] Unpublish success,tracks \").concat(e.map(e => \"\".concat(e.getTrackId()))));\n      } catch (e) {\n        throw NE.error(\"[\".concat(this._clientId, \"] unpublish error\"), e.toString()), e;\n      } finally {\n        t && t();\n      }\n    }\n    async subscribe(e, t) {\n      return this._subscribe(e, t);\n    }\n    async _subscribe(e, t, i) {\n      if (Jf(t, \"mediaType\", [\"audio\", \"video\"]), !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"Can't subscribe stream, not joined\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"Can't subscribe stream in \".concat(this.connectionState, \" state\"));\n      if (!this._users.find(t => t === e)) {\n        const t = new vE(TE.INVALID_REMOTE_USER, \"user is not in the channel\");\n        throw NE.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", this user is not in the channel\")), t;\n      }\n      if (!e.hasAudio && !e.hasVideo) {\n        const t = new vE(TE.INVALID_REMOTE_USER, \"user is not published\");\n        throw NE.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \", user is not published\")), t;\n      }\n      if (!(i || (\"audio\" !== t || e.hasAudio && void 0 !== e._audioSSRC) && (\"video\" !== t || e.hasVideo && void 0 !== e._videoSSRC))) {\n        const i = new vE(TE.REMOTE_USER_IS_NOT_PUBLISHED);\n        throw NE.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(e.uid, \" with mediaType \").concat(t, \", remote track is not published\")), i;\n      }\n      const r = \"audio\" === t ? e._audioSSRC : e._videoSSRC,\n        n = \"audio\" === t ? e._audioOrtc : e._videoOrtc,\n        o = \"video\" === t ? e._rtxSsrcId : void 0,\n        s = {\n          stream_type: \"audio\" === t ? yg.AUDIO : yg.VIDEO,\n          ssrcId: r\n        },\n        a = await this._subscribeMutex.lock();\n      NE.info(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \", mediaType: \").concat(t));\n      try {\n        if (await this._p2pChannel.hasRemoteMediaWithLock(e, t)) await this._p2pChannel.unmuteRemote(e, t);else try {\n          pR.markSubscribeStart(this.store.clientId, r), this.store.subscribe(e.uid, t, Date.now()), await this._p2pChannel.subscribe(e, t, r, o, n);\n          try {\n            await this._gateway.subscribe(e.uid, s, !0);\n          } catch (i) {\n            if ((null == i ? void 0 : i.code) !== TE.WS_ABORT) throw await this._p2pChannel.unsubscribe(e, t), i;\n            await this._p2pChannel.unsubscribe(e, t, !0), this._p2pChannel.setPendingRemoteMedia(e, t);\n          }\n          this.store.subscribe(e.uid, t, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(!0, null, e, t);\n        } catch (i) {\n          throw this._p2pChannel.reportSubscribeEvent(!1, null == i ? void 0 : i.code, e, t), i;\n        }\n        NE.info(\"[\".concat(this._clientId, \"] subscribe success user \").concat(e.uid, \", mediaType: \").concat(t)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e.uid, this._defaultStreamFallbackType).catch(e => {\n          NE.warning(\"[\".concat(this._clientId, \"] auto set fallback failed\"), e);\n        });\n        const i = \"audio\" === t ? e._audioTrack : e._videoTrack;\n        if (!i) throw new vE(TE.UNEXPECTED_ERROR, \"can not find remote track in user object\");\n        return i;\n      } catch (t) {\n        throw NE.error(\"[\".concat(this._clientId, \"] subscribe user \").concat(e.uid, \" error\"), t), t;\n      } finally {\n        a();\n      }\n    }\n    async massSubscribe(e) {\n      if (Zf(e, \"subscribeList\"), !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"Can't subscribe stream, not joined\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"Can't subscribe stream in \".concat(this.connectionState, \" state\"));\n      const t = Date.now(),\n        i = new Map(),\n        r = await this._subscribeMutex.lock();\n      NE.info(\"[\".concat(this._clientId, \"]start massSubscribe user \").concat(e.map(e => {\n        let {\n          user: t,\n          mediaType: i\n        } = e;\n        return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i);\n      }).join(\"; \")));\n      const n = (e = [...e]).map(e => {\n          let {\n            user: t,\n            mediaType: i\n          } = e;\n          return {\n            user: t,\n            mediaType: i\n          };\n        }),\n        o = await this._p2pChannel.globalLock();\n      try {\n        var s;\n        for (let t = e.length - 1; t >= 0; t--) {\n          const r = e[t],\n            {\n              user: o,\n              mediaType: s\n            } = r;\n          if (Jf(s, \"mediaType\", [\"audio\", \"video\"]), !o) {\n            const e = new vE(TE.INVALID_PARAMS, \"user property does not exist in subscribeList item\");\n            throw NE.error(\"[\".concat(this._clientId, \"] user property does not exist in subscribeList item\")), e;\n          }\n          if (!this._users.find(e => e === o)) {\n            const i = new vE(TE.INVALID_REMOTE_USER, \"user is not in the channel\");\n            NE.error(\"[\".concat(this._clientId, \"] can not massSubscribe \").concat(o.uid, \", this user is not in the channel\")), n[t].error = i, e.splice(t, 1);\n            continue;\n          }\n          if (\"audio\" === s && (!o.hasAudio || void 0 === o._audioSSRC) || \"video\" === s && (!o.hasVideo || void 0 === o._videoSSRC)) {\n            const i = new vE(TE.REMOTE_USER_IS_NOT_PUBLISHED);\n            NE.error(\"[\".concat(this._clientId, \"] can not subscribe \").concat(o.uid, \" with mediaType \").concat(s, \", remote user is not published\")), n[t].error = i, e.splice(t, 1);\n            continue;\n          }\n          const a = dg.Video | dg.LwoVideo,\n            c = i.get(o);\n          if (c) {\n            if (\"video\" === s ? c & a : c & dg.Audio) {\n              e.splice(t, 1), NE.warning(\"repeat massSubscribe user:\".concat(o.uid, \", mediaType:\").concat(s, \" twice\"));\n              continue;\n            }\n            i.set(o, c | (\"video\" === s ? a : dg.Audio));\n          } else i.set(o, \"video\" === s ? a : dg.Audio);\n        }\n        for (let t = e.length - 1; t >= 0; t--) {\n          const r = e[t],\n            {\n              user: n,\n              mediaType: o\n            } = r,\n            s = dg.Video | dg.LwoVideo;\n          if (this._p2pChannel.hasRemoteMedia(n, o)) {\n            await this._p2pChannel.unmuteRemoteNoLock(n, o);\n            const r = i.get(n);\n            i.set(n, \"video\" === o ? r ^ s : r ^ dg.Audio), e.splice(t, 1);\n          }\n        }\n        this.store.massSubscribe(e.map(e => ({\n          userId: e.user.uid,\n          type: e.mediaType\n        })), t);\n        const a = zi(s = Array.from(i.entries())).call(s, (e, t) => {\n          let [i, r] = t;\n          if (0 === r) return e;\n          const n = {\n            stream_id: i.uid,\n            stream_type: r\n          };\n          return r & dg.Audio && (n.audio_ssrc = i._audioSSRC), r & dg.Video && (n.video_ssrc = i._videoSSRC), e.push(n), e;\n        }, []);\n        try {\n          e.length > 0 && (await this._p2pChannel.massSubscribeNoLock(e.map(e => {\n            let {\n              user: t,\n              mediaType: i\n            } = e;\n            return {\n              user: t,\n              mediaType: i,\n              ssrcId: i === yg.VIDEO ? t._videoSSRC : t._audioSSRC,\n              rtxSsrcId: t._rtxSsrcId\n            };\n          })));\n          const i = new Map();\n          if (a.length > 0) {\n            const e = await this._gateway.subscribeAll(a, !0);\n            ((null == e ? void 0 : e.users) || []).forEach(e => {\n              let {\n                stream_id: t,\n                video_error_code: r,\n                audio_error_code: n,\n                error_code: o\n              } = e;\n              (r || n || o) && i.set(t, {\n                video_error_code: r,\n                audio_error_code: n,\n                error_code: o\n              });\n            });\n          }\n          if (Array.from(i.entries()).length > 0) {\n            const e = Array.from(i.entries()).map(e => {\n              let t,\n                [i, r] = e;\n              r.error_code || r.video_error_code && r.audio_error_code ? t = void 0 : r.video_error_code ? t = yg.VIDEO : r.audio_error_code && (t = yg.AUDIO);\n              return {\n                user: this.remoteUsers.find(e => e.uid === i),\n                mediaType: t\n              };\n            });\n            await this._p2pChannel.massUnsubscribeNoLock(e);\n          }\n          for (const e of n) {\n            const t = i.get(e.user.uid);\n            if (t) {\n              const i = t.error_code || \"audio\" === e.mediaType && t.audio_error_code || \"video\" === e.mediaType && t.video_error_code;\n              if (i) {\n                const t = zA(i);\n                NE.error(\"user:\".concat(e.user.uid, \" mediaType:\").concat(e.mediaType, \" has massSubscribe error \").concat(t.desc)), e.error = new vE(TE.SUBSCRIBE_FAILED, \"code \".concat(i, \": \").concat(t.desc));\n              }\n            }\n            e.error || (\"video\" === e.mediaType ? e.track = e.user.videoTrack : e.track = e.user.audioTrack);\n          }\n          return this.store.massSubscribe(n.filter(e => !e.error).map(e => ({\n            userId: e.user.uid,\n            type: e.mediaType\n          })), void 0, Date.now()), n.forEach(e => {\n            var i;\n            IT.subscribe(this.store.sessionId, {\n              succ: !!e.error,\n              ec: (null === (i = e.error) || void 0 === i ? void 0 : i.code) || null,\n              video: e.mediaType === yg.VIDEO,\n              audio: e.mediaType === yg.AUDIO,\n              peerid: e.user.uid,\n              subscribeRequestid: e.mediaType === yg.VIDEO ? e.user._videoSSRC : e.user._audioSSRC,\n              p2pid: this.store.p2pId,\n              eventElapse: Math.floor(performance.now() - t)\n            }, !0);\n          }), NE.info(\"[\".concat(this._clientId, \"] massSubscribe success \").concat(e.map(e => {\n            let {\n              user: t,\n              mediaType: i\n            } = e;\n            return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i);\n          }).join(\"; \"))), n;\n        } catch (t) {\n          throw await this._p2pChannel.massUnsubscribeNoLock(e), t;\n        }\n      } finally {\n        o(), r();\n      }\n    }\n    async unsubscribe(e, t) {\n      if (t && Jf(t, \"mediaType\", [\"audio\", \"video\"]), !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"Can't unsubscribe stream, haven't joined yet!\");\n      if (!this._users.find(t => t === e)) {\n        const t = new vE(TE.INVALID_REMOTE_USER, \"user is not in the channel\");\n        throw NE.error(\"[\".concat(this._clientId, \"] can not unsubscribe \").concat(e.uid, \", user is not in the channel\")), t;\n      }\n      NE.info(\"[\".concat(this._clientId, \"] unsubscribe uid: \").concat(e.uid, \", mediaType: \").concat(t));\n      try {\n        const i = await this._p2pChannel.unsubscribe(e, t);\n        i && (await this._gateway.unsubscribe(i, e.uid)), NE.info(\"[\".concat(this._clientId, \"] unsubscribe success uid: \").concat(e.uid, \", mediaType: \").concat(t));\n      } catch (t) {\n        if (t.code === TE.DISCONNECT_P2P) return void NE.warning(\"disconnecting p2p, abort unsubscribe request.\");\n        throw NE.error(\"[\".concat(this._clientId, \"] unsubscribe user \").concat(e.uid, \" error\"), t.toString()), t;\n      }\n    }\n    async massUnsubscribe(e) {\n      if (Zf(e, \"unsubscribeList\"), !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"Can't unsubscribeAll stream, haven't joined yet!\");\n      NE.info(\"[\".concat(this._clientId, \"] start massUnsubscribe \").concat(e.map(e => {\n        let {\n          user: t,\n          mediaType: i\n        } = e;\n        return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i, \";\");\n      }).join())), e = [...e];\n      const t = new Map();\n      for (let i = e.length - 1; i >= 0; i--) {\n        const {\n          user: r,\n          mediaType: n\n        } = e[i];\n        if (!r) {\n          const e = new vE(TE.INVALID_PARAMS, \"user property does not exist in unsubscribeList item\");\n          throw NE.error(\"[\".concat(this._clientId, \"] user property does not exist in unsubscribeList item\")), e;\n        }\n        Jf(n, \"mediaType\", [\"video\", \"audio\", void 0]);\n        if (!this._users.find(e => e === r)) {\n          NE.warning(\"[\".concat(this._clientId, \"] can not unsubscribe \").concat(r.uid, \", user is not in the channel\")), e.splice(i, 1);\n          continue;\n        }\n        const o = dg.Video | dg.LwoVideo;\n        if (t.has(r)) {\n          const s = t.get(r);\n          let a;\n          switch (n) {\n            case \"video\":\n              a = s & o;\n              break;\n            case \"audio\":\n              a = s & dg.Audio;\n              break;\n            default:\n              a = s & (dg.Audio | o);\n          }\n          if (a) {\n            NE.warning(\"repeat massUnsubscribe user:\".concat(r.uid, \",mediaType:\").concat(n, \" twice.\")), e.splice(i, 1);\n            continue;\n          }\n          n ? \"audio\" === n ? t.set(r, s | dg.Audio) : \"video\" === n && t.set(r, s | o) : t.set(r, s | dg.Audio | o);\n        } else n ? \"audio\" === n ? t.set(r, dg.Audio) : \"video\" === n && t.set(r, o) : t.set(r, dg.Audio | o);\n      }\n      try {\n        const t = await this._p2pChannel.massUnsubscribe(e);\n        t && (await this._gateway.massUnsubscribe(t)), NE.info(\"[\".concat(this._clientId, \"] massUnsubscribe success \").concat(e.map(e => {\n          let {\n            user: t,\n            mediaType: i\n          } = e;\n          return \"user: \".concat(null == t ? void 0 : t.uid, \", mediaType: \").concat(i, \";\");\n        }).join()));\n      } catch (e) {\n        if (e.code === TE.DISCONNECT_P2P) return void NE.warning(\"disconnecting p2p, abort unsubscribe request.\");\n        throw NE.error(\"[\".concat(this._clientId, \"] massUnsubscribe error\"), e.toString()), e;\n      }\n    }\n    setLowStreamParameter(e) {\n      !function (e) {\n        if (!e) throw new vE(TE.INVALID_PARAMS);\n        tm(e.width) || zf(e.width, \"streamParameter.width\"), tm(e.height) || zf(e.height, \"streamParameter.height\"), tm(e.framerate) || zf(e.framerate, \"streamParameter.framerate\"), tm(e.bitrate) || Xf(e.bitrate, \"streamParameter.bitrate\");\n      }(e), (!e.width && e.height || e.width && !e.height) && NE.warning(\"[\".concat(this._clientId, \"] The width and height parameters take effect only when both are set\")), NE.info(\"[\".concat(this._clientId, \"] set low stream parameter to\"), JSON.stringify(e));\n      const t = this._configDistribute.getLowStreamConfigDistribute();\n      t && t.bitrate && e.bitrate && t.bitrate < e.bitrate && (e.bitrate = t.bitrate), this._lowStreamParameter = e;\n    }\n    async enableDualStream() {\n      if (!jg().supportDualStream) throw IT.streamSwitch(this._sessionId, {\n        lts: Date.now(),\n        isdual: !0,\n        succ: !1\n      }), new vE(TE.NOT_SUPPORTED, \"Your browser is not support dual stream\");\n      if (this._isDualStreamEnabled) throw new vE(TE.INVALID_OPERATION, \"Dual stream is already enabled\");\n      if (this._p2pChannel.canPublishLowStream()) try {\n        await this._publishLowStream();\n      } catch (e) {\n        throw IT.streamSwitch(this._sessionId, {\n          lts: Date.now(),\n          isdual: !0,\n          succ: !1\n        }), e;\n      }\n      this._isDualStreamEnabled = !0, IT.streamSwitch(this._sessionId, {\n        lts: Date.now(),\n        isdual: !0,\n        succ: !0\n      }), NE.info(\"[\".concat(this._clientId, \"] enable dual stream\"));\n    }\n    async disableDualStream() {\n      if (this._isDualStreamEnabled) {\n        if (!this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n        if (this._p2pChannel.getLocalMedia(Cg.LocalVideoLowTrack)) try {\n          const e = await this._p2pChannel.unpublishLowStream();\n          e && (await this._gateway.unpublish(e, this._joinInfo.stringUid || this._joinInfo.uid));\n        } catch (e) {\n          throw IT.streamSwitch(this._sessionId, {\n            lts: Date.now(),\n            isdual: !1,\n            succ: !1\n          }), e;\n        }\n        this._isDualStreamEnabled = !1, IT.streamSwitch(this._sessionId, {\n          lts: Date.now(),\n          isdual: !1,\n          succ: !0\n        }), NE.info(\"[\".concat(this._clientId, \"] disable dual stream\"));\n      }\n    }\n    async setClientRole(e, t) {\n      if (function (e) {\n        Jf(e, \"role\", [\"audience\", \"host\"]);\n      }(e), t && jm(t), \"rtc\" === this._mode) throw NE.warning(\"[\".concat(this._clientId, \"]rtc mode can not use setClientRole\")), new vE(TE.INVALID_OPERATION, \"rtc mode can not use setClientRole\");\n      if (t && t.level && \"host\" === e) throw new vE(TE.INVALID_OPERATION, \"host mode can not set audience latency level\");\n      if (\"audience\" === e && this._p2pChannel.hasLocalMedia()) throw new vE(TE.INVALID_OPERATION, \"can not set client role to audience when publishing stream\");\n      await this._gateway.setClientRole(e, t), NE.info(\"[\".concat(this._clientId, \"] set client role to \").concat(e, \", level: \").concat(t && t.level));\n    }\n    setProxyServer(e, t) {\n      if (Qf(e, \"proxyServer\"), !t) {\n        if (\"DISCONNECTED\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"Set proxy server before join channel\");\n        if (\"disabled\" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new vE(TE.INVALID_OPERATION, \"You have already set the proxy\");\n      }\n      this._proxyServer = e, IT.setProxyServer(this._proxyServer), NE.setProxyServer(this._proxyServer), NE.info(\"[\".concat(this._clientId, \"] Set proxy server \").concat(t ? \"by initialize call\" : \"\", \" success.\"));\n    }\n    setTurnServer(e, t) {\n      if (Array.isArray(e) || (e = [e]), !t) {\n        if (\"DISCONNECTED\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"Set turn server before join channel\");\n        if (\"disabled\" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new vE(TE.INVALID_OPERATION, \"You have already set the proxy\");\n      }\n      if (xm(e)) return this._turnServer = {\n        servers: e,\n        mode: \"original-manual\"\n      }, void NE.info(\"[\".concat(this._clientId, \"] Set original turnserver \").concat(t ? \"by initialize call\" : \"\", \" success: \").concat(e.map(e => e.urls).join(\",\"), \".\"));\n      e.forEach(e => Vm(e)), this._turnServer = {\n        servers: e,\n        mode: \"manual\"\n      }, NE.info(\"[\".concat(this._clientId, \"] Set turnserver \").concat(t ? \"by initialize call\" : \"\", \" success.\"));\n    }\n    setLicense(e) {\n      if (\"DISCONNECTED\" !== this.connectionState) {\n        throw new vE(TE.INVALID_OPERATION, \"you should set license before join channel\");\n      }\n      if (Qf(e, \"license\", 32, 32), !/^[A-Za-z\\d]+$/.test(e)) throw new vE(TE.INVALID_PARAMS, \"license should only contains characters from A-Z a-z 0-9\");\n      this._license = e, NE.info(\"[\".concat(this._clientId, \"] set license success\"), e);\n    }\n    startProxyServer(e) {\n      if (\"DISCONNECTED\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"Start proxy server before join channel\");\n      if (this._proxyServer || \"manual\" === this._turnServer.mode || this._useLocalAccessPoint) throw new vE(TE.INVALID_OPERATION, \"You have already set the proxy\");\n      const t = [3, 4, 5];\n      let i;\n      switch (void 0 === e && (e = 3), e) {\n        case 1:\n        case 2:\n          throw new vE(TE.NOT_SUPPORTED, \"proxy mode 1/2 has been deprecated and not supported.\");\n        case 3:\n          i = \"proxy3\";\n          break;\n        case 4:\n          i = \"proxy4\";\n          break;\n        case 5:\n          i = \"proxy5\";\n          break;\n        default:\n          throw new vE(TE.INVALID_PARAMS, \"proxy server mode must be \".concat(t.join(\"|\")));\n      }\n      this._cloudProxyServerMode = i, this.store.cloudProxyServerMode = i, NE.info(\"[\".concat(this._clientId, \"] set cloud proxy server mode to\"), this._cloudProxyServerMode);\n    }\n    stopProxyServer() {\n      if (\"DISCONNECTED\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"Stop proxy server after leave channel\");\n      IT.setProxyServer(), NE.setProxyServer(), this._cloudProxyServerMode = \"disabled\", this.store.cloudProxyServerMode = \"disabled\", NE.info(\"[\".concat(this._clientId, \"] set cloud proxy server mode to\"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = {\n        mode: \"auto\",\n        servers: []\n      };\n    }\n    setLocalAccessPointsV2(e) {\n      if (!e.accessPoints) throw new vE(TE.INVALID_PARAMS, \"accessPoints is required.\");\n      Zf(e.accessPoints.serverList, \"accessPoints.serverList\"), Qf(e.accessPoints.domain, \"accessPoints.domain\");\n      const t = (e, t) => {\n        Xf(e, t, 0, 65535, !0);\n      };\n      let i = 443;\n      if (e.accessPoints.port && (t(e.accessPoints.port, \"accessPoints.port\"), i = e.accessPoints.port), this._proxyServer || \"disabled\" !== this._cloudProxyServerMode) throw new vE(TE.INVALID_OPERATION, \"set local access point failed, You have already set the cloud proxy\");\n      HE(\"CLOSE_AFB_FOR_LOCAL_AP\") && (WE(\"JOIN_WITH_FALLBACK_SIGNAL_PROXY\", !1), WE(\"JOIN_WITH_FALLBACK_MEDIA_PROXY\", !1));\n      const r = /^((\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/,\n        n = e.accessPoints.domain,\n        o = e.accessPoints.serverList.map(e => r.test(e) ? \"\".concat(e.replace(/\\./g, \"-\"), \".\").concat(n) : e),\n        s = o.map(e => \"\".concat(e, \":\").concat(i));\n      this._useLocalAccessPoint = !0, this._setLocalAPVersion = 2, WE(\"WEBCS_DOMAIN\", s), WE(\"WEBCS_DOMAIN_BACKUP_LIST\", s), WE(\"GATEWAY_DOMAINS\", [n]), e.report && e.report.hostname && Array.isArray(e.report.hostname) && e.report.hostname.length ? (Zf(e.report.hostname, \"report.hostname\"), WE(\"EVENT_REPORT_DOMAIN\", e.report.hostname[0]), WE(\"EVENT_REPORT_BACKUP_DOMAIN\", e.report.hostname[1] || e.report.hostname[0])) : (WE(\"EVENT_REPORT_DOMAIN\", o[0]), WE(\"EVENT_REPORT_BACKUP_DOMAIN\", o[1] || o[0]));\n      let a = 6443;\n      e.report && e.report.port && (t(e.report.port, \"report.port\"), a = e.report.port), WE(\"STATS_COLLECTOR_PORT\", a), e.report ? WE(\"ENABLE_EVENT_REPORT\", !0) : WE(\"ENABLE_EVENT_REPORT\", !1);\n      let c = \"\";\n      e.log && e.log.hostname && Array.isArray(e.log.hostname) && e.log.hostname.length ? (Zf(e.log.hostname, \"log.hostname\"), c = e.log.hostname[0]) : c = o[0];\n      let d = 6444;\n      e.log && e.log.port && (t(e.log.port, \"log.port\"), d = e.log.port), WE(\"LOG_UPLOAD_SERVER\", \"\".concat(c, \":\").concat(d));\n      let u = [];\n      e.cds && e.cds.hostname && Array.isArray(e.cds.hostname) && e.cds.hostname.length ? (Zf(e.cds.hostname, \"cds.hostname\"), u = e.cds.hostname) : u = o;\n      let l = 443;\n      e.cds && e.cds.port && (t(e.cds.port, \"cds.port\"), l = e.cds.port), WE(\"CDS_AP\", u.map(e => \"\".concat(e, \":\").concat(l))), e.cds ? WE(\"ENABLE_CONFIG_DISTRIBUTE\", !0) : WE(\"ENABLE_CONFIG_DISTRIBUTE\", !1), NE.info(\"set local access point v2 success\");\n    }\n    setLocalAccessPoints(e, t) {\n      if (Zf(e, \"serverList\"), Qf(t, \"domain\"), this._proxyServer || \"disabled\" !== this._cloudProxyServerMode) throw new vE(TE.INVALID_OPERATION, \"set local access point failed, You have already set the cloud proxy\");\n      const i = /^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/;\n      e = e.map(e => i.test(e) ? \"\".concat(e.replace(/\\./g, \"-\"), \".\").concat(t) : e), this._useLocalAccessPoint = !0, this._setLocalAPVersion = 1, WE(\"WEBCS_DOMAIN\", e), WE(\"WEBCS_DOMAIN_BACKUP_LIST\", e), WE(\"GATEWAY_DOMAINS\", [t]), WE(\"EVENT_REPORT_DOMAIN\", e[0]), WE(\"EVENT_REPORT_BACKUP_DOMAIN\", e[1] || e[0]), WE(\"LOG_UPLOAD_SERVER\", \"\".concat(e[0], \":6444\")), NE.info(\"set local access point success\");\n    }\n    async setRemoteDefaultVideoStreamType(e) {\n      if (Jf(e, \"streamType\", [0, 1]), this._remoteDefaultVideoStreamType = e, this._joinInfo) try {\n        await this._gateway.setDefaultRemoteVideoStreamType(e), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType;\n      } catch (e) {\n        throw NE.error(\"[\".concat(this._clientId, \"] set default remote video stream type error\"), e.toString()), e;\n      } else NE.debug(\"haven't joined yet, cache remoteDefaultVideoStreamType \".concat(e));\n    }\n    async setRemoteVideoStreamType(e, t) {\n      Jf(t, \"streamType\", [0, 1]);\n      try {\n        await this._gateway.setRemoteVideoStreamType(e, t), setTimeout(() => {\n          const t = this._users.find(t => t.uid === e);\n          t && t.videoTrack && t.videoTrack.updateMediaStreamTrackResolution();\n        }, 2e3);\n      } catch (e) {\n        throw NE.error(\"[\".concat(this._clientId, \"] set remote video stream type error\"), e.toString()), e;\n      }\n      NE.info(\"[\".concat(this._clientId, \"] set remote \").concat(e, \" video stream type to \").concat(t)), this._remoteStreamTypeCacheMap.set(e, t);\n    }\n    async setStreamFallbackOption(e, t) {\n      Jf(t, \"fallbackType\", [0, 1, 2]);\n      try {\n        await this._gateway.setStreamFallbackOption(e, t);\n      } catch (e) {\n        throw NE.error(\"[\".concat(this._clientId, \"] set stream fallback option\"), e.toString()), e;\n      }\n      NE.info(\"[\".concat(this._clientId, \"] set remote \").concat(e, \" stream fallback type to \").concat(t)), this._streamFallbackTypeCacheMap.set(e, t);\n    }\n    setEncryptionConfig(e, t, i) {\n      !function (e) {\n        Jf(e, \"encryptionMode\", [\"aes-128-xts\", \"aes-256-xts\", \"aes-128-ecb\", \"sm4-128-ecb\", \"aes-128-gcm\", \"aes-256-gcm\", \"aes-128-gcm2\", \"aes-256-gcm2\", \"none\"]);\n      }(e), Qf(t, \"secret\");\n      if ([\"aes-128-gcm2\", \"aes-256-gcm2\"].includes(e)) {\n        if (!i || !(i instanceof Uint8Array && 32 === i.length)) throw new vE(TE.INVALID_PARAMS, \"salt must be an Uint8Array and exactly equal to 32 bytes\");\n      } else if (i) throw new vE(TE.INVALID_PARAMS, \"current encrypt mode does not need salt\");\n      new RegExp(\"^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\\\"|{}\\\\[\\\\]])(?=.{8,})\").test(t) || NE.warning(\"The secret is not strong:\\n      The secret must contain at least 1 lowercase alphabetical character,\\n      The secret must contain at least 1 uppercase alphabetical character,\\n      The secret must contain at least 1 numeric character,\\n      The secret must contain at least one special character,\\n      The secret must be eight characters or longer.\\n      \"), this._encryptionMode = e, this._encryptionSecret = t, i && (this._encryptionSalt = QR(i));\n    }\n    async renewToken(e) {\n      if (Qf(e, \"token\", 1, 2047), !this._key || !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"renewToken should not be called before user join\");\n      const t = this._key;\n      this._key = e, this._joinInfo && (this._joinInfo.token = e);\n      const i = await this._renewTokenMutex.lock();\n      try {\n        if (HE(\"USE_NEW_TOKEN\")) {\n          NE.debug(\"start renew token with ticket from unilbs\");\n          const t = await BO(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || RE);\n          NE.debug(\"[\".concat(this._clientId, \"] get ticket from unilbs success\")), await this._gateway.renewToken({\n            token: e,\n            ticket: t\n          });\n        } else NE.debug(\"start renew token without ticket\"), await this._gateway.renewToken({\n          token: e\n        });\n        NE.debug(\"[\".concat(this._clientId, \"] renewToken success\"));\n      } catch (e) {\n        throw this._key = t, this._joinInfo.token = t, NE.error(\"[\".concat(this._clientId, \"] renewToken failed\"), e.toString()), e;\n      } finally {\n        i();\n      }\n    }\n    enableAudioVolumeIndicator() {\n      this._audioVolumeIndicationInterval ? NE.warning(\"you have already enabled audio volume indicator!\") : this._audioVolumeIndicationInterval = window.setInterval(() => {\n        const e = this._p2pChannel.getAudioLevels();\n        this.emit(Am.VOLUME_INDICATOR, e);\n      }, HE(\"AUDIO_VOLUME_INDICATION_INTERVAL\") || 2e3);\n    }\n    getRTCStats() {\n      const e = this._statsCollector.getRTCStats(),\n        t = this._gateway.getInChannelInfo();\n      return e.Duration = Math.round(t.duration / 1e3), e;\n    }\n    async startLiveStreaming(e, t) {\n      if (!t) {\n        if (\"h264\" !== this._codec) throw new vE(TE.LIVE_STREAMING_INVALID_RAW_STREAM, \"raw streaming is only support h264\");\n        if (!this._p2pChannel.hasLocalMedia()) throw new vE(TE.LIVE_STREAMING_INVALID_RAW_STREAM, \"can not find stream to raw streaming\");\n      }\n      if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e)) throw new vE(TE.LIVE_STREAMING_TASK_CONFLICT);\n      const i = t ? Ym.TRANSCODE : Ym.RAW;\n      return this._createLiveStreamingClient(i).startLiveStreamingTask(e, i);\n    }\n    setLiveTranscoding(e) {\n      return this._createLiveStreamingClient(Ym.TRANSCODE).setTranscodingConfig(e);\n    }\n    async stopLiveStreaming(e) {\n      const t = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter(t => t && t.hasUrl(e));\n      if (!t.length) throw new vE(TE.INVALID_PARAMS, \"can not find live streaming url to stop\");\n      await Cl.all(t.map(t => t && t.stopLiveStreamingTask(e)));\n    }\n    async addInjectStreamUrl(e, t) {\n      if (!this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"can not addInjectStreamUrl, no joininfo\");\n      const i = this._createLiveStreamingClient(Ym.INJECT);\n      i.setInjectStreamConfig(t, 0), await i.startLiveStreamingTask(e, Ym.INJECT);\n    }\n    async removeInjectStreamUrl() {\n      var e;\n      const t = this._createLiveStreamingClient(Ym.INJECT),\n        i = Array.from(zv(e = t.streamingTasks).call(e)).find(e => e.mode === Ym.INJECT);\n      if (!this._joinInfo || !i) throw new vE(TE.INVALID_OPERATION, \"can remove addInjectStreamUrl, no joininfo or inject task\");\n      await t.stopLiveStreamingTask(i.url);\n    }\n    async startChannelMediaRelay(e) {\n      ZO(e);\n      const t = this._createChannelMediaRelayClient();\n      await t.startChannelMediaRelay(e);\n    }\n    async updateChannelMediaRelay(e) {\n      ZO(e);\n      const t = this._createChannelMediaRelayClient();\n      await t.updateChannelMediaRelay(e);\n    }\n    async stopChannelMediaRelay() {\n      const e = this._createChannelMediaRelayClient();\n      await e.stopChannelMediaRelay();\n    }\n    sendStreamMessage(e) {\n      let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];\n      if (!this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"can not send data stream, not joined\");\n      if (\"string\" == typeof e) {\n        e = new TextEncoder().encode(e);\n      }\n      if (new Blob([e]).size > 1024) throw new vE(TE.INVALID_PARAMS, \"stream message out of range.\");\n      return this._gateway.signal.request(Nm.DATA_STREAM, {\n        payload: QR(e)\n      }, !t);\n    }\n    sendMetadata(e) {\n      if (!this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"can not send metadata, not joined\");\n      if (new Blob([e]).size > 1024) throw new vE(TE.METADATA_OUT_OF_RANGE);\n      return this._gateway.signal.request(Nm.SEND_METADATA, {\n        session_id: this._joinInfo.sid,\n        metadata: QR(e)\n      });\n    }\n    async sendCustomReportMessage(e) {\n      if (Array.isArray(e) || (e = [e]), e.forEach(dm), !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"can not send custom report, not joined\");\n      await IT.sendCustomReportMessage(this._joinInfo.sid, e);\n    }\n    getLocalAudioStats() {\n      return this._statsCollector.getLocalAudioTrackStats();\n    }\n    getRemoteAudioStats() {\n      return this._statsCollector.getRemoteAudioTrackStats();\n    }\n    getLocalVideoStats() {\n      return this._statsCollector.getLocalVideoTrackStats();\n    }\n    getRemoteVideoStats() {\n      return this._statsCollector.getRemoteVideoTrackStats();\n    }\n    getRemoteNetworkQuality() {\n      return this._statsCollector.getRemoteNetworkQualityStats();\n    }\n    async pickSVCLayer(e, t) {\n      Jf(t.spatialLayer, \"spatialLayer\", [0, 1, 2, 3]), Jf(t.temporalLayer, \"temporalLayer\", [0, 1, 2, 3]);\n      try {\n        await this._gateway.pickSVCLayer(e, t);\n      } catch (e) {\n        throw NE.error(\"[\".concat(this._clientId, \"] pick SVC layer failed\"), e.toString()), e;\n      }\n    }\n    _reset() {\n      if (NE.debug(\"[\".concat(this._clientId, \"] reset client\")), this._axiosCancelSource.cancel(), this._axiosCancelSource = fE.CancelToken.source(), this._streamFallbackTypeCacheMap = new Map(), this._remoteStreamTypeCacheMap = new Map(), this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = \"none\", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach(e => {\n        e._audioTrack && e._audioTrack._destroy(), e._videoTrack && e._videoTrack._destroy();\n      }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), \"fallback\" === this._cloudProxyServerMode && (this._cloudProxyServerMode = \"disabled\", this.store.cloudProxyServerMode = \"disabled\"), this._p2pChannel.reset(), this._publishMutex = new OT(\"client-publish\"), this._subscribeMutex = new OT(\"client-subscribe\"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {\n        this._inspect.close(), this._inspect = void 0;\n      } catch (e) {}\n    }\n    _startSession(e, t) {\n      const i = e || UR();\n      e ? NE.debug(\"[\".concat(this._clientId, \"] new Session \").concat(i)) : NE.debug(\"[\".concat(this._clientId, \"] renewSession \").concat(this._sessionId, \" => \").concat(i)), this._sessionId = i, this.store.sessionId = i, t ? IT.sessionInit(this._sessionId, {\n        lts: new Date().getTime(),\n        cname: t.channel,\n        appid: t.appId,\n        mode: this._mode\n      }) : this._joinInfo ? IT.sessionInit(this._sessionId, {\n        lts: new Date().getTime(),\n        cname: this._joinInfo.cname,\n        appid: this._joinInfo.appId,\n        mode: this._mode\n      }) : this._gateway.joinInfo && IT.sessionInit(this._sessionId, {\n        lts: new Date().getTime(),\n        cname: this._gateway.joinInfo.cname,\n        appid: this._gateway.joinInfo.appId,\n        mode: this._mode\n      }), this._joinInfo && (this._joinInfo.sid = i), this._gateway.joinInfo && (this._gateway.joinInfo.sid = i);\n    }\n    async _publishHighStream(e) {\n      if (!this._joinInfo || void 0 === this._uid) throw new vE(TE.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"can not publish stream in \".concat(this.connectionState, \" state\"));\n      if (\"auto\" === this._turnServer.mode && HE(\"FORCE_TURN\") && !HE(\"TURN_ENABLE_TCP\") && !HE(\"TURN_ENABLE_UDP\")) throw new vE(TE.UNEXPECTED_ERROR, \"force TURN With No TURN Configuration\");\n      NE.debug(\"[\".concat(this._clientId, \"] publish high stream\"));\n      try {\n        const i = await this._p2pChannel.publish(e, this._isDualStreamEnabled, this._lowStreamParameter),\n          r = (await i.next()).value;\n        if (r) {\n          var t;\n          let e;\n          try {\n            e = await this._gateway.publish(this._uid, r, !0);\n          } catch (e) {\n            if (e.code !== TE.DISCONNECT_P2P) throw i.throw(e), e;\n          }\n          await i.next((null === (t = e) || void 0 === t ? void 0 : t.ortc) || []);\n        }\n        this._p2pChannel.reportPublishEvent(!0, null);\n        for (const t of e) t instanceof Ew && t._encoderConfig && this._gateway.setVideoProfile(t._encoderConfig), !t.muted && t.enabled || (await this._p2pChannel.muteLocalTrack(t));\n      } catch (t) {\n        if (this._p2pChannel.reportPublishEvent(!1, null == t ? void 0 : t.code, e), (null == t ? void 0 : t.code) === TE.WS_ABORT) return;\n        throw t;\n      }\n    }\n    async _publishLowStream() {\n      if (!this._joinInfo || void 0 === this._uid) throw new vE(TE.INVALID_OPERATION, \"Can't publish stream, haven't joined yet!\");\n      if (\"CONNECTED\" !== this.connectionState && \"RECONNECTING\" !== this.connectionState) throw new vE(TE.INVALID_OPERATION, \"can not publish stream in \".concat(this.connectionState, \" state\"));\n      NE.debug(\"[\".concat(this._clientId, \"] publish low stream\"));\n      const e = this._configDistribute.getLowStreamConfigDistribute();\n      e && e.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = {\n        width: 160,\n        height: 120,\n        framerate: 15,\n        bitrate: 50\n      }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e.bitrate));\n      try {\n        const e = await this._p2pChannel.publishLowStream(this._lowStreamParameter),\n          i = (await e.next()).value;\n        if (i) {\n          var t;\n          let r;\n          try {\n            r = await this._gateway.publish(this._uid, i, !0);\n          } catch (t) {\n            if (t.code !== TE.DISCONNECT_P2P) throw e.throw(t), t;\n          }\n          e.next((null === (t = r) || void 0 === t ? void 0 : t.ortc) || []), this._p2pChannel.reportPublishEvent(!0, null, void 0, !0);\n        }\n      } catch (e) {\n        if (this._p2pChannel.reportPublishEvent(!1, null == e ? void 0 : e.code, void 0, !0), (null == e ? void 0 : e.code) === TE.WS_ABORT) return;\n        throw e;\n      }\n    }\n    _createLiveStreamingClient(e) {\n      if (!this._joinInfo || !this._appId) {\n        return new vE(TE.INVALID_OPERATION, \"can not create live streaming client, please join channel first\").throw();\n      }\n      const t = () => new zO(this._joinInfo, this._config.websocketRetryConfig || RE, this._config.httpRetryConfig || RE),\n        i = e => {\n          e.onLiveStreamError = (e, t) => {\n            IT.reportApiInvoke(this._sessionId, {\n              name: Em.ON_LIVE_STREAM_ERROR,\n              options: [e, t],\n              tag: fm.TRACER\n            }).onSuccess(), this.emit(Am.LIVE_STREAMING_ERROR, e, t);\n          }, e.onLiveStreamWarning = (e, t) => {\n            IT.reportApiInvoke(this._sessionId, {\n              name: Em.ON_LIVE_STREAM_WARNING,\n              options: [e, t],\n              tag: fm.TRACER\n            }).onSuccess(), this.emit(Am.LIVE_STREAMING_WARNING, e, t);\n          }, e.on(eg.REQUEST_WORKER_MANAGER_LIST, (e, t, i) => {\n            if (!this._joinInfo) return i(new vE(TE.INVALID_OPERATION, \"can not find join info to get worker manager\"));\n            jO(e, this._joinInfo, this._axiosCancelSource.token, RE).then(t).catch(i);\n          });\n        };\n      switch (e) {\n        case Ym.RAW:\n          return this._liveRawStreamingClient || (this._liveRawStreamingClient = t(), i(this._liveRawStreamingClient)), this._liveRawStreamingClient;\n        case Ym.TRANSCODE:\n          return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t(), i(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;\n        case Ym.INJECT:\n          return this._injectStreamingClient || (this._injectStreamingClient = t(), this._injectStreamingClient.on(eg.REQUEST_WORKER_MANAGER_LIST, (e, t, i) => {\n            if (!this._joinInfo) return i(new vE(TE.INVALID_OPERATION, \"can not find join info to get worker manager\"));\n            jO(e, this._joinInfo, this._axiosCancelSource.token, RE).then(t).catch(i);\n          }), this._injectStreamingClient.onInjectStatusChange = (e, t, i) => {\n            this.emit(Am.INJECT_STREAM_STATUS, e, t, i);\n          }), this._injectStreamingClient;\n      }\n    }\n    _createChannelMediaRelayClient() {\n      if (!this._joinInfo) {\n        return new vE(TE.INVALID_OPERATION, \"can not create channel media relay client, please join channel first\").throw();\n      }\n      return this._channelMediaRelayClient || (this._channelMediaRelayClient = new eb(this._joinInfo, this._clientId, this._config.websocketRetryConfig || RE, this._config.httpRetryConfig || RE), this._channelMediaRelayClient.on(\"state\", e => {\n        e === og.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.emit(Am.CHANNEL_MEDIA_RELAY_STATE, e);\n      }), this._channelMediaRelayClient.on(\"event\", e => {\n        this.emit(Am.CHANNEL_MEDIA_RELAY_EVENT, e);\n      })), this._channelMediaRelayClient;\n    }\n    _handleGatewayEvents() {\n      this._gateway.on(cg.DISCONNECT_P2P, async () => {\n        await this._p2pChannel.disconnectForReconnect();\n      }), this._gateway.on(cg.CONNECTION_STATE_CHANGE, (e, t, i) => {\n        var r;\n        if (i === Cm.FALLBACK) return;\n        const n = () => {\n          this.emit(Am.CONNECTION_STATE_CHANGE, e, t, i);\n        };\n        if (IT.reportApiInvoke(this._sessionId || (null === (r = this._gateway.joinInfo) || void 0 === r ? void 0 : r.sid) || null, {\n          name: Em.CONNECTION_STATE_CHANGE,\n          options: [e, t, i],\n          tag: fm.TRACER\n        }).onSuccess(JSON.stringify({\n          cur: e,\n          prev: t,\n          reason: i\n        })), NE.info(\"[\".concat(this._clientId, \"] connection state change: \").concat(t, \" -> \").concat(e)), \"DISCONNECTED\" === e) return this._reset(), void n();\n        if (\"RECONNECTING\" === e) this._users.forEach(e => {\n          e._trust_in_room_ = !1, e._trust_audio_enabled_state_ = !1, e._trust_video_enabled_state_ = !1, e._trust_audio_mute_state_ = !1, e._trust_video_mute_state_ = !1, e._trust_audio_stream_added_state_ = !1, e._trust_video_stream_added_state_ = !1, e._audioSSRC = void 0, e._videoSSRC = void 0, e._videoOrtc = void 0, e._audioOrtc = void 0, e._cname = void 0, e._rtxSsrcId = void 0;\n        }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0;else if (\"CONNECTED\" === e) {\n          var o;\n          this._streamFallbackTypeCacheMap.forEach((e, t) => {\n            this._gateway.setStreamFallbackOption(t, e).catch(e => {\n              NE.warning(\"[\".concat(this._clientId, \"] auto set stream fallback option failed\"), e);\n            });\n          }), this._remoteStreamTypeCacheMap.forEach((e, t) => {\n            this._gateway.setRemoteVideoStreamType(t, e).catch(e => {\n              NE.warning(\"[\".concat(this._clientId, \"] auto set remote stream type failed\"), e);\n            });\n          }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o = this._joinInfo) || void 0 === o ? void 0 : o.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {\n            NE.debug(\"[\".concat(this._clientId, \"] setRemoteDefaultVideoStreamType after gateway connected\"));\n          }).catch(e => {\n            NE.error(\"[\".concat(this._clientId, \"] setRemoteDefaultVideoStreamType after gateway failed, \").concat(e));\n          }), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {\n            if (\"CONNECTED\" !== this.connectionState) return;\n            this._userOfflineTimeout = void 0;\n            this._users.filter(e => !e._trust_in_room_).forEach(e => {\n              NE.debug(\"[\".concat(this._clientId, \"] user offline timeout, emit user offline \").concat(e.uid)), this._handleUserOffline({\n                uid: e.uid\n              });\n            });\n          }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {\n            \"CONNECTED\" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach(e => {\n              e._trust_audio_mute_state_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch audio unmute event \").concat(e.uid)), this._handleMuteStream(e.uid, \"audio\", !1)), e._trust_video_mute_state_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch video unmute event \").concat(e.uid)), this._handleMuteStream(e.uid, \"video\", !1)), e._trust_audio_enabled_state_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch enable local audio \").concat(e.uid)), this._handleSetStreamLocalEnable(\"audio\", e.uid, !0)), e._trust_video_enabled_state_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch enable local video \").concat(e.uid)), this._handleSetStreamLocalEnable(\"video\", e.uid, !0)), e._trust_video_stream_added_state_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch reset video stream added \").concat(e.uid)), this._handleResetAddStream(e, \"video\")), e._trust_audio_stream_added_state_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch reset audio stream added \").concat(e.uid)), this._handleResetAddStream(e, \"audio\")), e._video_added_ || e._audio_added_ || (NE.debug(\"[\".concat(this._clientId, \"] auto dispatch stream remove \").concat(e.uid)), this._handleRemoveStream({\n                uid: e.uid,\n                uint_id: e._uintid\n              }));\n            }));\n          }, 1e3);\n        }\n        n();\n      }), this._gateway.on(cg.REQUEST_NEW_GATEWAY_LIST, (e, t) => {\n        if (!this._joinInfo) return t(new vE(TE.UNEXPECTED_ERROR, \"can not recover, no join info\"));\n        kO(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || RE, this.store).then(t => {\n          this._joinInfo && (this._joinInfo.apResponse = t.gatewayInfo.res, this._joinInfo.gatewayAddrs = t.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t.gatewayInfo.uni_lbs_ip), e(t.gatewayInfo.gatewayAddrs.map(e => {\n            if (this._joinInfo && this._joinInfo.proxyServer) {\n              const t = e.address.split(\":\");\n              return \"wss://\".concat(this._joinInfo.proxyServer, \"/ws/?h=\").concat(t[0], \"&p=\").concat(t[1]);\n            }\n            return \"wss://\".concat(e.address);\n          }));\n        }).catch(t);\n      }), this._gateway.on(cg.NETWORK_QUALITY, e => {\n        \"normal\" === this._networkQualitySensitivity && this.emit(Am.NETWORK_QUALITY, e);\n      }), this._gateway.on(cg.STREAM_TYPE_CHANGE, (e, t) => {\n        this.emit(Am.STREAM_TYPE_CHANGED, e, t);\n        IT.reportApiInvoke(this._sessionId, {\n          name: Em.STREAM_TYPE_CHANGE,\n          options: [e, t],\n          tag: fm.TRACER\n        }).onSuccess(JSON.stringify({\n          uid: e,\n          streamType: t\n        }));\n      }), this._gateway.on(cg.IS_P2P_DISCONNECTED, e => {\n        this._p2pChannel.isP2PDisconnected() ? e(!0) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e(!1) : e(!0);\n      }), this._gateway.on(cg.NEED_RENEW_SESSION, () => {\n        this._startSession();\n      }), this._gateway.on(cg.REQUEST_P2P_CONNECTION_PARAMS, async (e, t, i) => {\n        try {\n          t(await this._p2pChannel.startP2PConnection(e));\n        } catch (e) {\n          i(e);\n        }\n      }), this._gateway.on(cg.JOIN_RESPONSE, (e, t) => {\n        const {\n          dtlsParameters: i,\n          iceParameters: r,\n          candidates: n,\n          rtpCapabilities: o,\n          setup: s,\n          cname: a\n        } = kD(e.ortc, t);\n        this._p2pChannel.connect(r, i, n, o, s, a);\n      }), this._gateway.on(cg.REQUEST_DC_CONNECTION_PARAMS, e => {\n        e(this._p2pChannel.getEstablishParams());\n      }), this._gateway.on(cg.RESET_CONNECTION_EVENTS, () => {\n        this._handleGatewaySignalEvents();\n      }), this._gateway.on(cg.DATACHANNEL_FAILBACK, () => {\n        this._joinGateway();\n      }), this._gateway.on(cg.DATACHANNEL_PRECONNECT, async (e, t, i, r) => {\n        var n, o, s, a, c, d;\n        await this._p2pChannel.startP2PConnection({\n          turnServer: null === (n = this._joinInfo) || void 0 === n ? void 0 : n.turnServer\n        }, !0);\n        const u = function (e, t) {\n          let i;\n          return t && t.ip && \"number\" == typeof t.port ? (i = [{\n            foundation: \"udpcandidate\",\n            componentId: \"1\",\n            transport: \"udp\",\n            priority: \"2103266323\",\n            connectionAddress: t.ip,\n            port: t.port.toString(),\n            type: \"host\",\n            extension: {}\n          }], NE.debug(\"Using remote candidate from AP \".concat(t.ip, \":\").concat(t.port)), t.ip6 && (i.push({\n            foundation: \"udpcandidate\",\n            componentId: \"1\",\n            transport: \"udp\",\n            priority: \"2103266323\",\n            connectionAddress: t.ip6,\n            port: t.port.toString(),\n            type: \"host\",\n            extension: {}\n          }), NE.debug(\"Using IPV6 remote candidate from AP \".concat(t.ip6, \":\").concat(t.port)))) : i = [{\n            foundation: \"udpcandidate\",\n            componentId: \"1\",\n            transport: \"udp\",\n            priority: \"2103266323\",\n            connectionAddress: e.ip,\n            port: e.port.toString(),\n            type: \"host\",\n            extension: {}\n          }], i;\n        }(e, t);\n        return this._p2pChannel.preConnect({\n          iceUfrag: \"\".concat(null === (o = this._joinInfo) || void 0 === o ? void 0 : o.apResponse.cid, \"_\").concat(null === (s = this._joinInfo) || void 0 === s ? void 0 : s.apResponse.cert),\n          icePwd: \"\".concat(null === (a = this._joinInfo) || void 0 === a ? void 0 : a.apResponse.cid, \"_\").concat(null === (c = this._joinInfo) || void 0 === c ? void 0 : c.apResponse.cert)\n        }, {\n          fingerprints: [{\n            hashFunction: \"sha-256\",\n            fingerprint: null !== (d = HE(\"FINGERPRINT\")) && void 0 !== d ? d : e.fingerprint\n          }]\n        }, u, {\n          send: {\n            audioCodecs: [],\n            videoCodecs: [],\n            audioExtensions: [],\n            videoExtensions: []\n          },\n          recv: {\n            audioCodecs: [],\n            videoCodecs: [],\n            audioExtensions: [],\n            videoExtensions: []\n          }\n        }, \"active\", \"o/i14u9pJrxRKAsu\").then(i).catch(r);\n      });\n    }\n    _handleGatewaySignalEvents() {\n      this._gateway.signal.on(Pm.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(Pm.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(Pm.ON_ADD_AUDIO_STREAM, e => this._handleAddAudioOrVideoStream(\"audio\", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc)), this._gateway.signal.on(Pm.ON_ADD_VIDEO_STREAM, e => this._handleAddAudioOrVideoStream(\"video\", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc, e.rtxSsrcId)), this._gateway.signal.on(Pm.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(Pm.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(Pm.MUTE_AUDIO, e => this._handleMuteStream(e.uid, \"audio\", !0)), this._gateway.signal.on(Pm.UNMUTE_AUDIO, e => this._handleMuteStream(e.uid, \"audio\", !1)), this._gateway.signal.on(Pm.MUTE_VIDEO, e => this._handleMuteStream(e.uid, \"video\", !0)), this._gateway.signal.on(Pm.UNMUTE_VIDEO, e => this._handleMuteStream(e.uid, \"video\", !1)), this._gateway.signal.on(Pm.RECEIVE_METADATA, e => {\n        const t = zR(e.metadata);\n        this.emit(Am.RECEIVE_METADATA, e.uid, t);\n      }), this._gateway.signal.on(Pm.ON_DATA_STREAM, e => {\n        e.seq && delete e.seq, e.payload = zR(e.payload), this.emit(Am.STREAM_MESSAGE, e.uid, e.payload), this.onStreamMessage && this.onStreamMessage(e);\n      }), this._gateway.signal.on(Pm.ON_CRYPT_ERROR, () => {\n        XR(() => {\n          NE.warning(\"[\".concat(this._clientId, \"] on crypt error\")), this.emit(Am.CRYPT_ERROR);\n        }, this._sessionId);\n      }), this._gateway.signal.on(Pm.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(Pm.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {\n        NE.warning(\"[\".concat(this._clientId, \"] received message onTokenPrivilegeDidExpire, please get new token and join again\")), this._gateway.leave(!0), this.emit(Am.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset();\n      }), this._gateway.signal.on(Pm.ON_STREAM_FALLBACK_UPDATE, e => {\n        NE.debug(\"[\".concat(this._clientId, \"] stream fallback peerId: \").concat(e.stream_id, \", attr: \").concat(e.stream_type)), this.emit(Am.STREAM_FALLBACK, e.stream_id, 1 === e.stream_type ? \"fallback\" : \"recover\");\n      }), this._gateway.signal.on(Pm.ON_PUBLISH_STREAM, e => {\n        this.uid === this._uid && (this._p2pChannel.reportPublishEvent(!0, null, void 0, !1, JSON.stringify({\n          proxy: e.proxy\n        })), NE.info(\"[\".concat(this._clientId, \"] on publish stream, \").concat(JSON.stringify(e))));\n      }), this._gateway.signal.on(Pm.ENABLE_LOCAL_VIDEO, e => {\n        this._handleSetStreamLocalEnable(\"video\", e.uid, !0);\n      }), this._gateway.signal.on(Pm.DISABLE_LOCAL_VIDEO, e => {\n        this._handleSetStreamLocalEnable(\"video\", e.uid, !1);\n      }), this._gateway.signal.on(wm.REQUEST_TIMEOUT, (e, t) => {\n        if (this._joinInfo) switch (e) {\n          case Nm.PUBLISH:\n            {\n              if (!t) return;\n              const e = (t = t).ortc;\n              if (e) {\n                var i, r, n, o;\n                const s = e.some(e => {\n                    let {\n                      stream_type: t\n                    } = e;\n                    return t === ag.Audio;\n                  }),\n                  a = e.some(e => {\n                    let {\n                      stream_type: t\n                    } = e;\n                    return t !== ag.Audio;\n                  }),\n                  c = e.some(e => {\n                    let {\n                      stream_type: t\n                    } = e;\n                    return t === ag.Screen || t === ag.ScreenLow;\n                  });\n                \"offer\" === t.state && IT.publish(this._joinInfo.sid, {\n                  eventElapse: pR.measureFromPublishStart(this.store.clientId, this.store.pubId),\n                  succ: !1,\n                  ec: TE.TIMEOUT,\n                  audio: s,\n                  video: a,\n                  p2pid: t.p2p_id,\n                  publishRequestid: this.store.pubId,\n                  screenshare: c,\n                  audioName: s ? null === (i = e.find(e => {\n                    let {\n                      stream_type: t\n                    } = e;\n                    return t === ag.Audio;\n                  })) || void 0 === i || null === (r = i.ssrcs[0]) || void 0 === r ? void 0 : r.ssrcId.toString() : void 0,\n                  videoName: a ? null === (n = e.find(e => {\n                    let {\n                      stream_type: t\n                    } = e;\n                    return t !== ag.Audio;\n                  })) || void 0 === n || null === (o = n.ssrcs[0]) || void 0 === o ? void 0 : o.ssrcId.toString() : void 0\n                });\n              }\n              break;\n            }\n          case Nm.SUBSCRIBE:\n            (t = t) && IT.subscribe(this._joinInfo.sid, {\n              succ: !1,\n              ec: TE.TIMEOUT,\n              audio: t.stream_type === yg.AUDIO,\n              video: t.stream_type === yg.VIDEO,\n              peerid: t.stream_id,\n              subscribeRequestid: t.ssrcId,\n              p2pid: this.store.p2pId,\n              eventElapse: pR.measureFromSubscribeStart(this.store.clientId, t.ssrcId)\n            });\n        }\n      }), this._gateway.signal.on(Pm.ON_P2P_OK, e => {\n        this.uid, this._uid;\n      }), this._gateway.signal.on(Pm.ON_PUBLISHED_USER_LIST, e => {\n        if (null == e || !e.users) return;\n        const t = [],\n          i = [];\n        for (const r of e.users) {\n          let e = this._users.find(e => e.uid === r.stream_id);\n          e ? e._trust_in_room_ = !0 : (e = new mw(r.stream_id, r.stream_id), this._users.push(e), 0 === this.getListeners(Am.PUBLISHED_USER_LIST).length && (NE.debug(\"[\".concat(this._clientId, \"] user online\"), r.stream_id), this.emit(Am.USER_JOINED, e)));\n          const n = dg.Audio & r.stream_type,\n            o = (dg.Video | dg.LwoVideo) & r.stream_type,\n            s = n && e.hasAudio,\n            a = o && e.hasVideo;\n          o && (e._trust_video_stream_added_state_ = !0, e._video_added_ = !0, e._videoSSRC = r.video_ssrc), n && (e._trust_audio_stream_added_state_ = !0, e._audio_added_ = !0, e._audioSSRC = r.audio_ssrc), n && !s && 0 === this.getListeners(Am.PUBLISHED_USER_LIST).length && (NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(e.uid, \" published audio\")), this.emit(Am.USER_PUBLISHED, e, \"audio\")), o && !a && 0 === this.getListeners(Am.PUBLISHED_USER_LIST).length && (NE.info(\"[\".concat(this._clientId, \"] remote user \").concat(e.uid, \" published video\")), this.emit(Am.USER_PUBLISHED, e, \"video\")), (n && !s || o && !a) && t.push(e), o && this._p2pChannel.hasPendingRemoteMedia(e, \"video\") && i.push({\n            user: e,\n            mediaType: \"video\"\n          }), n && this._p2pChannel.hasPendingRemoteMedia(e, \"audio\") && i.push({\n            user: e,\n            mediaType: \"audio\"\n          });\n        }\n        i.length > 0 && (NE.debug(\"[\".concat(this._clientId, \"] RE massSubscribe after reconnect \").concat(i.map(e => \"user: \".concat(e.user.uid, \", mediaType: \").concat(e.mediaType)).join(\"; \"), \" \")), this.massSubscribe(i).catch(e => {\n          NE.error(\"[\".concat(this._clientId, \"] mass resubscribe error\"), e.toString());\n        })), this.getListeners(Am.PUBLISHED_USER_LIST).length > 0 ? (NE.info(\"[\".concat(this._clientId, \"] client emit user-list event, users: \").concat(t.map(e => e.uid).join(\", \"))), this.emit(Am.PUBLISHED_USER_LIST, t)) : NE.info(\"[\".concat(this._clientId, \"] client not emit user-list event case there is no user-list listener, users: \").concat(t.map(e => e.uid).join(\", \")));\n      });\n    }\n    _handleP2PChannelEvents() {\n      this._p2pChannel.on(Og.RequestMuteLocal, async (e, t, i) => {\n        if (this._joinInfo) try {\n          await this._gateway.muteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t();\n        } catch (e) {\n          e.code === TE.DISCONNECT_P2P ? t() : i(e);\n        } else t();\n      }), this._p2pChannel.on(Og.RequestUnmuteLocal, async (e, t, i) => {\n        if (this._joinInfo) try {\n          await this._gateway.unmuteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t();\n        } catch (e) {\n          e.code === TE.DISCONNECT_P2P ? t() : i(e);\n        } else t();\n      }), this._p2pChannel.on(Og.RequestRePublish, (e, t, i) => {\n        this.publish(e, !1).then(t).catch(i);\n      }), this._p2pChannel.on(Og.RequestReSubscribe, async (e, t, i) => {\n        try {\n          for (const {\n            user: t,\n            kind: i\n          } of e) i === yg.VIDEO ? await this.subscribe(t, \"video\") : await this.subscribe(t, \"audio\");\n          t();\n        } catch (e) {\n          i(e);\n        }\n      }), this._p2pChannel.on(Og.RequestUploadStats, (e, t) => {\n        this._gateway.uploadStats(e, t);\n      }), this._p2pChannel.on(Og.MediaReconnectStart, e => {\n        this.emit(Am.MEDIA_RECONNECT_START, e);\n      }), this._p2pChannel.on(Og.MediaReconnectEnd, e => {\n        this.emit(Am.MEDIA_RECONNECT_END, e);\n      }), this._p2pChannel.on(Og.NeedSignalRTT, e => {\n        e(this._gateway.getSignalRTT());\n      }), this._p2pChannel.on(Og.RequestRestartICE, async () => {\n        const e = await this._p2pChannel.restartICE(),\n          t = await e.next();\n        if (t.done) return;\n        const i = t.value;\n        let r;\n        try {\n          r = await this._gateway.restartICE({\n            iceParameters: i\n          });\n        } catch (t) {\n          return void e.throw(t);\n        }\n        const {\n          iceParameters: n\n        } = function (e) {\n          const t = e.iceParameters;\n          return {\n            iceParameters: {\n              iceUfrag: t.iceUfrag,\n              icePwd: t.icePwd\n            }\n          };\n        }(r);\n        await e.next({\n          remoteIceParameters: n\n        });\n      }), this._p2pChannel.on(Og.RequestReconnect, async () => {\n        this._gateway.reconnect();\n      }), this._p2pChannel.on(Og.RequestReconnectPC, async () => {\n        var e;\n        const {\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: r\n          } = await this._p2pChannel.startP2PConnection({\n            turnServer: null === (e = this._joinInfo) || void 0 === e ? void 0 : e.turnServer\n          }),\n          {\n            gatewayEstablishParams: n,\n            gatewayAddress: o\n          } = await this._gateway.reconnectPC({\n            iceParameters: t,\n            dtlsParameters: i,\n            rtpCapabilities: r\n          }),\n          {\n            dtlsParameters: s,\n            iceParameters: a,\n            candidates: c,\n            rtpCapabilities: d,\n            setup: u,\n            cname: l\n          } = kD(n, o);\n        await this._p2pChannel.connect(a, s, c, d, u, l), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe();\n      }), this._p2pChannel.on(Og.RequestUnpublishForReconnectPC, async (e, t, i) => {\n        this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e, this._uid), t()) : i();\n      }), this._p2pChannel.on(Og.P2PLost, () => {\n        this.emit(Am.P2P_LOST, this.store.uid);\n      }), this._p2pChannel.on(Og.UpdateVideoEncoder, e => {\n        e._encoderConfig && this._gateway.setVideoProfile(e._encoderConfig);\n      }), this._p2pChannel.on(Og.ConnectionTypeChange, e => {\n        this.emit(Am.IS_USING_CLOUD_PROXY, e);\n      }), this._p2pChannel.on(Og.RequestLowStreamParameter, e => {\n        e(this._lowStreamParameter || {\n          width: 160,\n          height: 120,\n          framerate: 15,\n          bitrate: 50\n        });\n      }), this._p2pChannel.on(Og.QueryClientConnectionState, e => {\n        e(this.connectionState);\n      });\n    }\n    getKeyMetrics() {\n      return this.store.keyMetrics;\n    }\n    async enableContentInspect(e) {\n      if (\"CONNECTED\" !== this.connectionState || !this._joinInfo) throw new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Client did not join channel\"));\n      if (this._inspect) throw new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] Inspect content service already in connecting/connected state\"));\n      if (!e) throw new vE(TE.INVALID_PARAMS, \"[\".concat(this._clientId, \"] inspectConfig is necessary\"));\n      if (!e.inspectType || !Array.isArray(e.inspectType)) throw new vE(TE.INVALID_PARAMS, \"[\".concat(this._clientId, \"] inspectConfig.inspectType is necessary and is an instance of Array.\"));\n      {\n        const t = [...new Set(e.inspectType)];\n        t.forEach(e => {\n          if (![\"supervise\", \"moderation\"].includes(e)) throw new vE(TE.INVALID_PARAMS, \"[\".concat(this._clientId, \"] \").concat(e, \" is not a valid inspect type.\"));\n        }), e.inspectType = t;\n      }\n      if (e && e.extraInfo && e.extraInfo.length > 1024) throw new vE(TE.INVALID_PARAMS, \"[\".concat(this._clientId, \"] inspectConfig.extraInfo length cannot exceed 1024 bytes\"));\n      try {\n        const t = new ak(e);\n        this._inspect = t, this.handleVideoInspectEvents(this._inspect), await t.init({\n          appId: this._joinInfo.appId,\n          areaCode: \"\",\n          cname: this._joinInfo.cname,\n          sid: this._joinInfo.sid,\n          token: this._joinInfo.token,\n          uid: this._joinInfo.uid,\n          cid: this._joinInfo.cid,\n          vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0\n        }, RE);\n      } catch (e) {\n        throw Array.isArray(e) ? e[0] : e;\n      }\n    }\n    async disableContentInspect() {\n      if (!this._inspect) throw new vE(TE.INVALID_OPERATION, \"[\".concat(this._clientId, \"] inspectVideoContent not started\"));\n      try {\n        this._inspect.close(), this._inspect = void 0;\n      } catch (e) {\n        throw Array.isArray(e) ? e[0] : e;\n      }\n    }\n    handleVideoInspectEvents(e) {\n      e.on(kg.CONNECTION_STATE_CHANGE, (t, i) => {\n        switch (this.emit(Am.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t, i), i) {\n          case Pg.CONNECTED:\n            if (\"CONNECTED\" !== this.connectionState) return void this.emit(Am.CONTENT_INSPECT_ERROR, new vE(TE.OPERATION_ABORTED, \"Content inspect was cancelled because it left the channel\"));\n            e.inspectImage();\n        }\n      }), e.on(kg.INSPECT_RESULT, (e, t) => {\n        var i;\n        if ((null == t ? void 0 : t.code) === TE.INVALID_OPERATION && \"DISCONNECTED\" === this.connectionState) return NE.debug(\"Stop inspect content because that has left channel\"), null == this || null === (i = this._inspect) || void 0 === i || i.close(), void (this._inspect = void 0);\n        this.emit(Am.CONTENT_INSPECT_RESULT, e, t);\n      }), e.on(kg.CLIENT_LOCAL_VIDEO_TRACK, e => {\n        e(this.localTracks.filter(e => \"video\" === e.trackMediaType)[0]);\n      });\n    }\n    getJoinChannelServiceRecords() {\n      return NE.debug(\"getJoinChannelServiceRecords\"), this.store.joinChannelServiceRecords;\n    }\n    async setPublishAudioFilterEnabled(e) {\n      qf(e, \"enabled\"), WE(\"ENABLE_PUBLISH_AUDIO_FILTER\", e), this._joinInfo && (await this._gateway.setPublishAudioFilterEnabled(e));\n    }\n    _handleResetAddStream(e, t) {\n      switch (t) {\n        case \"audio\":\n          e._audio_added_ = !1, e._trust_audio_stream_added_state_ = !0;\n          break;\n        case \"video\":\n          e._video_added_ = !1, e._trust_video_stream_added_state_ = !0;\n      }\n    }\n  }).prototype, \"leave\", [ck], Object.getOwnPropertyDescriptor(Yk.prototype, \"leave\"), Yk.prototype), ZS(Yk.prototype, \"publish\", [dk], Object.getOwnPropertyDescriptor(Yk.prototype, \"publish\"), Yk.prototype), ZS(Yk.prototype, \"unpublish\", [uk], Object.getOwnPropertyDescriptor(Yk.prototype, \"unpublish\"), Yk.prototype), ZS(Yk.prototype, \"subscribe\", [lk], Object.getOwnPropertyDescriptor(Yk.prototype, \"subscribe\"), Yk.prototype), ZS(Yk.prototype, \"massSubscribe\", [hk], Object.getOwnPropertyDescriptor(Yk.prototype, \"massSubscribe\"), Yk.prototype), ZS(Yk.prototype, \"unsubscribe\", [pk], Object.getOwnPropertyDescriptor(Yk.prototype, \"unsubscribe\"), Yk.prototype), ZS(Yk.prototype, \"massUnsubscribe\", [_k], Object.getOwnPropertyDescriptor(Yk.prototype, \"massUnsubscribe\"), Yk.prototype), ZS(Yk.prototype, \"setLowStreamParameter\", [Ek], Object.getOwnPropertyDescriptor(Yk.prototype, \"setLowStreamParameter\"), Yk.prototype), ZS(Yk.prototype, \"enableDualStream\", [fk], Object.getOwnPropertyDescriptor(Yk.prototype, \"enableDualStream\"), Yk.prototype), ZS(Yk.prototype, \"disableDualStream\", [mk], Object.getOwnPropertyDescriptor(Yk.prototype, \"disableDualStream\"), Yk.prototype), ZS(Yk.prototype, \"setClientRole\", [gk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setClientRole\"), Yk.prototype), ZS(Yk.prototype, \"setProxyServer\", [Sk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setProxyServer\"), Yk.prototype), ZS(Yk.prototype, \"setTurnServer\", [Tk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setTurnServer\"), Yk.prototype), ZS(Yk.prototype, \"setLicense\", [vk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setLicense\"), Yk.prototype), ZS(Yk.prototype, \"startProxyServer\", [Rk], Object.getOwnPropertyDescriptor(Yk.prototype, \"startProxyServer\"), Yk.prototype), ZS(Yk.prototype, \"stopProxyServer\", [Ik], Object.getOwnPropertyDescriptor(Yk.prototype, \"stopProxyServer\"), Yk.prototype), ZS(Yk.prototype, \"setLocalAccessPointsV2\", [yk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setLocalAccessPointsV2\"), Yk.prototype), ZS(Yk.prototype, \"setLocalAccessPoints\", [Ck], Object.getOwnPropertyDescriptor(Yk.prototype, \"setLocalAccessPoints\"), Yk.prototype), ZS(Yk.prototype, \"setRemoteDefaultVideoStreamType\", [Ak], Object.getOwnPropertyDescriptor(Yk.prototype, \"setRemoteDefaultVideoStreamType\"), Yk.prototype), ZS(Yk.prototype, \"setRemoteVideoStreamType\", [Ok], Object.getOwnPropertyDescriptor(Yk.prototype, \"setRemoteVideoStreamType\"), Yk.prototype), ZS(Yk.prototype, \"setStreamFallbackOption\", [bk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setStreamFallbackOption\"), Yk.prototype), ZS(Yk.prototype, \"setEncryptionConfig\", [wk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setEncryptionConfig\"), Yk.prototype), ZS(Yk.prototype, \"renewToken\", [Nk], Object.getOwnPropertyDescriptor(Yk.prototype, \"renewToken\"), Yk.prototype), ZS(Yk.prototype, \"enableAudioVolumeIndicator\", [Dk], Object.getOwnPropertyDescriptor(Yk.prototype, \"enableAudioVolumeIndicator\"), Yk.prototype), ZS(Yk.prototype, \"startLiveStreaming\", [Pk], Object.getOwnPropertyDescriptor(Yk.prototype, \"startLiveStreaming\"), Yk.prototype), ZS(Yk.prototype, \"setLiveTranscoding\", [Lk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setLiveTranscoding\"), Yk.prototype), ZS(Yk.prototype, \"stopLiveStreaming\", [kk], Object.getOwnPropertyDescriptor(Yk.prototype, \"stopLiveStreaming\"), Yk.prototype), ZS(Yk.prototype, \"addInjectStreamUrl\", [Mk], Object.getOwnPropertyDescriptor(Yk.prototype, \"addInjectStreamUrl\"), Yk.prototype), ZS(Yk.prototype, \"removeInjectStreamUrl\", [Uk], Object.getOwnPropertyDescriptor(Yk.prototype, \"removeInjectStreamUrl\"), Yk.prototype), ZS(Yk.prototype, \"startChannelMediaRelay\", [xk], Object.getOwnPropertyDescriptor(Yk.prototype, \"startChannelMediaRelay\"), Yk.prototype), ZS(Yk.prototype, \"updateChannelMediaRelay\", [Vk], Object.getOwnPropertyDescriptor(Yk.prototype, \"updateChannelMediaRelay\"), Yk.prototype), ZS(Yk.prototype, \"stopChannelMediaRelay\", [jk], Object.getOwnPropertyDescriptor(Yk.prototype, \"stopChannelMediaRelay\"), Yk.prototype), ZS(Yk.prototype, \"sendCustomReportMessage\", [Fk], Object.getOwnPropertyDescriptor(Yk.prototype, \"sendCustomReportMessage\"), Yk.prototype), ZS(Yk.prototype, \"pickSVCLayer\", [Bk], Object.getOwnPropertyDescriptor(Yk.prototype, \"pickSVCLayer\"), Yk.prototype), ZS(Yk.prototype, \"enableContentInspect\", [Gk], Object.getOwnPropertyDescriptor(Yk.prototype, \"enableContentInspect\"), Yk.prototype), ZS(Yk.prototype, \"disableContentInspect\", [Wk], Object.getOwnPropertyDescriptor(Yk.prototype, \"disableContentInspect\"), Yk.prototype), ZS(Yk.prototype, \"getJoinChannelServiceRecords\", [Hk], Object.getOwnPropertyDescriptor(Yk.prototype, \"getJoinChannelServiceRecords\"), Yk.prototype), ZS(Yk.prototype, \"setPublishAudioFilterEnabled\", [Kk], Object.getOwnPropertyDescriptor(Yk.prototype, \"setPublishAudioFilterEnabled\"), Yk.prototype), Yk);\n  class zk extends GT {\n    set currentState(e) {\n      e !== this._currentState && (this._currentState = e, this.emit(km.AUDIO_SOURCE_STATE_CHANGE, this._currentState));\n    }\n    get currentState() {\n      return this._currentState;\n    }\n    constructor(e) {\n      let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      super(), mp(this, \"audioBuffer\", void 0), mp(this, \"sourceNode\", void 0), mp(this, \"startPlayTime\", 0), mp(this, \"startPlayOffset\", 0), mp(this, \"pausePlayTime\", 0), mp(this, \"options\", void 0), mp(this, \"currentLoopCount\", 0), mp(this, \"_currentState\", \"stopped\"), this.audioBuffer = e, this.options = t, this.startPlayOffset = this.options.startPlayTime || 0;\n    }\n    createWebAudioDiagram() {\n      return this.context.createGain();\n    }\n    get duration() {\n      return this.audioBuffer.duration;\n    }\n    get currentTime() {\n      return \"stopped\" === this.currentState ? 0 : \"paused\" === this.currentState ? this.pausePlayTime : (this.context.currentTime - this.startPlayTime + this.startPlayOffset) % this.audioBuffer.duration;\n    }\n    updateOptions(e) {\n      \"stopped\" === this.currentState ? (this.options = e, this.startPlayOffset = this.options.startPlayTime || 0) : NE.warning(\"can not set audio source options\");\n    }\n    startProcessAudioBuffer() {\n      this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = \"playing\";\n    }\n    pauseProcessAudioBuffer() {\n      this.sourceNode && \"playing\" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = \"paused\");\n    }\n    seekAudioBuffer(e) {\n      this.sourceNode && (this.sourceNode.onended = null, \"playing\" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), \"playing\" === this.currentState ? (this.startPlayOffset = e, this.startSourceNode()) : \"paused\" === this.currentState && (this.pausePlayTime = e));\n    }\n    resumeProcessAudioBuffer() {\n      \"paused\" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = \"playing\");\n    }\n    stopProcessAudioBuffer() {\n      if (this.sourceNode) {\n        this.sourceNode.onended = null;\n        try {\n          this.sourceNode.stop();\n        } catch (e) {}\n        this.reset();\n      }\n    }\n    startSourceNode() {\n      this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this));\n    }\n    createSourceNode() {\n      const e = this.context.createBufferSource();\n      return e.buffer = this.audioBuffer, e.loop = !!this.options.loop, e.connect(this.outputNode), e;\n    }\n    handleSourceNodeEnded() {\n      if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();\n      this.reset();\n    }\n    reset() {\n      this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = \"stopped\", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0;\n    }\n  }\n  const Qk = new Map();\n  async function Zk(e, t) {\n    let i = null;\n    if (\"string\" == typeof e) {\n      const t = Qk.get(e);\n      if (t) return NE.debug(\"use cached audio resource: \", e), t;\n      try {\n        i = (await yE(() => fE.get(e, {\n          responseType: \"arraybuffer\"\n        }), void 0, void 0, {\n          maxRetryCount: 3\n        })).data;\n      } catch (e) {\n        throw new vE(TE.FETCH_AUDIO_FILE_FAILED, e.toString());\n      }\n    } else {\n      const t = new Cl((t, i) => {\n        const r = new FileReader();\n        r.onload = e => {\n          e.target ? t(e.target.result) : i(new vE(TE.READ_LOCAL_AUDIO_FILE_ERROR));\n        }, r.onerror = () => {\n          i(new vE(TE.READ_LOCAL_AUDIO_FILE_ERROR));\n        }, r.readAsArrayBuffer(e);\n      });\n      i = await t;\n    }\n    const r = await function (e) {\n      const t = MT();\n      return new Cl((i, r) => {\n        t.decodeAudioData(e, e => {\n          i(e);\n        }, e => {\n          r(new vE(TE.DECODE_AUDIO_FILE_FAILED, e.toString()));\n        });\n      });\n    }(i);\n    return \"string\" == typeof e && t && Qk.set(e, r), r;\n  }\n  function $k(e, t) {\n    var i = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var r = Object.getOwnPropertySymbols(e);\n      t && (r = r.filter(function (t) {\n        return Object.getOwnPropertyDescriptor(e, t).enumerable;\n      })), i.push.apply(i, r);\n    }\n    return i;\n  }\n  function eM(e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var i = null != arguments[t] ? arguments[t] : {};\n      t % 2 ? $k(Object(i), !0).forEach(function (t) {\n        mp(e, t, i[t]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : $k(Object(i)).forEach(function (t) {\n        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));\n      });\n    }\n    return e;\n  }\n  function tM(e, t, i, r) {\n    i.optimizationMode && (r && r.width && r.height ? (i.encoderConfig = eM(eM({}, r), {}, {\n      bitrateMin: r.bitrateMin,\n      bitrateMax: r.bitrateMax\n    }), \"motion\" !== i.optimizationMode && \"detail\" !== i.optimizationMode || (t.contentHint = i.optimizationMode, t.contentHint === i.optimizationMode ? NE.debug(\"[\".concat(e, \"] set content hint to\"), i.optimizationMode) : NE.debug(\"[\".concat(e, \"] set content hint failed\")))) : NE.warning(\"[\".concat(e, \"] can not apply optimization mode bitrate config, no encoderConfig\")));\n  }\n  const iM = Bh().name;\n  function rM(e, t, i, r) {\n    let n,\n      o = 0,\n      s = null;\n    return new Cl((a, c) => {\n      setTimeout(() => {\n        n && (n(), a(o));\n      }, t), n = VT(() => {\n        !function () {\n          o > r && n && (n(), a(o));\n          const t = i.getContext(\"2d\");\n          if (!t) {\n            const e = new vE(TE.UNEXPECTED_ERROR, \"can not get canvas 2d context.\");\n            return NE.error(e.toString()), void c(e);\n          }\n          t.drawImage(e, 0, 0, 160, 120);\n          const d = t.getImageData(0, 0, i.width, i.height),\n            u = Math.floor(d.data.length / 3);\n          if (s) {\n            for (let e = 0; e < u; e += 3) if (d.data[e] !== s[e]) return o += 1, void (s = d.data);\n            s = d.data;\n          } else s = d.data;\n        }();\n      }, 30);\n    });\n  }\n  class nM {\n    constructor(e, t) {\n      mp(this, \"id\", 0), mp(this, \"element\", void 0), mp(this, \"peerPair\", void 0), mp(this, \"context\", void 0), mp(this, \"audioPlayerElement\", void 0), mp(this, \"audioTrack\", void 0), nM.count += 1, this.id = nM.count, this.element = e, this.context = t;\n    }\n    initPeers() {\n      this.peerPair = [new RTCPeerConnection(), new RTCPeerConnection()], this.peerPair[1].ontrack = e => {\n        const t = document.createElement(\"audio\");\n        t.srcObject = new MediaStream([e.track]), t.play(), this.audioPlayerElement = t;\n      };\n    }\n    async switchSdp() {\n      if (!this.peerPair) return;\n      const e = async (e, t) => {\n          const i = \"offer\" === t ? await e.createOffer() : await e.createAnswer();\n          return await e.setLocalDescription(i), \"complete\" === e.iceGatheringState ? e.localDescription : new Cl(t => {\n            e.onicegatheringstatechange = () => {\n              \"complete\" === e.iceGatheringState && t(e.localDescription);\n            };\n          });\n        },\n        t = async (e, t) => await e.setRemoteDescription(t);\n      try {\n        const i = await e(this.peerPair[0], \"offer\");\n        await t(this.peerPair[1], i);\n        const r = await e(this.peerPair[1], \"answer\");\n        await t(this.peerPair[0], r);\n      } catch (e) {\n        throw new vE(TE.LOCAL_AEC_ERROR, e.toString()).print();\n      }\n    }\n    async getTracksFromMediaElement(e) {\n      if (this.audioTrack) return this.audioTrack;\n      let t;\n      try {\n        e instanceof HTMLVideoElement && (e.captureStream ? e.captureStream() : e.mozCaptureStream()), t = this.context.createMediaStreamDestination();\n        this.context.createMediaElementSource(e).connect(t);\n      } catch (e) {\n        throw new vE(TE.LOCAL_AEC_ERROR, e.toString()).print();\n      }\n      if (!t) {\n        throw new vE(TE.LOCAL_AEC_ERROR, \"no dest node when local aec\").print();\n      }\n      const i = t.stream.getAudioTracks()[0];\n      return this.audioTrack = i, i;\n    }\n    getElement() {\n      return this.element;\n    }\n    async startEchoCancellation() {\n      this.context.resume(), this.peerPair && this.close(), this.initPeers();\n      const e = this.element,\n        t = await this.getTracksFromMediaElement(e);\n      this.peerPair && this.peerPair[0].addTrack(t), await this.switchSdp();\n    }\n    close() {\n      NE.debug(\"close echo cancellation unit, id is\", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach(e => {\n        e.close();\n      }), this.peerPair = void 0, this.audioPlayerElement = void 0;\n    }\n  }\n  var oM, sM;\n  mp(nM, \"count\", 0);\n  const aM = window.AudioContext || window.webkitAudioContext;\n  const cM = new (oM = RT({\n    report: IT\n  }), ZS((sM = class {\n    constructor() {\n      mp(this, \"units\", []), mp(this, \"context\", void 0);\n    }\n    processExternalMediaAEC(e) {\n      if (!this._doesEnvironmentNeedAEC()) return NE.debug(\"the system does not need to process local aec\"), -1;\n      this.context || (this.context = new aM());\n      let t = this.units.find(t => t && t.getElement() === e);\n      return t || (t = new nM(e, this.context), this.units.push(t)), t.startEchoCancellation(), NE.debug(\"start processing local audio echo cancellation, id is\", t.id), t.id;\n    }\n    _doesEnvironmentNeedAEC() {\n      return Bh().name !== xh.SAFARI;\n    }\n  }).prototype, \"processExternalMediaAEC\", [oM], Object.getOwnPropertyDescriptor(sM.prototype, \"processExternalMediaAEC\"), sM.prototype), sM)();\n  WE(\"PROCESS_ID\", \"process-\".concat(MR(8, \"\"), \"-\").concat(MR(4, \"\"), \"-\").concat(MR(4, \"\"), \"-\").concat(MR(4, \"\"), \"-\").concat(MR(12, \"\"))), function () {\n    const e = Bh();\n    Vg.getDisplayMedia = function (e) {\n      if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) return !0;\n      return !1;\n    }(), Vg.getStreamFromExtension = e.name === xh.CHROME && Number(e.version) > 34, Vg.supportUnifiedPlan = function () {\n      if (!window.RTCRtpTransceiver) return !1;\n      if (!(\"currentDirection\" in RTCRtpTransceiver.prototype)) return !1;\n      const e = new RTCPeerConnection();\n      let t = !1;\n      try {\n        e.addTransceiver(\"audio\"), t = !0;\n      } catch (e) {}\n      return e.close(), t;\n    }(), Vg.supportMinBitrate = e.name === xh.CHROME || e.name === xh.EDGE, Vg.supportSetRtpSenderParameters = function () {\n      const e = Bh();\n      if (!window.RTCRtpSender || !window.RTCRtpSender.prototype.setParameters || !window.RTCRtpSender.prototype.getParameters) return !1;\n      return !!ap() || !(!zh() && !Yh()) || e.name === xh.FIREFOX && Number(e.version) >= 64;\n    }(), e.name === xh.SAFARI && (Number(e.version) >= 14 ? Vg.supportDualStream = !0 : Vg.supportDualStream = !1), Vg.webAudioMediaStreamDest = function () {\n      const e = Bh();\n      if (e.name === xh.SAFARI && Number(e.version) < 12) return !1;\n      return !0;\n    }(), Vg.supportReplaceTrack = function () {\n      if (!window.RTCRtpSender) return !1;\n      if (\"function\" == typeof RTCRtpSender.prototype.replaceTrack) return !0;\n      return !1;\n    }(), Vg.supportWebGL = \"undefined\" != typeof WebGLRenderingContext, Vg.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, ap() || (Vg.webAudioWithAEC = !0), Vg.supportShareAudio = function () {\n      const e = Bh();\n      if ((e.os === Uh.WIN_10 || e.os === Uh.WIN_81 || e.os === Uh.WIN_7 || e.os === Uh.LINUX || e.os === Uh.MAC_OS) && e.name === xh.CHROME && Number(e.version) >= 74) return !0;\n      return !1;\n    }(), Vg.supportDualStreamEncoding = function () {\n      const e = Bh();\n      if (HE(\"DISABLE_WEBAUDIO\")) return !0;\n      return \"Safari\" === e.name && Number(e.version) >= 14 || !!(\"Chrome\" === e.name && /Windows/i.test(e.os || \"\") && Number(e.version) >= 100 && HE(\"CHROME_DUAL_STREAM_USE_ENCODING\"));\n    }(), Vg.supportDataChannel = function () {\n      if (function (e) {\n        const t = Bh();\n        return !(t.name !== xh.CHROME || !t.osVersion) && Number(t.version) >= e;\n      }(76) || function (e) {\n        const t = Bh();\n        return !(t.name !== xh.FIREFOX || !t.osVersion) && Number(t.version) >= e;\n      }(68) || function (e) {\n        const t = Bh();\n        return !(t.name !== xh.SAFARI || !t.osVersion) && Number(t.version) >= e;\n      }(14)) return !0;\n      return !1;\n    }(), NE.info(\"browser compatibility\", JSON.stringify(Vg), JSON.stringify(e));\n  }(), function () {\n    let e;\n    try {\n      e = window.localStorage.getItem(\"websdk_ng_global_parameter\");\n    } catch (e) {\n      return void NE.error(\"Error loading sdk config\", e.message);\n    }\n    if (e) try {\n      const t = JSON.parse(window.atob(e)),\n        i = Date.now();\n      NE.debug(\"Loading global parameters from cache\", t), Object.keys(t).forEach(e => {\n        if (Object.prototype.hasOwnProperty.call(KE, e)) {\n          const {\n            value: r,\n            expires: n\n          } = t[e];\n          if (n && n <= i) return;\n          YE[e] = r, KE[e] = r;\n        }\n      });\n    } catch (t) {\n      NE.error(\"Error loading mutableParamsCache: \".concat(e), t.message);\n    }\n  }();\n  const dM = {\n      __CLIENT_LIST__: ZE,\n      __TRACK_LIST__: $E,\n      VERSION: PE,\n      BUILD: DE,\n      setParameter: (e, t, i) => {\n        NE.debug(\"setParameter key:\".concat(e, \", value:\").concat(JSON.stringify(t))), WE(e, t, i);\n      },\n      getParameter: HE,\n      getSupportedCodec: async function () {\n        let e = {\n          audio: [],\n          video: []\n        };\n        try {\n          let t = new RTCPeerConnection();\n          t.addTransceiver(\"video\", {\n            direction: \"recvonly\"\n          }), t.addTransceiver(\"audio\", {\n            direction: \"recvonly\"\n          });\n          const i = (await t.createOffer()).sdp;\n          if (!i) return e;\n          t.close(), t = null, e = function (e) {\n            const t = {\n              video: [],\n              audio: []\n            };\n            return e.match(/ VP8/i) && t.video.push(\"VP8\"), e.match(/ VP9/i) && t.video.push(\"VP9\"), e.match(/ AV1/i) && t.video.push(\"AV1\"), e.match(/ H264/i) && t.video.push(\"H264\"), e.match(/ opus/i) && t.audio.push(\"OPUS\"), e.match(/ PCMU/i) && t.audio.push(\"PCMU\"), e.match(/ PCMA/i) && t.audio.push(\"PCMA\"), e.match(/ G722/i) && t.audio.push(\"G722\"), t;\n          }(i);\n        } catch (e) {\n          throw new vE(TE.CREATE_OFFER_FAILED, e.toString && e.toString()).print();\n        }\n        return e;\n      },\n      checkSystemRequirements: function () {\n        const e = IT.reportApiInvoke(null, {\n          name: Em.CHECK_SYSTEM_REQUIREMENTS,\n          options: [],\n          tag: fm.TRACER\n        });\n        let t = !1;\n        try {\n          const e = window.RTCPeerConnection,\n            i = navigator.mediaDevices && navigator.mediaDevices.getUserMedia,\n            r = window.WebSocket;\n          t = !!(e && i && r);\n        } catch (e) {\n          return NE.error(\"check system requirement failed: \", e), !1;\n        }\n        let i = !1;\n        const r = Bh();\n        r.name === xh.CHROME && Number(r.version) >= 58 && (!Jh() || qh()) && (i = !0), r.name === xh.FIREFOX && Number(r.version) >= 56 && (i = !0), r.name === xh.OPERA && Number(r.version) >= 45 && (i = !0), r.name === xh.SAFARI && Number(r.version) >= 11 && (i = !0), (op() || Bh().name === xh.QQ) && (i = !0), NE.debug(\"checkSystemRequirements, api:\", t, \"browser\", i);\n        const n = t && i;\n        return e.onSuccess(n), n;\n      },\n      getDevices: function (e) {\n        return iv.enumerateDevices(!0, !0, e);\n      },\n      getMicrophones: function (e) {\n        return iv.getRecordingDevices(e);\n      },\n      getCameras: function (e) {\n        return iv.getCamerasDevices(e);\n      },\n      getElectronScreenSources: YT,\n      getPlaybackDevices: function (e) {\n        return iv.getSpeakers(e);\n      },\n      createClient: function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {\n          codec: \"vp8\",\n          audioCodec: \"opus\",\n          mode: \"rtc\"\n        };\n        const t = IT.reportApiInvoke(null, {\n          name: Em.CREATE_CLIENT,\n          options: [e],\n          tag: fm.TRACER\n        });\n        try {\n          Um(e);\n        } catch (e) {\n          throw t.onError(e), e;\n        }\n        return void 0 === e.audioCodec && (e.audioCodec = \"opus\"), t.onSuccess(), new Xk(Jk(Jk({\n          forceWaitGatewayResponse: !0\n        }, e), {}, {\n          role: \"rtc\" === e.mode ? \"host\" : e.role\n        }));\n      },\n      createCameraVideoTrack: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {\n          encoderConfig: \"480p_1\"\n        };\n        const t = IT.reportApiInvoke(null, {\n            tag: fm.TRACER,\n            name: Em.CREATE_CAM_VIDEO_TRACK,\n            options: [eM({}, e)]\n          }),\n          i = Nb(e),\n          r = MR(8, \"track-cam-\");\n        let n = null;\n        NE.info(\"start create camera video track with config\", JSON.stringify(e), \"trackId\", r);\n        try {\n          n = (await ZT({\n            video: i\n          }, r)).getVideoTracks()[0] || null;\n        } catch (e) {\n          throw t.onError(e), e;\n        }\n        if (!n) {\n          const e = new vE(TE.UNEXPECTED_ERROR, \"can not find track in media stream\");\n          return t.onError(e), e.throw();\n        }\n        e.optimizationMode && tM(r, n, e, e.encoderConfig && VE(e.encoderConfig));\n        const o = new fw(n, e, i, e.scalabiltyMode ? FE(e.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, e.optimizationMode, r);\n        return t.onSuccess(o.getTrackId()), NE.info(\"create camera video success, trackId:\", r), o;\n      },\n      createCustomVideoTrack: function (e) {\n        const t = IT.reportApiInvoke(null, {\n            tag: fm.TRACER,\n            name: Em.CREATE_CUSTOM_VIDEO_TRACK,\n            options: [e]\n          }),\n          i = new Ew(e.mediaStreamTrack, {\n            bitrateMax: e.bitrateMax,\n            bitrateMin: e.bitrateMin\n          }, e.scalabiltyMode ? FE(e.scalabiltyMode) : {\n            numSpatialLayers: 1,\n            numTemporalLayers: 1\n          }, e.optimizationMode);\n        return t.onSuccess(i.getTrackId()), NE.info(\"create custom video track success with config\", e, \"trackId\", i.getTrackId()), i;\n      },\n      createScreenVideoTrack: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"disable\";\n        const i = IT.reportApiInvoke(null, {\n          tag: fm.TRACER,\n          name: Em.CREATE_SCREEN_VIDEO_TRACK,\n          options: [eM({}, e), t]\n        });\n        e.encoderConfig ? \"string\" == typeof e.encoderConfig || e.encoderConfig.width && e.encoderConfig.height || (e.encoderConfig.width = {\n          max: 1920\n        }, e.encoderConfig.height = {\n          max: 1080\n        }) : e.encoderConfig = \"1080p_2\";\n        const r = Db(e),\n          n = MR(8, \"track-scr\");\n        let o = null,\n          s = null;\n        const a = jg();\n        if (!a.supportShareAudio && \"enable\" === t) {\n          const e = new vE(TE.NOT_SUPPORTED, \"your browser or platform is not support share-screen with audio\");\n          return i.onError(e), e.throw();\n        }\n        NE.info(\"start create screen video track with config\", e, \"withAudio\", t, \"trackId\", n);\n        try {\n          const e = await ZT({\n            screen: r,\n            screenAudio: \"auto\" === t ? a.supportShareAudio : \"enable\" === t\n          }, n);\n          o = e.getVideoTracks()[0] || null, s = e.getAudioTracks()[0] || null;\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        if (!o) {\n          const e = new vE(TE.UNEXPECTED_ERROR, \"can not find track in media stream\");\n          return i.onError(e), e.throw();\n        }\n        if (!s && \"enable\" === t) {\n          o && o.stop();\n          const e = new vE(TE.SHARE_AUDIO_NOT_ALLOWED);\n          return i.onError(e), e.throw();\n        }\n        e.optimizationMode || (e.optimizationMode = \"detail\"), e.optimizationMode && (tM(n, o, e, e.encoderConfig && jE(e.encoderConfig)), e.encoderConfig && \"string\" != typeof e.encoderConfig && (e.encoderConfig.bitrateMin = e.encoderConfig.bitrateMax));\n        const c = new Ew(o, e.encoderConfig ? jE(e.encoderConfig) : {}, e.scalabiltyMode ? FE(e.scalabiltyMode) : {\n          numSpatialLayers: 1,\n          numTemporalLayers: 1\n        }, e.optimizationMode, n, [lg.SCREEN_TRACK]);\n        if (!s) return i.onSuccess(c.getTrackId()), NE.info(\"create screen video track success\", \"video:\", c.getTrackId()), c;\n        const d = new aR(s);\n        return i.onSuccess([c.getTrackId(), d.getTrackId()]), NE.info(\"create screen video track success\", \"video:\", c.getTrackId(), \"audio:\", d.getTrackId()), [c, d];\n      },\n      createMicrophoneAndCameraTracks: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n          t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {\n            encoderConfig: \"480p_1\"\n          };\n        const i = IT.reportApiInvoke(null, {\n            tag: fm.TRACER,\n            name: Em.CREATE_MIC_AND_CAM_TRACKS,\n            options: [e, t]\n          }),\n          r = Nb(t),\n          n = Pb(e),\n          o = MR(8, \"track-mic-\"),\n          s = MR(8, \"track-cam-\");\n        let a = null,\n          c = null;\n        NE.info(\"start create camera video track(\".concat(s, \") and microphone audio track(\").concat(o, \") with config, audio: \").concat(JSON.stringify(e), \", video: \").concat(JSON.stringify(t)));\n        try {\n          const e = await ZT({\n            audio: n,\n            video: r\n          }, \"\".concat(o, \"-\").concat(s));\n          a = e.getAudioTracks()[0], c = e.getVideoTracks()[0];\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        if (!a || !c) {\n          const e = new vE(TE.UNEXPECTED_ERROR, \"can not find tracks in media stream\");\n          return i.onError(e), e.throw();\n        }\n        t.optimizationMode && tM(s, c, t, t.encoderConfig && VE(t.encoderConfig));\n        const d = new cR(a, e, n, o),\n          u = new fw(c, t, r, t.scalabiltyMode ? FE(t.scalabiltyMode) : {\n            numSpatialLayers: 1,\n            numTemporalLayers: 1\n          }, t.optimizationMode, s);\n        return i.onSuccess([d.getTrackId(), u.getTrackId()]), NE.info(\"create camera video track(\".concat(s, \") and microphone audio track(\").concat(o, \") success\")), [d, u];\n      },\n      createMicrophoneAudioTrack: async function () {\n        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        const t = IT.reportApiInvoke(null, {\n            tag: fm.TRACER,\n            name: Em.CREATE_MIC_AUDIO_TRACK,\n            options: [e]\n          }),\n          i = Pb(e),\n          r = MR(8, \"track-mic-\");\n        let n = null;\n        NE.info(\"start create microphone audio track with config\", JSON.stringify(e), \"trackId\", r);\n        try {\n          n = (await ZT({\n            audio: i\n          }, r)).getAudioTracks()[0] || null;\n        } catch (e) {\n          throw t.onError(e), e;\n        }\n        if (!n) {\n          const e = new vE(TE.UNEXPECTED_ERROR, \"can not find track in media stream\");\n          return t.onError(e), e.throw();\n        }\n        const o = new cR(n, e, i, r);\n        return t.onSuccess(o.getTrackId()), NE.info(\"create microphone audio track success, trackId:\", r), o;\n      },\n      createCustomAudioTrack: function (e) {\n        const t = IT.reportApiInvoke(null, {\n            tag: fm.TRACER,\n            name: Em.CREATE_CUSTOM_AUDIO_TRACK,\n            options: [e]\n          }),\n          i = new aR(e.mediaStreamTrack, e.encoderConfig ? GE(e.encoderConfig) : {});\n        return NE.info(\"create custom audio track success with config\", e, \"trackId\", i.getTrackId()), t.onSuccess(i.getTrackId()), i;\n      },\n      createBufferSourceAudioTrack: async function (e) {\n        const t = IT.reportApiInvoke(null, {\n          tag: fm.TRACER,\n          name: Em.CREATE_BUFFER_AUDIO_TRACK,\n          options: [e]\n        });\n        if (HE(\"DISABLE_WEBAUDIO\")) throw new vE(TE.NOT_SUPPORTED, \"can not create BufferSourceAudioTrack when WebAudio disabled\");\n        const i = MR(8, \"track-buf-\");\n        NE.info(\"start create buffer source audio track with config\", JSON.stringify(e), \"trackId\", i);\n        const r = e.source;\n        if (!(e.source instanceof AudioBuffer)) try {\n          e.source = await Zk(e.source, e.cacheOnlineFile);\n        } catch (e) {\n          return t.onError(e), e.throw();\n        }\n        const n = new zk(e.source),\n          o = new dR(r, n, e.encoderConfig ? GE(e.encoderConfig) : {}, i);\n        return NE.info(\"create buffer source audio track success, trackId:\", i), t.onSuccess(o.getTrackId()), o;\n      },\n      setAppType: function (e) {\n        if (NE.debug(\"setAppType: \".concat(e)), !(Number.isInteger(e) && e >= 0)) throw NE.debug(\"Invalid appType\"), new vE(TE.INVALID_PARAMS, \"invalid app type\", e);\n        WE(\"APP_TYPE\", Math.floor(e));\n      },\n      setLogLevel: function (e) {\n        NE.setLogLevel(e);\n      },\n      enableLogUpload: function () {\n        HE(\"USE_NEW_LOG\") ? WE(\"UPLOAD_LOG\", !0) : NE.enableLogUpload();\n      },\n      disableLogUpload: function () {\n        HE(\"USE_NEW_LOG\") ? WE(\"UPLOAD_LOG\", !1) : NE.disableLogUpload();\n      },\n      createChannelMediaRelayConfiguration: function () {\n        return new QO();\n      },\n      checkAudioTrackIsActive: async function (e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n        const i = IT.reportApiInvoke(null, {\n          tag: fm.TRACER,\n          name: Em.CHECK_AUDIO_TRACK_IS_ACTIVE,\n          options: [t]\n        });\n        if (!(e instanceof aR || e instanceof WP)) {\n          const e = new vE(TE.INVALID_TRACK, \"the parameter is not a audio track\");\n          return i.onError(e), e.throw();\n        }\n        t && t < 1e3 && (t = 1e3);\n        const r = e instanceof aR ? e.getTrackLabel() : \"remote_track\",\n          n = e.getVolumeLevel();\n        let o = n,\n          s = n;\n        const a = Date.now();\n        return new Cl(n => {\n          const c = setInterval(() => {\n            const d = e.getVolumeLevel();\n            o = d > o ? d : o, s = d < s ? d : s;\n            const u = o - s > 1e-4,\n              l = Date.now() - a;\n            if (u || l > t) {\n              clearInterval(c);\n              const t = u,\n                s = {\n                  duration: l,\n                  deviceLabel: r,\n                  maxVolumeLevel: o,\n                  result: t\n                };\n              NE.info(\"[track-\".concat(e.getTrackId(), \"] check audio track active completed. \").concat(JSON.stringify(s))), i.onSuccess(s), n(t);\n            }\n          }, 200);\n        });\n      },\n      checkVideoTrackIsActive: async function (e) {\n        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;\n        const i = IT.reportApiInvoke(null, {\n          tag: fm.TRACER,\n          name: Em.CHECK_VIDEO_TRACK_IS_ACTIVE,\n          options: [t]\n        });\n        if (!(e instanceof Ew || e instanceof GP)) {\n          const e = new vE(TE.INVALID_TRACK, \"the parameter is not a video track\");\n          return i.onError(e), e.throw();\n        }\n        const r = 4;\n        t && t < 1e3 && (t = 1e3);\n        const n = e instanceof Ew ? e.getTrackLabel() : \"remote_track\",\n          o = e.getMediaStreamTrack(!0),\n          s = document.createElement(\"video\");\n        s.style.width = \"1px\", s.style.height = \"1px\", s.setAttribute(\"muted\", \"\"), s.muted = !0, s.setAttribute(\"playsinline\", \"\"), s.controls = !1, (zh() || Yh()) && (s.style.opacity = \"0.01\", s.style.position = \"fixed\", s.style.left = \"0\", s.style.top = \"0\", document.body.appendChild(s)), s.srcObject = new MediaStream([o]), s.play();\n        const a = document.createElement(\"canvas\");\n        a.width = 160, a.height = 120;\n        let c = 0,\n          d = 0;\n        try {\n          const e = Date.now();\n          c = await rM(s, t, a, r), d = Date.now() - e;\n        } catch (e) {\n          throw i.onError(e), e;\n        }\n        iM === xh.SAFARI && (s.pause(), s.remove()), s.srcObject = null;\n        const u = c > r,\n          l = {\n            duration: d,\n            changedPicNum: c,\n            deviceLabel: n,\n            result: u\n          };\n        return NE.info(\"[track-\".concat(e.getTrackId(), \"] check video track active completed. \").concat(JSON.stringify(l))), i.onSuccess(l), u;\n      },\n      setArea: function (e) {\n        const t = IT.reportApiInvoke(null, {\n          name: Em.SET_AREA,\n          options: e,\n          tag: fm.TRACER\n        });\n        try {\n          let t = [];\n          if (\"string\" == typeof e && (t = [e]), Array.isArray(e) && (e.forEach(e => {\n            if (!Sg.includes(e)) throw new vE(TE.INVALID_PARAMS, \"invalid area code\");\n          }), t = e), \"[object Object]\" === Object.prototype.toString.call(e)) {\n            const {\n              areaCode: i,\n              excludedArea: r\n            } = e;\n            if (!i) throw new vE(TE.INVALID_PARAMS, \"area code is needed\");\n            let n = i;\n            \"string\" == typeof i && (n = [i]), t = r ? LO(n, r) : n;\n          }\n          WE(\"AREAS\", t);\n          const i = (e => {\n            const t = {\n              CODE: \"\",\n              WEBCS_DOMAIN: [],\n              WEBCS_DOMAIN_BACKUP_LIST: [],\n              PROXY_CS: [],\n              CDS_AP: [],\n              ACCOUNT_REGISTER: [],\n              UAP_AP: [],\n              EVENT_REPORT_DOMAIN: [],\n              EVENT_REPORT_BACKUP_DOMAIN: [],\n              LOG_UPLOAD_SERVER: [],\n              PROXY_SERVER_TYPE3: []\n            };\n            return e.map(e => {\n              const i = vg[e],\n                r = Object.keys(i);\n              r && r.map(e => {\n                \"CODE\" !== e && (t[e] = t[e].concat(i[e]));\n              });\n            }), t;\n          })(t);\n          Object.keys(i).map(e => {\n            if (\"LOG_UPLOAD_SERVER\" === e || \"EVENT_REPORT_DOMAIN\" === e || \"EVENT_REPORT_BACKUP_DOMAIN\" === e || \"PROXY_SERVER_TYPE3\" === e) {\n              WE(e, i[e][0]);\n            } else WE(e, i[e]);\n          }), NE.debug(\"set area success:\", t.join(\",\"));\n        } catch (e) {\n          throw t.onError(e), e;\n        }\n        t.onSuccess();\n      },\n      audioElementPlayCenter: nv,\n      processExternalMediaAEC: function (e) {\n        cM.processExternalMediaAEC(e);\n      },\n      registerExtensions: function (e) {\n        e.forEach(e => {\n          const t = e;\n          t.__registered__ = !0, t.logger.hookLog = NE.extLog, t.reporter.hookApiInvoke = IT.extApiInvoke, t.parameters && Object.keys(t.parameters).forEach(e => {\n            t.parameters[e] = HE(e);\n          });\n        });\n      },\n      ChannelMediaRelayError: sg,\n      ChannelMediaRelayEvent: ng,\n      ChannelMediaRelayState: og,\n      RemoteStreamFallbackType: pg,\n      RemoteStreamType: hg,\n      ConnectionDisconnectedReason: Cm,\n      AudienceLatencyLevelType: ym,\n      AREAS: fg\n    },\n    uM = window || document;\n  return Object.defineProperties(dM, {\n    onAudioAutoplayFailed: {\n      get: () => ET.onAudioAutoplayFailed,\n      set: e => {\n        ET.onAudioAutoplayFailed = e;\n      }\n    },\n    onAutoplayFailed: {\n      get: () => ET.onAutoplayFailed,\n      set: e => {\n        ET.onAutoplayFailed = e;\n      }\n    },\n    _onSecurityPolicyViolation: {\n      value: void 0,\n      writable: !0\n    },\n    _cspEventHandlerPointer: {\n      value: void 0,\n      writable: !0\n    },\n    onSecurityPolicyViolation: {\n      get: () => dM._onSecurityPolicyViolation,\n      set(e) {\n        if (dM._onSecurityPolicyViolation = e, !uM) return;\n        const t = e => {\n            if (!(e && e.blockedURI && dM.onSecurityPolicyViolation)) return;\n            const t = e.blockedURI;\n            HE(\"CSP_DETECTED_HOSTNAME_LIST\").some(e => t.includes(e)) && dM.onSecurityPolicyViolation && \"function\" == typeof dM.onSecurityPolicyViolation && dM.onSecurityPolicyViolation(e);\n          },\n          i = dM._cspEventHandlerPointer;\n        i && uM.removeEventListener(\"securitypolicyviolation\", i), e && \"function\" == typeof e && uM.addEventListener(\"securitypolicyviolation\", t), dM._cspEventHandlerPointer = t;\n      }\n    }\n  }), iv.on(gm.CAMERA_DEVICE_CHANGED, e => {\n    NE.info(\"camera device changed\", JSON.stringify(e)), dM.onCameraChanged && dM.onCameraChanged(e);\n  }), iv.on(gm.RECORDING_DEVICE_CHANGED, e => {\n    NE.info(\"microphone device changed\", JSON.stringify(e)), dM.onMicrophoneChanged && dM.onMicrophoneChanged(e);\n  }), iv.on(gm.PLAYOUT_DEVICE_CHANGED, e => {\n    NE.debug(\"playout device changed\", JSON.stringify(e)), dM.onPlaybackDeviceChanged && dM.onPlaybackDeviceChanged(e);\n  }), nv.onAutoplayFailed = () => {\n    NE.info(\"detect audio element autoplay failed\"), ET.onAudioAutoplayFailed && ET.onAudioAutoplayFailed();\n  }, LT.on(\"autoplay-failed\", () => {\n    NE.info(\"detect webaudio autoplay failed\"), ET.onAudioAutoplayFailed && ET.onAudioAutoplayFailed();\n  }), window && (window.__ARTC__ = dM), dM;\n});","map":null,"metadata":{},"sourceType":"script"}